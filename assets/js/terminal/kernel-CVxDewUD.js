var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _a, _b, _c, _d, _e, _buffer, _f, _g;
async function blank({ terminal }) {
  if (document.getElementById("screensaver")) return false;
  const canvas = document.createElement("canvas");
  canvas.id = "screensaver";
  canvas.width = globalThis.innerWidth;
  canvas.height = globalThis.innerHeight;
  canvas.style.position = "absolute";
  canvas.style.top = "0";
  canvas.style.left = "0";
  canvas.style.zIndex = "1000000";
  document.body.appendChild(canvas);
  const ctx = canvas.getContext("2d");
  if (!ctx) return false;
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  canvas.addEventListener("click", () => exit$1(canvas, terminal));
  document.addEventListener("click", () => exit$1(canvas, terminal));
  document.addEventListener("mousemove", () => exit$1(canvas, terminal));
  document.addEventListener("keydown", () => exit$1(canvas, terminal));
}
__name(blank, "blank");
async function exit$1(canvas, terminal) {
  canvas.remove();
  terminal.listen();
}
__name(exit$1, "exit$1");
const __vite_glob_0_0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: blank,
  exit: exit$1
}, Symbol.toStringTag, { value: "Module" }));
async function matrix({ terminal }) {
  if (document.getElementById("screensaver")) return false;
  const canvas = document.createElement("canvas");
  canvas.id = "screensaver";
  canvas.width = globalThis.innerWidth;
  canvas.height = globalThis.innerHeight;
  canvas.style.position = "absolute";
  canvas.style.top = "0";
  canvas.style.left = "0";
  canvas.style.zIndex = Number.MAX_SAFE_INTEGER.toString();
  document.body.appendChild(canvas);
  const ctx = canvas.getContext("2d");
  const fontSize = 14;
  const columns = Math.floor(canvas.width / fontSize);
  const drops = Array(columns).fill(1);
  const chars2 = '01~!#$%^&*()_+=-[]{}\\|;:",./<>?ﾊﾐﾋｰｳｼﾅﾓﾆｻﾜﾂｵﾘｱﾎﾃﾏｹﾒｴｶｷﾑﾕﾗｾﾈｽﾀﾇﾍﾊﾐﾋｰｳｼﾅﾓﾆｻﾜﾂｵﾘｱﾎﾃﾏｹﾒｴｶｷﾑﾕﾗｾﾈｽﾀﾇﾍ'.split("");
  if (!ctx) return false;
  ctx.font = ctx.font.replace(/\d+px/, `${fontSize}px`);
  const animatrix = /* @__PURE__ */ __name(() => {
    ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    for (const [x, y] of drops.entries()) {
      ctx.fillStyle = "#0f0";
      const char = chars2[Math.floor(Math.random() * chars2.length)];
      if (!char) continue;
      ctx.fillText(char, x * fontSize, y * fontSize);
      drops[x]++;
      if (y * fontSize > canvas.height && Math.random() > 0.95) drops[x] = 0;
    }
  }, "animatrix");
  terminal.unlisten();
  const interval = setInterval(animatrix, 33);
  document.addEventListener("click", () => exit(interval, canvas, terminal));
  document.addEventListener("mousemove", () => exit(interval, canvas, terminal));
  document.addEventListener("keydown", () => exit(interval, canvas, terminal));
}
__name(matrix, "matrix");
async function exit(interval, canvas, terminal) {
  clearInterval(interval);
  canvas.remove();
  terminal.listen();
}
__name(exit, "exit");
const __vite_glob_0_1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: matrix,
  exit
}, Symbol.toStringTag, { value: "Module" }));
function isObject$7(input) {
  return typeof input === "object" && input !== null;
}
__name(isObject$7, "isObject$7");
function isArrayLike$6(input) {
  return isObject$7(input) && typeof input.length === "number";
}
__name(isArrayLike$6, "isArrayLike$6");
function arrayify$5(input) {
  if (Array.isArray(input)) {
    return input;
  } else if (input === void 0) {
    return [];
  } else if (isArrayLike$6(input) || input instanceof Set) {
    return Array.from(input);
  } else {
    return [input];
  }
}
__name(arrayify$5, "arrayify$5");
const csi$5 = "\x1B[";
const ansi$6 = {};
ansi$6.style = {
  reset: "\x1B[0m",
  bold: "\x1B[1m",
  italic: "\x1B[3m",
  underline: "\x1B[4m",
  fontDefault: "\x1B[10m",
  font2: "\x1B[11m",
  font3: "\x1B[12m",
  font4: "\x1B[13m",
  font5: "\x1B[14m",
  font6: "\x1B[15m",
  imageNegative: "\x1B[7m",
  imagePositive: "\x1B[27m",
  black: "\x1B[30m",
  red: "\x1B[31m",
  green: "\x1B[32m",
  yellow: "\x1B[33m",
  blue: "\x1B[34m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  white: "\x1B[37m",
  grey: "\x1B[90m",
  gray: "\x1B[90m",
  brightRed: "\x1B[91m",
  brightGreen: "\x1B[92m",
  brightYellow: "\x1B[93m",
  brightBlue: "\x1B[94m",
  brightMagenta: "\x1B[95m",
  brightCyan: "\x1B[96m",
  brightWhite: "\x1B[97m",
  "bg-black": "\x1B[40m",
  "bg-red": "\x1B[41m",
  "bg-green": "\x1B[42m",
  "bg-yellow": "\x1B[43m",
  "bg-blue": "\x1B[44m",
  "bg-magenta": "\x1B[45m",
  "bg-cyan": "\x1B[46m",
  "bg-white": "\x1B[47m",
  "bg-grey": "\x1B[100m",
  "bg-gray": "\x1B[100m",
  "bg-brightRed": "\x1B[101m",
  "bg-brightGreen": "\x1B[102m",
  "bg-brightYellow": "\x1B[103m",
  "bg-brightBlue": "\x1B[104m",
  "bg-brightMagenta": "\x1B[105m",
  "bg-brightCyan": "\x1B[106m",
  "bg-brightWhite": "\x1B[107m"
};
ansi$6.rgb = function(r, g, b) {
  return `\x1B[38;2;${r};${g};${b}m`;
};
ansi$6.bgRgb = function(r, g, b) {
  return `\x1B[48;2;${r};${g};${b}m`;
};
ansi$6.styles = function(styles2) {
  styles2 = arrayify$5(styles2);
  return styles2.map(function(effect) {
    const rgbMatches = effect.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    const bgRgbMatches = effect.match(/bg-rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (bgRgbMatches) {
      const [full, r, g, b] = bgRgbMatches;
      return ansi$6.bgRgb(r, g, b);
    } else if (rgbMatches) {
      const [full, r, g, b] = rgbMatches;
      return ansi$6.rgb(r, g, b);
    } else {
      return ansi$6.style[effect];
    }
  }).join("");
};
ansi$6.format = function(str, styleArray) {
  const re2 = /\[([\w\s-\(\),]+)\]{([^]*?)}/;
  let matches;
  str = String(str);
  if (!str) return "";
  while (matches = str.match(re2)) {
    const inlineStyles = matches[1].split(/\s+/);
    const inlineString = matches[2];
    str = str.replace(matches[0], ansi$6.format(inlineString, inlineStyles));
  }
  return styleArray && styleArray.length ? ansi$6.styles(styleArray) + str + ansi$6.style.reset : str;
};
ansi$6.cursor = {
  /**
   * Moves the cursor `lines` cells up. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  up: /* @__PURE__ */ __name(function(lines) {
    return csi$5 + (lines || 1) + "A";
  }, "up"),
  /**
   * Moves the cursor `lines` cells down. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  down: /* @__PURE__ */ __name(function(lines) {
    return csi$5 + (lines || 1) + "B";
  }, "down"),
  /**
   * Moves the cursor `lines` cells forward. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  forward: /* @__PURE__ */ __name(function(lines) {
    return csi$5 + (lines || 1) + "C";
  }, "forward"),
  /**
   * Moves the cursor `lines` cells back. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  back: /* @__PURE__ */ __name(function(lines) {
    return csi$5 + (lines || 1) + "D";
  }, "back"),
  /**
   * Moves cursor to beginning of the line n lines down.
   * @param [lines=1] {number}
   * @return {string}
   */
  nextLine: /* @__PURE__ */ __name(function(lines) {
    return csi$5 + (lines || 1) + "E";
  }, "nextLine"),
  /**
   * Moves cursor to beginning of the line n lines up.
   * @param [lines=1] {number}
   * @return {string}
   */
  previousLine: /* @__PURE__ */ __name(function(lines) {
    return csi$5 + (lines || 1) + "F";
  }, "previousLine"),
  /**
   * Moves the cursor to column n.
   * @param n {number} - column number
   * @return {string}
   */
  horizontalAbsolute: /* @__PURE__ */ __name(function(n) {
    return csi$5 + n + "G";
  }, "horizontalAbsolute"),
  /**
   * Moves the cursor to row n, column m. The values are 1-based, and default to 1 (top left corner) if omitted.
   * @param n {number} - row number
   * @param m {number} - column number
   * @return {string}
   */
  position: /* @__PURE__ */ __name(function(n, m) {
    return csi$5 + (n || 1) + ";" + (m || 1) + "H";
  }, "position"),
  /**
   * Hides the cursor
   */
  hide: csi$5 + "?25l",
  /**
   * Shows the cursor
   */
  show: csi$5 + "?25h"
};
ansi$6.erase = {
  /**
   * Clears part of the screen. If n is 0 (or missing), clear from cursor to end of screen. If n is 1, clear from cursor to beginning of the screen. If n is 2, clear entire screen.
   * @param n {number}
   * @return {string}
   */
  display: /* @__PURE__ */ __name(function(n) {
    return csi$5 + (n || 0) + "J";
  }, "display"),
  /**
   * Erases part of the line. If n is zero (or missing), clear from cursor to the end of the line. If n is one, clear from cursor to beginning of the line. If n is two, clear entire line. Cursor position does not change.
   * @param n {number}
   * @return {string}
   */
  inLine: /* @__PURE__ */ __name(function(n) {
    return csi$5 + (n || 0) + "K";
  }, "inLine")
};
const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = /* @__PURE__ */ __name((offset = 0) => (code2) => `\x1B[${code2 + offset}m`, "wrapAnsi16");
const wrapAnsi256 = /* @__PURE__ */ __name((offset = 0) => (code2) => `\x1B[${38 + offset};5;${code2}m`, "wrapAnsi256");
const wrapAnsi16m = /* @__PURE__ */ __name((offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`, "wrapAnsi16m");
const styles$1 = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
Object.keys(styles$1.modifier);
const foregroundColorNames = Object.keys(styles$1.color);
const backgroundColorNames = Object.keys(styles$1.bgColor);
[...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles$1)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles$1[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles$1[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles$1, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles$1, "codes", {
    value: codes,
    enumerable: false
  });
  styles$1.color.close = "\x1B[39m";
  styles$1.bgColor.close = "\x1B[49m";
  styles$1.color.ansi = wrapAnsi16();
  styles$1.color.ansi256 = wrapAnsi256();
  styles$1.color.ansi16m = wrapAnsi16m();
  styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles$1, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: /* @__PURE__ */ __name((hex) => styles$1.rgbToAnsi256(...styles$1.hexToRgb(hex)), "value"),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code2) {
        if (code2 < 8) {
          return 30 + code2;
        }
        if (code2 < 16) {
          return 90 + (code2 - 8);
        }
        let red;
        let green;
        let blue;
        if (code2 >= 232) {
          red = ((code2 - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code2 -= 16;
          const remainder = code2 % 36;
          red = Math.floor(code2 / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: /* @__PURE__ */ __name((red, green, blue) => styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(red, green, blue)), "value"),
      enumerable: false
    },
    hexToAnsi: {
      value: /* @__PURE__ */ __name((hex) => styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(hex)), "value"),
      enumerable: false
    }
  });
  return styles$1;
}
__name(assembleStyles, "assembleStyles");
const ansiStyles$1 = assembleStyles();
const level = (() => {
  if (navigator.userAgentData) {
    const brand = navigator.userAgentData.brands.find(({ brand: brand2 }) => brand2 === "Chromium");
    if (brand && brand.version > 93) {
      return 3;
    }
  }
  if (/\b(Chrome|Chromium)\//.test(navigator.userAgent)) {
    return 1;
  }
  return 0;
})();
const colorSupport = level !== 0 && {
  level
};
const supportsColor = {
  stdout: colorSupport,
  stderr: colorSupport
};
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
__name(stringReplaceAll, "stringReplaceAll");
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
__name(stringEncaseCRLFWithFirstIndex, "stringEncaseCRLFWithFirstIndex");
const { stdout: stdoutColor, stderr: stderrColor } = supportsColor;
const GENERATOR = Symbol("GENERATOR");
const STYLER = Symbol("STYLER");
const IS_EMPTY = Symbol("IS_EMPTY");
const levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
const styles = /* @__PURE__ */ Object.create(null);
const applyOptions = /* @__PURE__ */ __name((object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
}, "applyOptions");
const chalkFactory = /* @__PURE__ */ __name((options) => {
  const chalk2 = /* @__PURE__ */ __name((...strings2) => strings2.join(" "), "chalk");
  applyOptions(chalk2, options);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
}, "chalkFactory");
function createChalk(options) {
  return chalkFactory(options);
}
__name(createChalk, "createChalk");
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansiStyles$1)) {
  styles[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
const getModelAnsi = /* @__PURE__ */ __name((model, level2, type, ...arguments_) => {
  if (model === "rgb") {
    if (level2 === "ansi16m") {
      return ansiStyles$1[type].ansi16m(...arguments_);
    }
    if (level2 === "ansi256") {
      return ansiStyles$1[type].ansi256(ansiStyles$1.rgbToAnsi256(...arguments_));
    }
    return ansiStyles$1[type].ansi(ansiStyles$1.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level2, type, ...ansiStyles$1.hexToRgb(...arguments_));
  }
  return ansiStyles$1[type][model](...arguments_);
}, "getModelAnsi");
const usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles[model] = {
    get() {
      const { level: level2 } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level2], "color", ...arguments_), ansiStyles$1.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles[bgModel] = {
    get() {
      const { level: level2 } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level2], "bgColor", ...arguments_), ansiStyles$1.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
const proto = Object.defineProperties(() => {
}, {
  ...styles,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level2) {
      this[GENERATOR].level = level2;
    }
  }
});
const createStyler = /* @__PURE__ */ __name((open2, close2, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open2;
    closeAll = close2;
  } else {
    openAll = parent.openAll + open2;
    closeAll = close2 + parent.closeAll;
  }
  return {
    open: open2,
    close: close2,
    openAll,
    closeAll,
    parent
  };
}, "createStyler");
const createBuilder = /* @__PURE__ */ __name((self2, _styler, _isEmpty) => {
  const builder = /* @__PURE__ */ __name((...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" ")), "builder");
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
}, "createBuilder");
const applyStyle = /* @__PURE__ */ __name((self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
}, "applyStyle");
Object.defineProperties(createChalk.prototype, styles);
const chalk$1 = createChalk();
createChalk({ level: stderrColor ? stderrColor.level : 0 });
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$1(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
__name(getDefaultExportFromCjs$1, "getDefaultExportFromCjs$1");
var figlet$1 = { exports: {} };
var hasRequiredFiglet;
function requireFiglet() {
  if (hasRequiredFiglet) return figlet$1.exports;
  hasRequiredFiglet = 1;
  (function(module) {
    const figlet2 = (() => {
      const FULL_WIDTH = 0, FITTING = 1, SMUSHING = 2, CONTROLLED_SMUSHING = 3;
      const figFonts = {};
      const figDefaults = {
        font: "Standard",
        fontPath: "./fonts"
      };
      function getSmushingRules(oldLayout, newLayout) {
        let rules = {};
        let val, index, len, code2;
        let codes = [
          [16384, "vLayout", SMUSHING],
          [8192, "vLayout", FITTING],
          [4096, "vRule5", true],
          [2048, "vRule4", true],
          [1024, "vRule3", true],
          [512, "vRule2", true],
          [256, "vRule1", true],
          [128, "hLayout", SMUSHING],
          [64, "hLayout", FITTING],
          [32, "hRule6", true],
          [16, "hRule5", true],
          [8, "hRule4", true],
          [4, "hRule3", true],
          [2, "hRule2", true],
          [1, "hRule1", true]
        ];
        val = newLayout !== null ? newLayout : oldLayout;
        index = 0;
        len = codes.length;
        while (index < len) {
          code2 = codes[index];
          if (val >= code2[0]) {
            val = val - code2[0];
            rules[code2[1]] = typeof rules[code2[1]] === "undefined" ? code2[2] : rules[code2[1]];
          } else if (code2[1] !== "vLayout" && code2[1] !== "hLayout") {
            rules[code2[1]] = false;
          }
          index++;
        }
        if (typeof rules["hLayout"] === "undefined") {
          if (oldLayout === 0) {
            rules["hLayout"] = FITTING;
          } else if (oldLayout === -1) {
            rules["hLayout"] = FULL_WIDTH;
          } else {
            if (rules["hRule1"] || rules["hRule2"] || rules["hRule3"] || rules["hRule4"] || rules["hRule5"] || rules["hRule6"]) {
              rules["hLayout"] = CONTROLLED_SMUSHING;
            } else {
              rules["hLayout"] = SMUSHING;
            }
          }
        } else if (rules["hLayout"] === SMUSHING) {
          if (rules["hRule1"] || rules["hRule2"] || rules["hRule3"] || rules["hRule4"] || rules["hRule5"] || rules["hRule6"]) {
            rules["hLayout"] = CONTROLLED_SMUSHING;
          }
        }
        if (typeof rules["vLayout"] === "undefined") {
          if (rules["vRule1"] || rules["vRule2"] || rules["vRule3"] || rules["vRule4"] || rules["vRule5"]) {
            rules["vLayout"] = CONTROLLED_SMUSHING;
          } else {
            rules["vLayout"] = FULL_WIDTH;
          }
        } else if (rules["vLayout"] === SMUSHING) {
          if (rules["vRule1"] || rules["vRule2"] || rules["vRule3"] || rules["vRule4"] || rules["vRule5"]) {
            rules["vLayout"] = CONTROLLED_SMUSHING;
          }
        }
        return rules;
      }
      __name(getSmushingRules, "getSmushingRules");
      function hRule1_Smush(ch1, ch2, hardBlank) {
        if (ch1 === ch2 && ch1 !== hardBlank) {
          return ch1;
        }
        return false;
      }
      __name(hRule1_Smush, "hRule1_Smush");
      function hRule2_Smush(ch1, ch2) {
        let rule2Str = "|/\\[]{}()<>";
        if (ch1 === "_") {
          if (rule2Str.indexOf(ch2) !== -1) {
            return ch2;
          }
        } else if (ch2 === "_") {
          if (rule2Str.indexOf(ch1) !== -1) {
            return ch1;
          }
        }
        return false;
      }
      __name(hRule2_Smush, "hRule2_Smush");
      function hRule3_Smush(ch1, ch2) {
        let rule3Classes = "| /\\ [] {} () <>";
        let r3_pos1 = rule3Classes.indexOf(ch1);
        let r3_pos2 = rule3Classes.indexOf(ch2);
        if (r3_pos1 !== -1 && r3_pos2 !== -1) {
          if (r3_pos1 !== r3_pos2 && Math.abs(r3_pos1 - r3_pos2) !== 1) {
            const startPos = Math.max(r3_pos1, r3_pos2);
            const endPos = startPos + 1;
            return rule3Classes.substring(startPos, endPos);
          }
        }
        return false;
      }
      __name(hRule3_Smush, "hRule3_Smush");
      function hRule4_Smush(ch1, ch2) {
        let rule4Str = "[] {} ()";
        let r4_pos1 = rule4Str.indexOf(ch1);
        let r4_pos2 = rule4Str.indexOf(ch2);
        if (r4_pos1 !== -1 && r4_pos2 !== -1) {
          if (Math.abs(r4_pos1 - r4_pos2) <= 1) {
            return "|";
          }
        }
        return false;
      }
      __name(hRule4_Smush, "hRule4_Smush");
      function hRule5_Smush(ch1, ch2) {
        let rule5Str = "/\\ \\/ ><";
        let rule5Hash = { 0: "|", 3: "Y", 6: "X" };
        let r5_pos1 = rule5Str.indexOf(ch1);
        let r5_pos2 = rule5Str.indexOf(ch2);
        if (r5_pos1 !== -1 && r5_pos2 !== -1) {
          if (r5_pos2 - r5_pos1 === 1) {
            return rule5Hash[r5_pos1];
          }
        }
        return false;
      }
      __name(hRule5_Smush, "hRule5_Smush");
      function hRule6_Smush(ch1, ch2, hardBlank) {
        if (ch1 === hardBlank && ch2 === hardBlank) {
          return hardBlank;
        }
        return false;
      }
      __name(hRule6_Smush, "hRule6_Smush");
      function vRule1_Smush(ch1, ch2) {
        if (ch1 === ch2) {
          return ch1;
        }
        return false;
      }
      __name(vRule1_Smush, "vRule1_Smush");
      function vRule2_Smush(ch1, ch2) {
        let rule2Str = "|/\\[]{}()<>";
        if (ch1 === "_") {
          if (rule2Str.indexOf(ch2) !== -1) {
            return ch2;
          }
        } else if (ch2 === "_") {
          if (rule2Str.indexOf(ch1) !== -1) {
            return ch1;
          }
        }
        return false;
      }
      __name(vRule2_Smush, "vRule2_Smush");
      function vRule3_Smush(ch1, ch2) {
        let rule3Classes = "| /\\ [] {} () <>";
        let r3_pos1 = rule3Classes.indexOf(ch1);
        let r3_pos2 = rule3Classes.indexOf(ch2);
        if (r3_pos1 !== -1 && r3_pos2 !== -1) {
          if (r3_pos1 !== r3_pos2 && Math.abs(r3_pos1 - r3_pos2) !== 1) {
            const startPos = Math.max(r3_pos1, r3_pos2);
            const endPos = startPos + 1;
            return rule3Classes.substring(startPos, endPos);
          }
        }
        return false;
      }
      __name(vRule3_Smush, "vRule3_Smush");
      function vRule4_Smush(ch1, ch2) {
        if (ch1 === "-" && ch2 === "_" || ch1 === "_" && ch2 === "-") {
          return "=";
        }
        return false;
      }
      __name(vRule4_Smush, "vRule4_Smush");
      function vRule5_Smush(ch1, ch2) {
        if (ch1 === "|" && ch2 === "|") {
          return "|";
        }
        return false;
      }
      __name(vRule5_Smush, "vRule5_Smush");
      function uni_Smush(ch1, ch2, hardBlank) {
        if (ch2 === " " || ch2 === "") {
          return ch1;
        } else if (ch2 === hardBlank && ch1 !== " ") {
          return ch1;
        } else {
          return ch2;
        }
      }
      __name(uni_Smush, "uni_Smush");
      function canVerticalSmush(txt1, txt2, opts) {
        if (opts.fittingRules.vLayout === FULL_WIDTH) {
          return "invalid";
        }
        let ii, len = Math.min(txt1.length, txt2.length), ch1, ch2, endSmush = false, validSmush;
        if (len === 0) {
          return "invalid";
        }
        for (ii = 0; ii < len; ii++) {
          ch1 = txt1.substring(ii, ii + 1);
          ch2 = txt2.substring(ii, ii + 1);
          if (ch1 !== " " && ch2 !== " ") {
            if (opts.fittingRules.vLayout === FITTING) {
              return "invalid";
            } else if (opts.fittingRules.vLayout === SMUSHING) {
              return "end";
            } else {
              if (vRule5_Smush(ch1, ch2)) {
                endSmush = endSmush || false;
                continue;
              }
              validSmush = false;
              validSmush = opts.fittingRules.vRule1 ? vRule1_Smush(ch1, ch2) : validSmush;
              validSmush = !validSmush && opts.fittingRules.vRule2 ? vRule2_Smush(ch1, ch2) : validSmush;
              validSmush = !validSmush && opts.fittingRules.vRule3 ? vRule3_Smush(ch1, ch2) : validSmush;
              validSmush = !validSmush && opts.fittingRules.vRule4 ? vRule4_Smush(ch1, ch2) : validSmush;
              endSmush = true;
              if (!validSmush) {
                return "invalid";
              }
            }
          }
        }
        if (endSmush) {
          return "end";
        } else {
          return "valid";
        }
      }
      __name(canVerticalSmush, "canVerticalSmush");
      function getVerticalSmushDist(lines1, lines2, opts) {
        let maxDist = lines1.length;
        let len1 = lines1.length;
        lines2.length;
        let subLines1, subLines2, slen;
        let curDist = 1;
        let ii, ret, result;
        while (curDist <= maxDist) {
          subLines1 = lines1.slice(Math.max(0, len1 - curDist), len1);
          subLines2 = lines2.slice(0, Math.min(maxDist, curDist));
          slen = subLines2.length;
          result = "";
          for (ii = 0; ii < slen; ii++) {
            ret = canVerticalSmush(subLines1[ii], subLines2[ii], opts);
            if (ret === "end") {
              result = ret;
            } else if (ret === "invalid") {
              result = ret;
              break;
            } else {
              if (result === "") {
                result = "valid";
              }
            }
          }
          if (result === "invalid") {
            curDist--;
            break;
          }
          if (result === "end") {
            break;
          }
          if (result === "valid") {
            curDist++;
          }
        }
        return Math.min(maxDist, curDist);
      }
      __name(getVerticalSmushDist, "getVerticalSmushDist");
      function verticallySmushLines(line1, line22, opts) {
        let ii, len = Math.min(line1.length, line22.length);
        let ch1, ch2, result = "", validSmush;
        for (ii = 0; ii < len; ii++) {
          ch1 = line1.substring(ii, ii + 1);
          ch2 = line22.substring(ii, ii + 1);
          if (ch1 !== " " && ch2 !== " ") {
            if (opts.fittingRules.vLayout === FITTING) {
              result += uni_Smush(ch1, ch2);
            } else if (opts.fittingRules.vLayout === SMUSHING) {
              result += uni_Smush(ch1, ch2);
            } else {
              validSmush = false;
              validSmush = opts.fittingRules.vRule5 ? vRule5_Smush(ch1, ch2) : validSmush;
              validSmush = !validSmush && opts.fittingRules.vRule1 ? vRule1_Smush(ch1, ch2) : validSmush;
              validSmush = !validSmush && opts.fittingRules.vRule2 ? vRule2_Smush(ch1, ch2) : validSmush;
              validSmush = !validSmush && opts.fittingRules.vRule3 ? vRule3_Smush(ch1, ch2) : validSmush;
              validSmush = !validSmush && opts.fittingRules.vRule4 ? vRule4_Smush(ch1, ch2) : validSmush;
              result += validSmush;
            }
          } else {
            result += uni_Smush(ch1, ch2);
          }
        }
        return result;
      }
      __name(verticallySmushLines, "verticallySmushLines");
      function verticalSmush(lines1, lines2, overlap, opts) {
        let len1 = lines1.length;
        let len2 = lines2.length;
        let piece1 = lines1.slice(0, Math.max(0, len1 - overlap));
        let piece2_1 = lines1.slice(Math.max(0, len1 - overlap), len1);
        let piece2_2 = lines2.slice(0, Math.min(overlap, len2));
        let ii, len, line3, piece2 = [], piece3, result = [];
        len = piece2_1.length;
        for (ii = 0; ii < len; ii++) {
          if (ii >= len2) {
            line3 = piece2_1[ii];
          } else {
            line3 = verticallySmushLines(piece2_1[ii], piece2_2[ii], opts);
          }
          piece2.push(line3);
        }
        piece3 = lines2.slice(Math.min(overlap, len2), len2);
        return result.concat(piece1, piece2, piece3);
      }
      __name(verticalSmush, "verticalSmush");
      function padLines(lines, numSpaces) {
        let ii, len = lines.length, padding = "";
        for (ii = 0; ii < numSpaces; ii++) {
          padding += " ";
        }
        for (ii = 0; ii < len; ii++) {
          lines[ii] += padding;
        }
      }
      __name(padLines, "padLines");
      function smushVerticalFigLines(output2, lines, opts) {
        let len1 = output2[0].length;
        let len2 = lines[0].length;
        let overlap;
        if (len1 > len2) {
          padLines(lines, len1 - len2);
        } else if (len2 > len1) {
          padLines(output2, len2 - len1);
        }
        overlap = getVerticalSmushDist(output2, lines, opts);
        return verticalSmush(output2, lines, overlap, opts);
      }
      __name(smushVerticalFigLines, "smushVerticalFigLines");
      function getHorizontalSmushLength(txt1, txt2, opts) {
        if (opts.fittingRules.hLayout === FULL_WIDTH) {
          return 0;
        }
        let ii, len1 = txt1.length, len2 = txt2.length;
        let maxDist = len1;
        let curDist = 1;
        let breakAfter = false;
        let validSmush = false;
        let seg1, seg2, ch1, ch2;
        if (len1 === 0) {
          return 0;
        }
        distCal: while (curDist <= maxDist) {
          const seg1StartPos = len1 - curDist;
          seg1 = txt1.substring(seg1StartPos, seg1StartPos + curDist);
          seg2 = txt2.substring(0, Math.min(curDist, len2));
          for (ii = 0; ii < Math.min(curDist, len2); ii++) {
            ch1 = seg1.substring(ii, ii + 1);
            ch2 = seg2.substring(ii, ii + 1);
            if (ch1 !== " " && ch2 !== " ") {
              if (opts.fittingRules.hLayout === FITTING) {
                curDist = curDist - 1;
                break distCal;
              } else if (opts.fittingRules.hLayout === SMUSHING) {
                if (ch1 === opts.hardBlank || ch2 === opts.hardBlank) {
                  curDist = curDist - 1;
                }
                break distCal;
              } else {
                breakAfter = true;
                validSmush = false;
                validSmush = opts.fittingRules.hRule1 ? hRule1_Smush(ch1, ch2, opts.hardBlank) : validSmush;
                validSmush = !validSmush && opts.fittingRules.hRule2 ? hRule2_Smush(ch1, ch2, opts.hardBlank) : validSmush;
                validSmush = !validSmush && opts.fittingRules.hRule3 ? hRule3_Smush(ch1, ch2, opts.hardBlank) : validSmush;
                validSmush = !validSmush && opts.fittingRules.hRule4 ? hRule4_Smush(ch1, ch2, opts.hardBlank) : validSmush;
                validSmush = !validSmush && opts.fittingRules.hRule5 ? hRule5_Smush(ch1, ch2, opts.hardBlank) : validSmush;
                validSmush = !validSmush && opts.fittingRules.hRule6 ? hRule6_Smush(ch1, ch2, opts.hardBlank) : validSmush;
                if (!validSmush) {
                  curDist = curDist - 1;
                  break distCal;
                }
              }
            }
          }
          if (breakAfter) {
            break;
          }
          curDist++;
        }
        return Math.min(maxDist, curDist);
      }
      __name(getHorizontalSmushLength, "getHorizontalSmushLength");
      function horizontalSmush(textBlock1, textBlock2, overlap, opts) {
        let ii, jj, outputFig = [], overlapStart, piece1, piece2, piece3, len1, len2, txt1, txt2;
        for (ii = 0; ii < opts.height; ii++) {
          txt1 = textBlock1[ii];
          txt2 = textBlock2[ii];
          len1 = txt1.length;
          len2 = txt2.length;
          overlapStart = len1 - overlap;
          piece1 = txt1.substr(0, Math.max(0, overlapStart));
          piece2 = "";
          const seg1StartPos = Math.max(0, len1 - overlap);
          var seg1 = txt1.substring(seg1StartPos, seg1StartPos + overlap);
          var seg2 = txt2.substring(0, Math.min(overlap, len2));
          for (jj = 0; jj < overlap; jj++) {
            var ch1 = jj < len1 ? seg1.substring(jj, jj + 1) : " ";
            var ch2 = jj < len2 ? seg2.substring(jj, jj + 1) : " ";
            if (ch1 !== " " && ch2 !== " ") {
              if (opts.fittingRules.hLayout === FITTING) {
                piece2 += uni_Smush(ch1, ch2, opts.hardBlank);
              } else if (opts.fittingRules.hLayout === SMUSHING) {
                piece2 += uni_Smush(ch1, ch2, opts.hardBlank);
              } else {
                var nextCh = "";
                nextCh = !nextCh && opts.fittingRules.hRule1 ? hRule1_Smush(ch1, ch2, opts.hardBlank) : nextCh;
                nextCh = !nextCh && opts.fittingRules.hRule2 ? hRule2_Smush(ch1, ch2, opts.hardBlank) : nextCh;
                nextCh = !nextCh && opts.fittingRules.hRule3 ? hRule3_Smush(ch1, ch2, opts.hardBlank) : nextCh;
                nextCh = !nextCh && opts.fittingRules.hRule4 ? hRule4_Smush(ch1, ch2, opts.hardBlank) : nextCh;
                nextCh = !nextCh && opts.fittingRules.hRule5 ? hRule5_Smush(ch1, ch2, opts.hardBlank) : nextCh;
                nextCh = !nextCh && opts.fittingRules.hRule6 ? hRule6_Smush(ch1, ch2, opts.hardBlank) : nextCh;
                nextCh = nextCh || uni_Smush(ch1, ch2, opts.hardBlank);
                piece2 += nextCh;
              }
            } else {
              piece2 += uni_Smush(ch1, ch2, opts.hardBlank);
            }
          }
          if (overlap >= len2) {
            piece3 = "";
          } else {
            piece3 = txt2.substring(overlap, overlap + Math.max(0, len2 - overlap));
          }
          outputFig[ii] = piece1 + piece2 + piece3;
        }
        return outputFig;
      }
      __name(horizontalSmush, "horizontalSmush");
      function newFigChar(len) {
        let outputFigText = [], row;
        for (row = 0; row < len; row++) {
          outputFigText[row] = "";
        }
        return outputFigText;
      }
      __name(newFigChar, "newFigChar");
      const figLinesWidth = /* @__PURE__ */ __name(function(textLines) {
        return Math.max.apply(
          Math,
          textLines.map(function(line3, i) {
            return line3.length;
          })
        );
      }, "figLinesWidth");
      function joinFigArray(array2, len, opts) {
        return array2.reduce(function(acc, data) {
          return horizontalSmush(acc, data.fig, data.overlap, opts);
        }, newFigChar(len));
      }
      __name(joinFigArray, "joinFigArray");
      function breakWord2(figChars, len, opts) {
        const result = {};
        for (let i = figChars.length; --i; ) {
          let w = joinFigArray(figChars.slice(0, i), len, opts);
          if (figLinesWidth(w) <= opts.width) {
            result.outputFigText = w;
            if (i < figChars.length) {
              result.chars = figChars.slice(i);
            } else {
              result.chars = [];
            }
            break;
          }
        }
        return result;
      }
      __name(breakWord2, "breakWord");
      function generateFigTextLines(txt, figChars, opts) {
        let charIndex, figChar, overlap = 0, row, outputFigText, len, height = opts.height, outputFigLines = [], maxWidth, nextFigChars, figWords = [], char, isSpace, textFigWord, textFigLine, tmpBreak;
        outputFigText = newFigChar(height);
        if (opts.width > 0 && opts.whitespaceBreak) {
          nextFigChars = {
            chars: [],
            overlap
          };
        }
        if (opts.printDirection === 1) {
          txt = txt.split("").reverse().join("");
        }
        len = txt.length;
        for (charIndex = 0; charIndex < len; charIndex++) {
          char = txt.substring(charIndex, charIndex + 1);
          isSpace = char.match(/\s/);
          figChar = figChars[char.charCodeAt(0)];
          textFigLine = null;
          if (figChar) {
            if (opts.fittingRules.hLayout !== FULL_WIDTH) {
              overlap = 1e4;
              for (row = 0; row < opts.height; row++) {
                overlap = Math.min(
                  overlap,
                  getHorizontalSmushLength(outputFigText[row], figChar[row], opts)
                );
              }
              overlap = overlap === 1e4 ? 0 : overlap;
            }
            if (opts.width > 0) {
              if (opts.whitespaceBreak) {
                textFigWord = joinFigArray(
                  nextFigChars.chars.concat([
                    {
                      fig: figChar,
                      overlap
                    }
                  ]),
                  height,
                  opts
                );
                textFigLine = joinFigArray(
                  figWords.concat([
                    {
                      fig: textFigWord,
                      overlap: nextFigChars.overlap
                    }
                  ]),
                  height,
                  opts
                );
                maxWidth = figLinesWidth(textFigLine);
              } else {
                textFigLine = horizontalSmush(
                  outputFigText,
                  figChar,
                  overlap,
                  opts
                );
                maxWidth = figLinesWidth(textFigLine);
              }
              if (maxWidth >= opts.width && charIndex > 0) {
                if (opts.whitespaceBreak) {
                  outputFigText = joinFigArray(figWords.slice(0, -1), height, opts);
                  if (figWords.length > 1) {
                    outputFigLines.push(outputFigText);
                    outputFigText = newFigChar(height);
                  }
                  figWords = [];
                } else {
                  outputFigLines.push(outputFigText);
                  outputFigText = newFigChar(height);
                }
              }
            }
            if (opts.width > 0 && opts.whitespaceBreak) {
              if (!isSpace || charIndex === len - 1) {
                nextFigChars.chars.push({ fig: figChar, overlap });
              }
              if (isSpace || charIndex === len - 1) {
                tmpBreak = null;
                while (true) {
                  textFigLine = joinFigArray(nextFigChars.chars, height, opts);
                  maxWidth = figLinesWidth(textFigLine);
                  if (maxWidth >= opts.width) {
                    tmpBreak = breakWord2(nextFigChars.chars, height, opts);
                    nextFigChars = { chars: tmpBreak.chars };
                    outputFigLines.push(tmpBreak.outputFigText);
                  } else {
                    break;
                  }
                }
                if (maxWidth > 0) {
                  if (tmpBreak) {
                    figWords.push({ fig: textFigLine, overlap: 1 });
                  } else {
                    figWords.push({
                      fig: textFigLine,
                      overlap: nextFigChars.overlap
                    });
                  }
                }
                if (isSpace) {
                  figWords.push({ fig: figChar, overlap });
                  outputFigText = newFigChar(height);
                }
                if (charIndex === len - 1) {
                  outputFigText = joinFigArray(figWords, height, opts);
                }
                nextFigChars = {
                  chars: [],
                  overlap
                };
                continue;
              }
            }
            outputFigText = horizontalSmush(outputFigText, figChar, overlap, opts);
          }
        }
        if (figLinesWidth(outputFigText) > 0) {
          outputFigLines.push(outputFigText);
        }
        if (opts.showHardBlanks !== true) {
          outputFigLines.forEach(function(outputFigText2) {
            len = outputFigText2.length;
            for (row = 0; row < len; row++) {
              outputFigText2[row] = outputFigText2[row].replace(
                new RegExp("\\" + opts.hardBlank, "g"),
                " "
              );
            }
          });
        }
        return outputFigLines;
      }
      __name(generateFigTextLines, "generateFigTextLines");
      const getHorizontalFittingRules = /* @__PURE__ */ __name(function(layout, options) {
        let props = [
          "hLayout",
          "hRule1",
          "hRule2",
          "hRule3",
          "hRule4",
          "hRule5",
          "hRule6"
        ], params = {}, ii;
        if (layout === "default") {
          for (ii = 0; ii < props.length; ii++) {
            params[props[ii]] = options.fittingRules[props[ii]];
          }
        } else if (layout === "full") {
          params = {
            hLayout: FULL_WIDTH,
            hRule1: false,
            hRule2: false,
            hRule3: false,
            hRule4: false,
            hRule5: false,
            hRule6: false
          };
        } else if (layout === "fitted") {
          params = {
            hLayout: FITTING,
            hRule1: false,
            hRule2: false,
            hRule3: false,
            hRule4: false,
            hRule5: false,
            hRule6: false
          };
        } else if (layout === "controlled smushing") {
          params = {
            hLayout: CONTROLLED_SMUSHING,
            hRule1: true,
            hRule2: true,
            hRule3: true,
            hRule4: true,
            hRule5: true,
            hRule6: true
          };
        } else if (layout === "universal smushing") {
          params = {
            hLayout: SMUSHING,
            hRule1: false,
            hRule2: false,
            hRule3: false,
            hRule4: false,
            hRule5: false,
            hRule6: false
          };
        } else {
          return;
        }
        return params;
      }, "getHorizontalFittingRules");
      const getVerticalFittingRules = /* @__PURE__ */ __name(function(layout, options) {
        let props = ["vLayout", "vRule1", "vRule2", "vRule3", "vRule4", "vRule5"], params = {}, ii;
        if (layout === "default") {
          for (ii = 0; ii < props.length; ii++) {
            params[props[ii]] = options.fittingRules[props[ii]];
          }
        } else if (layout === "full") {
          params = {
            vLayout: FULL_WIDTH,
            vRule1: false,
            vRule2: false,
            vRule3: false,
            vRule4: false,
            vRule5: false
          };
        } else if (layout === "fitted") {
          params = {
            vLayout: FITTING,
            vRule1: false,
            vRule2: false,
            vRule3: false,
            vRule4: false,
            vRule5: false
          };
        } else if (layout === "controlled smushing") {
          params = {
            vLayout: CONTROLLED_SMUSHING,
            vRule1: true,
            vRule2: true,
            vRule3: true,
            vRule4: true,
            vRule5: true
          };
        } else if (layout === "universal smushing") {
          params = {
            vLayout: SMUSHING,
            vRule1: false,
            vRule2: false,
            vRule3: false,
            vRule4: false,
            vRule5: false
          };
        } else {
          return;
        }
        return params;
      }, "getVerticalFittingRules");
      const generateText = /* @__PURE__ */ __name(function(fontName, options, txt) {
        txt = txt.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        let lines = txt.split("\n");
        let figLines = [];
        let ii, len, output2;
        len = lines.length;
        for (ii = 0; ii < len; ii++) {
          figLines = figLines.concat(
            generateFigTextLines(lines[ii], figFonts[fontName], options)
          );
        }
        len = figLines.length;
        output2 = figLines[0];
        for (ii = 1; ii < len; ii++) {
          output2 = smushVerticalFigLines(output2, figLines[ii], options);
        }
        return output2 ? output2.join("\n") : "";
      }, "generateText");
      function _reworkFontOpts(fontOpts, options) {
        let myOpts = JSON.parse(JSON.stringify(fontOpts)), params, prop;
        if (typeof options.horizontalLayout !== "undefined") {
          params = getHorizontalFittingRules(options.horizontalLayout, fontOpts);
          for (prop in params) {
            if (params.hasOwnProperty(prop)) {
              myOpts.fittingRules[prop] = params[prop];
            }
          }
        }
        if (typeof options.verticalLayout !== "undefined") {
          params = getVerticalFittingRules(options.verticalLayout, fontOpts);
          for (prop in params) {
            if (params.hasOwnProperty(prop)) {
              myOpts.fittingRules[prop] = params[prop];
            }
          }
        }
        myOpts.printDirection = typeof options.printDirection !== "undefined" ? options.printDirection : fontOpts.printDirection;
        myOpts.showHardBlanks = options.showHardBlanks || false;
        myOpts.width = options.width || -1;
        myOpts.whitespaceBreak = options.whitespaceBreak || false;
        return myOpts;
      }
      __name(_reworkFontOpts, "_reworkFontOpts");
      const me = /* @__PURE__ */ __name(function(txt, options, next) {
        return me.text(txt, options, next);
      }, "me");
      me.text = async function(txt, options, next) {
        let fontName = "";
        txt = txt + "";
        if (typeof arguments[1] === "function") {
          next = options;
          options = {};
          options.font = figDefaults.font;
        }
        if (typeof options === "string") {
          fontName = options;
          options = {};
        } else {
          options = options || {};
          fontName = options.font || figDefaults.font;
        }
        return await new Promise((resolve2, reject) => {
          me.loadFont(fontName, function(err2, fontOpts) {
            if (err2) {
              reject(err2);
              if (next) next(err2);
              return;
            }
            const generatedTxt = generateText(
              fontName,
              _reworkFontOpts(fontOpts, options),
              txt
            );
            resolve2(generatedTxt);
            if (next) next(null, generatedTxt);
          });
        });
      };
      me.textSync = function(txt, options) {
        let fontName = "";
        txt = txt + "";
        if (typeof options === "string") {
          fontName = options;
          options = {};
        } else {
          options = options || {};
          fontName = options.font || figDefaults.font;
        }
        var fontOpts = _reworkFontOpts(me.loadFontSync(fontName), options);
        return generateText(fontName, fontOpts, txt);
      };
      me.metadata = function(fontName, next) {
        fontName = fontName + "";
        return new Promise(function(resolve2, reject) {
          me.loadFont(fontName, function(err2, fontOpts) {
            if (err2) {
              if (next) next(err2);
              reject(err2);
              return;
            }
            if (next) {
              next(null, fontOpts, figFonts[fontName].comment);
            }
            resolve2([fontOpts, figFonts[fontName].comment]);
          });
        });
      };
      me.defaults = function(opts) {
        if (typeof opts === "object" && opts !== null) {
          for (var prop in opts) {
            if (opts.hasOwnProperty(prop)) {
              figDefaults[prop] = opts[prop];
            }
          }
        }
        return JSON.parse(JSON.stringify(figDefaults));
      };
      me.parseFont = function(fontName, data) {
        data = data.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        figFonts[fontName] = {};
        var lines = data.split("\n");
        var headerData = lines.splice(0, 1)[0].split(" ");
        var figFont = figFonts[fontName];
        var opts = {};
        opts.hardBlank = headerData[0].substr(5, 1);
        opts.height = parseInt(headerData[1], 10);
        opts.baseline = parseInt(headerData[2], 10);
        opts.maxLength = parseInt(headerData[3], 10);
        opts.oldLayout = parseInt(headerData[4], 10);
        opts.numCommentLines = parseInt(headerData[5], 10);
        opts.printDirection = headerData.length >= 6 ? parseInt(headerData[6], 10) : 0;
        opts.fullLayout = headerData.length >= 7 ? parseInt(headerData[7], 10) : null;
        opts.codeTagCount = headerData.length >= 8 ? parseInt(headerData[8], 10) : null;
        opts.fittingRules = getSmushingRules(opts.oldLayout, opts.fullLayout);
        figFont.options = opts;
        if (opts.hardBlank.length !== 1 || isNaN(opts.height) || isNaN(opts.baseline) || isNaN(opts.maxLength) || isNaN(opts.oldLayout) || isNaN(opts.numCommentLines)) {
          throw new Error("FIGlet header contains invalid values.");
        }
        let charNums = [], ii;
        for (ii = 32; ii <= 126; ii++) {
          charNums.push(ii);
        }
        charNums = charNums.concat(196, 214, 220, 228, 246, 252, 223);
        if (lines.length < opts.numCommentLines + opts.height * charNums.length) {
          throw new Error("FIGlet file is missing data.");
        }
        let cNum, endCharRegEx, parseError2 = false;
        figFont.comment = lines.splice(0, opts.numCommentLines).join("\n");
        figFont.numChars = 0;
        while (lines.length > 0 && figFont.numChars < charNums.length) {
          cNum = charNums[figFont.numChars];
          figFont[cNum] = lines.splice(0, opts.height);
          for (ii = 0; ii < opts.height; ii++) {
            if (typeof figFont[cNum][ii] === "undefined") {
              figFont[cNum][ii] = "";
            } else {
              endCharRegEx = new RegExp(
                "\\" + figFont[cNum][ii].substr(figFont[cNum][ii].length - 1, 1) + "+$"
              );
              figFont[cNum][ii] = figFont[cNum][ii].replace(endCharRegEx, "");
            }
          }
          figFont.numChars++;
        }
        while (lines.length > 0) {
          cNum = lines.splice(0, 1)[0].split(" ")[0];
          if (/^0[xX][0-9a-fA-F]+$/.test(cNum)) {
            cNum = parseInt(cNum, 16);
          } else if (/^0[0-7]+$/.test(cNum)) {
            cNum = parseInt(cNum, 8);
          } else if (/^[0-9]+$/.test(cNum)) {
            cNum = parseInt(cNum, 10);
          } else if (/^-0[xX][0-9a-fA-F]+$/.test(cNum)) {
            cNum = parseInt(cNum, 16);
          } else {
            if (cNum === "") {
              break;
            }
            console.log("Invalid data:" + cNum);
            parseError2 = true;
            break;
          }
          figFont[cNum] = lines.splice(0, opts.height);
          for (ii = 0; ii < opts.height; ii++) {
            if (typeof figFont[cNum][ii] === "undefined") {
              figFont[cNum][ii] = "";
            } else {
              endCharRegEx = new RegExp(
                "\\" + figFont[cNum][ii].substr(figFont[cNum][ii].length - 1, 1) + "+$"
              );
              figFont[cNum][ii] = figFont[cNum][ii].replace(endCharRegEx, "");
            }
          }
          figFont.numChars++;
        }
        if (parseError2 === true) {
          throw new Error("Error parsing data.");
        }
        return opts;
      };
      me.loadFont = function(fontName, next) {
        if (figFonts[fontName]) {
          if (next) {
            next(null, figFonts[fontName].options);
          }
          return Promise.resolve();
        }
        if (typeof fetch !== "function") {
          console.error(
            "figlet.js requires the fetch API or a fetch polyfill such as https://cdnjs.com/libraries/fetch"
          );
          throw new Error("fetch is required for figlet.js to work.");
        }
        return fetch(figDefaults.fontPath + "/" + fontName + ".flf").then(function(response) {
          if (response.ok) {
            return response.text();
          }
          console.log("Unexpected response", response);
          throw new Error("Network response was not ok.");
        }).then(function(text) {
          if (next) {
            next(null, me.parseFont(fontName, text));
          }
        }).catch(next);
      };
      me.loadFontSync = function(name) {
        if (figFonts[name]) {
          return figFonts[name].options;
        }
        throw new Error(
          "synchronous font loading is not implemented for the browser"
        );
      };
      me.preloadFonts = function(fonts, next) {
        let fontData = [];
        return fonts.reduce(function(promise, name) {
          return promise.then(function() {
            return fetch(figDefaults.fontPath + "/" + name + ".flf").then((response) => {
              return response.text();
            }).then(function(data) {
              fontData.push(data);
            });
          });
        }, Promise.resolve()).then(function(res) {
          for (var i in fonts) {
            if (fonts.hasOwnProperty(i)) {
              me.parseFont(fonts[i], fontData[i]);
            }
          }
          if (next) next();
        });
      };
      me.figFonts = figFonts;
      return me;
    })();
    {
      {
        module.exports = figlet2;
      }
    }
  })(figlet$1);
  return figlet$1.exports;
}
__name(requireFiglet, "requireFiglet");
var figletExports = requireFiglet();
const figlet = /* @__PURE__ */ getDefaultExportFromCjs$1(figletExports);
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
var browser$5 = { exports: {} };
var process = browser$5.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
__name(defaultSetTimout, "defaultSetTimout");
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
__name(defaultClearTimeout, "defaultClearTimeout");
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e2) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e2) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e3) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
__name(runTimeout, "runTimeout");
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e3) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
__name(runClearTimeout, "runClearTimeout");
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
__name(cleanUpNextTick, "cleanUpNextTick");
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
__name(drainQueue, "drainQueue");
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array2) {
  this.fun = fun;
  this.array = array2;
}
__name(Item, "Item");
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$1() {
}
__name(noop$1, "noop$1");
process.on = noop$1;
process.addListener = noop$1;
process.once = noop$1;
process.off = noop$1;
process.removeListener = noop$1;
process.removeAllListeners = noop$1;
process.emit = noop$1;
process.prependListener = noop$1;
process.prependOnceListener = noop$1;
process.listeners = function(name) {
  return [];
};
process.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$2 = browser$5.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$2);
var pathBrowserify;
var hasRequiredPathBrowserify;
function requirePathBrowserify() {
  if (hasRequiredPathBrowserify) return pathBrowserify;
  hasRequiredPathBrowserify = 1;
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
    }
  }
  __name(assertPath, "assertPath");
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots15 = 0;
    var code2;
    for (var i = 0; i <= path2.length; ++i) {
      if (i < path2.length)
        code2 = path2.charCodeAt(i);
      else if (code2 === 47)
        break;
      else
        code2 = 47;
      if (code2 === 47) {
        if (lastSlash === i - 1 || dots15 === 1) ;
        else if (lastSlash !== i - 1 && dots15 === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i;
                dots15 = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots15 = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path2.slice(lastSlash + 1, i);
          else
            res = path2.slice(lastSlash + 1, i);
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots15 = 0;
      } else if (code2 === 46 && dots15 !== -1) {
        ++dots15;
      } else {
        dots15 = -1;
      }
    }
    return res;
  }
  __name(normalizeStringPosix, "normalizeStringPosix");
  function _format2(sep2, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep2 + base;
  }
  __name(_format2, "_format");
  var posix = {
    // path.resolve([from ...], to)
    resolve: /* @__PURE__ */ __name(function resolve2() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path2;
        if (i >= 0)
          path2 = arguments[i];
        else {
          if (cwd === void 0)
            cwd = process$1.cwd();
          path2 = cwd;
        }
        assertPath(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + "/" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    }, "resolve"),
    normalize: /* @__PURE__ */ __name(function normalize2(path2) {
      assertPath(path2);
      if (path2.length === 0) return ".";
      var isAbsolute2 = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute2);
      if (path2.length === 0 && !isAbsolute2) path2 = ".";
      if (path2.length > 0 && trailingSeparator) path2 += "/";
      if (isAbsolute2) return "/" + path2;
      return path2;
    }, "normalize"),
    isAbsolute: /* @__PURE__ */ __name(function isAbsolute2(path2) {
      assertPath(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    }, "isAbsolute"),
    join: /* @__PURE__ */ __name(function join2() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i = 0; i < arguments.length; ++i) {
        var arg = arguments[i];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix.normalize(joined);
    }, "join"),
    relative: /* @__PURE__ */ __name(function relative2(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to) return "";
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to) return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i = 0;
      for (; i <= length; ++i) {
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === 47) {
              return to.slice(toStart + i + 1);
            } else if (i === 0) {
              return to.slice(toStart + i);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i) === 47) {
              lastCommonSep = i;
            } else if (i === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i);
        var toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i;
      }
      var out = "";
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    }, "relative"),
    _makeLong: /* @__PURE__ */ __name(function _makeLong(path2) {
      return path2;
    }, "_makeLong"),
    dirname: /* @__PURE__ */ __name(function dirname2(path2) {
      assertPath(path2);
      if (path2.length === 0) return ".";
      var code2 = path2.charCodeAt(0);
      var hasRoot = code2 === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i = path2.length - 1; i >= 1; --i) {
        code2 = path2.charCodeAt(i);
        if (code2 === 47) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) return hasRoot ? "/" : ".";
      if (hasRoot && end === 1) return "//";
      return path2.slice(0, end);
    }, "dirname"),
    basename: /* @__PURE__ */ __name(function basename2(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
      assertPath(path2);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2) return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i = path2.length - 1; i >= 0; --i) {
          var code2 = path2.charCodeAt(i);
          if (code2 === 47) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code2 === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path2.length;
        return path2.slice(start, end);
      } else {
        for (i = path2.length - 1; i >= 0; --i) {
          if (path2.charCodeAt(i) === 47) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
        }
        if (end === -1) return "";
        return path2.slice(start, end);
      }
    }, "basename"),
    extname: /* @__PURE__ */ __name(function extname2(path2) {
      assertPath(path2);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i = path2.length - 1; i >= 0; --i) {
        var code2 = path2.charCodeAt(i);
        if (code2 === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code2 === 46) {
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    }, "extname"),
    format: /* @__PURE__ */ __name(function format2(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format2("/", pathObject);
    }, "format"),
    parse: /* @__PURE__ */ __name(function parse2(path2) {
      assertPath(path2);
      var ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path2.length === 0) return ret;
      var code2 = path2.charCodeAt(0);
      var isAbsolute2 = code2 === 47;
      var start;
      if (isAbsolute2) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i = path2.length - 1;
      var preDotState = 0;
      for (; i >= start; --i) {
        code2 = path2.charCodeAt(i);
        if (code2 === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code2 === 46) {
          if (startDot === -1) startDot = i;
          else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute2) ret.base = ret.name = path2.slice(1, end);
          else ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute2) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      if (startPart > 0) ret.dir = path2.slice(0, startPart - 1);
      else if (isAbsolute2) ret.dir = "/";
      return ret;
    }, "parse"),
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix.posix = posix;
  pathBrowserify = posix;
  return pathBrowserify;
}
__name(requirePathBrowserify, "requirePathBrowserify");
var pathBrowserifyExports = requirePathBrowserify();
const path$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(pathBrowserifyExports);
var re$2 = { exports: {} };
var constants$1;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants$1;
  hasRequiredConstants = 1;
  const SEMVER_SPEC_VERSION = "2.0.0";
  const MAX_LENGTH = 256;
  const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991;
  const MAX_SAFE_COMPONENT_LENGTH = 16;
  const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  const RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  constants$1 = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
  return constants$1;
}
__name(requireConstants, "requireConstants");
var debug_1;
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug_1;
  hasRequiredDebug = 1;
  const debug2 = typeof process$1 === "object" && process$1.env && process$1.env.NODE_DEBUG && /\bsemver\b/i.test(process$1.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  debug_1 = debug2;
  return debug_1;
}
__name(requireDebug, "requireDebug");
var hasRequiredRe;
function requireRe() {
  if (hasRequiredRe) return re$2.exports;
  hasRequiredRe = 1;
  (function(module, exports) {
    const {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = requireConstants();
    const debug2 = requireDebug();
    exports = module.exports = {};
    const re2 = exports.re = [];
    const safeRe = exports.safeRe = [];
    const src = exports.src = [];
    const t2 = exports.t = {};
    let R = 0;
    const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    const safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    const makeSafeRegex = /* @__PURE__ */ __name((value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    }, "makeSafeRegex");
    const createToken = /* @__PURE__ */ __name((name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug2(name, index, value);
      t2[name] = index;
      src[index] = value;
      re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    }, "createToken");
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
    createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
    createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t2.COERCEPLAIN] + `(?:${src[t2.PRERELEASE]})?(?:${src[t2.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t2.COERCE], true);
    createToken("COERCERTLFULL", src[t2.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(re$2, re$2.exports);
  return re$2.exports;
}
__name(requireRe, "requireRe");
var parseOptions_1;
var hasRequiredParseOptions;
function requireParseOptions() {
  if (hasRequiredParseOptions) return parseOptions_1;
  hasRequiredParseOptions = 1;
  const looseOption = Object.freeze({ loose: true });
  const emptyOpts = Object.freeze({});
  const parseOptions = /* @__PURE__ */ __name((options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  }, "parseOptions");
  parseOptions_1 = parseOptions;
  return parseOptions_1;
}
__name(requireParseOptions, "requireParseOptions");
var identifiers;
var hasRequiredIdentifiers;
function requireIdentifiers() {
  if (hasRequiredIdentifiers) return identifiers;
  hasRequiredIdentifiers = 1;
  const numeric = /^[0-9]+$/;
  const compareIdentifiers = /* @__PURE__ */ __name((a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }, "compareIdentifiers");
  const rcompareIdentifiers = /* @__PURE__ */ __name((a, b) => compareIdentifiers(b, a), "rcompareIdentifiers");
  identifiers = {
    compareIdentifiers,
    rcompareIdentifiers
  };
  return identifiers;
}
__name(requireIdentifiers, "requireIdentifiers");
var semver$2;
var hasRequiredSemver$1;
function requireSemver$1() {
  if (hasRequiredSemver$1) return semver$2;
  hasRequiredSemver$1 = 1;
  const debug2 = requireDebug();
  const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants();
  const { safeRe: re2, t: t2 } = requireRe();
  const parseOptions = requireParseOptions();
  const { compareIdentifiers } = requireIdentifiers();
  const _SemVer = class _SemVer {
    constructor(version2, options) {
      options = parseOptions(options);
      if (version2 instanceof _SemVer) {
        if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError(
          `version is longer than ${MAX_LENGTH} characters`
        );
      }
      debug2("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version2.trim().match(options.loose ? re2[t2.LOOSE] : re2[t2.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version2}`);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug2("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof _SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new _SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof _SemVer)) {
        other = new _SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof _SemVer)) {
        other = new _SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug2("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof _SemVer)) {
        other = new _SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug2("build compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  };
  __name(_SemVer, "SemVer");
  let SemVer = _SemVer;
  semver$2 = SemVer;
  return semver$2;
}
__name(requireSemver$1, "requireSemver$1");
var parse_1;
var hasRequiredParse$1;
function requireParse$1() {
  if (hasRequiredParse$1) return parse_1;
  hasRequiredParse$1 = 1;
  const SemVer = requireSemver$1();
  const parse2 = /* @__PURE__ */ __name((version2, options, throwErrors = false) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  }, "parse");
  parse_1 = parse2;
  return parse_1;
}
__name(requireParse$1, "requireParse$1");
var valid_1;
var hasRequiredValid$1;
function requireValid$1() {
  if (hasRequiredValid$1) return valid_1;
  hasRequiredValid$1 = 1;
  const parse2 = requireParse$1();
  const valid2 = /* @__PURE__ */ __name((version2, options) => {
    const v = parse2(version2, options);
    return v ? v.version : null;
  }, "valid");
  valid_1 = valid2;
  return valid_1;
}
__name(requireValid$1, "requireValid$1");
var clean_1;
var hasRequiredClean;
function requireClean() {
  if (hasRequiredClean) return clean_1;
  hasRequiredClean = 1;
  const parse2 = requireParse$1();
  const clean = /* @__PURE__ */ __name((version2, options) => {
    const s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }, "clean");
  clean_1 = clean;
  return clean_1;
}
__name(requireClean, "requireClean");
var inc_1;
var hasRequiredInc;
function requireInc() {
  if (hasRequiredInc) return inc_1;
  hasRequiredInc = 1;
  const SemVer = requireSemver$1();
  const inc = /* @__PURE__ */ __name((version2, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = void 0;
    }
    try {
      return new SemVer(
        version2 instanceof SemVer ? version2.version : version2,
        options
      ).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  }, "inc");
  inc_1 = inc;
  return inc_1;
}
__name(requireInc, "requireInc");
var diff_1;
var hasRequiredDiff;
function requireDiff() {
  if (hasRequiredDiff) return diff_1;
  hasRequiredDiff = 1;
  const parse2 = requireParse$1();
  const diff = /* @__PURE__ */ __name((version1, version2) => {
    const v1 = parse2(version1, null, true);
    const v2 = parse2(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (highVersion.patch) {
        return "patch";
      }
      if (highVersion.minor) {
        return "minor";
      }
      return "major";
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  }, "diff");
  diff_1 = diff;
  return diff_1;
}
__name(requireDiff, "requireDiff");
var major_1;
var hasRequiredMajor;
function requireMajor() {
  if (hasRequiredMajor) return major_1;
  hasRequiredMajor = 1;
  const SemVer = requireSemver$1();
  const major = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).major, "major");
  major_1 = major;
  return major_1;
}
__name(requireMajor, "requireMajor");
var minor_1;
var hasRequiredMinor;
function requireMinor() {
  if (hasRequiredMinor) return minor_1;
  hasRequiredMinor = 1;
  const SemVer = requireSemver$1();
  const minor = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).minor, "minor");
  minor_1 = minor;
  return minor_1;
}
__name(requireMinor, "requireMinor");
var patch_1;
var hasRequiredPatch;
function requirePatch() {
  if (hasRequiredPatch) return patch_1;
  hasRequiredPatch = 1;
  const SemVer = requireSemver$1();
  const patch = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).patch, "patch");
  patch_1 = patch;
  return patch_1;
}
__name(requirePatch, "requirePatch");
var prerelease_1;
var hasRequiredPrerelease;
function requirePrerelease() {
  if (hasRequiredPrerelease) return prerelease_1;
  hasRequiredPrerelease = 1;
  const parse2 = requireParse$1();
  const prerelease = /* @__PURE__ */ __name((version2, options) => {
    const parsed = parse2(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }, "prerelease");
  prerelease_1 = prerelease;
  return prerelease_1;
}
__name(requirePrerelease, "requirePrerelease");
var compare_1;
var hasRequiredCompare;
function requireCompare() {
  if (hasRequiredCompare) return compare_1;
  hasRequiredCompare = 1;
  const SemVer = requireSemver$1();
  const compare = /* @__PURE__ */ __name((a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose)), "compare");
  compare_1 = compare;
  return compare_1;
}
__name(requireCompare, "requireCompare");
var rcompare_1;
var hasRequiredRcompare;
function requireRcompare() {
  if (hasRequiredRcompare) return rcompare_1;
  hasRequiredRcompare = 1;
  const compare = requireCompare();
  const rcompare = /* @__PURE__ */ __name((a, b, loose) => compare(b, a, loose), "rcompare");
  rcompare_1 = rcompare;
  return rcompare_1;
}
__name(requireRcompare, "requireRcompare");
var compareLoose_1;
var hasRequiredCompareLoose;
function requireCompareLoose() {
  if (hasRequiredCompareLoose) return compareLoose_1;
  hasRequiredCompareLoose = 1;
  const compare = requireCompare();
  const compareLoose = /* @__PURE__ */ __name((a, b) => compare(a, b, true), "compareLoose");
  compareLoose_1 = compareLoose;
  return compareLoose_1;
}
__name(requireCompareLoose, "requireCompareLoose");
var compareBuild_1;
var hasRequiredCompareBuild;
function requireCompareBuild() {
  if (hasRequiredCompareBuild) return compareBuild_1;
  hasRequiredCompareBuild = 1;
  const SemVer = requireSemver$1();
  const compareBuild = /* @__PURE__ */ __name((a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }, "compareBuild");
  compareBuild_1 = compareBuild;
  return compareBuild_1;
}
__name(requireCompareBuild, "requireCompareBuild");
var sort_1;
var hasRequiredSort;
function requireSort() {
  if (hasRequiredSort) return sort_1;
  hasRequiredSort = 1;
  const compareBuild = requireCompareBuild();
  const sort = /* @__PURE__ */ __name((list2, loose) => list2.sort((a, b) => compareBuild(a, b, loose)), "sort");
  sort_1 = sort;
  return sort_1;
}
__name(requireSort, "requireSort");
var rsort_1;
var hasRequiredRsort;
function requireRsort() {
  if (hasRequiredRsort) return rsort_1;
  hasRequiredRsort = 1;
  const compareBuild = requireCompareBuild();
  const rsort = /* @__PURE__ */ __name((list2, loose) => list2.sort((a, b) => compareBuild(b, a, loose)), "rsort");
  rsort_1 = rsort;
  return rsort_1;
}
__name(requireRsort, "requireRsort");
var gt_1;
var hasRequiredGt;
function requireGt() {
  if (hasRequiredGt) return gt_1;
  hasRequiredGt = 1;
  const compare = requireCompare();
  const gt = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) > 0, "gt");
  gt_1 = gt;
  return gt_1;
}
__name(requireGt, "requireGt");
var lt_1;
var hasRequiredLt;
function requireLt() {
  if (hasRequiredLt) return lt_1;
  hasRequiredLt = 1;
  const compare = requireCompare();
  const lt = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) < 0, "lt");
  lt_1 = lt;
  return lt_1;
}
__name(requireLt, "requireLt");
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  const compare = requireCompare();
  const eq = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) === 0, "eq");
  eq_1 = eq;
  return eq_1;
}
__name(requireEq, "requireEq");
var neq_1;
var hasRequiredNeq;
function requireNeq() {
  if (hasRequiredNeq) return neq_1;
  hasRequiredNeq = 1;
  const compare = requireCompare();
  const neq = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) !== 0, "neq");
  neq_1 = neq;
  return neq_1;
}
__name(requireNeq, "requireNeq");
var gte_1;
var hasRequiredGte;
function requireGte() {
  if (hasRequiredGte) return gte_1;
  hasRequiredGte = 1;
  const compare = requireCompare();
  const gte = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) >= 0, "gte");
  gte_1 = gte;
  return gte_1;
}
__name(requireGte, "requireGte");
var lte_1;
var hasRequiredLte;
function requireLte() {
  if (hasRequiredLte) return lte_1;
  hasRequiredLte = 1;
  const compare = requireCompare();
  const lte = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) <= 0, "lte");
  lte_1 = lte;
  return lte_1;
}
__name(requireLte, "requireLte");
var cmp_1;
var hasRequiredCmp;
function requireCmp() {
  if (hasRequiredCmp) return cmp_1;
  hasRequiredCmp = 1;
  const eq = requireEq();
  const neq = requireNeq();
  const gt = requireGt();
  const gte = requireGte();
  const lt = requireLt();
  const lte = requireLte();
  const cmp = /* @__PURE__ */ __name((a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  }, "cmp");
  cmp_1 = cmp;
  return cmp_1;
}
__name(requireCmp, "requireCmp");
var coerce_1;
var hasRequiredCoerce;
function requireCoerce() {
  if (hasRequiredCoerce) return coerce_1;
  hasRequiredCoerce = 1;
  const SemVer = requireSemver$1();
  const parse2 = requireParse$1();
  const { safeRe: re2, t: t2 } = requireRe();
  const coerce = /* @__PURE__ */ __name((version2, options) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version2.match(options.includePrerelease ? re2[t2.COERCEFULL] : re2[t2.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re2[t2.COERCERTLFULL] : re2[t2.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  }, "coerce");
  coerce_1 = coerce;
  return coerce_1;
}
__name(requireCoerce, "requireCoerce");
var lrucache;
var hasRequiredLrucache;
function requireLrucache() {
  if (hasRequiredLrucache) return lrucache;
  hasRequiredLrucache = 1;
  const _LRUCache = class _LRUCache {
    constructor() {
      this.max = 1e3;
      this.map = /* @__PURE__ */ new Map();
    }
    get(key) {
      const value = this.map.get(key);
      if (value === void 0) {
        return void 0;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== void 0) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  };
  __name(_LRUCache, "LRUCache");
  let LRUCache = _LRUCache;
  lrucache = LRUCache;
  return lrucache;
}
__name(requireLrucache, "requireLrucache");
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  const _Range = class _Range {
    constructor(range2, options) {
      options = parseOptions(options);
      if (range2 instanceof _Range) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new _Range(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range2);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof _Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  };
  __name(_Range, "Range");
  let Range = _Range;
  range = Range;
  const LRU = requireLrucache();
  const cache = new LRU();
  const parseOptions = requireParseOptions();
  const Comparator = requireComparator();
  const debug2 = requireDebug();
  const SemVer = requireSemver$1();
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = requireRe();
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants();
  const isNullSet = /* @__PURE__ */ __name((c) => c.value === "<0.0.0-0", "isNullSet");
  const isAny = /* @__PURE__ */ __name((c) => c.value === "", "isAny");
  const isSatisfiable = /* @__PURE__ */ __name((comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  }, "isSatisfiable");
  const parseComparator = /* @__PURE__ */ __name((comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  }, "parseComparator");
  const isX = /* @__PURE__ */ __name((id) => !id || id.toLowerCase() === "x" || id === "*", "isX");
  const replaceTildes = /* @__PURE__ */ __name((comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  }, "replaceTildes");
  const replaceTilde = /* @__PURE__ */ __name((comp, options) => {
    const r = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  }, "replaceTilde");
  const replaceCarets = /* @__PURE__ */ __name((comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  }, "replaceCarets");
  const replaceCaret = /* @__PURE__ */ __name((comp, options) => {
    debug2("caret", comp, options);
    const r = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  }, "replaceCaret");
  const replaceXRanges = /* @__PURE__ */ __name((comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  }, "replaceXRanges");
  const replaceXRange = /* @__PURE__ */ __name((comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  }, "replaceXRange");
  const replaceStars = /* @__PURE__ */ __name((comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  }, "replaceStars");
  const replaceGTE0 = /* @__PURE__ */ __name((comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  }, "replaceGTE0");
  const hyphenReplace = /* @__PURE__ */ __name((incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  }, "hyphenReplace");
  const testSet = /* @__PURE__ */ __name((set2, version2, options) => {
    for (let i = 0; i < set2.length; i++) {
      if (!set2[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set2.length; i++) {
        debug2(set2[i].semver);
        if (set2[i].semver === Comparator.ANY) {
          continue;
        }
        if (set2[i].semver.prerelease.length > 0) {
          const allowed = set2[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }, "testSet");
  return range;
}
__name(requireRange, "requireRange");
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY = Symbol("SemVer ANY");
  const _Comparator = class _Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof _Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof _Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  };
  __name(_Comparator, "Comparator");
  let Comparator = _Comparator;
  comparator = Comparator;
  const parseOptions = requireParseOptions();
  const { safeRe: re2, t: t2 } = requireRe();
  const cmp = requireCmp();
  const debug2 = requireDebug();
  const SemVer = requireSemver$1();
  const Range = requireRange();
  return comparator;
}
__name(requireComparator, "requireComparator");
var satisfies_1;
var hasRequiredSatisfies;
function requireSatisfies() {
  if (hasRequiredSatisfies) return satisfies_1;
  hasRequiredSatisfies = 1;
  const Range = requireRange();
  const satisfies = /* @__PURE__ */ __name((version2, range2, options) => {
    try {
      range2 = new Range(range2, options);
    } catch (er) {
      return false;
    }
    return range2.test(version2);
  }, "satisfies");
  satisfies_1 = satisfies;
  return satisfies_1;
}
__name(requireSatisfies, "requireSatisfies");
var toComparators_1;
var hasRequiredToComparators;
function requireToComparators() {
  if (hasRequiredToComparators) return toComparators_1;
  hasRequiredToComparators = 1;
  const Range = requireRange();
  const toComparators = /* @__PURE__ */ __name((range2, options) => new Range(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" ")), "toComparators");
  toComparators_1 = toComparators;
  return toComparators_1;
}
__name(requireToComparators, "requireToComparators");
var maxSatisfying_1;
var hasRequiredMaxSatisfying;
function requireMaxSatisfying() {
  if (hasRequiredMaxSatisfying) return maxSatisfying_1;
  hasRequiredMaxSatisfying = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const maxSatisfying = /* @__PURE__ */ __name((versions, range2, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }, "maxSatisfying");
  maxSatisfying_1 = maxSatisfying;
  return maxSatisfying_1;
}
__name(requireMaxSatisfying, "requireMaxSatisfying");
var minSatisfying_1;
var hasRequiredMinSatisfying;
function requireMinSatisfying() {
  if (hasRequiredMinSatisfying) return minSatisfying_1;
  hasRequiredMinSatisfying = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const minSatisfying = /* @__PURE__ */ __name((versions, range2, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }, "minSatisfying");
  minSatisfying_1 = minSatisfying;
  return minSatisfying_1;
}
__name(requireMinSatisfying, "requireMinSatisfying");
var minVersion_1;
var hasRequiredMinVersion;
function requireMinVersion() {
  if (hasRequiredMinVersion) return minVersion_1;
  hasRequiredMinVersion = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const gt = requireGt();
  const minVersion = /* @__PURE__ */ __name((range2, loose) => {
    range2 = new Range(range2, loose);
    let minver = new SemVer("0.0.0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0; i < range2.set.length; ++i) {
      const comparators = range2.set[i];
      let setMin = null;
      comparators.forEach((comparator2) => {
        const compver = new SemVer(comparator2.semver.version);
        switch (comparator2.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          /* fallthrough */
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${comparator2.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range2.test(minver)) {
      return minver;
    }
    return null;
  }, "minVersion");
  minVersion_1 = minVersion;
  return minVersion_1;
}
__name(requireMinVersion, "requireMinVersion");
var valid;
var hasRequiredValid;
function requireValid() {
  if (hasRequiredValid) return valid;
  hasRequiredValid = 1;
  const Range = requireRange();
  const validRange = /* @__PURE__ */ __name((range2, options) => {
    try {
      return new Range(range2, options).range || "*";
    } catch (er) {
      return null;
    }
  }, "validRange");
  valid = validRange;
  return valid;
}
__name(requireValid, "requireValid");
var outside_1;
var hasRequiredOutside;
function requireOutside() {
  if (hasRequiredOutside) return outside_1;
  hasRequiredOutside = 1;
  const SemVer = requireSemver$1();
  const Comparator = requireComparator();
  const { ANY } = Comparator;
  const Range = requireRange();
  const satisfies = requireSatisfies();
  const gt = requireGt();
  const lt = requireLt();
  const lte = requireLte();
  const gte = requireGte();
  const outside = /* @__PURE__ */ __name((version2, range2, hilo, options) => {
    version2 = new SemVer(version2, options);
    range2 = new Range(range2, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range2, options)) {
      return false;
    }
    for (let i = 0; i < range2.set.length; ++i) {
      const comparators = range2.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator2) => {
        if (comparator2.semver === ANY) {
          comparator2 = new Comparator(">=0.0.0");
        }
        high = high || comparator2;
        low = low || comparator2;
        if (gtfn(comparator2.semver, high.semver, options)) {
          high = comparator2;
        } else if (ltfn(comparator2.semver, low.semver, options)) {
          low = comparator2;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  }, "outside");
  outside_1 = outside;
  return outside_1;
}
__name(requireOutside, "requireOutside");
var gtr_1;
var hasRequiredGtr;
function requireGtr() {
  if (hasRequiredGtr) return gtr_1;
  hasRequiredGtr = 1;
  const outside = requireOutside();
  const gtr = /* @__PURE__ */ __name((version2, range2, options) => outside(version2, range2, ">", options), "gtr");
  gtr_1 = gtr;
  return gtr_1;
}
__name(requireGtr, "requireGtr");
var ltr_1;
var hasRequiredLtr;
function requireLtr() {
  if (hasRequiredLtr) return ltr_1;
  hasRequiredLtr = 1;
  const outside = requireOutside();
  const ltr = /* @__PURE__ */ __name((version2, range2, options) => outside(version2, range2, "<", options), "ltr");
  ltr_1 = ltr;
  return ltr_1;
}
__name(requireLtr, "requireLtr");
var intersects_1;
var hasRequiredIntersects;
function requireIntersects() {
  if (hasRequiredIntersects) return intersects_1;
  hasRequiredIntersects = 1;
  const Range = requireRange();
  const intersects = /* @__PURE__ */ __name((r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  }, "intersects");
  intersects_1 = intersects;
  return intersects_1;
}
__name(requireIntersects, "requireIntersects");
var simplify;
var hasRequiredSimplify;
function requireSimplify() {
  if (hasRequiredSimplify) return simplify;
  hasRequiredSimplify = 1;
  const satisfies = requireSatisfies();
  const compare = requireCompare();
  simplify = /* @__PURE__ */ __name((versions, range2, options) => {
    const set2 = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version2 of v) {
      const included = satisfies(version2, range2, options);
      if (included) {
        prev = version2;
        if (!first) {
          first = version2;
        }
      } else {
        if (prev) {
          set2.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set2.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set2) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range2.raw === "string" ? range2.raw : String(range2);
    return simplified.length < original.length ? simplified : range2;
  }, "simplify");
  return simplify;
}
__name(requireSimplify, "requireSimplify");
var subset_1;
var hasRequiredSubset;
function requireSubset() {
  if (hasRequiredSubset) return subset_1;
  hasRequiredSubset = 1;
  const Range = requireRange();
  const Comparator = requireComparator();
  const { ANY } = Comparator;
  const satisfies = requireSatisfies();
  const compare = requireCompare();
  const subset = /* @__PURE__ */ __name((sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) {
          continue OUTER;
        }
      }
      if (sawNonNull) {
        return false;
      }
    }
    return true;
  }, "subset");
  const minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  const minimumVersion = [new Comparator(">=0.0.0")];
  const simpleSubset = /* @__PURE__ */ __name((sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = /* @__PURE__ */ new Set();
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  }, "simpleSubset");
  const higherGT = /* @__PURE__ */ __name((a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  }, "higherGT");
  const lowerLT = /* @__PURE__ */ __name((a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  }, "lowerLT");
  subset_1 = subset;
  return subset_1;
}
__name(requireSubset, "requireSubset");
var semver$1;
var hasRequiredSemver;
function requireSemver() {
  if (hasRequiredSemver) return semver$1;
  hasRequiredSemver = 1;
  const internalRe = requireRe();
  const constants2 = requireConstants();
  const SemVer = requireSemver$1();
  const identifiers2 = requireIdentifiers();
  const parse2 = requireParse$1();
  const valid2 = requireValid$1();
  const clean = requireClean();
  const inc = requireInc();
  const diff = requireDiff();
  const major = requireMajor();
  const minor = requireMinor();
  const patch = requirePatch();
  const prerelease = requirePrerelease();
  const compare = requireCompare();
  const rcompare = requireRcompare();
  const compareLoose = requireCompareLoose();
  const compareBuild = requireCompareBuild();
  const sort = requireSort();
  const rsort = requireRsort();
  const gt = requireGt();
  const lt = requireLt();
  const eq = requireEq();
  const neq = requireNeq();
  const gte = requireGte();
  const lte = requireLte();
  const cmp = requireCmp();
  const coerce = requireCoerce();
  const Comparator = requireComparator();
  const Range = requireRange();
  const satisfies = requireSatisfies();
  const toComparators = requireToComparators();
  const maxSatisfying = requireMaxSatisfying();
  const minSatisfying = requireMinSatisfying();
  const minVersion = requireMinVersion();
  const validRange = requireValid();
  const outside = requireOutside();
  const gtr = requireGtr();
  const ltr = requireLtr();
  const intersects = requireIntersects();
  const simplifyRange = requireSimplify();
  const subset = requireSubset();
  semver$1 = {
    parse: parse2,
    valid: valid2,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants2.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants2.RELEASE_TYPES,
    compareIdentifiers: identifiers2.compareIdentifiers,
    rcompareIdentifiers: identifiers2.rcompareIdentifiers
  };
  return semver$1;
}
__name(requireSemver, "requireSemver");
var semverExports = requireSemver();
const semver = /* @__PURE__ */ getDefaultExportFromCjs$1(semverExports);
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3) return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has2 = Object.prototype.hasOwnProperty, prefix = "~";
    function Events2() {
    }
    __name(Events2, "Events");
    if (Object.create) {
      Events2.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events2().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    __name(EE, "EE");
    function addListener2(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    __name(addListener2, "addListener");
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events2();
      else delete emitter._events[evt];
    }
    __name(clearEvent, "clearEvent");
    function EventEmitter2() {
      this._events = new Events2();
      this._eventsCount = 0;
    }
    __name(EventEmitter2, "EventEmitter");
    EventEmitter2.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
      var names = [], events2, name;
      if (this._eventsCount === 0) return names;
      for (name in events2 = this._events) {
        if (has2.call(events2, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events2));
      }
      return names;
    }, "eventNames");
    EventEmitter2.prototype.listeners = /* @__PURE__ */ __name(function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    }, "listeners");
    EventEmitter2.prototype.listenerCount = /* @__PURE__ */ __name(function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    }, "listenerCount");
    EventEmitter2.prototype.emit = /* @__PURE__ */ __name(function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    }, "emit");
    EventEmitter2.prototype.on = /* @__PURE__ */ __name(function on(event, fn, context) {
      return addListener2(this, event, fn, context, false);
    }, "on");
    EventEmitter2.prototype.once = /* @__PURE__ */ __name(function once(event, fn, context) {
      return addListener2(this, event, fn, context, true);
    }, "once");
    EventEmitter2.prototype.removeListener = /* @__PURE__ */ __name(function removeListener2(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else clearEvent(this, evt);
      }
      return this;
    }, "removeListener");
    EventEmitter2.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events2();
        this._eventsCount = 0;
      }
      return this;
    }, "removeAllListeners");
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module.exports = EventEmitter2;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
__name(requireEventemitter3, "requireEventemitter3");
var eventemitter3Exports = requireEventemitter3();
const EventEmitter$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(eventemitter3Exports);
const _List = class _List extends EventEmitter$1 {
  constructor(values) {
    super();
    __publicField(this, _a, "List");
    __publicField(this, "data", /* @__PURE__ */ new Set());
    if (values) {
      this.push(...values);
    }
  }
  toSet() {
    return new Set(this.data);
  }
  toArray() {
    return Array.from(this.data);
  }
  toJSON() {
    return Array.from(this.data);
  }
  toString() {
    return this.join(",");
  }
  _set(index, value, _delete = false) {
    if (Math.abs(index) > this.data.size) {
      throw new ReferenceError("Can not set an element outside the bounds of the list");
    }
    const data = Array.from(this.data);
    data.splice(index, +_delete, value);
    this.data = new Set(data);
    this.emit("update");
  }
  set(index, value) {
    this._set(index, value, true);
  }
  deleteAt(index) {
    if (Math.abs(index) > this.data.size) {
      throw new ReferenceError("Can not delete an element outside the bounds of the list");
    }
    this.delete(Array.from(this.data).at(index));
  }
  insert(value, index = this.data.size) {
    this._set(index, value, false);
  }
  // Array methods
  at(index) {
    if (Math.abs(index) > this.data.size) {
      throw new ReferenceError("Can not access an element outside the bounds of the list");
    }
    return Array.from(this.data).at(index);
  }
  pop() {
    const item = Array.from(this.data).pop();
    if (item !== void 0) {
      this.delete(item);
    }
    return item;
  }
  push(...items) {
    for (const item of items) {
      this.add(item);
    }
    return this.data.size;
  }
  join(separator) {
    return Array.from(this.data).join(separator);
  }
  splice(start, deleteCount, ...items) {
    if (Math.abs(start) > this.data.size) {
      throw new ReferenceError("Can not splice elements outside the bounds of the list");
    }
    const data = Array.from(this.data);
    const deleted = data.splice(start, deleteCount, ...items);
    this.data = new Set(data);
    this.emit("update");
    return deleted;
  }
  // Set methods
  add(value) {
    this.data.add(value);
    this.emit("update");
    this.emit("add", value);
    return this;
  }
  clear() {
    this.data.clear();
    this.emit("update");
  }
  delete(value) {
    const success = this.data.delete(value);
    this.emit("update");
    return success;
  }
  has(value) {
    return this.data.has(value);
  }
  get size() {
    return this.data.size;
  }
  // Iteration
  entries() {
    return this.toArray().entries();
  }
  keys() {
    return this.toArray().keys();
  }
  values() {
    return this.data.values();
  }
  [(_a = Symbol.toStringTag, Symbol.iterator)]() {
    return this.data[Symbol.iterator]();
  }
};
__name(_List, "List");
let List = _List;
function filterObject(object, predicate) {
  const entries2 = Object.entries(object);
  return Object.fromEntries(entries2.filter(([key, value]) => predicate(key, value)));
}
__name(filterObject, "filterObject");
function pick(object, ...keys) {
  const picked = {};
  for (const key of keys.flat()) {
    picked[key] = object[key];
  }
  return picked;
}
__name(pick, "pick");
function omit(object, ...keys) {
  return filterObject(object, (key) => !keys.flat().includes(key));
}
__name(omit, "omit");
function isJSON(str) {
  try {
    JSON.parse(str);
    return true;
  } catch {
    return false;
  }
}
__name(isJSON, "isJSON");
function resolveConstructors(object) {
  const constructors = [];
  for (let prototype = object; prototype && !["Function", "Object"].includes(prototype.constructor.name); prototype = Object.getPrototypeOf(prototype)) {
    constructors.push(prototype.constructor.name);
  }
  return constructors;
}
__name(resolveConstructors, "resolveConstructors");
function bindFunctions(fns, thisValue) {
  return Object.fromEntries(Object.entries(fns).map(([k, v]) => [k, typeof v == "function" ? v.bind(thisValue) : v]));
}
__name(bindFunctions, "bindFunctions");
function canary(error = new Error()) {
  const timeout = setTimeout(() => {
    throw error;
  }, 5e3);
  return () => clearTimeout(timeout);
}
__name(canary, "canary");
function _throw(e2) {
  if (e2 && typeof e2 == "object" && resolveConstructors(e2).includes("Error"))
    Error?.captureStackTrace(e2, _throw);
  throw e2;
}
__name(_throw, "_throw");
const __formatter = Intl.NumberFormat("en", { notation: "compact" });
__formatter.format.bind(__formatter);
function randomInt(min = 0, max = 1) {
  return Math.round(Math.random() * (max - min) + min);
}
__name(randomInt, "randomInt");
function capitalize$1(value) {
  return value.at(0).toUpperCase() + value.slice(1);
}
__name(capitalize$1, "capitalize$1");
const encoder$1 = new TextEncoder();
function encodeUTF8(input) {
  return encoder$1.encode(input);
}
__name(encodeUTF8, "encodeUTF8");
const decoder$1 = new TextDecoder();
function decodeUTF8(input) {
  if (!input)
    return "";
  if (input.buffer instanceof ArrayBuffer && !input.buffer.resizable)
    return decoder$1.decode(input);
  const buffer2 = new Uint8Array(input.byteLength);
  buffer2.set(input);
  return decoder$1.decode(buffer2);
}
__name(decodeUTF8, "decodeUTF8");
function encodeUUID(uuid) {
  const hex = uuid.replace(/-/g, "");
  const data = new Uint8Array(16);
  for (let i = 0; i < 16; i++) {
    data[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
  }
  return data;
}
__name(encodeUUID, "encodeUUID");
var Errno;
(function(Errno2) {
  Errno2[Errno2["EPERM"] = 1] = "EPERM";
  Errno2[Errno2["ENOENT"] = 2] = "ENOENT";
  Errno2[Errno2["ESRCH"] = 3] = "ESRCH";
  Errno2[Errno2["EINTR"] = 4] = "EINTR";
  Errno2[Errno2["EIO"] = 5] = "EIO";
  Errno2[Errno2["ENXIO"] = 6] = "ENXIO";
  Errno2[Errno2["E2BIG"] = 7] = "E2BIG";
  Errno2[Errno2["ENOEXEC"] = 8] = "ENOEXEC";
  Errno2[Errno2["EBADF"] = 9] = "EBADF";
  Errno2[Errno2["ECHILD"] = 10] = "ECHILD";
  Errno2[Errno2["EAGAIN"] = 11] = "EAGAIN";
  Errno2[Errno2["ENOMEM"] = 12] = "ENOMEM";
  Errno2[Errno2["EACCES"] = 13] = "EACCES";
  Errno2[Errno2["EFAULT"] = 14] = "EFAULT";
  Errno2[Errno2["ENOTBLK"] = 15] = "ENOTBLK";
  Errno2[Errno2["EBUSY"] = 16] = "EBUSY";
  Errno2[Errno2["EEXIST"] = 17] = "EEXIST";
  Errno2[Errno2["EXDEV"] = 18] = "EXDEV";
  Errno2[Errno2["ENODEV"] = 19] = "ENODEV";
  Errno2[Errno2["ENOTDIR"] = 20] = "ENOTDIR";
  Errno2[Errno2["EISDIR"] = 21] = "EISDIR";
  Errno2[Errno2["EINVAL"] = 22] = "EINVAL";
  Errno2[Errno2["ENFILE"] = 23] = "ENFILE";
  Errno2[Errno2["EMFILE"] = 24] = "EMFILE";
  Errno2[Errno2["ETXTBSY"] = 26] = "ETXTBSY";
  Errno2[Errno2["EFBIG"] = 27] = "EFBIG";
  Errno2[Errno2["ENOSPC"] = 28] = "ENOSPC";
  Errno2[Errno2["ESPIPE"] = 29] = "ESPIPE";
  Errno2[Errno2["EROFS"] = 30] = "EROFS";
  Errno2[Errno2["EMLINK"] = 31] = "EMLINK";
  Errno2[Errno2["EPIPE"] = 32] = "EPIPE";
  Errno2[Errno2["EDOM"] = 33] = "EDOM";
  Errno2[Errno2["ERANGE"] = 34] = "ERANGE";
  Errno2[Errno2["EDEADLK"] = 35] = "EDEADLK";
  Errno2[Errno2["ENAMETOOLONG"] = 36] = "ENAMETOOLONG";
  Errno2[Errno2["ENOLCK"] = 37] = "ENOLCK";
  Errno2[Errno2["ENOSYS"] = 38] = "ENOSYS";
  Errno2[Errno2["ENOTEMPTY"] = 39] = "ENOTEMPTY";
  Errno2[Errno2["ELOOP"] = 40] = "ELOOP";
  Errno2[Errno2["ENOMSG"] = 42] = "ENOMSG";
  Errno2[Errno2["EIDRM"] = 43] = "EIDRM";
  Errno2[Errno2["ECHRNG"] = 44] = "ECHRNG";
  Errno2[Errno2["EL2NSYNC"] = 45] = "EL2NSYNC";
  Errno2[Errno2["EL3HLT"] = 46] = "EL3HLT";
  Errno2[Errno2["EL3RST"] = 47] = "EL3RST";
  Errno2[Errno2["ENRNG"] = 48] = "ENRNG";
  Errno2[Errno2["EUNATCH"] = 49] = "EUNATCH";
  Errno2[Errno2["ECSI"] = 50] = "ECSI";
  Errno2[Errno2["EL2HLT"] = 51] = "EL2HLT";
  Errno2[Errno2["EBADE"] = 52] = "EBADE";
  Errno2[Errno2["EBADR"] = 53] = "EBADR";
  Errno2[Errno2["EXFULL"] = 54] = "EXFULL";
  Errno2[Errno2["ENOANO"] = 55] = "ENOANO";
  Errno2[Errno2["EBADRQC"] = 56] = "EBADRQC";
  Errno2[Errno2["EBADSLT"] = 57] = "EBADSLT";
  Errno2[Errno2["EBFONT"] = 59] = "EBFONT";
  Errno2[Errno2["ENOSTR"] = 60] = "ENOSTR";
  Errno2[Errno2["ENODATA"] = 61] = "ENODATA";
  Errno2[Errno2["ETIME"] = 62] = "ETIME";
  Errno2[Errno2["ENOSR"] = 63] = "ENOSR";
  Errno2[Errno2["ENONET"] = 64] = "ENONET";
  Errno2[Errno2["ENOPKG"] = 65] = "ENOPKG";
  Errno2[Errno2["EREMOTE"] = 66] = "EREMOTE";
  Errno2[Errno2["ENOLINK"] = 67] = "ENOLINK";
  Errno2[Errno2["EADV"] = 68] = "EADV";
  Errno2[Errno2["ESRMNT"] = 69] = "ESRMNT";
  Errno2[Errno2["ECOMM"] = 70] = "ECOMM";
  Errno2[Errno2["EPROTO"] = 71] = "EPROTO";
  Errno2[Errno2["EMULTIHOP"] = 72] = "EMULTIHOP";
  Errno2[Errno2["EDOTDOT"] = 73] = "EDOTDOT";
  Errno2[Errno2["EBADMSG"] = 74] = "EBADMSG";
  Errno2[Errno2["EOVERFLOW"] = 75] = "EOVERFLOW";
  Errno2[Errno2["ENOTUNIQ"] = 76] = "ENOTUNIQ";
  Errno2[Errno2["EBADFD"] = 77] = "EBADFD";
  Errno2[Errno2["EREMCHG"] = 78] = "EREMCHG";
  Errno2[Errno2["ELIBACC"] = 79] = "ELIBACC";
  Errno2[Errno2["ELIBBAD"] = 80] = "ELIBBAD";
  Errno2[Errno2["ELIBSCN"] = 81] = "ELIBSCN";
  Errno2[Errno2["ELIBMAX"] = 82] = "ELIBMAX";
  Errno2[Errno2["ELIBEXEC"] = 83] = "ELIBEXEC";
  Errno2[Errno2["EILSEQ"] = 84] = "EILSEQ";
  Errno2[Errno2["ERESTART"] = 85] = "ERESTART";
  Errno2[Errno2["ESTRPIPE"] = 86] = "ESTRPIPE";
  Errno2[Errno2["EUSERS"] = 87] = "EUSERS";
  Errno2[Errno2["ENOTSOCK"] = 88] = "ENOTSOCK";
  Errno2[Errno2["EDESTADDRREQ"] = 89] = "EDESTADDRREQ";
  Errno2[Errno2["EMSGSIZE"] = 90] = "EMSGSIZE";
  Errno2[Errno2["EPROTOTYPE"] = 91] = "EPROTOTYPE";
  Errno2[Errno2["ENOPROTOOPT"] = 92] = "ENOPROTOOPT";
  Errno2[Errno2["EPROTONOSUPPORT"] = 93] = "EPROTONOSUPPORT";
  Errno2[Errno2["ESOCKTNOSUPPORT"] = 94] = "ESOCKTNOSUPPORT";
  Errno2[Errno2["ENOTSUP"] = 95] = "ENOTSUP";
  Errno2[Errno2["EPFNOSUPPORT"] = 96] = "EPFNOSUPPORT";
  Errno2[Errno2["EAFNOSUPPORT"] = 97] = "EAFNOSUPPORT";
  Errno2[Errno2["EADDRINUSE"] = 98] = "EADDRINUSE";
  Errno2[Errno2["EADDRNOTAVAIL"] = 99] = "EADDRNOTAVAIL";
  Errno2[Errno2["ENETDOWN"] = 100] = "ENETDOWN";
  Errno2[Errno2["ENETUNREACH"] = 101] = "ENETUNREACH";
  Errno2[Errno2["ENETRESET"] = 102] = "ENETRESET";
  Errno2[Errno2["ECONNABORTED"] = 103] = "ECONNABORTED";
  Errno2[Errno2["ECONNRESET"] = 104] = "ECONNRESET";
  Errno2[Errno2["ENOBUFS"] = 105] = "ENOBUFS";
  Errno2[Errno2["EISCONN"] = 106] = "EISCONN";
  Errno2[Errno2["ENOTCONN"] = 107] = "ENOTCONN";
  Errno2[Errno2["ESHUTDOWN"] = 108] = "ESHUTDOWN";
  Errno2[Errno2["ETOOMANYREFS"] = 109] = "ETOOMANYREFS";
  Errno2[Errno2["ETIMEDOUT"] = 110] = "ETIMEDOUT";
  Errno2[Errno2["ECONNREFUSED"] = 111] = "ECONNREFUSED";
  Errno2[Errno2["EHOSTDOWN"] = 112] = "EHOSTDOWN";
  Errno2[Errno2["EHOSTUNREACH"] = 113] = "EHOSTUNREACH";
  Errno2[Errno2["EALREADY"] = 114] = "EALREADY";
  Errno2[Errno2["EINPROGRESS"] = 115] = "EINPROGRESS";
  Errno2[Errno2["ESTALE"] = 116] = "ESTALE";
  Errno2[Errno2["EEUCLEAN"] = 117] = "EEUCLEAN";
  Errno2[Errno2["ENOTNAM"] = 118] = "ENOTNAM";
  Errno2[Errno2["ENAVAIL"] = 119] = "ENAVAIL";
  Errno2[Errno2["EISNAM"] = 120] = "EISNAM";
  Errno2[Errno2["EREMOTEIO"] = 121] = "EREMOTEIO";
  Errno2[Errno2["EDQUOT"] = 122] = "EDQUOT";
  Errno2[Errno2["ENOMEDIUM"] = 123] = "ENOMEDIUM";
  Errno2[Errno2["EMEDIUMTYPE"] = 124] = "EMEDIUMTYPE";
  Errno2[Errno2["ECANCELED"] = 125] = "ECANCELED";
  Errno2[Errno2["ENOKEY"] = 126] = "ENOKEY";
  Errno2[Errno2["EKEYEXPIRED"] = 127] = "EKEYEXPIRED";
  Errno2[Errno2["EKEYREVOKED"] = 128] = "EKEYREVOKED";
  Errno2[Errno2["EKEYREJECTED"] = 129] = "EKEYREJECTED";
  Errno2[Errno2["EOWNERDEAD"] = 130] = "EOWNERDEAD";
  Errno2[Errno2["ENOTRECOVERABLE"] = 131] = "ENOTRECOVERABLE";
  Errno2[Errno2["ERFKILL"] = 132] = "ERFKILL";
  Errno2[Errno2["EHWPOISON"] = 133] = "EHWPOISON";
})(Errno || (Errno = {}));
const errnoMessages = {
  [Errno.EPERM]: "Operation not permitted",
  [Errno.ENOENT]: "No such file or directory",
  [Errno.ESRCH]: "No such process",
  [Errno.EINTR]: "Interrupted system call",
  [Errno.EIO]: "Input/output error",
  [Errno.ENXIO]: "No such device or address",
  [Errno.E2BIG]: "Argument list too long",
  [Errno.ENOEXEC]: "Exec format error",
  [Errno.EBADF]: "Bad file descriptor",
  [Errno.ECHILD]: "No child processes",
  [Errno.EAGAIN]: "Resource temporarily unavailable",
  [Errno.ENOMEM]: "Out of memory",
  [Errno.EACCES]: "Permission denied",
  [Errno.EFAULT]: "Bad address",
  [Errno.ENOTBLK]: "Block device required",
  [Errno.EBUSY]: "Resource busy or locked",
  [Errno.EEXIST]: "File exists",
  [Errno.EXDEV]: "Invalid cross-device link",
  [Errno.ENODEV]: "No such device",
  [Errno.ENOTDIR]: "File is not a directory",
  [Errno.EISDIR]: "File is a directory",
  [Errno.EINVAL]: "Invalid argument",
  [Errno.ENFILE]: "Too many open files in system",
  [Errno.EMFILE]: "Too many open files",
  [Errno.ETXTBSY]: "Text file busy",
  [Errno.EFBIG]: "File is too big",
  [Errno.ENOSPC]: "No space left on disk",
  [Errno.ESPIPE]: "Illegal seek",
  [Errno.EROFS]: "Cannot modify a read-only file system",
  [Errno.EMLINK]: "Too many links",
  [Errno.EPIPE]: "Broken pipe",
  [Errno.EDOM]: "Numerical argument out of domain",
  [Errno.ERANGE]: "Numerical result out of range",
  [Errno.EDEADLK]: "Resource deadlock would occur",
  [Errno.ENAMETOOLONG]: "File name too long",
  [Errno.ENOLCK]: "No locks available",
  [Errno.ENOSYS]: "Function not implemented",
  [Errno.ENOTEMPTY]: "Directory is not empty",
  [Errno.ELOOP]: "Too many levels of symbolic links",
  [Errno.ENOMSG]: "No message of desired type",
  [Errno.EIDRM]: "Identifier removed",
  [Errno.ECHRNG]: "Channel number out of range",
  [Errno.EL2NSYNC]: "Level 2 not synchronized",
  [Errno.EL3HLT]: "Level 3 halted",
  [Errno.EL3RST]: "Level 3 reset",
  [Errno.ENRNG]: "Link number out of range",
  [Errno.EUNATCH]: "Protocol driver not attached",
  [Errno.ECSI]: "No CSI structure available",
  [Errno.EL2HLT]: "Level 2 halted",
  [Errno.EBADE]: "Invalid exchange",
  [Errno.EBADR]: "Invalid request descriptor",
  [Errno.EXFULL]: "Exchange full",
  [Errno.ENOANO]: "No anode",
  [Errno.EBADRQC]: "Invalid request code",
  [Errno.EBADSLT]: "Invalid slot",
  [Errno.EBFONT]: "Bad font file format",
  [Errno.ENOSTR]: "Device not a stream",
  [Errno.ENODATA]: "No data available",
  [Errno.ETIME]: "Timer expired",
  [Errno.ENOSR]: "Out of streams resources",
  [Errno.ENONET]: "Machine is not on the network",
  [Errno.ENOPKG]: "Package not installed",
  [Errno.EREMOTE]: "Object is remote",
  [Errno.ENOLINK]: "Link has been severed",
  [Errno.EADV]: "Advertise error",
  [Errno.ESRMNT]: "Srmount error",
  [Errno.ECOMM]: "Communication error on send",
  [Errno.EPROTO]: "Protocol error",
  [Errno.EMULTIHOP]: "Multihop attempted",
  [Errno.EDOTDOT]: "RFS specific error",
  [Errno.EBADMSG]: "Bad message",
  [Errno.EOVERFLOW]: "Value too large for defined data type",
  [Errno.ENOTUNIQ]: "Name not unique on network",
  [Errno.EBADFD]: "File descriptor in bad state",
  [Errno.EREMCHG]: "Remote address changed",
  [Errno.ELIBACC]: "Can not access a needed shared library",
  [Errno.ELIBBAD]: "Accessing a corrupted shared library",
  [Errno.ELIBSCN]: ".lib section in a.out corrupted",
  [Errno.ELIBMAX]: "Attempting to link in too many shared libraries",
  [Errno.ELIBEXEC]: "Cannot exec a shared library directly",
  [Errno.EILSEQ]: "Invalid or incomplete multibyte or wide character",
  [Errno.ERESTART]: "Interrupted system call should be restarted",
  [Errno.ESTRPIPE]: "Streams pipe error",
  [Errno.EUSERS]: "Too many users",
  [Errno.ENOTSOCK]: "Socket operation on non-socket",
  [Errno.EDESTADDRREQ]: "Destination address required",
  [Errno.EMSGSIZE]: "Message too long",
  [Errno.EPROTOTYPE]: "Protocol wrong type for socket",
  [Errno.ENOPROTOOPT]: "Protocol not available",
  [Errno.EPROTONOSUPPORT]: "Protocol not supported",
  [Errno.ESOCKTNOSUPPORT]: "Socket type not supported",
  [Errno.ENOTSUP]: "Operation is not supported",
  [Errno.EPFNOSUPPORT]: "Protocol family not supported",
  [Errno.EAFNOSUPPORT]: "Address family not supported by protocol",
  [Errno.EADDRINUSE]: "Address already in use",
  [Errno.EADDRNOTAVAIL]: "Cannot assign requested address",
  [Errno.ENETDOWN]: "Network is down",
  [Errno.ENETUNREACH]: "Network is unreachable",
  [Errno.ENETRESET]: "Network dropped connection on reset",
  [Errno.ECONNABORTED]: "Software caused connection abort",
  [Errno.ECONNRESET]: "Connection reset by peer",
  [Errno.ENOBUFS]: "No buffer space available",
  [Errno.EISCONN]: "Transport endpoint is already connected",
  [Errno.ENOTCONN]: "Transport endpoint is not connected",
  [Errno.ESHUTDOWN]: "Cannot send after transport endpoint shutdown",
  [Errno.ETOOMANYREFS]: "Too many references: cannot splice",
  [Errno.ETIMEDOUT]: "Connection timed out",
  [Errno.ECONNREFUSED]: "Connection refused",
  [Errno.EHOSTDOWN]: "Host is down",
  [Errno.EHOSTUNREACH]: "No route to host",
  [Errno.EALREADY]: "Operation already in progress",
  [Errno.EINPROGRESS]: "Operation now in progress",
  [Errno.ESTALE]: "Stale file handle",
  [Errno.EEUCLEAN]: "Structure needs cleaning",
  [Errno.ENOTNAM]: "Not a XENIX named type file",
  [Errno.ENAVAIL]: "No XENIX semaphores available",
  [Errno.EISNAM]: "Is a named type file",
  [Errno.EREMOTEIO]: "Remote I/O error",
  [Errno.EDQUOT]: "Disk quota exceeded",
  [Errno.ENOMEDIUM]: "No medium found",
  [Errno.EMEDIUMTYPE]: "Wrong medium type",
  [Errno.ECANCELED]: "Operation canceled",
  [Errno.ENOKEY]: "Required key not available",
  [Errno.EKEYEXPIRED]: "Key has expired",
  [Errno.EKEYREVOKED]: "Key has been revoked",
  [Errno.EKEYREJECTED]: "Key was rejected by service",
  [Errno.EOWNERDEAD]: "Owner died",
  [Errno.ENOTRECOVERABLE]: "State not recoverable",
  [Errno.ERFKILL]: "Operation not possible due to RF-kill",
  [Errno.EHWPOISON]: "Memory page has hardware error"
};
function setUVMessage(ex) {
  let message = `${ex.code}: ${errnoMessages[ex.errno]}, ${ex.syscall}`;
  if (ex.path)
    message += ` '${ex.path}'`;
  if (ex.dest)
    message += ` -> '${ex.dest}'`;
  if (ex.message && ex.message !== errnoMessages[ex.errno])
    message += ` (${ex.message})`;
  ex.message = message;
  return ex;
}
__name(setUVMessage, "setUVMessage");
const _Exception = class _Exception extends Error {
  constructor(errno, message, ctx = {}) {
    const code2 = Errno[errno];
    if (message === false) {
      message = `${code2}: ${errnoMessages[errno]}, ${ctx.syscall}`;
      if (ctx.path)
        message += ` '${ctx.path}'`;
      if (ctx.dest)
        message += ` -> '${ctx.dest}'`;
    }
    super(message);
    __publicField(this, "errno");
    __publicField(this, "code");
    __publicField(this, "path");
    __publicField(this, "dest");
    __publicField(this, "syscall");
    this.errno = errno;
    this.code = code2;
    Object.assign(this, omit(ctx, "message"));
    Error.captureStackTrace?.(this, this.constructor);
  }
  toString() {
    return this.message;
  }
  toJSON() {
    const json = {
      errno: this.errno,
      code: this.code,
      stack: this.stack,
      message: this.message
    };
    if (this.path)
      json.path = this.path;
    if (this.dest)
      json.dest = this.dest;
    if (this.syscall)
      json.syscall = this.syscall;
    return json;
  }
  static fromJSON(json) {
    const err2 = json.syscall ? new _Exception(json.errno, false, json) : new _Exception(json.errno, json.message);
    err2.stack = json.stack;
    return err2;
  }
};
__name(_Exception, "Exception");
let Exception = _Exception;
function UV(code2, context, path2, dest) {
  if (typeof context === "string")
    context = { syscall: context, path: path2, dest };
  const err2 = new Exception(Errno[code2], false, context ?? {});
  Error.captureStackTrace?.(err2, UV);
  return err2;
}
__name(UV, "UV");
function withErrno(code2, message) {
  const err2 = new Exception(Errno[code2], message ?? errnoMessages[Errno[code2]]);
  Error.captureStackTrace?.(err2, withErrno);
  return err2;
}
__name(withErrno, "withErrno");
function rethrow(extra, path2, dest) {
  const ctx = typeof extra === "string" ? { syscall: extra } : extra;
  if (path2)
    ctx.path = path2;
  return function(e2) {
    Object.assign(e2, ctx);
    setUVMessage(e2);
    throw e2;
  };
}
__name(rethrow, "rethrow");
var Level;
(function(Level2) {
  Level2[Level2["EMERG"] = 0] = "EMERG";
  Level2[Level2["ALERT"] = 1] = "ALERT";
  Level2[Level2["CRIT"] = 2] = "CRIT";
  Level2[Level2["ERR"] = 3] = "ERR";
  Level2[Level2["WARN"] = 4] = "WARN";
  Level2[Level2["NOTICE"] = 5] = "NOTICE";
  Level2[Level2["INFO"] = 6] = "INFO";
  Level2[Level2["DEBUG"] = 7] = "DEBUG";
})(Level || (Level = {}));
const levels = [
  "emergency",
  "alert",
  "critical",
  "error",
  "warning",
  "notice",
  "info",
  "debug"
];
function levelOf(value) {
  return levels.indexOf(value);
}
__name(levelOf, "levelOf");
const entries = new List();
function log(level2, message) {
  if (!isEnabled)
    return;
  const entry = {
    level: level2,
    message,
    timestamp: /* @__PURE__ */ new Date(),
    elapsedMs: performance.now()
  };
  entries.add(entry);
  output(entry);
}
__name(log, "log");
function _shortcut$1(level2) {
  return function(message) {
    log(level2, message.toString());
    return message;
  };
}
__name(_shortcut$1, "_shortcut$1");
_shortcut$1(Level.EMERG);
const alert = _shortcut$1(Level.ALERT);
const crit = _shortcut$1(Level.CRIT);
const err$1 = _shortcut$1(Level.ERR);
const warn = _shortcut$1(Level.WARN);
const notice = _shortcut$1(Level.NOTICE);
const info = _shortcut$1(Level.INFO);
const debug = _shortcut$1(Level.DEBUG);
function ansi$5(text, format2) {
  return `\x1B[${format2}m${text}\x1B[0m`;
}
__name(ansi$5, "ansi$5");
function _prettyMs(entry, style) {
  const text = "[" + (entry.elapsedMs / 1e3).toFixed(3).padStart(10) + "] ";
  switch (style) {
    case "ansi":
      return [ansi$5(text, "2;37")];
    case "css":
      return ["%c" + text, "opacity: 0.8; color: white;"];
    default:
      return [text];
  }
}
__name(_prettyMs, "_prettyMs");
({
  ansi: {
    [Level.EMERG]: "1;4;37;41",
    [Level.ALERT]: "1;37;41",
    [Level.CRIT]: "1;35",
    [Level.ERR]: "1;31",
    [Level.WARN]: "1;33",
    [Level.NOTICE]: "1;36",
    [Level.INFO]: "1;37",
    [Level.DEBUG]: "0;2;37"
  },
  css: {
    [Level.EMERG]: "font-weight: bold; text-decoration: underline; color: white; background-color: red;",
    [Level.ALERT]: "font-weight: bold; color: white; background-color: red;",
    [Level.CRIT]: "font-weight: bold; color: magenta;",
    [Level.ERR]: "font-weight: bold; color: red;",
    [Level.WARN]: "font-weight: bold; color: yellow;",
    [Level.NOTICE]: "font-weight: bold; color: cyan;",
    [Level.INFO]: "font-weight: bold; color: white;",
    [Level.DEBUG]: "opacity: 0.8; color: white;"
  }
});
({
  ansi: {
    [Level.EMERG]: "1;31",
    [Level.ALERT]: "1;31",
    [Level.CRIT]: "1;31",
    [Level.ERR]: "31",
    [Level.WARN]: "33",
    [Level.NOTICE]: "1;37",
    [Level.INFO]: "37",
    [Level.DEBUG]: "2;37"
  },
  css: {
    [Level.EMERG]: "font-weight: bold; color: red;",
    [Level.ALERT]: "font-weight: bold; color: red;",
    [Level.CRIT]: "font-weight: bold; color: red;",
    [Level.ERR]: "color: red;",
    [Level.WARN]: "color: yellow;",
    [Level.NOTICE]: "font-weight: bold; color: white;",
    [Level.INFO]: "color: white;",
    [Level.DEBUG]: "opacity: 0.8; color: white;"
  }
});
let _format = /* @__PURE__ */ __name((entry) => [..._prettyMs(entry), entry.message], "_format");
function format$2(entry) {
  const formatted = _format(entry);
  return typeof formatted == "string" ? [formatted] : Array.from(formatted);
}
__name(format$2, "format$2");
let _output = console.error;
function output(entry) {
  if (entry.level > minLevel)
    return;
  _output(...format$2(entry));
}
__name(output, "output");
let minLevel = Level.ALERT;
let includeStack = false;
let isEnabled = true;
function configure$2(options) {
  _format = options.format ?? _format;
  _output = options.output ?? _output;
  minLevel = typeof options.level == "string" ? levelOf(options.level) : options.level ?? minLevel;
  isEnabled = options.enabled ?? isEnabled;
  includeStack = options.stack ?? includeStack;
  if (!options.dumpBacklog)
    return;
  for (const entry of entries) {
    output(entry);
  }
}
__name(configure$2, "configure$2");
function isBackend(arg) {
  return arg != null && typeof arg == "object" && "create" in arg && typeof arg.create == "function";
}
__name(isBackend, "isBackend");
function _isClass(func) {
  if (!(func && func.constructor === Function) || func.prototype === void 0)
    return false;
  if (Function.prototype !== Object.getPrototypeOf(func))
    return true;
  return Object.getOwnPropertyNames(func.prototype).length > 1;
}
__name(_isClass, "_isClass");
function checkOptions(backend, options) {
  if (typeof options != "object" || options === null) {
    throw err$1(withErrno("EINVAL", "Invalid options"));
  }
  for (const [optName, opt] of Object.entries(backend.options)) {
    const value = options?.[optName];
    if (value === void 0 || value === null) {
      if (!opt.required) {
        debug("Using default for option: " + optName);
        continue;
      }
      throw err$1(withErrno("EINVAL", "Missing required option: " + optName));
    }
    const isType2 = /* @__PURE__ */ __name((type2, _ = value) => typeof type2 == "function" ? _isClass(type2) ? value instanceof type2 : type2(value) : typeof value === type2 || value?.constructor?.name === type2, "isType");
    if (Array.isArray(opt.type) ? opt.type.some((v) => isType2(v)) : isType2(opt.type))
      continue;
    const type = typeof value == "object" && "constructor" in value ? value.constructor.name : typeof value;
    const name = /* @__PURE__ */ __name((type2) => typeof type2 == "function" ? type2.name != "type" ? type2.name : type2.toString() : type2, "name");
    const expected = Array.isArray(opt.type) ? `one of ${opt.type.map(name).join(", ")}` : name(opt.type);
    throw err$1(withErrno("EINVAL", `Incorrect type for "${optName}": ${type} (expected ${expected})`));
  }
}
__name(checkOptions, "checkOptions");
function isBackendConfig(arg) {
  return arg != null && typeof arg == "object" && "backend" in arg && isBackend(arg.backend);
}
__name(isBackendConfig, "isBackendConfig");
function createCredentials(source2) {
  return {
    suid: source2.uid,
    sgid: source2.gid,
    euid: source2.uid,
    egid: source2.gid,
    groups: [],
    ...source2
  };
}
__name(createCredentials, "createCredentials");
function credentialsAllowRoot(cred) {
  if (!cred)
    return false;
  return !cred.uid || !cred.gid || !cred.euid || !cred.egid || cred.groups.some((gid) => !gid);
}
__name(credentialsAllowRoot, "credentialsAllowRoot");
const defaultContext = {
  id: 0,
  root: "/",
  pwd: "/",
  credentials: createCredentials({ uid: 0, gid: 0 }),
  descriptors: /* @__PURE__ */ new Map(),
  parent: null,
  children: []
};
const F_OK = 0;
const R_OK = 4;
const W_OK = 2;
const X_OK = 1;
const COPYFILE_EXCL = 1;
const COPYFILE_FICLONE = 2;
const COPYFILE_FICLONE_FORCE = 4;
const O_RDONLY = 0;
const O_WRONLY = 1;
const O_RDWR = 2;
const O_CREAT = 64;
const O_EXCL = 128;
const O_NOCTTY = 256;
const O_TRUNC = 512;
const O_APPEND = 1024;
const O_DIRECTORY = 65536;
const O_NOATIME = 262144;
const O_NOFOLLOW = 131072;
const O_SYNC = 1052672;
const O_DSYNC = 4096;
const O_SYMLINK = 32768;
const O_DIRECT = 16384;
const O_NONBLOCK = 2048;
const S_IFMT = 61440;
const S_IFSOCK = 49152;
const S_IFLNK = 40960;
const S_IFREG = 32768;
const S_IFBLK = 24576;
const S_IFDIR = 16384;
const S_IFCHR = 8192;
const S_IFIFO = 4096;
const S_ISUID = 2048;
const S_ISGID = 1024;
const S_ISVTX = 512;
const S_IRWXU = 448;
const S_IRUSR = 256;
const S_IWUSR = 128;
const S_IXUSR = 64;
const S_IRWXG = 56;
const S_IRGRP = 32;
const S_IWGRP = 16;
const S_IXGRP = 8;
const S_IRWXO = 7;
const S_IROTH = 4;
const S_IWOTH = 2;
const S_IXOTH = 1;
const UV_FS_O_FILEMAP = 0;
const size_max = 4294967295;
const constants = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  COPYFILE_EXCL,
  COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE,
  F_OK,
  O_APPEND,
  O_CREAT,
  O_DIRECT,
  O_DIRECTORY,
  O_DSYNC,
  O_EXCL,
  O_NOATIME,
  O_NOCTTY,
  O_NOFOLLOW,
  O_NONBLOCK,
  O_RDONLY,
  O_RDWR,
  O_SYMLINK,
  O_SYNC,
  O_TRUNC,
  O_WRONLY,
  R_OK,
  S_IFBLK,
  S_IFCHR,
  S_IFDIR,
  S_IFIFO,
  S_IFLNK,
  S_IFMT,
  S_IFREG,
  S_IFSOCK,
  S_IRGRP,
  S_IROTH,
  S_IRUSR,
  S_IRWXG,
  S_IRWXO,
  S_IRWXU,
  S_ISGID,
  S_ISUID,
  S_ISVTX,
  S_IWGRP,
  S_IWOTH,
  S_IWUSR,
  S_IXGRP,
  S_IXOTH,
  S_IXUSR,
  UV_FS_O_FILEMAP,
  W_OK,
  X_OK,
  size_max
}, Symbol.toStringTag, { value: "Module" }));
function StructArray(type) {
  const _StructArray = class _StructArray extends DataView {
    constructor(lengthOrBuffer, byteOffset, byteLength2) {
      const buffer2 = typeof lengthOrBuffer === "object" ? lengthOrBuffer : new ArrayBuffer((lengthOrBuffer ?? 0) * type.size);
      super(buffer2, byteOffset, byteLength2);
      __publicField(this, "length");
      __publicField(this, "type", type);
      this.length = typeof lengthOrBuffer === "number" ? lengthOrBuffer : Math.floor(this.byteLength / type.size);
      return new Proxy(this, {
        get(target, index) {
          if (index in target)
            return target[index];
          const i = parseInt(index.toString());
          if (!Number.isSafeInteger(i))
            throw withErrno("EINVAL", "Invalid index: " + index.toString());
          return type.get(target.buffer, target.byteOffset + i * type.size);
        },
        set(target, index, value) {
          const i = parseInt(index.toString());
          if (!Number.isSafeInteger(i))
            throw withErrno("EINVAL", "Invalid index: " + index.toString());
          type.set(target.buffer, target.byteOffset + i * type.size, value);
          return true;
        }
      });
    }
    *[Symbol.iterator]() {
      for (let i = 0; i < this.length; i++)
        yield this[i];
    }
  };
  __name(_StructArray, "StructArray");
  let StructArray2 = _StructArray;
  for (const key of Object.getOwnPropertyNames(DataView.prototype)) {
    if (!key.startsWith("get") && !key.startsWith("set"))
      continue;
    Object.defineProperty(StructArray2.prototype, key, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: void 0
    });
  }
  return StructArray2;
}
__name(StructArray, "StructArray");
const _ArrayType = class _ArrayType {
  constructor(type, length) {
    __publicField(this, "type");
    __publicField(this, "length");
    __publicField(this, "name");
    __publicField(this, "size");
    __publicField(this, "__arrayType");
    __publicField(this, "get", /* @__PURE__ */ __name((buffer2, offset) => {
      return new this.__arrayType(buffer2, offset, this.size);
    }, "get"));
    __publicField(this, "set", /* @__PURE__ */ __name((buffer2, offset, value) => {
      for (let i = 0; i < this.length; i++) {
        this.type.set(buffer2, offset + i * this.type.size, value[i]);
      }
    }, "set"));
    /**
     * This is for an array of this array
     */
    __publicField(this, "array");
    this.type = type;
    this.length = length;
    this.name = `${type.name}[${length}]`;
    this.size = type.size * length;
    this.array = StructArray(this);
    this.__arrayType = type.array ? type.array : StructArray(type);
  }
};
__name(_ArrayType, "ArrayType");
let ArrayType = _ArrayType;
function isType(type) {
  if (typeof type != "object" && typeof type != "function" || type === null || type === void 0)
    return false;
  if (type instanceof ArrayType)
    return isType(type.type);
  return "name" in type && "size" in type && "get" in type && "set" in type && typeof type.name == "string" && typeof type.size == "number" && typeof type.get == "function" && typeof type.set == "function" && typeRegistry.has(type.name) && typeRegistry.get(type.name)?.name === type.name;
}
__name(isType, "isType");
const typeRegistry = /* @__PURE__ */ new Map();
function registerType(t2) {
  if (typeRegistry.has(t2.name))
    throw new ReferenceError(`Type is already registered: ${t2.name}`);
  typeRegistry.set(t2.name, t2);
}
__name(registerType, "registerType");
function parseFieldConfig(init2) {
  if (isType(init2))
    return { type: init2 };
  if (init2 instanceof FieldBuilder)
    return init2.toInit();
  return init2;
}
__name(parseFieldConfig, "parseFieldConfig");
const _FieldBuilder = class _FieldBuilder {
  constructor(type, init2) {
    __publicField(this, "type");
    __publicField(this, "init");
    this.type = type;
    this.init = init2;
    const _toArray = /* @__PURE__ */ __name(((length) => {
      return new _FieldBuilder(new ArrayType(type, length), init2);
    }), "_toArray");
    Object.setPrototypeOf(_toArray, new.target.prototype);
    Object.assign(_toArray, { type, init: init2 });
    return _toArray;
  }
  /**
   * Align the field to a given byte boundary.
   */
  align(align) {
    return new _FieldBuilder(this.type, { ...this.init, align });
  }
  countedBy(field2) {
    return new _FieldBuilder(this.type, { ...this.init, countedBy: field2 });
  }
  /**
   * Set the field to big-endian.
   */
  bigEndian() {
    return new _FieldBuilder(this.type, { ...this.init, bigEndian: true });
  }
  toInit() {
    return { type: this.type, ...this.init };
  }
  /**
   * Override the typescript type of the field's value, for example to override `number` with an enum type.
   * This does not have any runtime effects.
   */
  $type() {
    return new _FieldBuilder(this.type, this.init);
  }
};
__name(_FieldBuilder, "FieldBuilder");
let FieldBuilder = _FieldBuilder;
function array(type, length = 0) {
  return new FieldBuilder(new ArrayType(type, length), {});
}
__name(array, "array");
function __fieldInit(_name, init2, extraOpts = {}) {
  if (!_name)
    throw withErrno("EINVAL", "Invalid name for struct field");
  if (typeof _name == "symbol")
    console.warn("Symbol used for struct field name will be coerced to string: " + _name.toString());
  const name = _name.toString();
  const opt = Object.assign(parseFieldConfig(init2), extraOpts);
  if (!isType(opt.type))
    throw withErrno("EINVAL", `Invalid type for struct field "${name}"`);
  return {
    name,
    offset: 0,
    type: opt.type,
    countedBy: opt.countedBy,
    alignment: opt.align ?? opt.type.size,
    decl: opt.type instanceof ArrayType ? `${opt.typeName ?? opt.type.type.name} ${name}[${opt.type.length}]${opt.countedBy ? ` counted_by(${opt.countedBy})` : ""}` : `${opt.typeName ?? opt.type.name} ${name}`,
    littleEndian: !opt.bigEndian
  };
}
__name(__fieldInit, "__fieldInit");
function __fault(err2) {
  if (err2.message !== "offset is outside the bounds of the DataView")
    throw err2;
  else
    throw withErrno("EFAULT", "Segmentation fault");
}
__name(__fault, "__fault");
function __fieldSet(instance2, field2, value, index) {
  try {
    if (typeof value == "string")
      value = value.charCodeAt(0);
    const offset = instance2.byteOffset + field2.offset + (index ?? 0) * field2.type.size;
    field2.type.set(instance2.buffer, offset, value);
    return;
  } catch (err2) {
    __fault(err2);
  }
}
__name(__fieldSet, "__fieldSet");
function __fieldGet(instance2, field2) {
  try {
    return field2.type.get(instance2.buffer, instance2.byteOffset + field2.offset);
  } catch (err2) {
    __fault(err2);
  }
}
__name(__fieldGet, "__fieldGet");
const __view__ = Symbol("DataView");
function view(buffer2) {
  buffer2[__view__] ?? (buffer2[__view__] = new DataView(buffer2));
  return buffer2[__view__];
}
__name(view, "view");
const int8 = {
  name: "int8",
  size: 1,
  array: Int8Array,
  get: /* @__PURE__ */ __name((buffer2, offset) => view(buffer2).getInt8(offset), "get"),
  set: /* @__PURE__ */ __name((buffer2, offset, value) => view(buffer2).setInt8(offset, value), "set")
};
const uint8 = {
  name: "uint8",
  size: 1,
  array: Uint8Array,
  get: /* @__PURE__ */ __name((buffer2, offset) => view(buffer2).getUint8(offset), "get"),
  set: /* @__PURE__ */ __name((buffer2, offset, value) => view(buffer2).setUint8(offset, value), "set")
};
const int16 = {
  name: "int16",
  size: 2,
  array: Int16Array,
  get: /* @__PURE__ */ __name((buffer2, offset) => view(buffer2).getInt16(offset, true), "get"),
  set: /* @__PURE__ */ __name((buffer2, offset, value) => view(buffer2).setInt16(offset, value, true), "set")
};
const uint16 = {
  name: "uint16",
  size: 2,
  array: Uint16Array,
  get: /* @__PURE__ */ __name((buffer2, offset) => view(buffer2).getUint16(offset, true), "get"),
  set: /* @__PURE__ */ __name((buffer2, offset, value) => view(buffer2).setUint16(offset, value, true), "set")
};
const int32 = {
  name: "int32",
  size: 4,
  array: Int32Array,
  get: /* @__PURE__ */ __name((buffer2, offset) => view(buffer2).getInt32(offset, true), "get"),
  set: /* @__PURE__ */ __name((buffer2, offset, value) => view(buffer2).setInt32(offset, value, true), "set")
};
const uint32 = {
  name: "uint32",
  size: 4,
  array: Uint32Array,
  get: /* @__PURE__ */ __name((buffer2, offset) => view(buffer2).getUint32(offset, true), "get"),
  set: /* @__PURE__ */ __name((buffer2, offset, value) => view(buffer2).setUint32(offset, value, true), "set")
};
const int64 = {
  name: "int64",
  size: 8,
  array: BigInt64Array,
  get: /* @__PURE__ */ __name((buffer2, offset) => view(buffer2).getBigInt64(offset, true), "get"),
  set: /* @__PURE__ */ __name((buffer2, offset, value) => view(buffer2).setBigInt64(offset, value, true), "set")
};
const uint64 = {
  name: "uint64",
  size: 8,
  array: BigUint64Array,
  get: /* @__PURE__ */ __name((buffer2, offset) => view(buffer2).getBigUint64(offset, true), "get"),
  set: /* @__PURE__ */ __name((buffer2, offset, value) => view(buffer2).setBigUint64(offset, value, true), "set")
};
const float32 = {
  name: "float32",
  size: 4,
  array: Float32Array,
  get: /* @__PURE__ */ __name((buffer2, offset) => view(buffer2).getFloat32(offset, true), "get"),
  set: /* @__PURE__ */ __name((buffer2, offset, value) => view(buffer2).setFloat32(offset, value, true), "set")
};
const float64 = {
  name: "float64",
  size: 8,
  array: Float64Array,
  get: /* @__PURE__ */ __name((buffer2, offset) => view(buffer2).getFloat64(offset, true), "get"),
  set: /* @__PURE__ */ __name((buffer2, offset, value) => view(buffer2).setFloat64(offset, value, true), "set")
};
const types$1 = {
  int8,
  uint8,
  int16,
  uint16,
  int32,
  uint32,
  int64,
  uint64,
  float32,
  float64
};
const typeNames = Object.keys(types$1);
for (const t2 of Object.values(types$1))
  registerType(t2);
const rawTypes = {
  ...types$1,
  ...Object.fromEntries(typeNames.map((t2) => [capitalize$1(t2), types$1[t2]])),
  char: uint8
};
const validNames = Object.keys(rawTypes);
function isValid(type) {
  return validNames.includes(type.toString());
}
__name(isValid, "isValid");
function checkValid(type) {
  if (!isValid(type))
    throw withErrno("EINVAL", "Not a valid primitive type: " + type);
}
__name(checkValid, "checkValid");
function normalize$1(type) {
  return type == "char" ? "uint8" : type.toLowerCase();
}
__name(normalize$1, "normalize$1");
Symbol.metadata ?? (Symbol.metadata = Symbol.for("Symbol.metadata"));
function initMetadata(context) {
  context.metadata ?? (context.metadata = {});
  const existing = context.metadata.structInit ?? {};
  context.metadata.structInit = {
    fields: [...existing.fields ?? []]
  };
  return context.metadata.structInit;
}
__name(initMetadata, "initMetadata");
function struct$1(name, ...options) {
  const opts = options.reduce((acc, opt) => ({ ...acc, ...opt }), {});
  if (typeof this == "object")
    Object.assign(opts, this);
  return /* @__PURE__ */ __name(function __decorateStruct(target, context) {
    const init2 = initMetadata(context);
    let fieldAlignment = 1;
    const fields = {};
    let size = 0;
    const align = /* @__PURE__ */ __name((to) => {
      size = Math.ceil(size / to) * to;
    }, "align");
    for (const field2 of init2.fields) {
      if (!opts.isPacked)
        align(field2.alignment);
      if (opts.isUnion)
        size = Math.max(size, field2.type.size);
      else {
        field2.offset = size;
        size += field2.type.size;
      }
      fields[field2.name] = field2;
      fieldAlignment = Math.max(fieldAlignment, field2.alignment);
    }
    opts.alignment ?? (opts.alignment = fieldAlignment);
    if (!opts.isPacked)
      align(opts.alignment);
    context.metadata.struct = {
      fields,
      size,
      alignment: opts.isPacked ? 1 : opts.alignment,
      isUnion: opts.isUnion ?? false
    };
    const __struct = class __struct extends target {
      constructor(...args) {
        if (!args.length)
          args = [new ArrayBuffer(size), 0, size];
        super(...args);
        for (const field2 of Object.values(fields)) {
          Object.defineProperty(this, field2.name, {
            enumerable: true,
            configurable: true,
            get() {
              return __fieldGet(this, field2);
            },
            set(value) {
              __fieldSet(this, field2, value);
            }
          });
        }
      }
    };
    __name(__struct, "_struct");
    let _struct = __struct;
    const fix = /* @__PURE__ */ __name((value) => ({
      writable: false,
      enumerable: false,
      configurable: false,
      value
    }), "fix");
    Object.defineProperties(_struct, {
      name: fix(name),
      size: fix(size),
      alignment: fix(opts.alignment),
      isUnion: fix(!!opts.isUnion),
      fields: fix(fields),
      // @ts-expect-error 2511 : Please don't try to create an instance of an abstract struct
      get: fix((buffer2, offset) => new _struct(buffer2, offset)),
      set: fix((buffer2, offset, value) => {
        const source2 = new Uint8Array(value.buffer, value.byteOffset, size);
        const target2 = new Uint8Array(buffer2, offset, size);
        if (value.buffer === buffer2 && value.byteOffset === offset)
          return;
        for (let i = 0; i < size; i++)
          target2[i] = source2[i];
      }),
      [Symbol.toStringTag]: fix(`[struct ${name}]`)
    });
    registerType(_struct);
    return _struct;
  }, "__decorateStruct");
}
__name(struct$1, "struct$1");
struct$1.packed = struct$1.bind({ isPacked: true });
struct$1.align = function(alignment) {
  return struct$1.bind({ alignment });
};
function field(type, opt = {}) {
  return /* @__PURE__ */ __name(function __decorateField(value, context) {
    if (context.kind != "accessor")
      throw withErrno("EINVAL", "Field must be an accessor");
    const init2 = initMetadata(context);
    const field2 = __fieldInit(context.name, type, opt);
    init2.fields.push(field2);
    return {
      get() {
        return __fieldGet(this, field2);
      },
      set(value2) {
        __fieldSet(this, field2, value2);
      }
    };
  }, "__decorateField");
}
__name(field, "field");
function _shortcut(typeName) {
  const type = types$1[normalize$1(typeName)];
  function __decoratePrimitiveField(valueOrLength, context) {
    return typeof valueOrLength == "number" ? field(new ArrayType(type, valueOrLength), { typeName, ...context }) : field(type, { typeName })(valueOrLength, context && "name" in context ? context : _throw(withErrno("EINVAL", "Invalid decorator context object")));
  }
  __name(__decoratePrimitiveField, "__decoratePrimitiveField");
  return __decoratePrimitiveField;
}
__name(_shortcut, "_shortcut");
const types = Object.fromEntries(validNames.map((t2) => [t2, _shortcut(t2)]));
function $from(t2) {
  return t2;
}
__name($from, "$from");
$from.typed = function(t2) {
  return t2;
};
function isStructConstructor(arg) {
  return typeof arg == "function" && "prototype" in arg && "fields" in arg && typeof arg.fields == "object" && isType(arg);
}
__name(isStructConstructor, "isStructConstructor");
function struct(structName, fieldDecls, ...options) {
  const opts = options.reduce((acc, opt) => ({ ...acc, ...opt }), {});
  if (typeof this == "object")
    Object.assign(opts, this);
  let fieldAlignment = 1;
  let size = 0;
  const align = /* @__PURE__ */ __name((to) => {
    size = Math.ceil(size / to) * to;
  }, "align");
  const fields = /* @__PURE__ */ Object.create(null);
  for (const [name, init2] of Object.entries(fieldDecls)) {
    if (typeof name == "number")
      throw new TypeError("Field names can not be numbers");
    const field2 = __fieldInit(name, init2);
    if (!opts.isPacked)
      align(field2.alignment);
    if (opts.isUnion)
      size = Math.max(size, field2.type.size);
    else {
      field2.offset = size;
      size += field2.type.size;
    }
    fields[field2.name] = field2;
    fieldAlignment = Math.max(fieldAlignment, field2.alignment);
  }
  opts.alignment ?? (opts.alignment = fieldAlignment);
  if (!opts.isPacked)
    align(opts.alignment);
  class __struct extends DataView {
    constructor(buffer2 = new ArrayBuffer(size), byteOffset, byteLength2) {
      super(buffer2, byteOffset, byteLength2 ?? size);
      for (const field2 of Object.values(fields)) {
        Object.defineProperty(this, field2.name, {
          enumerable: true,
          configurable: true,
          get() {
            return __fieldGet(this, field2);
          },
          set(value) {
            __fieldSet(this, field2, value);
          }
        });
      }
    }
  }
  __publicField(__struct, "name", structName);
  for (const key of Object.getOwnPropertyNames(DataView.prototype)) {
    if (!key.startsWith("get") && !key.startsWith("set"))
      continue;
    Object.defineProperty(__struct.prototype, key, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: void 0
    });
  }
  const _struct = __struct;
  const fix = /* @__PURE__ */ __name((value) => ({
    writable: false,
    enumerable: false,
    configurable: false,
    value
  }), "fix");
  Object.defineProperties(_struct, {
    size: fix(size),
    alignment: fix(opts.alignment),
    isUnion: fix(!!opts.isUnion),
    fields: fix(fields),
    get: fix((buffer2, offset) => new _struct(buffer2, offset)),
    set: fix((buffer2, offset, value) => {
      const source2 = new Uint8Array(value.buffer, value.byteOffset, size);
      const target = new Uint8Array(buffer2, offset, size);
      if (value.buffer === buffer2 && value.byteOffset === offset)
        return;
      for (let i = 0; i < size; i++)
        target[i] = source2[i];
    }),
    [Symbol.toStringTag]: fix(`[struct ${structName}]`)
  });
  registerType(_struct);
  return _struct;
}
__name(struct, "struct");
struct.extend = function(base, structName, fieldDecls, ...options) {
  return struct(structName, { ...base.fields, ...fieldDecls }, ...options);
};
struct.packed = struct.bind({ isPacked: true });
struct.align = function(alignment) {
  return struct.bind({ alignment });
};
Object.fromEntries(Object.entries(rawTypes).map(([typeName, type]) => [
  typeName,
  new FieldBuilder(type, { typeName })
]));
function sizeof(type) {
  if (isType(type))
    return type.size;
  if (type === void 0 || type === null)
    return 0;
  if (typeof type == "object" && isType(type.constructor))
    return type.constructor.size;
  if (Array.isArray(type)) {
    let size = 0;
    for (let i = 0; i < type.length; i++)
      size += sizeof(type[i]);
    return size;
  }
  if (typeof type == "string") {
    checkValid(type);
    return types$1[normalize$1(type)].size;
  }
  throw new TypeError(`Unable to resolve size of \`${type.toString()}\``);
}
__name(sizeof, "sizeof");
function offsetof(type, fieldName) {
  let constructor;
  if (isStructConstructor(type))
    constructor = type;
  else if (isStructConstructor(type.constructor))
    constructor = type.constructor;
  else
    throw withErrno("EINVAL", "Type is not a struct or struct constructor");
  const { fields } = constructor;
  if (!(fieldName in fields))
    throw withErrno("EINVAL", "Struct does not have field: " + fieldName);
  return fields[fieldName].offset;
}
__name(offsetof, "offsetof");
function extendBuffer(buffer2, newByteLength) {
  if (buffer2.byteLength >= newByteLength)
    return buffer2;
  if (ArrayBuffer.isView(buffer2)) {
    const newBuffer = extendBuffer(buffer2.buffer, newByteLength);
    return new buffer2.constructor(newBuffer, buffer2.byteOffset, newByteLength);
  }
  const isShared = typeof SharedArrayBuffer !== "undefined" && buffer2 instanceof SharedArrayBuffer;
  if (buffer2.maxByteLength > newByteLength) {
    isShared ? buffer2.grow(newByteLength) : buffer2.resize(newByteLength);
    return buffer2;
  }
  if (isShared) {
    const newBuffer = new SharedArrayBuffer(newByteLength);
    new Uint8Array(newBuffer).set(new Uint8Array(buffer2));
    return newBuffer;
  }
  try {
    return buffer2.transfer(newByteLength);
  } catch {
    const newBuffer = new ArrayBuffer(newByteLength);
    new Uint8Array(newBuffer).set(new Uint8Array(buffer2));
    return newBuffer;
  }
}
__name(extendBuffer, "extendBuffer");
const _BufferView = class _BufferView extends DataView {
  constructor(_buffer2, _byteOffset, _byteLength2) {
    const { buffer: buffer2, byteOffset, byteLength: byteLength2 } = new Uint8Array(_buffer2, _byteOffset, _byteLength2);
    super(buffer2, byteOffset, byteLength2);
  }
};
__name(_BufferView, "BufferView");
let BufferView = _BufferView;
for (const key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (!key.startsWith("get") && !key.startsWith("set"))
    continue;
  Object.defineProperty(BufferView.prototype, key, {
    value: /* @__PURE__ */ __name(() => {
      throw new ReferenceError("Do not use DataView methods on a BufferView.");
    }, "value"),
    writable: false,
    enumerable: false,
    configurable: false
  });
}
function decodeDirListing(data) {
  return JSON.parse(decodeUTF8(data), (k, v) => k == "" ? v : typeof v == "string" ? BigInt(v).toString(16).slice(0, Math.min(v.length, 8)) : v);
}
__name(decodeDirListing, "decodeDirListing");
function encodeDirListing(data) {
  return encodeUTF8(JSON.stringify(data));
}
__name(encodeDirListing, "encodeDirListing");
function normalizeMode(mode2, def) {
  if (typeof mode2 == "number")
    return mode2;
  if (typeof mode2 == "string") {
    const parsed = parseInt(mode2, 8);
    if (!isNaN(parsed)) {
      return parsed;
    }
  }
  if (typeof def == "number")
    return def;
  throw withErrno("EINVAL", "Invalid mode: " + mode2?.toString());
}
__name(normalizeMode, "normalizeMode");
function normalizeTime(time) {
  if (time instanceof Date)
    return time.getTime();
  try {
    return Number(time);
  } catch {
    throw withErrno("EINVAL", "Invalid time.");
  }
}
__name(normalizeTime, "normalizeTime");
function normalizePath(p, noResolve = false) {
  if (p instanceof URL) {
    if (p.protocol != "file:")
      throw withErrno("EINVAL", "URLs must use the file: protocol");
    p = p.pathname;
  }
  p = p.toString();
  if (p.startsWith("file://"))
    p = p.slice("file://".length);
  if (p.includes("\0"))
    throw withErrno("EINVAL", "Path can not contain null character");
  if (p.length == 0)
    throw withErrno("EINVAL", "Path can not be empty");
  p = p.replaceAll(/[/\\]+/g, "/");
  return noResolve ? p : resolve$2(p);
}
__name(normalizePath, "normalizePath");
function normalizeOptions(options, encoding = "utf8", flag, mode2 = 0) {
  if (typeof options != "object" || options === null) {
    return {
      encoding: typeof options == "string" ? options : encoding ?? null,
      flag,
      mode: mode2
    };
  }
  return {
    encoding: typeof options?.encoding == "string" ? options.encoding : encoding ?? null,
    flag: typeof options?.flag == "string" ? options.flag : flag,
    mode: normalizeMode("mode" in options ? options?.mode : null, mode2)
  };
}
__name(normalizeOptions, "normalizeOptions");
function globToRegex(pattern2) {
  pattern2 = pattern2.replace(/([.?+^$(){}|[\]/])/g, "$1").replace(/\*\*/g, ".*").replace(/\*/g, "[^/]*").replace(/\?/g, ".");
  return new RegExp(`^${pattern2}$`);
}
__name(globToRegex, "globToRegex");
function _tempDirName(prefix) {
  return `/tmp/${normalizePath(prefix, true)}${Date.now()}-${Math.random().toString(36).slice(2)}`;
}
__name(_tempDirName, "_tempDirName");
const sep = "/";
function validateObject(str, name) {
  if (typeof str != "object") {
    throw new TypeError(`"${name}" is not an object`);
  }
}
__name(validateObject, "validateObject");
function normalizeString(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots15 = 0;
  let char = "\0";
  for (let i = 0; i <= path2.length; ++i) {
    if (i < path2.length) {
      char = path2[i];
    } else if (char == "/") {
      break;
    } else {
      char = "/";
    }
    if (char == "/") {
      if (lastSlash === i - 1 || dots15 === 1) ;
      else if (dots15 === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.at(-1) !== "." || res.at(-2) !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = i;
            dots15 = 0;
            continue;
          } else if (res.length !== 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots15 = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += "/" + path2.slice(lastSlash + 1, i);
        else
          res = path2.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots15 = 0;
    } else if (char === "." && dots15 !== -1) {
      ++dots15;
    } else {
      dots15 = -1;
    }
  }
  return res;
}
__name(normalizeString, "normalizeString");
function formatExt(ext) {
  return ext ? `${ext[0] === "." ? "" : "."}${ext}` : "";
}
__name(formatExt, "formatExt");
function resolve$2(...parts) {
  let resolved = "";
  for (const part of [...parts.reverse(), this?.pwd ?? defaultContext.pwd]) {
    if (!part?.length)
      continue;
    resolved = `${part}/${resolved}`;
    if (part.startsWith("/")) {
      break;
    }
  }
  const absolute = resolved.startsWith("/");
  resolved = normalizeString(resolved, !absolute);
  if (absolute) {
    return `/${resolved}`;
  }
  return resolved.length ? resolved : "/";
}
__name(resolve$2, "resolve$2");
function normalize(path2) {
  if (!path2.length)
    return ".";
  const isAbsolute2 = path2[0] === "/";
  const trailingSeparator = path2.at(-1) === "/";
  path2 = normalizeString(path2, !isAbsolute2);
  if (!path2.length) {
    if (isAbsolute2)
      return "/";
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator)
    path2 += "/";
  return isAbsolute2 ? `/${path2}` : path2;
}
__name(normalize, "normalize");
function isAbsolute(path2) {
  return path2.startsWith("/");
}
__name(isAbsolute, "isAbsolute");
function join(...parts) {
  if (!parts.length)
    return ".";
  const joined = parts.filter((p) => p).join("/");
  if (!joined?.length)
    return ".";
  return normalize(joined);
}
__name(join, "join");
function relative(from, to) {
  if (from === to)
    return "";
  from = resolve$2.call(this, from);
  to = resolve$2.call(this, to);
  if (from === to)
    return "";
  const fromStart = 1;
  const fromEnd = from.length;
  const fromLen = fromEnd - fromStart;
  const toStart = 1;
  const toLen = to.length - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i < length; i++) {
    const fromCode = from[fromStart + i];
    if (fromCode !== to[toStart + i])
      break;
    else if (fromCode === "/")
      lastCommonSep = i;
  }
  if (i === length) {
    if (toLen > length) {
      if (to[toStart + i] === "/") {
        return to.slice(toStart + i + 1);
      }
      if (i === 0) {
        return to.slice(toStart + i);
      }
    } else if (fromLen > length) {
      if (from[fromStart + i] === "/") {
        lastCommonSep = i;
      } else if (i === 0) {
        lastCommonSep = 0;
      }
    }
  }
  let out = "";
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from[i] === "/") {
      out += out.length === 0 ? ".." : "/..";
    }
  }
  return `${out}${to.slice(toStart + lastCommonSep)}`;
}
__name(relative, "relative");
function dirname(path2) {
  if (path2.length === 0)
    return ".";
  const hasRoot = path2[0] === "/";
  let end = -1;
  let matchedSlash = true;
  for (let i = path2.length - 1; i >= 1; --i) {
    if (path2[i] === "/") {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path2.slice(0, end);
}
__name(dirname, "dirname");
function basename(path2, suffix) {
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  if (suffix !== void 0 && suffix.length > 0 && suffix.length <= path2.length) {
    if (suffix === path2)
      return "";
    let extIdx = suffix.length - 1;
    let firstNonSlashEnd = -1;
    for (let i = path2.length - 1; i >= 0; --i) {
      if (path2[i] === "/") {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (path2[i] === suffix[extIdx]) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path2.length;
    return path2.slice(start, end);
  }
  for (let i = path2.length - 1; i >= 0; --i) {
    if (path2[i] === "/") {
      if (!matchedSlash) {
        start = i + 1;
        break;
      }
    } else if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
  }
  if (end === -1)
    return "";
  return path2.slice(start, end);
}
__name(basename, "basename");
function extname(path2) {
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i = path2.length - 1; i >= 0; --i) {
    if (path2[i] === "/") {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (path2[i] === ".") {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
__name(extname, "extname");
function format$1(pathObject) {
  validateObject(pathObject, "pathObject");
  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base || `${pathObject.name || ""}${formatExt(pathObject.ext)}`;
  if (!dir) {
    return base;
  }
  return dir === pathObject.root ? `${dir}${base}` : `${dir}/${base}`;
}
__name(format$1, "format$1");
function parse$3(path2) {
  const isAbsolute2 = path2.startsWith("/");
  const ret = { root: isAbsolute2 ? "/" : "", dir: "", base: "", ext: "", name: "" };
  if (path2.length === 0)
    return ret;
  const start = isAbsolute2 ? 1 : 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i = path2.length - 1;
  let preDotState = 0;
  for (; i >= start; --i) {
    if (path2[i] === "/") {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (path2[i] === ".") {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (end !== -1) {
    const start2 = startPart === 0 && isAbsolute2 ? 1 : startPart;
    if (startDot === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      ret.base = ret.name = path2.slice(start2, end);
    } else {
      ret.name = path2.slice(start2, startDot);
      ret.base = path2.slice(start2, end);
      ret.ext = path2.slice(startDot, end);
    }
  }
  if (startPart > 0)
    ret.dir = path2.slice(0, startPart - 1);
  else if (isAbsolute2)
    ret.dir = "/";
  return ret;
}
__name(parse$3, "parse$3");
function matchesGlob(pattern2, str) {
  return globToRegex(pattern2).test(str);
}
__name(matchesGlob, "matchesGlob");
const path = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  basename,
  dirname,
  extname,
  format: format$1,
  formatExt,
  isAbsolute,
  join,
  matchesGlob,
  normalize,
  normalizeString,
  parse: parse$3,
  relative,
  resolve: resolve$2,
  sep
}, Symbol.toStringTag, { value: "Module" }));
const n1000 = BigInt(1e3);
const _StatsCommon = class _StatsCommon {
  /**
   * Creates a new stats instance from a stats-like object. Can be used to copy stats (note)
   */
  constructor({ atimeMs, mtimeMs, ctimeMs, birthtimeMs, uid, gid, size, mode: mode2, ino, ...rest } = {}) {
    /**
     * Unix-style file mode (e.g. 0o644) that includes the type of the item.
     */
    __publicField(this, "mode");
    /**
     * ID of device containing file
     */
    __publicField(this, "dev", this._convert(0));
    /**
     * Inode number
     */
    __publicField(this, "ino", this._convert(0));
    /**
     * Device ID (if special file)
     */
    __publicField(this, "rdev", this._convert(0));
    /**
     * Number of hard links
     */
    __publicField(this, "nlink", this._convert(1));
    /**
     * Block size for file system I/O
     */
    __publicField(this, "blksize", this._convert(4096));
    /**
     * User ID of owner
     */
    __publicField(this, "uid", this._convert(0));
    /**
     * Group ID of owner
     */
    __publicField(this, "gid", this._convert(0));
    /**
     * Time of last access, since epoch
     */
    __publicField(this, "atimeMs");
    /**
     * Time of last modification, since epoch
     */
    __publicField(this, "mtimeMs");
    /**
     * Time of last time file status was changed, since epoch
     */
    __publicField(this, "ctimeMs");
    /**
     * Time of file creation, since epoch
     */
    __publicField(this, "birthtimeMs");
    /**
     * Size of the item in bytes.
     * For directories/symlinks, this is normally the size of the struct that represents the item.
     */
    __publicField(this, "size");
    /**
     * @internal Used by inodes
     */
    __publicField(this, "data");
    /**
     * @internal Used by inodes
     */
    __publicField(this, "flags");
    /**
     * @internal Used by inodes
     */
    __publicField(this, "version");
    const now = Date.now();
    this.atimeMs = this._convert(atimeMs ?? now);
    this.mtimeMs = this._convert(mtimeMs ?? now);
    this.ctimeMs = this._convert(ctimeMs ?? now);
    this.birthtimeMs = this._convert(birthtimeMs ?? now);
    this.uid = this._convert(uid ?? 0);
    this.gid = this._convert(gid ?? 0);
    this.size = this._convert(size ?? 0);
    this.ino = this._convert(ino ?? 0);
    this.mode = this._convert(mode2 ?? 420 & S_IFREG);
    if ((this.mode & S_IFMT) == 0) {
      this.mode = this.mode | this._convert(S_IFREG);
    }
    Object.assign(this, rest);
  }
  _convert(arg) {
    return this._isBigint ? BigInt(arg) : Number(arg);
  }
  get blocks() {
    return this._convert(Math.ceil(Number(this.size) / 512));
  }
  set blocks(value) {
  }
  get atime() {
    return new Date(Number(this.atimeMs));
  }
  set atime(value) {
    this.atimeMs = this._convert(value.getTime());
  }
  get mtime() {
    return new Date(Number(this.mtimeMs));
  }
  set mtime(value) {
    this.mtimeMs = this._convert(value.getTime());
  }
  get ctime() {
    return new Date(Number(this.ctimeMs));
  }
  set ctime(value) {
    this.ctimeMs = this._convert(value.getTime());
  }
  get birthtime() {
    return new Date(Number(this.birthtimeMs));
  }
  set birthtime(value) {
    this.birthtimeMs = this._convert(value.getTime());
  }
  isFile() {
    return (this.mode & S_IFMT) === S_IFREG;
  }
  isDirectory() {
    return (this.mode & S_IFMT) === S_IFDIR;
  }
  isSymbolicLink() {
    return (this.mode & S_IFMT) === S_IFLNK;
  }
  isSocket() {
    return (this.mode & S_IFMT) === S_IFSOCK;
  }
  isBlockDevice() {
    return (this.mode & S_IFMT) === S_IFBLK;
  }
  isCharacterDevice() {
    return (this.mode & S_IFMT) === S_IFCHR;
  }
  isFIFO() {
    return (this.mode & S_IFMT) === S_IFIFO;
  }
  toJSON() {
    return pick(this, _inode_fields);
  }
  /**
   * Checks if a given user/group has access to this item
   * @param mode The requested access, combination of W_OK, R_OK, and X_OK
   * @returns True if the request has access, false if the request does not
   * @internal
   */
  hasAccess(mode2, context) {
    return hasAccess(context, this._isBigint ? new Stats(this) : this, mode2);
  }
  get atimeNs() {
    return BigInt(this.atimeMs) * n1000;
  }
  get mtimeNs() {
    return BigInt(this.mtimeMs) * n1000;
  }
  get ctimeNs() {
    return BigInt(this.ctimeMs) * n1000;
  }
  get birthtimeNs() {
    return BigInt(this.birthtimeMs) * n1000;
  }
};
__name(_StatsCommon, "StatsCommon");
let StatsCommon = _StatsCommon;
const _Stats = class _Stats extends StatsCommon {
  constructor() {
    super(...arguments);
    __publicField(this, "_isBigint", false);
  }
};
__name(_Stats, "Stats");
let Stats = _Stats;
const _BigIntStats = class _BigIntStats extends StatsCommon {
  constructor() {
    super(...arguments);
    __publicField(this, "_isBigint", true);
  }
};
__name(_BigIntStats, "BigIntStats");
let BigIntStats = _BigIntStats;
function isStatsEqual(left, right) {
  return left.size == right.size && +left.atime == +right.atime && +left.mtime == +right.mtime && +left.ctime == +right.ctime && left.mode == right.mode;
}
__name(isStatsEqual, "isStatsEqual");
const _StatsFs = class _StatsFs {
  constructor() {
    /** Type of file system. */
    __publicField(this, "type", 525687744115);
    /**  Optimal transfer block size. */
    __publicField(this, "bsize", 4096);
    /**  Total data blocks in file system. */
    __publicField(this, "blocks", 0);
    /** Free blocks in file system. */
    __publicField(this, "bfree", 0);
    /** Available blocks for unprivileged users */
    __publicField(this, "bavail", 0);
    /** Total file nodes in file system. */
    __publicField(this, "files", size_max);
    /** Free file nodes in file system. */
    __publicField(this, "ffree", size_max);
  }
};
__name(_StatsFs, "StatsFs");
let StatsFs = _StatsFs;
const _BigIntStatsFs = class _BigIntStatsFs {
  constructor() {
    /** Type of file system. */
    __publicField(this, "type", BigInt("0x7a656e6673"));
    /**  Optimal transfer block size. */
    __publicField(this, "bsize", BigInt(4096));
    /**  Total data blocks in file system. */
    __publicField(this, "blocks", BigInt(0));
    /** Free blocks in file system. */
    __publicField(this, "bfree", BigInt(0));
    /** Available blocks for unprivileged users */
    __publicField(this, "bavail", BigInt(0));
    /** Total file nodes in file system. */
    __publicField(this, "files", BigInt(size_max));
    /** Free file nodes in file system. */
    __publicField(this, "ffree", BigInt(size_max));
  }
};
__name(_BigIntStatsFs, "BigIntStatsFs");
let BigIntStatsFs = _BigIntStatsFs;
var __esDecorate$2 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers$2 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
const rootIno = 0;
const maxDynamicData = 3968;
let Attribute = (() => {
  var _keySize_accessor_storage, _valueSize_accessor_storage, _a3;
  var _a2, _b2;
  let _classDecorators = [struct$1.packed("Attribute")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = $from.typed(Uint8Array);
  let _keySize_decorators;
  let _keySize_initializers = [];
  let _keySize_extraInitializers = [];
  let _valueSize_decorators;
  let _valueSize_initializers = [];
  let _valueSize_extraInitializers = [];
  _a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, _keySize_accessor_storage, __runInitializers$2(this, _keySize_initializers, void 0));
      __privateAdd(this, _valueSize_accessor_storage, (__runInitializers$2(this, _keySize_extraInitializers), __runInitializers$2(this, _valueSize_initializers, void 0)));
      __runInitializers$2(this, _valueSize_extraInitializers);
    }
    get keySize() {
      return __privateGet(this, _keySize_accessor_storage);
    }
    set keySize(value) {
      __privateSet(this, _keySize_accessor_storage, value);
    }
    get valueSize() {
      return __privateGet(this, _valueSize_accessor_storage);
    }
    set valueSize(value) {
      __privateSet(this, _valueSize_accessor_storage, value);
    }
    get name() {
      return decodeUTF8(this.subarray(8, 8 + this.keySize));
    }
    /**
     * Note that this does not handle moving the data.
     * Changing the name after setting the value is undefined behavior and will lead to corruption.
     * This should only be used when creating a new attribute.
     */
    set name(value) {
      const buf = encodeUTF8(value);
      if (8 + buf.length + this.valueSize > maxDynamicData)
        throw withErrno("EOVERFLOW");
      this.set(buf, 8);
      this.keySize = buf.length;
    }
    get value() {
      return this.subarray(8 + this.keySize, this.size);
    }
    set value(value) {
      if (8 + this.keySize + value.length > maxDynamicData)
        throw withErrno("EOVERFLOW");
      this.valueSize = value.length;
      this.set(value, 8 + this.keySize);
    }
    get size() {
      return 8 + this.keySize + this.valueSize;
    }
  }, _keySize_accessor_storage = new WeakMap(), _valueSize_accessor_storage = new WeakMap(), _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _keySize_decorators = [(_a2 = types).uint32.bind(_a2)];
    _valueSize_decorators = [(_b2 = types).uint32.bind(_b2)];
    __esDecorate$2(_a3, null, _keySize_decorators, { kind: "accessor", name: "keySize", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "keySize" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.keySize, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.keySize = value;
    }, "set") }, metadata: _metadata }, _keySize_initializers, _keySize_extraInitializers);
    __esDecorate$2(_a3, null, _valueSize_decorators, { kind: "accessor", name: "valueSize", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "valueSize" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.valueSize, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.valueSize = value;
    }, "set") }, metadata: _metadata }, _valueSize_initializers, _valueSize_extraInitializers);
    __esDecorate$2(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    __runInitializers$2(_classThis, _classExtraInitializers);
  })(), _a3;
  return _classThis;
})();
let Attributes = (() => {
  var _size_accessor_storage, _a3;
  var _a2;
  let _classDecorators = [struct$1.packed("Attributes")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = $from(BufferView);
  let _size_decorators;
  let _size_initializers = [];
  let _size_extraInitializers = [];
  _a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, _size_accessor_storage, __runInitializers$2(this, _size_initializers, void 0));
      __runInitializers$2(this, _size_extraInitializers);
    }
    get size() {
      return __privateGet(this, _size_accessor_storage);
    }
    set size(value) {
      __privateSet(this, _size_accessor_storage, value);
    }
    get byteSize() {
      let offset = this.byteOffset + sizeof(this);
      for (let i = 0; i < this.size; i++) {
        const entry = new Attribute(this.buffer, offset);
        offset += entry.size;
      }
      return offset;
    }
    has(name) {
      let offset = this.byteOffset + sizeof(this);
      for (let i = 0; i < this.size; i++) {
        const entry = new Attribute(this.buffer, offset);
        if (entry.name == name)
          return true;
        offset += entry.size;
      }
      return false;
    }
    get(name) {
      let offset = this.byteOffset + sizeof(this);
      for (let i = 0; i < this.size; i++) {
        const entry = new Attribute(this.buffer, offset);
        if (entry.name == name)
          return entry.value;
        offset += entry.size;
      }
    }
    set(name, value) {
      let offset = this.byteOffset + sizeof(this);
      let remove2;
      for (let i = 0; i < this.size; i++) {
        const entry = new Attribute(this.buffer, offset);
        if (entry.name == name)
          remove2 = [offset, entry.size];
        offset += entry.size;
      }
      const buf = new Uint8Array(this.buffer);
      if (remove2) {
        const [start, size] = remove2;
        offset -= size;
        buf.copyWithin(start, start + size, offset + size);
        buf.fill(0, offset, offset + size);
        this.size--;
      }
      const attr = new Attribute(this.buffer, offset);
      attr.name = name;
      attr.value = value;
      this.size++;
    }
    remove(name) {
      let offset = this.byteOffset + sizeof(this);
      let remove2;
      for (let i = 0; i < this.size; i++) {
        const entry = new Attribute(this.buffer, offset);
        if (entry.name == name)
          remove2 = [offset, entry.size];
        offset += entry.size;
      }
      if (!remove2)
        return false;
      const [start, size] = remove2;
      const buf = new Uint8Array(this.buffer);
      buf.copyWithin(start, start + size, offset);
      buf.fill(0, offset - size, offset);
      this.size--;
      return true;
    }
    copyFrom(other) {
      const { byteSize } = other;
      new Uint8Array(this.buffer, this.byteOffset, byteSize).set(new Uint8Array(other.buffer, other.byteOffset, byteSize));
    }
    *keys() {
      let offset = this.byteOffset + sizeof(this);
      for (let i = 0; i < this.size; i++) {
        const entry = new Attribute(this.buffer, offset);
        yield entry.name;
        offset += entry.size;
      }
    }
    *values() {
      let offset = this.byteOffset + sizeof(this);
      for (let i = 0; i < this.size; i++) {
        const entry = new Attribute(this.buffer, offset);
        yield entry.value;
        offset += entry.size;
      }
    }
    *entries() {
      let offset = this.byteOffset + sizeof(this);
      for (let i = 0; i < this.size; i++) {
        const entry = new Attribute(this.buffer, offset);
        yield [entry.name, entry.value];
        offset += entry.size;
      }
    }
  }, _size_accessor_storage = new WeakMap(), _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _size_decorators = [(_a2 = types).uint32.bind(_a2)];
    __esDecorate$2(_a3, null, _size_decorators, { kind: "accessor", name: "size", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "size" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.size, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.size = value;
    }, "set") }, metadata: _metadata }, _size_initializers, _size_extraInitializers);
    __esDecorate$2(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    __runInitializers$2(_classThis, _classExtraInitializers);
  })(), _a3;
  return _classThis;
})();
const _inode_fields = [
  "ino",
  "data",
  "size",
  "mode",
  "flags",
  "nlink",
  "uid",
  "gid",
  "atimeMs",
  "birthtimeMs",
  "mtimeMs",
  "ctimeMs",
  "version"
];
const _inode_version = 5;
var InodeFlags;
(function(InodeFlags2) {
  InodeFlags2[InodeFlags2["Sync"] = 1] = "Sync";
  InodeFlags2[InodeFlags2["NoAtime"] = 2] = "NoAtime";
  InodeFlags2[InodeFlags2["Append"] = 4] = "Append";
  InodeFlags2[InodeFlags2["Immutable"] = 8] = "Immutable";
  InodeFlags2[InodeFlags2["Dead"] = 16] = "Dead";
  InodeFlags2[InodeFlags2["NoQuota"] = 32] = "NoQuota";
  InodeFlags2[InodeFlags2["Dirsync"] = 64] = "Dirsync";
  InodeFlags2[InodeFlags2["NoCMtime"] = 128] = "NoCMtime";
  InodeFlags2[InodeFlags2["SwapFile"] = 256] = "SwapFile";
  InodeFlags2[InodeFlags2["Private"] = 512] = "Private";
  InodeFlags2[InodeFlags2["IMA"] = 1024] = "IMA";
  InodeFlags2[InodeFlags2["AutoMount"] = 2048] = "AutoMount";
  InodeFlags2[InodeFlags2["NoSec"] = 4096] = "NoSec";
  InodeFlags2[InodeFlags2["DAX"] = 8192] = "DAX";
  InodeFlags2[InodeFlags2["Encrypted"] = 16384] = "Encrypted";
  InodeFlags2[InodeFlags2["CaseFold"] = 32768] = "CaseFold";
  InodeFlags2[InodeFlags2["Verity"] = 65536] = "Verity";
  InodeFlags2[InodeFlags2["KernelFile"] = 131072] = "KernelFile";
})(InodeFlags || (InodeFlags = {}));
let Inode = (() => {
  var _data_accessor_storage, ___data_old_accessor_storage, _size_accessor_storage, _mode_accessor_storage, _nlink_accessor_storage, _uid_accessor_storage, _gid_accessor_storage, _atimeMs_accessor_storage, _birthtimeMs_accessor_storage, _mtimeMs_accessor_storage, _ctimeMs_accessor_storage, _ino_accessor_storage, ___ino_old_accessor_storage, _flags_accessor_storage, ___after_flags_accessor_storage, _version_accessor_storage, ___padding_accessor_storage, _attributes_accessor_storage, ___data_accessor_storage, _a3;
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h, _j, _k, _l, _m, _o, _p, _q, _r;
  let _classDecorators = [struct$1.packed("Inode")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = $from(BufferView);
  let _data_decorators;
  let _data_initializers = [];
  let _data_extraInitializers = [];
  let ___data_old_decorators;
  let ___data_old_initializers = [];
  let ___data_old_extraInitializers = [];
  let _size_decorators;
  let _size_initializers = [];
  let _size_extraInitializers = [];
  let _mode_decorators;
  let _mode_initializers = [];
  let _mode_extraInitializers = [];
  let _nlink_decorators;
  let _nlink_initializers = [];
  let _nlink_extraInitializers = [];
  let _uid_decorators;
  let _uid_initializers = [];
  let _uid_extraInitializers = [];
  let _gid_decorators;
  let _gid_initializers = [];
  let _gid_extraInitializers = [];
  let _atimeMs_decorators;
  let _atimeMs_initializers = [];
  let _atimeMs_extraInitializers = [];
  let _birthtimeMs_decorators;
  let _birthtimeMs_initializers = [];
  let _birthtimeMs_extraInitializers = [];
  let _mtimeMs_decorators;
  let _mtimeMs_initializers = [];
  let _mtimeMs_extraInitializers = [];
  let _ctimeMs_decorators;
  let _ctimeMs_initializers = [];
  let _ctimeMs_extraInitializers = [];
  let _ino_decorators;
  let _ino_initializers = [];
  let _ino_extraInitializers = [];
  let ___ino_old_decorators;
  let ___ino_old_initializers = [];
  let ___ino_old_extraInitializers = [];
  let _flags_decorators;
  let _flags_initializers = [];
  let _flags_extraInitializers = [];
  let ___after_flags_decorators;
  let ___after_flags_initializers = [];
  let ___after_flags_extraInitializers = [];
  let _version_decorators;
  let _version_initializers = [];
  let _version_extraInitializers = [];
  let ___padding_decorators;
  let ___padding_initializers = [];
  let ___padding_extraInitializers = [];
  let _attributes_decorators;
  let _attributes_initializers = [];
  let _attributes_extraInitializers = [];
  let ___data_decorators;
  let ___data_initializers = [];
  let ___data_extraInitializers = [];
  var Inode2 = (_a3 = class extends _classSuper {
    constructor(...args) {
      let data = {};
      if (typeof args[0] === "object" && args[0] !== null && !ArrayBuffer.isView(args[0])) {
        data = args[0];
        args = [sizeof(Inode2)];
      }
      super(...args);
      __privateAdd(this, _data_accessor_storage, __runInitializers$2(this, _data_initializers, void 0));
      __privateAdd(this, ___data_old_accessor_storage, (__runInitializers$2(this, _data_extraInitializers), __runInitializers$2(this, ___data_old_initializers, void 0)));
      __privateAdd(this, _size_accessor_storage, (__runInitializers$2(this, ___data_old_extraInitializers), __runInitializers$2(this, _size_initializers, void 0)));
      __privateAdd(this, _mode_accessor_storage, (__runInitializers$2(this, _size_extraInitializers), __runInitializers$2(this, _mode_initializers, void 0)));
      __privateAdd(this, _nlink_accessor_storage, (__runInitializers$2(this, _mode_extraInitializers), __runInitializers$2(this, _nlink_initializers, void 0)));
      __privateAdd(this, _uid_accessor_storage, (__runInitializers$2(this, _nlink_extraInitializers), __runInitializers$2(this, _uid_initializers, void 0)));
      __privateAdd(this, _gid_accessor_storage, (__runInitializers$2(this, _uid_extraInitializers), __runInitializers$2(this, _gid_initializers, void 0)));
      __privateAdd(this, _atimeMs_accessor_storage, (__runInitializers$2(this, _gid_extraInitializers), __runInitializers$2(this, _atimeMs_initializers, void 0)));
      __privateAdd(this, _birthtimeMs_accessor_storage, (__runInitializers$2(this, _atimeMs_extraInitializers), __runInitializers$2(this, _birthtimeMs_initializers, void 0)));
      __privateAdd(this, _mtimeMs_accessor_storage, (__runInitializers$2(this, _birthtimeMs_extraInitializers), __runInitializers$2(this, _mtimeMs_initializers, void 0)));
      __privateAdd(this, _ctimeMs_accessor_storage, (__runInitializers$2(this, _mtimeMs_extraInitializers), __runInitializers$2(this, _ctimeMs_initializers, void 0)));
      __privateAdd(this, _ino_accessor_storage, (__runInitializers$2(this, _ctimeMs_extraInitializers), __runInitializers$2(this, _ino_initializers, void 0)));
      __privateAdd(this, ___ino_old_accessor_storage, (__runInitializers$2(this, _ino_extraInitializers), __runInitializers$2(this, ___ino_old_initializers, void 0)));
      __privateAdd(this, _flags_accessor_storage, (__runInitializers$2(this, ___ino_old_extraInitializers), __runInitializers$2(this, _flags_initializers, void 0)));
      __privateAdd(this, ___after_flags_accessor_storage, (__runInitializers$2(this, _flags_extraInitializers), __runInitializers$2(this, ___after_flags_initializers, void 0)));
      __privateAdd(this, _version_accessor_storage, (__runInitializers$2(this, ___after_flags_extraInitializers), __runInitializers$2(this, _version_initializers, void 0)));
      __privateAdd(this, ___padding_accessor_storage, (__runInitializers$2(this, _version_extraInitializers), __runInitializers$2(this, ___padding_initializers, void 0)));
      __privateAdd(this, _attributes_accessor_storage, (__runInitializers$2(this, ___padding_extraInitializers), __runInitializers$2(this, _attributes_initializers, void 0)));
      __privateAdd(this, ___data_accessor_storage, (__runInitializers$2(this, _attributes_extraInitializers), __runInitializers$2(this, ___data_initializers, void 0)));
      __runInitializers$2(this, ___data_extraInitializers);
      if (this.byteLength < sizeof(Inode2)) {
        throw crit(withErrno("EIO", `Buffer is too small to create an inode (${this.byteLength} bytes)`));
      }
      Object.assign(this, data);
      this.atimeMs || (this.atimeMs = Date.now());
      this.mtimeMs || (this.mtimeMs = Date.now());
      this.ctimeMs || (this.ctimeMs = Date.now());
      this.birthtimeMs || (this.birthtimeMs = Date.now());
      if (this.ino && !this.nlink) {
        warn(`Inode ${this.ino} has an nlink of 0`);
      }
    }
    get data() {
      return __privateGet(this, _data_accessor_storage);
    }
    set data(value) {
      __privateSet(this, _data_accessor_storage, value);
    }
    /** For future use */
    get __data_old() {
      return __privateGet(this, ___data_old_accessor_storage);
    }
    set __data_old(value) {
      __privateSet(this, ___data_old_accessor_storage, value);
    }
    get size() {
      return __privateGet(this, _size_accessor_storage);
    }
    set size(value) {
      __privateSet(this, _size_accessor_storage, value);
    }
    get mode() {
      return __privateGet(this, _mode_accessor_storage);
    }
    set mode(value) {
      __privateSet(this, _mode_accessor_storage, value);
    }
    get nlink() {
      return __privateGet(this, _nlink_accessor_storage);
    }
    set nlink(value) {
      __privateSet(this, _nlink_accessor_storage, value);
    }
    get uid() {
      return __privateGet(this, _uid_accessor_storage);
    }
    set uid(value) {
      __privateSet(this, _uid_accessor_storage, value);
    }
    get gid() {
      return __privateGet(this, _gid_accessor_storage);
    }
    set gid(value) {
      __privateSet(this, _gid_accessor_storage, value);
    }
    get atimeMs() {
      return __privateGet(this, _atimeMs_accessor_storage);
    }
    set atimeMs(value) {
      __privateSet(this, _atimeMs_accessor_storage, value);
    }
    get birthtimeMs() {
      return __privateGet(this, _birthtimeMs_accessor_storage);
    }
    set birthtimeMs(value) {
      __privateSet(this, _birthtimeMs_accessor_storage, value);
    }
    get mtimeMs() {
      return __privateGet(this, _mtimeMs_accessor_storage);
    }
    set mtimeMs(value) {
      __privateSet(this, _mtimeMs_accessor_storage, value);
    }
    /**
     * The time the inode was changed.
     *
     * This is automatically updated whenever changed are made using `update()`.
     */
    get ctimeMs() {
      return __privateGet(this, _ctimeMs_accessor_storage);
    }
    set ctimeMs(value) {
      __privateSet(this, _ctimeMs_accessor_storage, value);
    }
    get ino() {
      return __privateGet(this, _ino_accessor_storage);
    }
    set ino(value) {
      __privateSet(this, _ino_accessor_storage, value);
    }
    /** For future use */
    get __ino_old() {
      return __privateGet(this, ___ino_old_accessor_storage);
    }
    set __ino_old(value) {
      __privateSet(this, ___ino_old_accessor_storage, value);
    }
    get flags() {
      return __privateGet(this, _flags_accessor_storage);
    }
    set flags(value) {
      __privateSet(this, _flags_accessor_storage, value);
    }
    /** For future use */
    get __after_flags() {
      return __privateGet(this, ___after_flags_accessor_storage);
    }
    set __after_flags(value) {
      __privateSet(this, ___after_flags_accessor_storage, value);
    }
    /**
     * The "version" of the inode/data.
     * Unrelated to the inode format!
     */
    get version() {
      return __privateGet(this, _version_accessor_storage);
    }
    set version(value) {
      __privateSet(this, _version_accessor_storage, value);
    }
    /**
     * Padding up to 128 bytes.
     * This ensures there is enough room for expansion without breaking the ABI.
     * @internal
     */
    get __padding() {
      return __privateGet(this, ___padding_accessor_storage);
    }
    set __padding(value) {
      __privateSet(this, ___padding_accessor_storage, value);
    }
    get attributes() {
      return __privateGet(this, _attributes_accessor_storage);
    }
    set attributes(value) {
      __privateSet(this, _attributes_accessor_storage, value);
    }
    /**
     * Since the attribute data uses dynamic arrays,
     * it is necessary to add this so attributes can be added.
     * @internal @hidden
     */
    get __data() {
      return __privateGet(this, ___data_accessor_storage);
    }
    set __data(value) {
      __privateSet(this, ___data_accessor_storage, value);
    }
    toString() {
      return `<Inode ${this.ino}>`;
    }
    toJSON() {
      return {
        ...pick(this, _inode_fields),
        attributes: this.attributes
      };
    }
    /**
     * Handy function that converts the Inode to a Node Stats object.
     * @deprecated Use `new Stats(inode)` instead.
     */
    toStats() {
      return new Stats(this);
    }
    /**
     * Updates the Inode using information from the stats object. Used by file
     * systems at sync time, e.g.:
     * - Program opens file and gets a File object.
     * - Program mutates file. File object is responsible for maintaining
     *   metadata changes locally -- typically in a Stats object.
     * - Program closes file. File object's metadata changes are synced with the
     *   file system.
     * @returns whether any changes have occurred.
     */
    update(data) {
      if (!data)
        return false;
      let hasChanged = false;
      for (const key of _inode_fields) {
        if (data[key] === void 0)
          continue;
        if (key == "ino" || key == "data")
          continue;
        if (this[key] === data[key])
          continue;
        if (key == "atimeMs" && this.flags & InodeFlags.NoAtime)
          continue;
        this[key] = data[key];
        hasChanged = true;
      }
      if (data.attributes) {
        this.attributes.copyFrom(data.attributes);
        hasChanged = true;
      }
      if (hasChanged)
        this.ctimeMs = Date.now();
      return hasChanged;
    }
  }, _data_accessor_storage = new WeakMap(), ___data_old_accessor_storage = new WeakMap(), _size_accessor_storage = new WeakMap(), _mode_accessor_storage = new WeakMap(), _nlink_accessor_storage = new WeakMap(), _uid_accessor_storage = new WeakMap(), _gid_accessor_storage = new WeakMap(), _atimeMs_accessor_storage = new WeakMap(), _birthtimeMs_accessor_storage = new WeakMap(), _mtimeMs_accessor_storage = new WeakMap(), _ctimeMs_accessor_storage = new WeakMap(), _ino_accessor_storage = new WeakMap(), ___ino_old_accessor_storage = new WeakMap(), _flags_accessor_storage = new WeakMap(), ___after_flags_accessor_storage = new WeakMap(), _version_accessor_storage = new WeakMap(), ___padding_accessor_storage = new WeakMap(), _attributes_accessor_storage = new WeakMap(), ___data_accessor_storage = new WeakMap(), __name(_a3, "Inode"), _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _data_decorators = [(_a2 = types).uint32.bind(_a2)];
    ___data_old_decorators = [(_b2 = types).uint32.bind(_b2)];
    _size_decorators = [(_c2 = types).uint32.bind(_c2)];
    _mode_decorators = [(_d2 = types).uint16.bind(_d2)];
    _nlink_decorators = [(_e2 = types).uint32.bind(_e2)];
    _uid_decorators = [(_f2 = types).uint32.bind(_f2)];
    _gid_decorators = [(_g2 = types).uint32.bind(_g2)];
    _atimeMs_decorators = [(_h = types).float64.bind(_h)];
    _birthtimeMs_decorators = [(_j = types).float64.bind(_j)];
    _mtimeMs_decorators = [(_k = types).float64.bind(_k)];
    _ctimeMs_decorators = [(_l = types).float64.bind(_l)];
    _ino_decorators = [(_m = types).uint32.bind(_m)];
    ___ino_old_decorators = [(_o = types).uint32.bind(_o)];
    _flags_decorators = [(_p = types).uint32.bind(_p)];
    ___after_flags_decorators = [(_q = types).uint16.bind(_q)];
    _version_decorators = [(_r = types).uint32.bind(_r)];
    ___padding_decorators = [types.uint8(48)];
    _attributes_decorators = [field(Attributes)];
    ___data_decorators = [types.uint8(maxDynamicData)];
    __esDecorate$2(_a3, null, _data_decorators, { kind: "accessor", name: "data", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "data" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.data, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.data = value;
    }, "set") }, metadata: _metadata }, _data_initializers, _data_extraInitializers);
    __esDecorate$2(_a3, null, ___data_old_decorators, { kind: "accessor", name: "__data_old", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "__data_old" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.__data_old, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.__data_old = value;
    }, "set") }, metadata: _metadata }, ___data_old_initializers, ___data_old_extraInitializers);
    __esDecorate$2(_a3, null, _size_decorators, { kind: "accessor", name: "size", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "size" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.size, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.size = value;
    }, "set") }, metadata: _metadata }, _size_initializers, _size_extraInitializers);
    __esDecorate$2(_a3, null, _mode_decorators, { kind: "accessor", name: "mode", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "mode" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.mode, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.mode = value;
    }, "set") }, metadata: _metadata }, _mode_initializers, _mode_extraInitializers);
    __esDecorate$2(_a3, null, _nlink_decorators, { kind: "accessor", name: "nlink", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "nlink" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.nlink, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.nlink = value;
    }, "set") }, metadata: _metadata }, _nlink_initializers, _nlink_extraInitializers);
    __esDecorate$2(_a3, null, _uid_decorators, { kind: "accessor", name: "uid", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "uid" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.uid, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.uid = value;
    }, "set") }, metadata: _metadata }, _uid_initializers, _uid_extraInitializers);
    __esDecorate$2(_a3, null, _gid_decorators, { kind: "accessor", name: "gid", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "gid" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.gid, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.gid = value;
    }, "set") }, metadata: _metadata }, _gid_initializers, _gid_extraInitializers);
    __esDecorate$2(_a3, null, _atimeMs_decorators, { kind: "accessor", name: "atimeMs", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "atimeMs" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.atimeMs, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.atimeMs = value;
    }, "set") }, metadata: _metadata }, _atimeMs_initializers, _atimeMs_extraInitializers);
    __esDecorate$2(_a3, null, _birthtimeMs_decorators, { kind: "accessor", name: "birthtimeMs", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "birthtimeMs" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.birthtimeMs, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.birthtimeMs = value;
    }, "set") }, metadata: _metadata }, _birthtimeMs_initializers, _birthtimeMs_extraInitializers);
    __esDecorate$2(_a3, null, _mtimeMs_decorators, { kind: "accessor", name: "mtimeMs", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "mtimeMs" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.mtimeMs, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.mtimeMs = value;
    }, "set") }, metadata: _metadata }, _mtimeMs_initializers, _mtimeMs_extraInitializers);
    __esDecorate$2(_a3, null, _ctimeMs_decorators, { kind: "accessor", name: "ctimeMs", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "ctimeMs" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.ctimeMs, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.ctimeMs = value;
    }, "set") }, metadata: _metadata }, _ctimeMs_initializers, _ctimeMs_extraInitializers);
    __esDecorate$2(_a3, null, _ino_decorators, { kind: "accessor", name: "ino", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "ino" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.ino, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.ino = value;
    }, "set") }, metadata: _metadata }, _ino_initializers, _ino_extraInitializers);
    __esDecorate$2(_a3, null, ___ino_old_decorators, { kind: "accessor", name: "__ino_old", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "__ino_old" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.__ino_old, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.__ino_old = value;
    }, "set") }, metadata: _metadata }, ___ino_old_initializers, ___ino_old_extraInitializers);
    __esDecorate$2(_a3, null, _flags_decorators, { kind: "accessor", name: "flags", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "flags" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.flags, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.flags = value;
    }, "set") }, metadata: _metadata }, _flags_initializers, _flags_extraInitializers);
    __esDecorate$2(_a3, null, ___after_flags_decorators, { kind: "accessor", name: "__after_flags", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "__after_flags" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.__after_flags, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.__after_flags = value;
    }, "set") }, metadata: _metadata }, ___after_flags_initializers, ___after_flags_extraInitializers);
    __esDecorate$2(_a3, null, _version_decorators, { kind: "accessor", name: "version", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "version" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.version, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.version = value;
    }, "set") }, metadata: _metadata }, _version_initializers, _version_extraInitializers);
    __esDecorate$2(_a3, null, ___padding_decorators, { kind: "accessor", name: "__padding", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "__padding" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.__padding, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.__padding = value;
    }, "set") }, metadata: _metadata }, ___padding_initializers, ___padding_extraInitializers);
    __esDecorate$2(_a3, null, _attributes_decorators, { kind: "accessor", name: "attributes", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "attributes" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.attributes, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.attributes = value;
    }, "set") }, metadata: _metadata }, _attributes_initializers, _attributes_extraInitializers);
    __esDecorate$2(_a3, null, ___data_decorators, { kind: "accessor", name: "__data", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "__data" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.__data, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.__data = value;
    }, "set") }, metadata: _metadata }, ___data_initializers, ___data_extraInitializers);
    __esDecorate$2(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Inode2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    __runInitializers$2(_classThis, _classExtraInitializers);
  })(), _a3);
  return Inode2 = _classThis;
})();
function isFile(metadata) {
  return (metadata.mode & S_IFMT) === S_IFREG;
}
__name(isFile, "isFile");
function isDirectory(metadata) {
  return (metadata.mode & S_IFMT) === S_IFDIR;
}
__name(isDirectory, "isDirectory");
function isSymbolicLink(metadata) {
  return (metadata.mode & S_IFMT) === S_IFLNK;
}
__name(isSymbolicLink, "isSymbolicLink");
function isBlockDevice(metadata) {
  return (metadata.mode & S_IFMT) === S_IFBLK;
}
__name(isBlockDevice, "isBlockDevice");
function isCharacterDevice(metadata) {
  return (metadata.mode & S_IFMT) === S_IFCHR;
}
__name(isCharacterDevice, "isCharacterDevice");
function hasAccess($, inode, access2) {
  const credentials = $?.credentials || defaultContext.credentials;
  if (isSymbolicLink(inode) || credentials.euid === 0 || credentials.egid === 0)
    return true;
  let perm = 0;
  if (credentials.uid === inode.uid) {
    if (inode.mode & S_IRUSR)
      perm |= R_OK;
    if (inode.mode & S_IWUSR)
      perm |= W_OK;
    if (inode.mode & S_IXUSR)
      perm |= X_OK;
  }
  if (credentials.gid === inode.gid || credentials.groups.includes(Number(inode.gid))) {
    if (inode.mode & S_IRGRP)
      perm |= R_OK;
    if (inode.mode & S_IWGRP)
      perm |= W_OK;
    if (inode.mode & S_IXGRP)
      perm |= X_OK;
  }
  if (inode.mode & S_IROTH)
    perm |= R_OK;
  if (inode.mode & S_IWOTH)
    perm |= W_OK;
  if (inode.mode & S_IXOTH)
    perm |= X_OK;
  return (perm & access2) === access2;
}
__name(hasAccess, "hasAccess");
function _chown(stats, uid, gid) {
  let valid2 = true;
  if (!isNaN(uid) && uid >= 0 && uid < size_max)
    stats.uid = uid;
  else
    valid2 = false;
  if (!isNaN(gid) && gid >= 0 && gid < size_max)
    stats.gid = gid;
  else
    valid2 = false;
  return valid2;
}
__name(_chown, "_chown");
const version$1 = 1;
const _Index = class _Index extends Map {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", size_max);
  }
  /**
   * Converts the index to JSON
   */
  toJSON() {
    return {
      version: version$1,
      maxSize: this.maxSize,
      entries: Object.fromEntries([...this].map(([k, v]) => [k, v.toJSON()]))
    };
  }
  /**
   * Converts the index to a string
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
  /**
   * Get the size in bytes of the index (including the size reported for each entry)
   */
  get byteSize() {
    let size = this.size * sizeof(Inode);
    for (const entry of this.values())
      size += entry.size;
    return size;
  }
  usage() {
    return {
      totalSpace: this.maxSize,
      freeSpace: this.maxSize - this.byteSize
    };
  }
  pathOf(id) {
    for (const [path2, inode] of this) {
      if (inode.ino == id || inode.data == id)
        return path2;
    }
  }
  getByID(id) {
    return this.entryByID(id)?.inode;
  }
  entryByID(id) {
    for (const [path2, inode] of this) {
      if (inode.ino == id || inode.data == id)
        return { path: path2, inode };
    }
  }
  directoryEntries(path2) {
    const node = this.get(path2);
    if (!node)
      throw withErrno("ENOENT");
    if ((node.mode & S_IFMT) != S_IFDIR)
      throw withErrno("ENOTDIR");
    const entries2 = {};
    for (const entry of this.keys()) {
      if (dirname(entry) == path2 && entry != path2) {
        entries2[basename(entry)] = this.get(entry).ino;
      }
    }
    return entries2;
  }
  /**
   * Get the next available ID in the index
   * @internal
   */
  _alloc() {
    return Math.max(...[...this.values()].flatMap((i) => [i.ino, i.data])) + 1;
  }
  /**
   * Gets a list of entries for each directory in the index.
   * Use
   */
  directories() {
    const dirs = /* @__PURE__ */ new Map();
    for (const [path2, node] of this) {
      if ((node.mode & S_IFMT) != S_IFDIR)
        continue;
      const entries2 = {};
      for (const entry of this.keys()) {
        if (dirname(entry) == path2 && entry != path2)
          entries2[basename(entry)] = this.get(entry).ino;
      }
      dirs.set(path2, entries2);
    }
    return dirs;
  }
  /**
   * Loads the index from JSON data
   */
  fromJSON(json) {
    if (json.version != version$1)
      throw withErrno("EINVAL", "Index version mismatch");
    this.clear();
    for (const [path2, node] of Object.entries(json.entries)) {
      node.data ?? (node.data = randomInt(1, size_max));
      if (path2 == "/")
        node.ino = 0;
      this.set(path2, new Inode(node));
    }
    return this;
  }
  /**
   * Parses an index from a string
   */
  static parse(data) {
    if (!isJSON(data))
      throw withErrno("EINVAL", "Invalid JSON");
    const json = JSON.parse(data);
    const index = new _Index();
    index.fromJSON(json);
    return index;
  }
};
__name(_Index, "Index");
let Index = _Index;
const _chunkSize = 4096;
const _FileSystem = class _FileSystem {
  constructor(type, name) {
    __publicField(this, "type");
    __publicField(this, "name");
    __publicField(this, "label");
    /**
     * The last place this file system was mounted
     * @internal @protected
     */
    __publicField(this, "_mountPoint");
    /**
     * The UUID of the file system.
     * @privateRemarks This is only used by `ioctl`
     * @internal @protected
     */
    __publicField(this, "_uuid", crypto.randomUUID());
    /**
     * @see FileSystemAttributes
     */
    __publicField(this, "attributes", /* @__PURE__ */ new Map());
    this.type = type;
    this.name = name;
    if (this.streamRead === _FileSystem.prototype.streamRead)
      this.attributes.set("default_stream_read");
    if (this.streamWrite === _FileSystem.prototype.streamWrite)
      this.attributes.set("default_stream_write");
  }
  get uuid() {
    return this._uuid;
  }
  toString() {
    return `${this.name} ${this.label ? JSON.stringify(this.label) : ""} (${this._mountPoint ? "mounted on " + this._mountPoint : "unmounted"})`;
  }
  /**
   * Default implementation.
   * @todo Implement
   * @experimental
   */
  usage() {
    return {
      totalSpace: 0,
      freeSpace: 0
    };
  }
  async ready() {
  }
  /**
   * Test whether or not `path` exists.
   */
  async exists(path2) {
    try {
      await this.stat(path2);
      return true;
    } catch (e2) {
      return e2.code != "ENOENT";
    }
  }
  /**
   * Test whether or not `path` exists.
   */
  existsSync(path2) {
    try {
      this.statSync(path2);
      return true;
    } catch (e2) {
      return e2.code != "ENOENT";
    }
  }
  /**
   * Read a file using a stream.
   * @privateRemarks The default implementation of `streamRead` uses "chunked" `read`s
   */
  streamRead(path2, options) {
    return new ReadableStream({
      start: /* @__PURE__ */ __name(async (controller) => {
        const { size } = await this.stat(path2);
        const { start = 0, end = size } = options;
        for (let offset = start; offset < end; offset += _chunkSize) {
          const bytesRead = offset + _chunkSize > end ? end - offset : _chunkSize;
          const buffer2 = new Uint8Array(bytesRead);
          await this.read(path2, buffer2, offset, offset + bytesRead).catch(controller.error.bind(controller));
          controller.enqueue(buffer2);
        }
        controller.close();
      }, "start"),
      type: "bytes"
    });
  }
  /**
   * Write a file using stream.
   * @privateRemarks The default implementation of `streamWrite` uses "chunked" `write`s
   */
  streamWrite(path2, options) {
    let position = options.start ?? 0;
    return new WritableStream({
      write: /* @__PURE__ */ __name(async (chunk, controller) => {
        let err2 = false;
        const _err = /* @__PURE__ */ __name((ex) => {
          err2 = true;
          controller.error(ex);
        }, "_err");
        const { size } = await this.stat(path2);
        await this.write(path2, chunk, position).catch(_err);
        if (err2)
          return;
        position += chunk.byteLength;
        await this.touch(path2, { mtimeMs: Date.now(), size: Math.max(size, position) }).catch(_err);
      }, "write")
    });
  }
};
__name(_FileSystem, "FileSystem");
let FileSystem = _FileSystem;
const _Resource = class _Resource {
  constructor(id, _size, options, resources2) {
    __publicField(this, "id");
    __publicField(this, "_size");
    __publicField(this, "options");
    /** Regions used to reduce unneeded allocations. Think of sparse arrays. */
    __publicField(this, "regions", []);
    this.id = id;
    this._size = _size;
    this.options = options;
    options.sparse ?? (options.sparse = true);
    if (!options.sparse)
      this.regions.push({ offset: 0, data: new Uint8Array(_size), ranges: [] });
    resources2?.set(id, this);
  }
  /** The full size of the resource */
  get size() {
    return this._size;
  }
  set size(value) {
    if (value >= this._size) {
      this._size = value;
      return;
    }
    this._size = value;
    for (let i = this.regions.length - 1; i >= 0; i--) {
      const region = this.regions[i];
      if (region.offset >= value) {
        this.regions.splice(i, 1);
        continue;
      }
      const maxLength = value - region.offset;
      if (region.data.byteLength > maxLength) {
        region.data = region.data.subarray(0, maxLength);
      }
      region.ranges = region.ranges.filter((range2) => range2.start < value).map((range2) => {
        if (range2.end > value) {
          return { start: range2.start, end: value };
        }
        return range2;
      });
    }
  }
  /** Combines adjacent regions and combines adjacent ranges within a region */
  collect() {
    if (!this.options.sparse)
      return;
    const { regionGapThreshold = 4095 } = this.options;
    for (let i = 0; i < this.regions.length - 1; ) {
      const current = this.regions[i];
      const next = this.regions[i + 1];
      if (next.offset - (current.offset + current.data.byteLength) > regionGapThreshold) {
        i++;
        continue;
      }
      current.ranges.push(...next.ranges);
      current.ranges.sort((a, b) => a.start - b.start);
      current.ranges = current.ranges.reduce((acc, range2) => {
        if (!acc.length || acc.at(-1).end < range2.start) {
          acc.push(range2);
        } else {
          acc.at(-1).end = Math.max(acc.at(-1).end, range2.end);
        }
        return acc;
      }, []);
      current.data = extendBuffer(current.data, next.offset + next.data.byteLength);
      current.data.set(next.data, next.offset - current.offset);
      this.regions.splice(i + 1, 1);
    }
  }
  /** Takes an initial range and finds the sub-ranges that are not in the cache */
  missing(start, end) {
    const missingRanges = [];
    for (const region of this.regions) {
      if (region.offset >= end)
        break;
      for (const range2 of region.ranges) {
        if (range2.end <= start)
          continue;
        if (range2.start >= end)
          break;
        if (range2.start > start) {
          missingRanges.push({ start, end: Math.min(range2.start, end) });
        }
        if (range2.end > start)
          start = Math.max(start, range2.end);
        if (start >= end)
          break;
      }
      if (start >= end)
        break;
    }
    if (start < end)
      missingRanges.push({ start, end });
    return missingRanges;
  }
  /**
   * Get the cached sub-ranges of an initial range.
   * This is conceptually the inverse of `missing`.
   */
  cached(start, end) {
    const cachedRanges = [];
    for (const region of this.regions) {
      if (region.offset >= end)
        break;
      for (const range2 of region.ranges) {
        if (range2.end <= start)
          continue;
        if (range2.start >= end)
          break;
        cachedRanges.push({
          start: Math.max(start, range2.start),
          end: Math.min(end, range2.end)
        });
      }
    }
    cachedRanges.sort((a, b) => a.start - b.start);
    const merged = [];
    for (const curr of cachedRanges) {
      const last = merged.at(-1);
      if (last && curr.start <= last.end) {
        last.end = Math.max(last.end, curr.end);
      } else {
        merged.push(curr);
      }
    }
    return merged;
  }
  /** Get the region who's ranges include an offset */
  regionAt(offset) {
    if (!this.regions.length)
      return;
    for (const region of this.regions) {
      if (region.offset > offset)
        break;
      if (offset >= region.offset && offset < region.offset + region.data.byteLength)
        return region;
    }
  }
  /** Add new data to the cache at given specified offset */
  add(data, offset) {
    const end = offset + data.byteLength;
    const region = this.regionAt(offset);
    if (region) {
      region.data = extendBuffer(region.data, end);
      region.data.set(data, offset);
      region.ranges.push({ start: offset, end });
      region.ranges.sort((a, b) => a.start - b.start);
      this.collect();
      return this;
    }
    const newRegion = { data, offset, ranges: [{ start: offset, end }] };
    const insertIndex = this.regions.findIndex((region2) => region2.offset > offset);
    if (insertIndex == -1) {
      this.regions.push(newRegion);
    } else {
      this.regions.splice(insertIndex, 0, newRegion);
    }
    this.collect();
    return this;
  }
};
__name(_Resource, "Resource");
let Resource = _Resource;
Promise.withResolvers ?? (Promise.withResolvers = (warn("Using a polyfill of Promise.withResolvers"), function() {
  let _resolve, _reject;
  const promise = new Promise((resolve2, reject) => {
    _resolve = resolve2;
    _reject = reject;
  });
  return { promise, resolve: _resolve, reject: _reject };
}));
Symbol["dispose"] ?? (Symbol["dispose"] = (warn("Using a polyfill of Symbol.dispose"), Symbol("Symbol.dispose")));
Symbol["asyncDispose"] ?? (Symbol["asyncDispose"] = (warn("Using a polyfill of Symbol.asyncDispose"), Symbol("Symbol.asyncDispose")));
(_b = globalThis.crypto).randomUUID ?? (_b.randomUUID = (warn("Using a polyfill of crypto.randomUUID"), /* @__PURE__ */ __name(function randomUUID() {
  const bytes = crypto.getRandomValues(new Uint8Array(16));
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const hex = [...bytes].map((b) => b.toString(16).padStart(2, "0")).join("");
  return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
}, "randomUUID")));
(_c = Uint8Array.prototype).toBase64 ?? (_c.toBase64 = (warn("Using a polyfill of Uint8Array.prototype.toBase64"), /* @__PURE__ */ __name(function toBase64() {
  return btoa(String.fromCharCode(...this));
}, "toBase64")));
Uint8Array.fromBase64 ?? (Uint8Array.fromBase64 = (warn("Using a polyfill of Uint8Array.fromBase64"), /* @__PURE__ */ __name(function fromBase64(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}, "fromBase64")));
(_d = Uint8Array.prototype).toHex ?? (_d.toHex = (warn("Using a polyfill of Uint8Array.prototype.toHex"), /* @__PURE__ */ __name(function toHex() {
  return [...this].map((b) => b.toString(16).padStart(2, "0")).join("");
}, "toHex")));
Uint8Array.fromHex ?? (Uint8Array.fromHex = (warn("Using a polyfill of Uint8Array.fromHex"), /* @__PURE__ */ __name(function fromHex(hex) {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
  }
  return bytes;
}, "fromHex")));
const _Transaction = class _Transaction {
  constructor(store) {
    __publicField(this, "store");
    this.store = store;
  }
};
__name(_Transaction, "Transaction");
let Transaction = _Transaction;
const _SyncTransaction = class _SyncTransaction extends Transaction {
  /* eslint-disable @typescript-eslint/require-await */
  async get(id, offset, end) {
    return this.getSync(id, offset, end);
  }
  async set(id, data, offset) {
    return this.setSync(id, data, offset);
  }
  async remove(id) {
    return this.removeSync(id);
  }
};
__name(_SyncTransaction, "SyncTransaction");
let SyncTransaction = _SyncTransaction;
const _AsyncTransaction = class _AsyncTransaction extends Transaction {
  constructor() {
    super(...arguments);
    __publicField(this, "asyncDone", Promise.resolve());
  }
  /**
   * Run a asynchronous operation from a sync context. Not magic and subject to (race) conditions.
   * @internal
   */
  async(promise) {
    this.asyncDone = this.asyncDone.then(() => promise);
  }
  /**
   * Gets a cache resource
   * If `info` is set and the resource doesn't exist, it will be created
   * @internal
   */
  _cached(id, info2) {
    var _a2;
    (_a2 = this.store).cache ?? (_a2.cache = /* @__PURE__ */ new Map());
    const resource = this.store.cache.get(id);
    if (!resource)
      return !info2 ? void 0 : new Resource(id, info2.size, {}, this.store.cache);
    if (info2)
      resource.size = info2.size;
    return resource;
  }
  getSync(id, offset, end) {
    const resource = this._cached(id);
    if (!resource)
      return;
    end ?? (end = resource.size);
    const missing = resource.missing(offset, end);
    for (const { start, end: end2 } of missing) {
      this.async(this.get(id, start, end2));
    }
    if (missing.length)
      throw withErrno("EAGAIN");
    const region = resource.regionAt(offset);
    if (!region) {
      warn("Missing cache region for " + id);
      return;
    }
    return region.data.subarray(offset - region.offset, end - region.offset);
  }
  setSync(id, data, offset) {
    this.async(this.set(id, data, offset));
  }
  removeSync(id) {
    this.async(this.remove(id));
    this.store.cache?.delete(id);
  }
};
__name(_AsyncTransaction, "AsyncTransaction");
let AsyncTransaction = _AsyncTransaction;
const _WrappedTransaction = class _WrappedTransaction {
  constructor(raw, fs2) {
    __publicField(this, "raw");
    __publicField(this, "fs");
    /**
     * Whether the transaction was committed or aborted
     */
    __publicField(this, "done", false);
    /**
     * Stores data in the keys we modify prior to modifying them.
     * Allows us to roll back commits.
     */
    __publicField(this, "originalData", /* @__PURE__ */ new Map());
    /**TransactionEntry
     * List of keys modified in this transaction, if any.
     */
    __publicField(this, "modifiedKeys", /* @__PURE__ */ new Set());
    this.raw = raw;
    this.fs = fs2;
  }
  flag(flag) {
    return this.raw.store.flags?.includes(flag) ?? false;
  }
  keys() {
    return this.raw.keys();
  }
  async get(id, offset = 0, end) {
    const data = await this.raw.get(id, offset, end);
    this.stash(id);
    return data;
  }
  getSync(id, offset = 0, end) {
    const data = this.raw.getSync(id, offset, end);
    this.stash(id);
    return data;
  }
  async set(id, view2, offset = 0) {
    await this.markModified(id, offset, view2.byteLength);
    const buffer2 = view2 instanceof Uint8Array ? view2 : new Uint8Array(view2.buffer, view2.byteOffset, view2.byteLength);
    await this.raw.set(id, buffer2, offset);
  }
  setSync(id, view2, offset = 0) {
    this.markModifiedSync(id, offset, view2.byteLength);
    const buffer2 = view2 instanceof Uint8Array ? view2 : new Uint8Array(view2.buffer, view2.byteOffset, view2.byteLength);
    this.raw.setSync(id, buffer2, offset);
  }
  async remove(id) {
    await this.markModified(id, 0, void 0);
    await this.raw.remove(id);
  }
  removeSync(id) {
    this.markModifiedSync(id, 0, void 0);
    this.raw.removeSync(id);
  }
  commit() {
    this.done = true;
    return Promise.resolve();
  }
  commitSync() {
    this.done = true;
  }
  async abort() {
    if (this.done)
      return;
    for (const [id, entries2] of this.originalData) {
      if (!this.modifiedKeys.has(id))
        continue;
      if (entries2.some((ent) => !ent.data)) {
        await this.raw.remove(id);
        this.fs._remove(id);
        continue;
      }
      for (const entry of entries2.reverse()) {
        await this.raw.set(id, entry.data, entry.offset);
      }
    }
    this.done = true;
  }
  abortSync() {
    if (this.done)
      return;
    for (const [id, entries2] of this.originalData) {
      if (!this.modifiedKeys.has(id))
        continue;
      if (entries2.some((ent) => !ent.data)) {
        this.raw.removeSync(id);
        this.fs._remove(id);
        continue;
      }
      for (const entry of entries2.reverse()) {
        this.raw.setSync(id, entry.data, entry.offset);
      }
    }
    this.done = true;
  }
  async [Symbol.asyncDispose]() {
    if (this.done)
      return;
    await this.abort();
  }
  [Symbol.dispose]() {
    if (this.done)
      return;
    this.abortSync();
  }
  /**
   * Stashes given key value pair into `originalData` if it doesn't already exist.
   * Allows us to stash values the program is requesting anyway to
   * prevent needless `get` requests if the program modifies the data later
   * on during the transaction.
   */
  stash(id, data, offset = 0) {
    if (!this.originalData.has(id))
      this.originalData.set(id, []);
    this.originalData.get(id).push({ data, offset });
  }
  /**
   * Marks an id as modified, and stashes its value if it has not been stashed already.
   */
  async markModified(id, offset, length) {
    this.modifiedKeys.add(id);
    const end = length ? offset + length : void 0;
    try {
      this.stash(id, await this.raw.get(id, offset, end), offset);
    } catch (e2) {
      if (!(this.raw instanceof AsyncTransaction))
        throw e2;
      const tx = this.raw;
      const resource = tx._cached(id);
      if (!resource)
        throw e2;
      for (const range2 of resource.cached(offset, end ?? offset)) {
        this.stash(id, await this.raw.get(id, range2.start, range2.end), range2.start);
      }
    }
  }
  /**
   * Marks an id as modified, and stashes its value if it has not been stashed already.
   */
  markModifiedSync(id, offset, length) {
    this.modifiedKeys.add(id);
    const end = length ? offset + length : void 0;
    try {
      this.stash(id, this.raw.getSync(id, offset, end), offset);
    } catch (e2) {
      if (!(this.raw instanceof AsyncTransaction))
        throw e2;
      const tx = this.raw;
      const resource = tx._cached(id);
      if (!resource)
        throw e2;
      for (const range2 of resource.cached(offset, end ?? offset)) {
        this.stash(id, this.raw.getSync(id, range2.start, range2.end), range2.start);
      }
    }
  }
};
__name(_WrappedTransaction, "WrappedTransaction");
let WrappedTransaction = _WrappedTransaction;
var __addDisposableResource$2 = function(env2, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = /* @__PURE__ */ __name(function() {
      try {
        inner.call(this);
      } catch (e2) {
        return Promise.reject(e2);
      }
    }, "dispose");
    env2.stack.push({ value, dispose, async });
  } else if (async) {
    env2.stack.push({ async: true });
  }
  return value;
};
var __disposeResources$2 = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    __name(fail, "fail");
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
          } else s |= 1;
        } catch (e2) {
          fail(e2);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    __name(next, "next");
    return next();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
const _StoreFS = class _StoreFS extends FileSystem {
  constructor(store) {
    super(store.type ?? 1802921587, store.name);
    __publicField(this, "store");
    /**
     * A map of paths to inode IDs
     * @internal @hidden
     */
    __publicField(this, "_ids", /* @__PURE__ */ new Map([["/", 0]]));
    /**
     * A map of inode IDs to paths
     * @internal @hidden
     */
    __publicField(this, "_paths", /* @__PURE__ */ new Map([[0, new Set("/")]]));
    __publicField(this, "_initialized", false);
    __publicField(this, "_lastID");
    this.store = store;
    store.fs = this;
    this._uuid = store.uuid ?? this.uuid;
    this.label = store.label;
    debug(this.name + ": supports features: " + this.store.flags?.join(", "));
  }
  /**
   * Gets the first path associated with an inode
   */
  _path(id) {
    const [path2] = this._paths.get(id) ?? [];
    return path2;
  }
  /**
   * Add a inode/path pair
   */
  _add(ino, path2) {
    if (!this._paths.has(ino))
      this._paths.set(ino, /* @__PURE__ */ new Set());
    this._paths.get(ino).add(path2);
    this._ids.set(path2, ino);
  }
  /**
   * Remove a inode/path pair
   */
  _remove(ino) {
    for (const path2 of this._paths.get(ino) ?? []) {
      this._ids.delete(path2);
    }
    this._paths.delete(ino);
  }
  /**
   * Move paths in the tables
   */
  _move(from, to) {
    const toMove = [];
    for (const [path2, ino] of this._ids) {
      const rel = relative(from, path2);
      if (rel.startsWith(".."))
        continue;
      let newKey = join(to, rel);
      if (newKey.endsWith("/"))
        newKey = newKey.slice(0, -1);
      toMove.push({ oldKey: path2, newKey, ino });
    }
    for (const { oldKey, newKey, ino } of toMove) {
      this._ids.delete(oldKey);
      this._ids.set(newKey, ino);
      const p = this._paths.get(ino);
      if (!p) {
        warn("Missing paths in table for ino " + ino);
        continue;
      }
      p.delete(oldKey);
      p.add(newKey);
    }
  }
  async ready() {
    if (this._initialized)
      return;
    if (!this.attributes.has("no_async_preload")) {
      this.checkRootSync();
    }
    await this.checkRoot();
    await this._populate();
    this._initialized = true;
  }
  /**
   * @experimental
   */
  usage() {
    return this.store.usage?.() || {
      totalSpace: 0,
      freeSpace: 0
    };
  }
  /**
   * Load an index into the StoreFS.
   * You *must* manually add non-directory files
   */
  async loadIndex(index) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_1, this.transaction(), true);
      const dirs = index.directories();
      for (const [path2, inode] of index) {
        this._add(inode.ino, path2);
        await tx.set(inode.ino, inode);
        if (dirs.has(path2))
          await tx.set(inode.data, encodeDirListing(dirs.get(path2)));
      }
      await tx.commit();
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      const result_1 = __disposeResources$2(env_1);
      if (result_1)
        await result_1;
    }
  }
  /**
   * Load an index into the StoreFS.
   * You *must* manually add non-directory files
   */
  loadIndexSync(index) {
    const env_2 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_2, this.transaction(), false);
      const dirs = index.directories();
      for (const [path2, inode] of index) {
        this._add(inode.ino, path2);
        tx.setSync(inode.ino, inode);
        if (dirs.has(path2))
          tx.setSync(inode.data, encodeDirListing(dirs.get(path2)));
      }
      tx.commitSync();
    } catch (e_2) {
      env_2.error = e_2;
      env_2.hasError = true;
    } finally {
      __disposeResources$2(env_2);
    }
  }
  async createIndex() {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
      const index = new Index();
      const tx = __addDisposableResource$2(env_3, this.transaction(), true);
      const queue2 = [["/", 0]];
      const silence = canary(withErrno("EDEADLK"));
      while (queue2.length) {
        const [path2, ino] = queue2.shift();
        const inode = new Inode(await tx.get(ino));
        index.set(path2, inode);
        if (inode.mode & S_IFDIR) {
          const dir = decodeDirListing(await tx.get(inode.data) ?? _throw(withErrno("ENODATA")));
          for (const [name, id] of Object.entries(dir)) {
            queue2.push([join(path2, name), id]);
          }
        }
      }
      silence();
      return index;
    } catch (e_3) {
      env_3.error = e_3;
      env_3.hasError = true;
    } finally {
      const result_2 = __disposeResources$2(env_3);
      if (result_2)
        await result_2;
    }
  }
  createIndexSync() {
    const env_4 = { stack: [], error: void 0, hasError: false };
    try {
      const index = new Index();
      const tx = __addDisposableResource$2(env_4, this.transaction(), false);
      const queue2 = [["/", 0]];
      const silence = canary(withErrno("EDEADLK"));
      while (queue2.length) {
        const [path2, ino] = queue2.shift();
        const inode = new Inode(tx.getSync(ino));
        index.set(path2, inode);
        if (inode.mode & S_IFDIR) {
          const dir = decodeDirListing(tx.getSync(inode.data) ?? _throw(withErrno("ENODATA")));
          for (const [name, id] of Object.entries(dir)) {
            queue2.push([join(path2, name), id]);
          }
        }
      }
      silence();
      return index;
    } catch (e_4) {
      env_4.error = e_4;
      env_4.hasError = true;
    } finally {
      __disposeResources$2(env_4);
    }
  }
  /**
   * @todo Make rename compatible with the cache.
   */
  async rename(oldPath, newPath) {
    const env_5 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_5, this.transaction(), true);
      const _old = parse$3(oldPath), _new = parse$3(newPath), oldDirNode = await this.findInode(tx, _old.dir), oldDirList = decodeDirListing(await tx.get(oldDirNode.data) ?? _throw(withErrno("ENODATA")));
      if (!oldDirList[_old.base])
        throw withErrno("ENOENT");
      const ino = oldDirList[_old.base];
      if (ino != this._ids.get(oldPath))
        err$1(`Ino mismatch while renaming ${oldPath} to ${newPath}`);
      delete oldDirList[_old.base];
      if ((_new.dir + "/").startsWith(oldPath + "/"))
        throw withErrno("EBUSY");
      const sameParent = _new.dir == _old.dir;
      const newDirNode = sameParent ? oldDirNode : await this.findInode(tx, _new.dir);
      const newDirList = sameParent ? oldDirList : decodeDirListing(await tx.get(newDirNode.data) ?? _throw(withErrno("ENODATA")));
      if (newDirList[_new.base]) {
        const existing = new Inode(await tx.get(newDirList[_new.base]) ?? _throw(withErrno("ENOENT")));
        if (!isFile(existing))
          throw withErrno("EISDIR");
        await tx.remove(existing.data);
        await tx.remove(newDirList[_new.base]);
      }
      newDirList[_new.base] = ino;
      await tx.set(oldDirNode.data, encodeDirListing(oldDirList));
      await tx.set(newDirNode.data, encodeDirListing(newDirList));
      await tx.commit();
      this._move(oldPath, newPath);
    } catch (e_5) {
      env_5.error = e_5;
      env_5.hasError = true;
    } finally {
      const result_3 = __disposeResources$2(env_5);
      if (result_3)
        await result_3;
    }
  }
  renameSync(oldPath, newPath) {
    const env_6 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_6, this.transaction(), false);
      const _old = parse$3(oldPath), _new = parse$3(newPath), oldDirNode = this.findInodeSync(tx, _old.dir), oldDirList = decodeDirListing(tx.getSync(oldDirNode.data) ?? _throw(withErrno("ENODATA")));
      if (!oldDirList[_old.base])
        throw withErrno("ENOENT");
      const ino = oldDirList[_old.base];
      if (ino != this._ids.get(oldPath))
        err$1(`Ino mismatch while renaming ${oldPath} to ${newPath}`);
      delete oldDirList[_old.base];
      if ((_new.dir + "/").startsWith(oldPath + "/"))
        throw withErrno("EBUSY");
      const sameParent = _new.dir === _old.dir;
      const newDirNode = sameParent ? oldDirNode : this.findInodeSync(tx, _new.dir);
      const newDirList = sameParent ? oldDirList : decodeDirListing(tx.getSync(newDirNode.data) ?? _throw(withErrno("ENODATA")));
      if (newDirList[_new.base]) {
        const existing = new Inode(tx.getSync(newDirList[_new.base]) ?? _throw(withErrno("ENOENT")));
        if (!isFile(existing))
          throw withErrno("EISDIR");
        tx.removeSync(existing.data);
        tx.removeSync(newDirList[_new.base]);
      }
      newDirList[_new.base] = ino;
      tx.setSync(oldDirNode.data, encodeDirListing(oldDirList));
      tx.setSync(newDirNode.data, encodeDirListing(newDirList));
      tx.commitSync();
      this._move(oldPath, newPath);
    } catch (e_6) {
      env_6.error = e_6;
      env_6.hasError = true;
    } finally {
      __disposeResources$2(env_6);
    }
  }
  async stat(path2) {
    const env_7 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_7, this.transaction(), true);
      return await this.findInode(tx, path2);
    } catch (e_7) {
      env_7.error = e_7;
      env_7.hasError = true;
    } finally {
      const result_4 = __disposeResources$2(env_7);
      if (result_4)
        await result_4;
    }
  }
  statSync(path2) {
    const env_8 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_8, this.transaction(), false);
      return this.findInodeSync(tx, path2);
    } catch (e_8) {
      env_8.error = e_8;
      env_8.hasError = true;
    } finally {
      __disposeResources$2(env_8);
    }
  }
  async touch(path2, metadata) {
    const env_9 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_9, this.transaction(), true);
      const inode = await this.findInode(tx, path2);
      if (inode.update(metadata)) {
        this._add(inode.ino, path2);
        tx.setSync(inode.ino, inode);
      }
      await tx.commit();
    } catch (e_9) {
      env_9.error = e_9;
      env_9.hasError = true;
    } finally {
      const result_5 = __disposeResources$2(env_9);
      if (result_5)
        await result_5;
    }
  }
  touchSync(path2, metadata) {
    const env_10 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_10, this.transaction(), false);
      const inode = this.findInodeSync(tx, path2);
      if (inode.update(metadata)) {
        this._add(inode.ino, path2);
        tx.setSync(inode.ino, inode);
      }
      tx.commitSync();
    } catch (e_10) {
      env_10.error = e_10;
      env_10.hasError = true;
    } finally {
      __disposeResources$2(env_10);
    }
  }
  async createFile(path2, options) {
    options.mode |= S_IFREG;
    return await this.commitNew(path2, options, new Uint8Array());
  }
  createFileSync(path2, options) {
    options.mode |= S_IFREG;
    return this.commitNewSync(path2, options, new Uint8Array());
  }
  async unlink(path2) {
    return this.remove(path2, false);
  }
  unlinkSync(path2) {
    this.removeSync(path2, false);
  }
  async rmdir(path2) {
    if ((await this.readdir(path2)).length)
      throw withErrno("ENOTEMPTY");
    await this.remove(path2, true);
  }
  rmdirSync(path2) {
    if (this.readdirSync(path2).length)
      throw withErrno("ENOTEMPTY");
    this.removeSync(path2, true);
  }
  async mkdir(path2, options) {
    options.mode |= S_IFDIR;
    return await this.commitNew(path2, options, encodeUTF8("{}"));
  }
  mkdirSync(path2, options) {
    options.mode |= S_IFDIR;
    return this.commitNewSync(path2, options, encodeUTF8("{}"));
  }
  async readdir(path2) {
    const env_11 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_11, this.transaction(), true);
      const node = await this.findInode(tx, path2);
      return Object.keys(decodeDirListing(await tx.get(node.data) ?? _throw(withErrno("ENOENT"))));
    } catch (e_11) {
      env_11.error = e_11;
      env_11.hasError = true;
    } finally {
      const result_6 = __disposeResources$2(env_11);
      if (result_6)
        await result_6;
    }
  }
  readdirSync(path2) {
    const env_12 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_12, this.transaction(), false);
      const node = this.findInodeSync(tx, path2);
      return Object.keys(decodeDirListing(tx.getSync(node.data) ?? _throw(withErrno("ENOENT"))));
    } catch (e_12) {
      env_12.error = e_12;
      env_12.hasError = true;
    } finally {
      __disposeResources$2(env_12);
    }
  }
  /**
   * Updated the inode and data node at `path`
   */
  async sync() {
  }
  /**
   * Updated the inode and data node at `path`
   */
  syncSync() {
  }
  async link(target, link2) {
    const env_13 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_13, this.transaction(), true);
      const newDir = dirname(link2), newDirNode = await this.findInode(tx, newDir), listing = decodeDirListing(await tx.get(newDirNode.data) ?? _throw(withErrno("ENOENT")));
      const inode = await this.findInode(tx, target);
      inode.nlink++;
      listing[basename(link2)] = inode.ino;
      this._add(inode.ino, link2);
      await tx.set(inode.ino, inode);
      await tx.set(newDirNode.data, encodeDirListing(listing));
      await tx.commit();
    } catch (e_13) {
      env_13.error = e_13;
      env_13.hasError = true;
    } finally {
      const result_7 = __disposeResources$2(env_13);
      if (result_7)
        await result_7;
    }
  }
  linkSync(target, link2) {
    const env_14 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_14, this.transaction(), false);
      const newDir = dirname(link2), newDirNode = this.findInodeSync(tx, newDir), listing = decodeDirListing(tx.getSync(newDirNode.data) ?? _throw(withErrno("ENOENT")));
      const inode = this.findInodeSync(tx, target);
      inode.nlink++;
      listing[basename(link2)] = inode.ino;
      this._add(inode.ino, link2);
      tx.setSync(inode.ino, inode);
      tx.setSync(newDirNode.data, encodeDirListing(listing));
      tx.commitSync();
    } catch (e_14) {
      env_14.error = e_14;
      env_14.hasError = true;
    } finally {
      __disposeResources$2(env_14);
    }
  }
  async read(path2, buffer2, offset, end) {
    const env_15 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_15, this.transaction(), true);
      const inode = await this.findInode(tx, path2);
      if (inode.size == 0)
        return;
      const data = await tx.get(inode.data, offset, end) ?? _throw(withErrno("ENODATA"));
      const _ = tx.flag("partial") ? data : data.subarray(offset, end);
      if (_.byteLength > buffer2.byteLength)
        err$1(`Trying to place ${_.byteLength} bytes into a ${buffer2.byteLength} byte buffer on read`);
      buffer2.set(_);
    } catch (e_15) {
      env_15.error = e_15;
      env_15.hasError = true;
    } finally {
      const result_8 = __disposeResources$2(env_15);
      if (result_8)
        await result_8;
    }
  }
  readSync(path2, buffer2, offset, end) {
    const env_16 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_16, this.transaction(), false);
      const inode = this.findInodeSync(tx, path2);
      if (inode.size == 0)
        return;
      const data = tx.getSync(inode.data, offset, end) ?? _throw(withErrno("ENODATA"));
      const _ = tx.flag("partial") ? data : data.subarray(offset, end);
      if (_.byteLength > buffer2.byteLength)
        err$1(`Trying to place ${_.byteLength} bytes into a ${buffer2.byteLength} byte buffer on read`);
      buffer2.set(_);
    } catch (e_16) {
      env_16.error = e_16;
      env_16.hasError = true;
    } finally {
      __disposeResources$2(env_16);
    }
  }
  async write(path2, data, offset) {
    const env_17 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_17, this.transaction(), true);
      const inode = await this.findInode(tx, path2);
      let buffer2 = data;
      if (!tx.flag("partial")) {
        buffer2 = extendBuffer(await tx.get(inode.data) ?? new Uint8Array(), offset + data.byteLength);
        buffer2.set(data, offset);
        offset = 0;
      }
      await tx.set(inode.data, buffer2, offset);
      this._add(inode.ino, path2);
      await tx.commit();
    } catch (e_17) {
      env_17.error = e_17;
      env_17.hasError = true;
    } finally {
      const result_9 = __disposeResources$2(env_17);
      if (result_9)
        await result_9;
    }
  }
  writeSync(path2, data, offset) {
    const env_18 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_18, this.transaction(), false);
      const inode = this.findInodeSync(tx, path2);
      let buffer2 = data;
      if (!tx.flag("partial")) {
        buffer2 = extendBuffer(tx.getSync(inode.data) ?? new Uint8Array(), offset + data.byteLength);
        buffer2.set(data, offset);
        offset = 0;
      }
      tx.setSync(inode.data, buffer2, offset);
      this._add(inode.ino, path2);
      tx.commitSync();
    } catch (e_18) {
      env_18.error = e_18;
      env_18.hasError = true;
    } finally {
      __disposeResources$2(env_18);
    }
  }
  /**
   * Wraps a transaction
   * @internal @hidden
   */
  transaction() {
    return new WrappedTransaction(this.store.transaction(), this);
  }
  /**
   * Checks if the root directory exists. Creates it if it doesn't.
   */
  async checkRoot() {
    const env_19 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_19, this.transaction(), true);
      if (await tx.get(rootIno))
        return;
      const inode = new Inode({ ino: rootIno, data: 1, mode: 511 | S_IFDIR });
      await tx.set(inode.data, encodeUTF8("{}"));
      this._add(rootIno, "/");
      await tx.set(rootIno, inode);
      await tx.commit();
    } catch (e_19) {
      env_19.error = e_19;
      env_19.hasError = true;
    } finally {
      const result_10 = __disposeResources$2(env_19);
      if (result_10)
        await result_10;
    }
  }
  /**
   * Checks if the root directory exists. Creates it if it doesn't.
   */
  checkRootSync() {
    const env_20 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_20, this.transaction(), false);
      if (tx.getSync(rootIno))
        return;
      const inode = new Inode({ ino: rootIno, data: 1, mode: 511 | S_IFDIR });
      tx.setSync(inode.data, encodeUTF8("{}"));
      this._add(rootIno, "/");
      tx.setSync(rootIno, inode);
      tx.commitSync();
    } catch (e_20) {
      env_20.error = e_20;
      env_20.hasError = true;
    } finally {
      __disposeResources$2(env_20);
    }
  }
  /**
   * Populates the `_ids` and `_paths` maps with all existing files stored in the underlying `Store`.
   */
  async _populate() {
    const env_21 = { stack: [], error: void 0, hasError: false };
    try {
      if (this._initialized) {
        warn("Attempted to populate tables after initialization");
        return;
      }
      debug("Populating tables with existing store metadata");
      const tx = __addDisposableResource$2(env_21, this.transaction(), true);
      const rootData = await tx.get(rootIno);
      if (!rootData) {
        notice("Store does not have a root inode");
        const inode = new Inode({ ino: rootIno, data: 1, mode: 511 | S_IFDIR });
        await tx.set(inode.data, encodeUTF8("{}"));
        this._add(rootIno, "/");
        await tx.set(rootIno, inode);
        await tx.commit();
        return;
      }
      if (rootData.length < sizeof(Inode)) {
        crit("Store contains an invalid root inode. Refusing to populate tables");
        return;
      }
      const visitedDirectories = /* @__PURE__ */ new Set();
      let i = 0;
      const queue2 = [["/", rootIno]];
      while (queue2.length > 0) {
        i++;
        const [path2, ino] = queue2.shift();
        this._add(ino, path2);
        const inodeData = await tx.get(ino);
        if (!inodeData) {
          warn("Store is missing data for inode: " + ino);
          continue;
        }
        if (inodeData.length < sizeof(Inode)) {
          warn(`Invalid inode size for ino ${ino}: ${inodeData.length}`);
          continue;
        }
        const inode = new Inode(inodeData);
        if ((inode.mode & S_IFDIR) != S_IFDIR || visitedDirectories.has(ino)) {
          continue;
        }
        visitedDirectories.add(ino);
        const dirData = await tx.get(inode.data);
        if (!dirData) {
          warn("Store is missing directory data: " + inode.data);
          continue;
        }
        const dirListing = decodeDirListing(dirData);
        for (const [entryName, childIno] of Object.entries(dirListing)) {
          queue2.push([join(path2, entryName), childIno]);
        }
      }
      debug(`Added ${i} existing inode(s) from store`);
    } catch (e_21) {
      env_21.error = e_21;
      env_21.hasError = true;
    } finally {
      const result_11 = __disposeResources$2(env_21);
      if (result_11)
        await result_11;
    }
  }
  /**
   * Find an inode without using the ID tables
   */
  async _findInode(tx, path2, visited = /* @__PURE__ */ new Set()) {
    if (visited.has(path2))
      throw crit(withErrno("EIO", "Infinite loop detected while finding inode"));
    visited.add(path2);
    if (path2 == "/")
      return new Inode(await tx.get(rootIno) ?? _throw(withErrno("ENODATA")));
    const { dir: parent, base: filename } = parse$3(path2);
    const inode = await this._findInode(tx, parent, visited);
    const dirList = decodeDirListing(await tx.get(inode.data) ?? _throw(withErrno("ENODATA")));
    if (!(filename in dirList))
      throw withErrno("ENOENT");
    return new Inode(await tx.get(dirList[filename]) ?? _throw(withErrno("ENODATA")));
  }
  /**
   * Find an inode without using the ID tables
   */
  _findInodeSync(tx, path2, visited = /* @__PURE__ */ new Set()) {
    if (visited.has(path2))
      throw crit(withErrno("EIO", "Infinite loop detected while finding inode"));
    visited.add(path2);
    if (path2 == "/")
      return new Inode(tx.getSync(rootIno) ?? _throw(withErrno("ENOENT")));
    const { dir: parent, base: filename } = parse$3(path2);
    const inode = this._findInodeSync(tx, parent, visited);
    const dir = decodeDirListing(tx.getSync(inode.data) ?? _throw(withErrno("ENODATA")));
    if (!(filename in dir))
      throw withErrno("ENOENT");
    return new Inode(tx.getSync(dir[filename]) ?? _throw(withErrno("ENODATA")));
  }
  /**
   * Finds the Inode of `path`.
   * @param path The path to look up.
   * @todo memoize/cache
   */
  async findInode(tx, path2) {
    if (this.attributes.has("no_id_tables"))
      return await this._findInode(tx, path2);
    const ino = this._ids.get(path2);
    if (ino === void 0)
      throw withErrno("ENOENT");
    return new Inode(await tx.get(ino) ?? _throw(withErrno("ENOENT")));
  }
  /**
   * Finds the Inode of `path`.
   * @param path The path to look up.
   * @return The Inode of the path p.
   * @todo memoize/cache
   */
  findInodeSync(tx, path2) {
    if (this.attributes.has("no_id_tables"))
      return this._findInodeSync(tx, path2);
    const ino = this._ids.get(path2);
    if (ino === void 0)
      throw withErrno("ENOENT");
    return new Inode(tx.getSync(ino) ?? _throw(withErrno("ENOENT")));
  }
  /** Allocates a new ID and adds the ID/path */
  allocNew(path2) {
    this._lastID ?? (this._lastID = Math.max(...this._paths.keys()));
    this._lastID += 2;
    const id = this._lastID;
    if (id > size_max)
      throw err$1(withErrno("ENOSPC", "No IDs available"));
    this._add(id, path2);
    return id;
  }
  /**
   * Commits a new file (well, a FILE or a DIRECTORY) to the file system with `mode`.
   * Note: This will commit the transaction.
   * @param path The path to the new file.
   * @param options The options to create the new file with.
   * @param data The data to store at the file's data node.
   */
  async commitNew(path2, options, data) {
    const env_22 = { stack: [], error: void 0, hasError: false };
    try {
      if (path2 == "/")
        throw withErrno("EEXIST");
      const tx = __addDisposableResource$2(env_22, this.transaction(), true);
      const { dir: parentPath, base: fname } = parse$3(path2);
      const parent = await this.findInode(tx, parentPath);
      const listing = decodeDirListing(await tx.get(parent.data) ?? _throw(withErrno("ENOENT")));
      if (listing[fname])
        throw withErrno("EEXIST");
      const id = this.allocNew(path2);
      const inode = new Inode({
        ...options,
        ino: id,
        data: id + 1,
        size: data.byteLength,
        nlink: 1
      });
      await tx.set(inode.ino, inode);
      await tx.set(inode.data, data);
      listing[fname] = inode.ino;
      await tx.set(parent.data, encodeDirListing(listing));
      await tx.commit();
      return inode;
    } catch (e_22) {
      env_22.error = e_22;
      env_22.hasError = true;
    } finally {
      const result_12 = __disposeResources$2(env_22);
      if (result_12)
        await result_12;
    }
  }
  /**
   * Commits a new file (well, a FILE or a DIRECTORY) to the file system with `mode`.
   * Note: This will commit the transaction.
   * @param path The path to the new file.
   * @param options The options to create the new file with.
   * @param data The data to store at the file's data node.
   * @return The Inode for the new file.
   */
  commitNewSync(path2, options, data) {
    const env_23 = { stack: [], error: void 0, hasError: false };
    try {
      if (path2 == "/")
        throw withErrno("EEXIST");
      const tx = __addDisposableResource$2(env_23, this.transaction(), false);
      const { dir: parentPath, base: fname } = parse$3(path2);
      const parent = this.findInodeSync(tx, parentPath);
      const listing = decodeDirListing(tx.getSync(parent.data) ?? _throw(withErrno("ENOENT")));
      if (listing[fname])
        throw withErrno("EEXIST");
      const id = this.allocNew(path2);
      const inode = new Inode({
        ...options,
        ino: id,
        data: id + 1,
        size: data.byteLength,
        nlink: 1
      });
      tx.setSync(inode.ino, inode);
      tx.setSync(inode.data, data);
      listing[fname] = inode.ino;
      tx.setSync(parent.data, encodeDirListing(listing));
      tx.commitSync();
      return inode;
    } catch (e_23) {
      env_23.error = e_23;
      env_23.hasError = true;
    } finally {
      __disposeResources$2(env_23);
    }
  }
  /**
   * Remove all traces of `path` from the file system.
   * @param path The path to remove from the file system.
   * @param isDir Does the path belong to a directory, or a file?
   */
  async remove(path2, isDir) {
    const env_24 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_24, this.transaction(), true);
      const { dir: parent, base: fileName } = parse$3(path2), parentNode = await this.findInode(tx, parent), listing = decodeDirListing(await tx.get(parentNode.data) ?? _throw(withErrno("ENOENT")));
      if (!listing[fileName])
        throw withErrno("ENOENT");
      const ino = listing[fileName];
      const inode = new Inode(await tx.get(ino) ?? _throw(withErrno("ENOENT")));
      delete listing[fileName];
      if (!isDir && isDirectory(inode))
        throw withErrno("EISDIR");
      await tx.set(parentNode.data, encodeDirListing(listing));
      if (inode.nlink > 1) {
        inode.update({ nlink: inode.nlink - 1 });
        await tx.set(inode.ino, inode);
      } else {
        await tx.remove(inode.data);
        await tx.remove(ino);
        this._remove(ino);
      }
      await tx.commit();
    } catch (e_24) {
      env_24.error = e_24;
      env_24.hasError = true;
    } finally {
      const result_13 = __disposeResources$2(env_24);
      if (result_13)
        await result_13;
    }
  }
  /**
   * Remove all traces of `path` from the file system.
   * @param path The path to remove from the file system.
   * @param isDir Does the path belong to a directory, or a file?
   */
  removeSync(path2, isDir) {
    const env_25 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource$2(env_25, this.transaction(), false);
      const { dir: parent, base: fileName } = parse$3(path2), parentNode = this.findInodeSync(tx, parent), listing = decodeDirListing(tx.getSync(parentNode.data) ?? _throw(withErrno("ENOENT"))), ino = listing[fileName];
      if (!ino)
        throw withErrno("ENOENT");
      const inode = new Inode(tx.getSync(ino) ?? _throw(withErrno("ENOENT")));
      delete listing[fileName];
      if (!isDir && isDirectory(inode))
        throw withErrno("EISDIR");
      tx.setSync(parentNode.data, encodeDirListing(listing));
      if (inode.nlink > 1) {
        inode.update({ nlink: inode.nlink - 1 });
        tx.setSync(inode.ino, inode);
      } else {
        tx.removeSync(inode.data);
        tx.removeSync(ino);
        this._remove(ino);
      }
      tx.commitSync();
    } catch (e_25) {
      env_25.error = e_25;
      env_25.hasError = true;
    } finally {
      __disposeResources$2(env_25);
    }
  }
};
__name(_StoreFS, "StoreFS");
let StoreFS = _StoreFS;
const _SyncMapTransaction = class _SyncMapTransaction extends SyncTransaction {
  // eslint-disable-next-line @typescript-eslint/require-await
  async keys() {
    return this.store.keys();
  }
  async get(id) {
    return await (this.store.getAsync?.(id) ?? this.store.get(id));
  }
  getSync(id) {
    return this.store.get(id);
  }
  setSync(id, data) {
    this.store.set(id, data);
  }
  removeSync(id) {
    this.store.delete(id);
  }
};
__name(_SyncMapTransaction, "SyncMapTransaction");
let SyncMapTransaction = _SyncMapTransaction;
const _InMemoryStore = class _InMemoryStore extends Map {
  constructor(maxSize = size_max, label) {
    super();
    __publicField(this, "maxSize");
    __publicField(this, "label");
    __publicField(this, "flags", []);
    __publicField(this, "name", "tmpfs");
    this.maxSize = maxSize;
    this.label = label;
  }
  async sync() {
  }
  transaction() {
    return new SyncMapTransaction(this);
  }
  get bytes() {
    let size = this.size * 4;
    for (const data of this.values())
      size += data.byteLength;
    return size;
  }
  usage() {
    return {
      totalSpace: this.maxSize,
      freeSpace: this.maxSize - this.bytes
    };
  }
};
__name(_InMemoryStore, "InMemoryStore");
let InMemoryStore = _InMemoryStore;
const _InMemory = {
  name: "InMemory",
  options: {
    maxSize: { type: "number", required: false },
    label: { type: "string", required: false }
  },
  create({ maxSize, label }) {
    const fs2 = new StoreFS(new InMemoryStore(maxSize, label));
    fs2.checkRootSync();
    return fs2;
  }
};
const InMemory = _InMemory;
const _DeviceFS = class _DeviceFS extends StoreFS {
  constructor() {
    super(new InMemoryStore(16777216, "devfs"));
    __publicField(this, "devices", /* @__PURE__ */ new Map());
  }
  devicesWithDriver(driver, forceIdentity) {
    if (forceIdentity && typeof driver == "string") {
      throw err$1(withErrno("EINVAL", "Can not fetch devices using only a driver name"));
    }
    const devs = [];
    for (const device of this.devices.values()) {
      if (forceIdentity && device.driver != driver)
        continue;
      const name = typeof driver == "string" ? driver : driver.name;
      if (name == device.driver.name)
        devs.push(device);
    }
    return devs;
  }
  /**
   * @internal
   */
  _createDevice(driver, options = {}) {
    let ino = 1;
    const lastDev = Array.from(this.devices.values()).at(-1);
    while (this.store.has(ino) || lastDev?.inode.ino == ino)
      ino++;
    const init2 = driver.init?.(ino, options);
    const dev = {
      data: {},
      minor: 0,
      major: 0,
      ...omit(init2 ?? {}, "metadata"),
      driver,
      inode: new Inode({
        mode: S_IFCHR | 438,
        ...init2?.metadata
      })
    };
    const path2 = "/" + (dev.name || driver.name) + (driver.singleton ? "" : this.devicesWithDriver(driver).length);
    if (this.existsSync(path2))
      throw withErrno("EEXIST");
    this.devices.set(path2, dev);
    info("Initialized device: " + this._mountPoint + path2);
    return dev;
  }
  /**
   * Adds default devices
   */
  addDefaults() {
    this._createDevice(nullDevice);
    this._createDevice(zeroDevice);
    this._createDevice(fullDevice);
    this._createDevice(randomDevice);
    this._createDevice(consoleDevice);
    debug("Added default devices");
  }
  async rename(oldPath, newPath) {
    if (this.devices.has(oldPath))
      throw withErrno("EPERM");
    if (this.devices.has(newPath))
      throw withErrno("EEXIST");
    return super.rename(oldPath, newPath);
  }
  renameSync(oldPath, newPath) {
    if (this.devices.has(oldPath))
      throw withErrno("EPERM");
    if (this.devices.has(newPath))
      throw withErrno("EEXIST");
    return super.renameSync(oldPath, newPath);
  }
  async stat(path2) {
    const dev = this.devices.get(path2);
    if (dev)
      return dev.inode;
    return super.stat(path2);
  }
  statSync(path2) {
    const dev = this.devices.get(path2);
    if (dev)
      return dev.inode;
    return super.statSync(path2);
  }
  async touch(path2, metadata) {
    const dev = this.devices.get(path2);
    if (dev)
      dev.inode.update(metadata);
    else
      await super.touch(path2, metadata);
  }
  touchSync(path2, metadata) {
    const dev = this.devices.get(path2);
    if (dev)
      dev.inode.update(metadata);
    else
      super.touchSync(path2, metadata);
  }
  async createFile(path2, options) {
    if (this.devices.has(path2))
      throw withErrno("EEXIST");
    return super.createFile(path2, options);
  }
  createFileSync(path2, options) {
    if (this.devices.has(path2))
      throw withErrno("EEXIST");
    return super.createFileSync(path2, options);
  }
  async unlink(path2) {
    if (this.devices.has(path2))
      throw withErrno("EPERM");
    return super.unlink(path2);
  }
  unlinkSync(path2) {
    if (this.devices.has(path2))
      throw withErrno("EPERM");
    return super.unlinkSync(path2);
  }
  async rmdir(path2) {
    return super.rmdir(path2);
  }
  rmdirSync(path2) {
    return super.rmdirSync(path2);
  }
  async mkdir(path2, options) {
    if (this.devices.has(path2))
      throw withErrno("EEXIST");
    return super.mkdir(path2, options);
  }
  mkdirSync(path2, options) {
    if (this.devices.has(path2))
      throw withErrno("EEXIST");
    return super.mkdirSync(path2, options);
  }
  async readdir(path2) {
    const entries2 = await super.readdir(path2);
    for (const dev of this.devices.keys()) {
      if (dirname(dev) == path2) {
        entries2.push(basename(dev));
      }
    }
    return entries2;
  }
  readdirSync(path2) {
    const entries2 = super.readdirSync(path2);
    for (const dev of this.devices.keys()) {
      if (dirname(dev) == path2) {
        entries2.push(basename(dev));
      }
    }
    return entries2;
  }
  async link(target, link2) {
    if (this.devices.has(target))
      throw withErrno("EPERM");
    if (this.devices.has(link2))
      throw withErrno("EEXIST");
    return super.link(target, link2);
  }
  linkSync(target, link2) {
    if (this.devices.has(target))
      throw withErrno("EPERM");
    if (this.devices.has(link2))
      throw withErrno("EEXIST");
    return super.linkSync(target, link2);
  }
  async sync() {
    for (const device of this.devices.values()) {
      device.driver.sync?.(device);
    }
    return super.sync();
  }
  syncSync() {
    for (const device of this.devices.values()) {
      device.driver.sync?.(device);
    }
    return super.syncSync();
  }
  async read(path2, buffer2, offset, end) {
    const device = this.devices.get(path2);
    if (!device) {
      await super.read(path2, buffer2, offset, end);
      return;
    }
    device.driver.read(device, buffer2, offset, end);
  }
  readSync(path2, buffer2, offset, end) {
    const device = this.devices.get(path2);
    if (!device) {
      super.readSync(path2, buffer2, offset, end);
      return;
    }
    device.driver.read(device, buffer2, offset, end);
  }
  async write(path2, data, offset) {
    const device = this.devices.get(path2);
    if (!device) {
      return await super.write(path2, data, offset);
    }
    device.driver.write(device, data, offset);
  }
  writeSync(path2, data, offset) {
    const device = this.devices.get(path2);
    if (!device) {
      return super.writeSync(path2, data, offset);
    }
    device.driver.write(device, data, offset);
  }
};
__name(_DeviceFS, "DeviceFS");
let DeviceFS = _DeviceFS;
const emptyBuffer = new Uint8Array();
const nullDevice = {
  name: "null",
  singleton: true,
  init() {
    return { major: 1, minor: 3 };
  },
  read() {
    return emptyBuffer;
  },
  write() {
    return;
  }
};
const zeroDevice = {
  name: "zero",
  singleton: true,
  init() {
    return { major: 1, minor: 5 };
  },
  read(device, buffer2, offset, end) {
    buffer2.fill(0, offset, end);
  },
  write() {
    return;
  }
};
const fullDevice = {
  name: "full",
  singleton: true,
  init() {
    return { major: 1, minor: 7 };
  },
  read(device, buffer2, offset, end) {
    buffer2.fill(0, offset, end);
  },
  write() {
    throw withErrno("ENOSPC");
  }
};
const randomDevice = {
  name: "random",
  singleton: true,
  init() {
    return { major: 1, minor: 8 };
  },
  read(device, buffer2) {
    for (let i = 0; i < buffer2.length; i++) {
      buffer2[i] = Math.floor(Math.random() * 256);
    }
  },
  write() {
    return;
  }
};
const consoleDevice = {
  name: "console",
  singleton: true,
  init(ino, { output: output2 = /* @__PURE__ */ __name((text) => console.log(text), "output") } = {}) {
    return { major: 5, minor: 1, data: { output: output2 } };
  },
  read() {
    return emptyBuffer;
  },
  write(device, buffer2, offset) {
    const text = decodeUTF8(buffer2);
    device.data.output(text, offset);
  }
};
var buffer$1 = {};
var base64Js$1 = {};
var hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js$1;
  hasRequiredBase64Js = 1;
  base64Js$1.byteLength = byteLength2;
  base64Js$1.toByteArray = toByteArray2;
  base64Js$1.fromByteArray = fromByteArray2;
  var lookup2 = [];
  var revLookup2 = [];
  var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code2.length; i < len; ++i) {
    lookup2[i] = code2[i];
    revLookup2[code2.charCodeAt(i)] = i;
  }
  revLookup2["-".charCodeAt(0)] = 62;
  revLookup2["_".charCodeAt(0)] = 63;
  function getLens2(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  __name(getLens2, "getLens");
  function byteLength2(b64) {
    var lens = getLens2(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  __name(byteLength2, "byteLength");
  function _byteLength2(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  __name(_byteLength2, "_byteLength");
  function toByteArray2(b64) {
    var tmp;
    var lens = getLens2(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr2(_byteLength2(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup2[b64.charCodeAt(i2)] << 18 | revLookup2[b64.charCodeAt(i2 + 1)] << 12 | revLookup2[b64.charCodeAt(i2 + 2)] << 6 | revLookup2[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup2[b64.charCodeAt(i2)] << 2 | revLookup2[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup2[b64.charCodeAt(i2)] << 10 | revLookup2[b64.charCodeAt(i2 + 1)] << 4 | revLookup2[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  __name(toByteArray2, "toByteArray");
  function tripletToBase642(num) {
    return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
  }
  __name(tripletToBase642, "tripletToBase64");
  function encodeChunk2(uint82, start, end) {
    var tmp;
    var output2 = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint82[i2] << 16 & 16711680) + (uint82[i2 + 1] << 8 & 65280) + (uint82[i2 + 2] & 255);
      output2.push(tripletToBase642(tmp));
    }
    return output2.join("");
  }
  __name(encodeChunk2, "encodeChunk");
  function fromByteArray2(uint82) {
    var tmp;
    var len2 = uint82.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk2(uint82, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint82[len2 - 1];
      parts.push(
        lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint82[len2 - 2] << 8) + uint82[len2 - 1];
      parts.push(
        lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  __name(fromByteArray2, "fromByteArray");
  return base64Js$1;
}
__name(requireBase64Js, "requireBase64Js");
var ieee754$1 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredIeee754;
function requireIeee754() {
  if (hasRequiredIeee754) return ieee754$1;
  hasRequiredIeee754 = 1;
  ieee754$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e2, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer2[offset + i];
    i += d;
    e2 = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    m = e2 & (1 << -nBits) - 1;
    e2 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    if (e2 === 0) {
      e2 = 1 - eBias;
    } else if (e2 === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e2 = e2 - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e2 - mLen);
  };
  ieee754$1.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e2, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e2 = eMax;
    } else {
      e2 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e2)) < 1) {
        e2--;
        c *= 2;
      }
      if (e2 + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e2++;
        c /= 2;
      }
      if (e2 + eBias >= eMax) {
        m = 0;
        e2 = eMax;
      } else if (e2 + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e2 = e2 + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e2 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e2 = e2 << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i] = e2 & 255, i += d, e2 /= 256, eLen -= 8) {
    }
    buffer2[offset + i - d] |= s * 128;
  };
  return ieee754$1;
}
__name(requireIeee754, "requireIeee754");
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer$1;
  hasRequiredBuffer = 1;
  (function(exports) {
    const base64 = requireBase64Js();
    const ieee7542 = requireIeee754();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto2 = { foo: /* @__PURE__ */ __name(function() {
          return 42;
        }, "foo") };
        Object.setPrototypeOf(proto2, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto2);
        return arr.foo() === 42;
      } catch (e2) {
        return false;
      }
    }
    __name(typedArraySupport, "typedArraySupport");
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.buffer;
      }, "get")
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.byteOffset;
      }, "get")
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    __name(createBuffer, "createBuffer");
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    __name(Buffer3, "Buffer");
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    __name(from, "from");
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    __name(assertSize, "assertSize");
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    __name(alloc, "alloc");
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    __name(allocUnsafe, "allocUnsafe");
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength2(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    __name(fromString, "fromString");
    function fromArrayLike(array2) {
      const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array2[i] & 255;
      }
      return buf;
    }
    __name(fromArrayLike, "fromArrayLike");
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy2 = new Uint8Array(arrayView);
        return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    __name(fromArrayView, "fromArrayView");
    function fromArrayBuffer(array2, byteOffset, length) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array2.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array2);
      } else if (length === void 0) {
        buf = new Uint8Array(array2, byteOffset);
      } else {
        buf = new Uint8Array(array2, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    __name(fromArrayBuffer, "fromArrayBuffer");
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    __name(fromObject, "fromObject");
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    __name(checked, "checked");
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    __name(SlowBuffer, "SlowBuffer");
    Buffer3.isBuffer = /* @__PURE__ */ __name(function isBuffer2(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    }, "isBuffer");
    Buffer3.compare = /* @__PURE__ */ __name(function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    }, "compare");
    Buffer3.isEncoding = /* @__PURE__ */ __name(function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, "isEncoding");
    Buffer3.concat = /* @__PURE__ */ __name(function concat2(list2, length) {
      if (!Array.isArray(list2)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list2.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list2.length; ++i) {
          length += list2[i].length;
        }
      }
      const buffer2 = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list2.length; ++i) {
        let buf = list2[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    }, "concat");
    function byteLength2(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(byteLength2, "byteLength");
    Buffer3.byteLength = byteLength2;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(slowToString, "slowToString");
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    __name(swap, "swap");
    Buffer3.prototype.swap16 = /* @__PURE__ */ __name(function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    }, "swap16");
    Buffer3.prototype.swap32 = /* @__PURE__ */ __name(function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    }, "swap32");
    Buffer3.prototype.swap64 = /* @__PURE__ */ __name(function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    }, "swap64");
    Buffer3.prototype.toString = /* @__PURE__ */ __name(function toString2() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    }, "toString");
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = /* @__PURE__ */ __name(function equals(b) {
      if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer3.compare(this, b) === 0;
    }, "equals");
    Buffer3.prototype.inspect = /* @__PURE__ */ __name(function inspect2() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    }, "inspect");
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = /* @__PURE__ */ __name(function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    }, "compare");
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    __name(bidirectionalIndexOf, "bidirectionalIndexOf");
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      __name(read2, "read");
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read2(arr, i + j) !== read2(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    __name(arrayIndexOf, "arrayIndexOf");
    Buffer3.prototype.includes = /* @__PURE__ */ __name(function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    }, "includes");
    Buffer3.prototype.indexOf = /* @__PURE__ */ __name(function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    }, "indexOf");
    Buffer3.prototype.lastIndexOf = /* @__PURE__ */ __name(function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    }, "lastIndexOf");
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    __name(hexWrite, "hexWrite");
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    __name(utf8Write, "utf8Write");
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    __name(asciiWrite, "asciiWrite");
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    __name(base64Write, "base64Write");
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    __name(ucs2Write, "ucs2Write");
    Buffer3.prototype.write = /* @__PURE__ */ __name(function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }, "write");
    Buffer3.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    }, "toJSON");
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    __name(base64Slice, "base64Slice");
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    __name(utf8Slice, "utf8Slice");
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    __name(decodeCodePointsArray, "decodeCodePointsArray");
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    __name(asciiSlice, "asciiSlice");
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    __name(latin1Slice, "latin1Slice");
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    __name(hexSlice, "hexSlice");
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    __name(utf16leSlice, "utf16leSlice");
    Buffer3.prototype.slice = /* @__PURE__ */ __name(function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    }, "slice");
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    __name(checkOffset, "checkOffset");
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = /* @__PURE__ */ __name(function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength3, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    }, "readUIntLE");
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = /* @__PURE__ */ __name(function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      let val = this[offset + --byteLength3];
      let mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    }, "readUIntBE");
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = /* @__PURE__ */ __name(function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    }, "readUInt8");
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = /* @__PURE__ */ __name(function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    }, "readUInt16LE");
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = /* @__PURE__ */ __name(function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    }, "readUInt16BE");
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = /* @__PURE__ */ __name(function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    }, "readUInt32LE");
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = /* @__PURE__ */ __name(function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    }, "readUInt32BE");
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    }, "readBigUInt64LE"));
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    }, "readBigUInt64BE"));
    Buffer3.prototype.readIntLE = /* @__PURE__ */ __name(function readIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength3, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
      return val;
    }, "readIntLE");
    Buffer3.prototype.readIntBE = /* @__PURE__ */ __name(function readIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength3, this.length);
      let i = byteLength3;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
      return val;
    }, "readIntBE");
    Buffer3.prototype.readInt8 = /* @__PURE__ */ __name(function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    }, "readInt8");
    Buffer3.prototype.readInt16LE = /* @__PURE__ */ __name(function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    }, "readInt16LE");
    Buffer3.prototype.readInt16BE = /* @__PURE__ */ __name(function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    }, "readInt16BE");
    Buffer3.prototype.readInt32LE = /* @__PURE__ */ __name(function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    }, "readInt32LE");
    Buffer3.prototype.readInt32BE = /* @__PURE__ */ __name(function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    }, "readInt32BE");
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    }, "readBigInt64LE"));
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    }, "readBigInt64BE"));
    Buffer3.prototype.readFloatLE = /* @__PURE__ */ __name(function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, true, 23, 4);
    }, "readFloatLE");
    Buffer3.prototype.readFloatBE = /* @__PURE__ */ __name(function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, false, 23, 4);
    }, "readFloatBE");
    Buffer3.prototype.readDoubleLE = /* @__PURE__ */ __name(function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, true, 52, 8);
    }, "readDoubleLE");
    Buffer3.prototype.readDoubleBE = /* @__PURE__ */ __name(function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, false, 52, 8);
    }, "readDoubleBE");
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    __name(checkInt, "checkInt");
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = /* @__PURE__ */ __name(function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    }, "writeUIntLE");
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = /* @__PURE__ */ __name(function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      let i = byteLength3 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    }, "writeUIntBE");
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = /* @__PURE__ */ __name(function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    }, "writeUInt8");
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = /* @__PURE__ */ __name(function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeUInt16LE");
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = /* @__PURE__ */ __name(function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeUInt16BE");
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = /* @__PURE__ */ __name(function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    }, "writeUInt32LE");
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = /* @__PURE__ */ __name(function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeUInt32BE");
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    __name(wrtBigUInt64LE, "wrtBigUInt64LE");
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    __name(wrtBigUInt64BE, "wrtBigUInt64BE");
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64LE"));
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64BE"));
    Buffer3.prototype.writeIntLE = /* @__PURE__ */ __name(function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    }, "writeIntLE");
    Buffer3.prototype.writeIntBE = /* @__PURE__ */ __name(function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      let i = byteLength3 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    }, "writeIntBE");
    Buffer3.prototype.writeInt8 = /* @__PURE__ */ __name(function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    }, "writeInt8");
    Buffer3.prototype.writeInt16LE = /* @__PURE__ */ __name(function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeInt16LE");
    Buffer3.prototype.writeInt16BE = /* @__PURE__ */ __name(function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeInt16BE");
    Buffer3.prototype.writeInt32LE = /* @__PURE__ */ __name(function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    }, "writeInt32LE");
    Buffer3.prototype.writeInt32BE = /* @__PURE__ */ __name(function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeInt32BE");
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64LE"));
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64BE"));
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    __name(checkIEEE754, "checkIEEE754");
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee7542.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    __name(writeFloat, "writeFloat");
    Buffer3.prototype.writeFloatLE = /* @__PURE__ */ __name(function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    }, "writeFloatLE");
    Buffer3.prototype.writeFloatBE = /* @__PURE__ */ __name(function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    }, "writeFloatBE");
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee7542.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    __name(writeDouble, "writeDouble");
    Buffer3.prototype.writeDoubleLE = /* @__PURE__ */ __name(function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    }, "writeDoubleLE");
    Buffer3.prototype.writeDoubleBE = /* @__PURE__ */ __name(function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }, "writeDoubleBE");
    Buffer3.prototype.copy = /* @__PURE__ */ __name(function copy2(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    }, "copy");
    Buffer3.prototype.fill = /* @__PURE__ */ __name(function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    }, "fill");
    const errors2 = {};
    function E(sym, getMessage, Base) {
      var _a2;
      errors2[sym] = (_a2 = class extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      }, __name(_a2, "NodeError"), _a2);
    }
    __name(E, "E");
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range2, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range2}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    __name(addNumericalSeparator, "addNumericalSeparator");
    function checkBounds(buf, offset, byteLength3) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
        boundsError(offset, buf.length - (byteLength3 + 1));
      }
    }
    __name(checkBounds, "checkBounds");
    function checkIntBI(value, min, max, buf, offset, byteLength3) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range2;
        {
          if (min === 0 || min === BigInt(0)) {
            range2 = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
          } else {
            range2 = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
          }
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
      }
      checkBounds(buf, offset, byteLength3);
    }
    __name(checkIntBI, "checkIntBI");
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    __name(validateNumber, "validateNumber");
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors2.ERR_OUT_OF_RANGE("offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(
        "offset",
        `>= ${0} and <= ${length}`,
        value
      );
    }
    __name(boundsError, "boundsError");
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    __name(base64clean, "base64clean");
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    __name(utf8ToBytes, "utf8ToBytes");
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    __name(asciiToBytes, "asciiToBytes");
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    __name(utf16leToBytes, "utf16leToBytes");
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    __name(base64ToBytes, "base64ToBytes");
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    __name(blitBuffer, "blitBuffer");
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    __name(isInstance, "isInstance");
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    __name(numberIsNaN, "numberIsNaN");
    const hexSliceLookupTable = (function() {
      const alphabet = "0123456789abcdef";
      const table2 = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table2[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table2;
    })();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    __name(defineBigIntMethod, "defineBigIntMethod");
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    __name(BufferBigIntNotDefined, "BufferBigIntNotDefined");
  })(buffer$1);
  return buffer$1;
}
__name(requireBuffer, "requireBuffer");
var bufferExports = requireBuffer();
let checkAccess = true;
function _setAccessChecks(value) {
  checkAccess = value;
}
__name(_setAccessChecks, "_setAccessChecks");
var DirType;
(function(DirType2) {
  DirType2[DirType2["UNKNOWN"] = 0] = "UNKNOWN";
  DirType2[DirType2["FIFO"] = 1] = "FIFO";
  DirType2[DirType2["CHR"] = 2] = "CHR";
  DirType2[DirType2["DIR"] = 4] = "DIR";
  DirType2[DirType2["BLK"] = 6] = "BLK";
  DirType2[DirType2["REG"] = 8] = "REG";
  DirType2[DirType2["LNK"] = 10] = "LNK";
  DirType2[DirType2["SOCK"] = 12] = "SOCK";
  DirType2[DirType2["WHT"] = 14] = "WHT";
})(DirType || (DirType = {}));
function ifToDt(mode2) {
  return (mode2 & 61440) >> 12;
}
__name(ifToDt, "ifToDt");
let Dirent$1 = (_e = class {
  constructor() {
    __publicField(this, "ino");
    __publicField(this, "type");
    __publicField(this, "path");
    __publicField(this, "name");
  }
}, __name(_e, "Dirent"), _e);
const _Handle = class _Handle {
  /**
   * Creates a file with `path` and, optionally, the given contents.
   * Note that, if contents is specified, it will be mutated by the file.
   */
  constructor(context, path2, fs2, internalPath, flag, inode) {
    __publicField(this, "context");
    __publicField(this, "path");
    __publicField(this, "fs");
    __publicField(this, "internalPath");
    __publicField(this, "flag");
    __publicField(this, "inode");
    __publicField(this, "_buffer");
    /**
     * Current position
     */
    __publicField(this, "_position", 0);
    /**
     * Whether the file has changes which have not been written to the FS
     */
    __publicField(this, "dirty", false);
    /**
     * Whether the file is open or closed
     */
    __publicField(this, "closed", false);
    this.context = context;
    this.path = path2;
    this.fs = fs2;
    this.internalPath = internalPath;
    this.flag = flag;
    this.inode = inode;
  }
  /**
   * Get the current file position.
   *
   * We emulate the following bug mentioned in the Node documentation:
   *
   * On Linux, positional writes don't work when the file is opened in append mode.
   * The kernel ignores the position argument and always appends the data to the end of the file.
   * @returns The current file position.
   */
  get position() {
    return this.flag & O_APPEND ? this.inode.size : this._position;
  }
  set position(value) {
    this._position = value;
  }
  get isClosed() {
    return this.closed;
  }
  get _isSync() {
    return !!(this.flag & O_SYNC || this.inode.flags & InodeFlags.Sync || this.fs.attributes.has("sync"));
  }
  [Symbol.dispose]() {
    this.closeSync();
  }
  syncSync() {
    if (this.closed)
      throw UV("EBADF", "sync", this.path);
    if (!this.dirty)
      return;
    if (!this.fs.attributes.has("no_write"))
      this.fs.touchSync(this.internalPath, this.inode);
    this.dirty = false;
  }
  /**
   * Default implementation maps to `syncSync`.
   */
  datasyncSync() {
    return this.syncSync();
  }
  closeSync() {
    if (this.closed)
      throw UV("EBADF", "close", this.path);
    this.syncSync();
    this.disposeSync();
  }
  /**
   * Cleans up. This will *not* sync the file data to the FS
   */
  disposeSync(force) {
    if (this.closed)
      throw UV("EBADF", "close", this.path);
    if (this.dirty && !force)
      throw UV("EBUSY", "close", this.path);
    this.closed = true;
  }
  truncateSync(length) {
    if (length < 0)
      throw UV("EINVAL", "truncate", this.path);
    if (this.closed)
      throw UV("EBADF", "truncate", this.path);
    if (!(this.flag & O_WRONLY || this.flag & O_RDWR))
      throw UV("EBADF", "truncate", this.path);
    if (this.fs.attributes.has("readonly"))
      throw UV("EROFS", "truncate", this.path);
    if (this.inode.flags & InodeFlags.Immutable)
      throw UV("EPERM", "truncate", this.path);
    this.dirty = true;
    this.inode.mtimeMs = Date.now();
    this.inode.size = length;
    this.inode.ctimeMs = Date.now();
    if (this._isSync)
      this.syncSync();
  }
  /**
   * Write buffer to the file.
   * @param buffer Uint8Array containing the data to write to the file.
   * @param offset Offset in the buffer to start reading data from.
   * @param length The amount of bytes to write to the file.
   * @param position Offset from the beginning of the file where this data should be written.
   * If position is null, the data will be written at  the current position.
   * @returns bytes written
   */
  writeSync(buffer2, offset = 0, length = buffer2.byteLength - offset, position = this.position) {
    if (this.closed)
      throw UV("EBADF", "write", this.path);
    if (!(this.flag & O_WRONLY || this.flag & O_RDWR))
      throw UV("EBADF", "write", this.path);
    if (this.fs.attributes.has("readonly"))
      throw UV("EROFS", "write", this.path);
    if (this.inode.flags & InodeFlags.Immutable)
      throw UV("EPERM", "write", this.path);
    this.dirty = true;
    const end = position + length;
    const slice = buffer2.subarray(offset, offset + length);
    if (!isCharacterDevice(this.inode) && !isBlockDevice(this.inode) && end > this.inode.size)
      this.inode.size = end;
    this.inode.mtimeMs = Date.now();
    this.inode.ctimeMs = Date.now();
    this._position = position + slice.byteLength;
    this.fs.writeSync(this.internalPath, slice, position);
    if (this._isSync)
      this.syncSync();
    return slice.byteLength;
  }
  /**
   * Read data from the file.
   * @param buffer The buffer that the data will be written to.
   * @param offset The offset within the buffer where writing will start.
   * @param length An integer specifying the number of bytes to read.
   * @param position An integer specifying where to begin reading from in the file.
   * If position is null, data will be read from the current file position.
   * @returns number of bytes written
   */
  readSync(buffer2, offset = 0, length = buffer2.byteLength - offset, position = this.position) {
    if (this.closed)
      throw UV("EBADF", "read", this.path);
    if (this.flag & O_WRONLY)
      throw UV("EBADF", "read", this.path);
    if (!(this.inode.flags & InodeFlags.NoAtime) && !this.fs.attributes.has("no_atime")) {
      this.dirty = true;
      this.inode.atimeMs = Date.now();
    }
    let end = position + length;
    if (!isCharacterDevice(this.inode) && !isBlockDevice(this.inode) && end > this.inode.size) {
      end = position + Math.max(this.inode.size - position, 0);
    }
    this._position = end;
    const uint82 = new Uint8Array(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
    this.fs.readSync(this.internalPath, uint82.subarray(offset, offset + length), position, end);
    if (this._isSync)
      this.syncSync();
    return end - position;
  }
  chmodSync(mode2) {
    if (this.closed)
      throw UV("EBADF", "chmod", this.path);
    this.dirty = true;
    this.inode.mode = this.inode.mode & (mode2 > S_IFMT ? -61441 : S_IFMT) | mode2;
    if (this._isSync || mode2 > S_IFMT)
      this.syncSync();
  }
  chownSync(uid, gid) {
    if (this.closed)
      throw UV("EBADF", "chmod", this.path);
    this.dirty = true;
    _chown(this.inode, uid, gid);
    if (this._isSync)
      this.syncSync();
  }
  /**
   * Change the file timestamps of the file.
   */
  utimesSync(atime, mtime) {
    if (this.closed)
      throw UV("EBADF", "utimes", this.path);
    this.dirty = true;
    this.inode.atimeMs = atime;
    this.inode.mtimeMs = mtime;
    if (this._isSync)
      this.syncSync();
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async sync() {
    if (this.closed)
      throw UV("EBADF", "sync", this.path);
    if (!this.dirty)
      return;
    if (!this.fs.attributes.has("no_write"))
      await this.fs.touch(this.internalPath, this.inode);
    this.dirty = false;
  }
  /**
   * Default implementation maps to `sync`.
   */
  datasync() {
    return this.sync();
  }
  async close() {
    if (this.closed)
      throw UV("EBADF", "close", this.path);
    await this.sync();
    this.dispose();
  }
  /**
   * Cleans up. This will *not* sync the file data to the FS
   */
  dispose(force) {
    if (this.closed)
      throw UV("EBADF", "close", this.path);
    if (this.dirty && !force)
      throw UV("EBUSY", "close", this.path);
    this.closed = true;
  }
  stat() {
    if (this.closed)
      throw UV("EBADF", "stat", this.path);
    return this.inode;
  }
  async truncate(length) {
    if (length < 0)
      throw UV("EINVAL", "truncate", this.path);
    if (this.closed)
      throw UV("EBADF", "truncate", this.path);
    if (!(this.flag & O_WRONLY || this.flag & O_RDWR))
      throw UV("EBADF", "truncate", this.path);
    if (this.fs.attributes.has("readonly"))
      throw UV("EROFS", "truncate", this.path);
    if (this.inode.flags & InodeFlags.Immutable)
      throw UV("EPERM", "truncate", this.path);
    this.dirty = true;
    this.inode.mtimeMs = Date.now();
    this.inode.size = length;
    this.inode.ctimeMs = Date.now();
    if (this._isSync)
      await this.sync();
  }
  /**
   * Write buffer to the file.
   * @param buffer Uint8Array containing the data to write to the file.
   * @param offset Offset in the buffer to start reading data from.
   * @param length The amount of bytes to write to the file.
   * @param position Offset from the beginning of the file where this data should be written.
   * If position is null, the data will be written at  the current position.
   * @returns bytes written
   */
  async write(buffer2, offset = 0, length = buffer2.byteLength - offset, position = this.position) {
    if (this.closed)
      throw UV("EBADF", "write", this.path);
    if (!(this.flag & O_WRONLY || this.flag & O_RDWR))
      throw UV("EBADF", "write", this.path);
    if (this.fs.attributes.has("readonly"))
      throw UV("EROFS", "write", this.path);
    if (this.inode.flags & InodeFlags.Immutable)
      throw UV("EPERM", "write", this.path);
    this.dirty = true;
    const end = position + length;
    const slice = buffer2.subarray(offset, offset + length);
    if (!isCharacterDevice(this.inode) && !isBlockDevice(this.inode) && end > this.inode.size)
      this.inode.size = end;
    this.inode.mtimeMs = Date.now();
    this.inode.ctimeMs = Date.now();
    this._position = position + slice.byteLength;
    await this.fs.write(this.internalPath, slice, position);
    if (this._isSync)
      await this.sync();
    return slice.byteLength;
  }
  /**
   * Read data from the file.
   * @param buffer The buffer that the data will be written to.
   * @param offset The offset within the buffer where writing will start.
   * @param length An integer specifying the number of bytes to read.
   * @param position An integer specifying where to begin reading from in the file.
   * If position is null, data will be read from the current file position.
   * @returns number of bytes written
   */
  async read(buffer2, offset = 0, length = buffer2.byteLength - offset, position = this.position) {
    if (this.closed)
      throw UV("EBADF", "read", this.path);
    if (this.flag & O_WRONLY)
      throw UV("EBADF", "read", this.path);
    if (!(this.inode.flags & InodeFlags.NoAtime) && !this.fs.attributes.has("no_atime")) {
      this.dirty = true;
      this.inode.atimeMs = Date.now();
    }
    let end = position + length;
    if (!isCharacterDevice(this.inode) && !isBlockDevice(this.inode) && end > this.inode.size) {
      end = position + Math.max(this.inode.size - position, 0);
    }
    this._position = end;
    const uint82 = new Uint8Array(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
    await this.fs.read(this.internalPath, uint82.subarray(offset, offset + length), position, end);
    if (this._isSync)
      await this.sync();
    return end - position;
  }
  async chmod(mode2) {
    if (this.closed)
      throw UV("EBADF", "chmod", this.path);
    this.dirty = true;
    this.inode.mode = this.inode.mode & (mode2 > S_IFMT ? -61441 : S_IFMT) | mode2;
    if (this._isSync || mode2 > S_IFMT)
      await this.sync();
  }
  async chown(uid, gid) {
    if (this.closed)
      throw UV("EBADF", "chown", this.path);
    this.dirty = true;
    _chown(this.inode, uid, gid);
    if (this._isSync)
      await this.sync();
  }
  /**
   * Change the file timestamps of the file.
   */
  async utimes(atime, mtime) {
    if (this.closed)
      throw UV("EBADF", "utimes", this.path);
    this.dirty = true;
    this.inode.atimeMs = atime;
    this.inode.mtimeMs = mtime;
    if (this._isSync)
      await this.sync();
  }
  /**
   * Create a stream for reading the file.
   */
  streamRead(options) {
    if (this.closed)
      throw UV("EBADF", "streamRead", this.path);
    return this.fs.streamRead(this.internalPath, options);
  }
  /**
   * Create a stream for writing the file.
   */
  streamWrite(options) {
    if (this.closed)
      throw UV("EBADF", "write", this.path);
    if (this.inode.flags & InodeFlags.Immutable)
      throw UV("EPERM", "write", this.path);
    if (this.fs.attributes.has("readonly"))
      throw UV("EROFS", "write", this.path);
    return this.fs.streamWrite(this.internalPath, options);
  }
};
__name(_Handle, "Handle");
let Handle = _Handle;
function toFD(file) {
  const map = file.context?.descriptors ?? defaultContext.descriptors;
  const fd = Math.max(map.size ? Math.max(...map.keys()) + 1 : 0, 4);
  map.set(fd, file);
  return fd;
}
__name(toFD, "toFD");
function fromFD($, fd) {
  const map = $?.descriptors ?? defaultContext.descriptors;
  const value = map.get(fd);
  if (!value)
    throw withErrno("EBADF");
  return value;
}
__name(fromFD, "fromFD");
function deleteFD($, fd) {
  return ($?.descriptors ?? defaultContext.descriptors).delete(fd);
}
__name(deleteFD, "deleteFD");
const pattern = /[rwasx]{1,2}\+?/;
function parse$2(flag) {
  if (typeof flag == "number")
    return flag;
  if (!pattern.test(flag)) {
    throw withErrno("EINVAL", "Invalid flag string: " + flag);
  }
  return toNumber(flag);
}
__name(parse$2, "parse$2");
function toNumber(flag) {
  if (!flag.includes("r") && !flag.includes("w") && !flag.includes("a")) {
    throw withErrno("EINVAL", "Invalid flag string: " + flag);
  }
  let n = flag.includes("r") ? O_RDONLY : O_CREAT;
  if (flag.includes("w"))
    n |= O_TRUNC;
  if (flag.includes("a"))
    n |= O_APPEND;
  if (flag.includes("+"))
    n |= O_RDWR;
  else if (!flag.includes("r"))
    n |= O_WRONLY;
  if (flag.includes("s"))
    n |= O_SYNC;
  if (flag.includes("x"))
    n |= O_EXCL;
  return n;
}
__name(toNumber, "toNumber");
function toMode(flag) {
  let mode2 = 0;
  if (!(flag & O_WRONLY))
    mode2 |= R_OK;
  if (flag & O_WRONLY || flag & O_RDWR)
    mode2 |= W_OK;
  return mode2;
}
__name(toMode, "toMode");
function wrap$1(fs2, prop, path2, dest) {
  const extra = typeof path2 === "string" ? { path: path2, dest, syscall: prop.endsWith("Sync") ? prop.slice(0, -4) : prop } : path2;
  const fn = fs2[prop];
  if (typeof fn !== "function")
    throw new TypeError(`${prop} is not a function`);
  return function(...args) {
    try {
      return fn.call(fs2, ...args);
    } catch (e2) {
      throw setUVMessage(Object.assign(e2, extra));
    }
  };
}
__name(wrap$1, "wrap$1");
function withExceptionContext(fs2, context) {
  return new Proxy(fs2, {
    get(target, prop) {
      const value = Reflect.get(target, prop);
      if (typeof value != "function")
        return value;
      return /* @__PURE__ */ __name(function __withContext(...args) {
        try {
          const result = value.apply(target, args);
          if (!(result instanceof Promise))
            return result;
          return result.catch((e2) => {
            if ("code" in e2)
              throw setUVMessage(Object.assign(e2, context));
            if (e2 in Errno) {
              const ex = UV(e2, context);
              Error.captureStackTrace(ex, __withContext);
            }
            throw e2;
          });
        } catch (e2) {
          throw setUVMessage(Object.assign(e2, context));
        }
      }, "__withContext");
    }
  });
}
__name(withExceptionContext, "withExceptionContext");
const mounts = /* @__PURE__ */ new Map();
mount$1("/", InMemory.create({ label: "root" }));
function mount$1(mountPoint, fs2) {
  if (mountPoint[0] != "/")
    mountPoint = "/" + mountPoint;
  mountPoint = resolve$2.call(this, mountPoint);
  if (mounts.has(mountPoint))
    throw err$1(withErrno("EINVAL", "Mount point is already in use: " + mountPoint));
  fs2._mountPoint = mountPoint;
  mounts.set(mountPoint, fs2);
  info(`Mounted ${fs2.name} on ${mountPoint}`);
  debug(`${fs2.name} attributes: ${[...fs2.attributes].map(([k, v]) => v !== void 0 && v !== null ? k + "=" + v : k).join(", ")}`);
}
__name(mount$1, "mount$1");
function umount$1(mountPoint) {
  if (mountPoint[0] != "/")
    mountPoint = "/" + mountPoint;
  mountPoint = resolve$2.call(this, mountPoint);
  if (!mounts.has(mountPoint)) {
    warn(mountPoint + " is already unmounted");
    return;
  }
  mounts.delete(mountPoint);
  notice("Unmounted " + mountPoint);
}
__name(umount$1, "umount$1");
function resolveMount(path2, ctx, extra) {
  const root = ctx?.root || defaultContext.root;
  const _exceptionContext = { path: path2, ...extra };
  path2 = normalizePath(join(root, path2));
  const sortedMounts = [...mounts].sort((a, b) => a[0].length > b[0].length ? -1 : 1);
  for (const [mountPoint, fs2] of sortedMounts) {
    if (!_isParentOf(mountPoint, path2))
      continue;
    path2 = path2.slice(mountPoint.length > 1 ? mountPoint.length : 0);
    if (path2 === "")
      path2 = "/";
    const case_fold = fs2.attributes.get("case_fold");
    if (case_fold === "lower")
      path2 = path2.toLowerCase();
    if (case_fold === "upper")
      path2 = path2.toUpperCase();
    return { fs: withExceptionContext(fs2, _exceptionContext), path: path2, mountPoint, root };
  }
  throw alert(new Exception(Errno.EIO, "No file system for " + path2));
}
__name(resolveMount, "resolveMount");
function _statfs(fs2, bigint) {
  const md = fs2.usage();
  const bs = md.blockSize || 4096;
  return {
    type: (bigint ? BigInt : Number)(fs2.type),
    bsize: (bigint ? BigInt : Number)(bs),
    ffree: (bigint ? BigInt : Number)(md.freeNodes || size_max),
    files: (bigint ? BigInt : Number)(md.totalNodes || size_max),
    bavail: (bigint ? BigInt : Number)(md.freeSpace / bs),
    bfree: (bigint ? BigInt : Number)(md.freeSpace / bs),
    blocks: (bigint ? BigInt : Number)(md.totalSpace / bs)
  };
}
__name(_statfs, "_statfs");
function chroot(path2) {
  const $ = this ?? defaultContext;
  if (!credentialsAllowRoot($.credentials))
    throw withErrno("EPERM", "Can not chroot() as non-root user");
  $.root ?? ($.root = "/");
  const newRoot = join($.root, path2);
  for (const handle of $.descriptors?.values() ?? []) {
    if (!handle.path.startsWith($.root))
      throw UV("EBUSY", "chroot", handle.path);
    handle.path = handle.path.slice($.root.length);
  }
  if (newRoot.length > $.root.length)
    throw withErrno("EPERM", "Can not chroot() outside of current root");
  $.root = newRoot;
}
__name(chroot, "chroot");
function _isParentOf(parent, child) {
  if (parent === "/" || parent === child)
    return true;
  if (!parent.endsWith("/"))
    parent += "/";
  return child.startsWith(parent);
}
__name(_isParentOf, "_isParentOf");
function resolve$1($, path2, preserveSymlinks, extra) {
  try {
    const resolved2 = resolveMount(path2, $);
    const stats2 = resolved2.fs.statSync(resolved2.path);
    if (!isSymbolicLink(stats2) || preserveSymlinks) {
      return { ...resolved2, fullPath: path2, stats: stats2 };
    }
    const target2 = resolve$2.call($, dirname(path2), readlink$3.call($, path2));
    return resolve$1($, target2, preserveSymlinks, extra);
  } catch (e2) {
    setUVMessage(Object.assign(e2, { syscall: "stat", path: path2 }));
    if (preserveSymlinks)
      throw e2;
  }
  const { base, dir } = parse$3(path2);
  const realDir = dir == "/" ? "/" : resolve$1($, dir, false, extra).fullPath;
  const maybePath = join(realDir, base);
  const resolved = resolveMount(maybePath, $);
  let stats;
  try {
    stats = resolved.fs.statSync(resolved.path);
  } catch (e2) {
    if (e2.code === "ENOENT")
      return { ...resolved, fullPath: path2 };
    throw setUVMessage(Object.assign(e2, { syscall: "stat", path: maybePath }));
  }
  if (!isSymbolicLink(stats)) {
    return { ...resolved, fullPath: maybePath, stats };
  }
  const target = resolve$2.call($, realDir, readlink$3.call($, maybePath));
  return resolve$1($, target, false, extra);
}
__name(resolve$1, "resolve$1");
function open$4(path2, opt) {
  path2 = normalizePath(path2);
  const mode2 = normalizeMode(opt.mode, 420), flag = parse$2(opt.flag);
  path2 = opt.preserveSymlinks ? path2 : resolve$1(this, path2).fullPath;
  const { fs: fs2, path: resolved } = resolveMount(path2, this);
  let stats;
  try {
    stats = fs2.statSync(resolved);
  } catch {
  }
  if (!stats) {
    if (!(flag & O_CREAT)) {
      throw UV("ENOENT", "open", path2);
    }
    const parentStats = fs2.statSync(dirname(resolved));
    if (checkAccess && !hasAccess(this, parentStats, W_OK)) {
      throw UV("EACCES", "open", path2);
    }
    if (!isDirectory(parentStats)) {
      throw UV("ENOTDIR", "open", path2);
    }
    if (!opt.allowDirectory && mode2 & S_IFDIR)
      throw UV("EISDIR", "open", path2);
    if (checkAccess && !hasAccess(this, parentStats, W_OK)) {
      throw UV("EACCES", "open", path2);
    }
    const { euid: uid, egid: gid } = this?.credentials ?? defaultContext.credentials;
    const inode = fs2.createFileSync(resolved, {
      mode: mode2,
      uid: parentStats.mode & S_ISUID ? parentStats.uid : uid,
      gid: parentStats.mode & S_ISGID ? parentStats.gid : gid
    });
    return new Handle(this, path2, fs2, resolved, flag, inode);
  }
  if (checkAccess && (!hasAccess(this, stats, mode2) || !hasAccess(this, stats, toMode(flag)))) {
    throw UV("EACCES", "open", path2);
  }
  if (flag & O_EXCL)
    throw UV("EEXIST", "open", path2);
  const file = new Handle(this, path2, fs2, resolved, flag, stats);
  if (!opt.allowDirectory && stats.mode & S_IFDIR)
    throw UV("EISDIR", "open", path2);
  if (flag & O_TRUNC)
    file.truncateSync(0);
  return file;
}
__name(open$4, "open$4");
function readlink$3(path2) {
  path2 = normalizePath(path2);
  const { fs: fs2, stats, path: resolved } = resolve$1(this, path2, true);
  if (!stats)
    throw UV("ENOENT", "readlink", path2);
  if (checkAccess && !hasAccess(this, stats, R_OK))
    throw UV("EACCES", "readlink", path2);
  if (!isSymbolicLink(stats))
    throw UV("EINVAL", "readlink", path2);
  const size = stats.size;
  const data = new Uint8Array(size);
  fs2.readSync(resolved, data, 0, size);
  return decodeUTF8(data);
}
__name(readlink$3, "readlink$3");
function mkdir$4(path2, options = {}) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolve$1(this, path2);
  const { euid: uid, egid: gid } = this?.credentials ?? defaultContext.credentials;
  const { mode: mode2 = 511, recursive } = options;
  const __create = /* @__PURE__ */ __name((path3, resolved2, parent) => {
    if (checkAccess && !hasAccess(this, parent, W_OK))
      throw UV("EACCES", "mkdir", dirname(path3));
    const inode = fs2.mkdirSync(resolved2, {
      mode: mode2,
      uid: parent.mode & S_ISUID ? parent.uid : uid,
      gid: parent.mode & S_ISGID ? parent.gid : gid
    });
    emitChange(this, "rename", path3);
    return inode;
  }, "__create");
  if (!recursive) {
    __create(path2, resolved, fs2.statSync(dirname(resolved)));
    return;
  }
  const dirs = [];
  for (let dir = resolved, original = path2; !fs2.existsSync(dir); dir = dirname(dir), original = dirname(original)) {
    dirs.unshift({ resolved: dir, original });
  }
  if (!dirs.length)
    return;
  const stats = [fs2.statSync(dirname(dirs[0].resolved))];
  for (const [i, dir] of dirs.entries()) {
    stats.push(__create(dir.original, dir.resolved, stats[i]));
  }
  return dirs[0].original;
}
__name(mkdir$4, "mkdir$4");
function readdir$3(path2, options = {}) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolve$1(this, path2);
  const stats = fs2.statSync(resolved);
  if (checkAccess && !hasAccess(this, stats, R_OK))
    throw UV("EACCES", "readdir", path2);
  if (!isDirectory(stats))
    throw UV("ENOTDIR", "readdir", path2);
  const entries2 = fs2.readdirSync(resolved);
  const values = [];
  const addEntry = /* @__PURE__ */ __name((entry) => {
    let entryStat;
    try {
      entryStat = fs2.statSync(join(resolved, entry));
    } catch (e2) {
      if (e2.code == "ENOENT")
        return;
      throw e2;
    }
    const ent = new Dirent$1();
    ent.ino = entryStat.ino;
    ent.type = ifToDt(entryStat.mode);
    ent.path = entry;
    ent.name = basename(entry);
    values.push(ent);
    if (!isDirectory(entryStat) || !options?.recursive)
      return;
    const children = fs2.readdirSync(join(resolved, entry));
    for (const child of children)
      addEntry(join(entry, child));
  }, "addEntry");
  for (const entry of entries2)
    addEntry(entry);
  return values;
}
__name(readdir$3, "readdir$3");
function rename$3(oldPath, newPath) {
  oldPath = normalizePath(oldPath);
  newPath = normalizePath(newPath);
  const $ex = { syscall: "rename", path: oldPath, dest: newPath };
  const src = resolve$1(this, oldPath, true, $ex);
  const dst = resolveMount(newPath, this, $ex);
  if (src.fs.uuid !== dst.fs.uuid)
    throw UV("EXDEV", $ex);
  if (dst.path.startsWith(src.path + "/"))
    throw UV("EBUSY", $ex);
  if (!src.stats)
    throw UV("ENOENT", $ex);
  const fs2 = src.fs;
  const oldParent = fs2.statSync(dirname(src.path));
  const newParent = fs2.statSync(dirname(dst.path));
  let newStats;
  try {
    newStats = fs2.statSync(dst.path);
  } catch (e2) {
    if (e2.code != "ENOENT")
      throw e2;
  }
  if (checkAccess && (!hasAccess(this, oldParent, R_OK) || !hasAccess(this, newParent, W_OK)))
    throw UV("EACCES", $ex);
  if (newStats && !isDirectory(src.stats) && isDirectory(newStats))
    throw UV("EISDIR", $ex);
  if (newStats && isDirectory(src.stats) && !isDirectory(newStats))
    throw UV("ENOTDIR", $ex);
  src.fs.renameSync(src.path, dst.path);
  emitChange(this, "rename", oldPath);
  emitChange(this, "change", newPath);
}
__name(rename$3, "rename$3");
function link$3(target, link2) {
  target = normalizePath(target);
  link2 = normalizePath(link2);
  const $ex = { syscall: "link", path: link2, dest: target };
  const { fs: fs2, path: resolved } = resolveMount(target, this, $ex);
  const dst = resolveMount(link2, this, $ex);
  if (fs2.uuid !== dst.fs.uuid)
    throw UV("EXDEV", $ex);
  const stats = fs2.statSync(resolved);
  if (checkAccess) {
    if (!hasAccess(this, stats, R_OK))
      throw UV("EACCES", $ex);
    const dirStats = fs2.statSync(dirname(resolved));
    if (!hasAccess(this, dirStats, R_OK))
      throw UV("EACCES", $ex);
    const destStats = fs2.statSync(dirname(dst.path));
    if (!hasAccess(this, destStats, W_OK))
      throw UV("EACCES", $ex);
  }
  return fs2.linkSync(resolved, dst.path);
}
__name(link$3, "link$3");
const _Dirent = class _Dirent {
  constructor() {
    __publicField(this, "ino");
    __publicField(this, "type");
    __publicField(this, "_name");
    /**
     * @internal @protected
     */
    __publicField(this, "_encoding");
    /**
     * @internal @protected
     */
    __publicField(this, "_parentPath");
  }
  get name() {
    const name = bufferExports.Buffer.from(this._name);
    return this._encoding == "buffer" ? name : name.toString(this._encoding);
  }
  get parentPath() {
    return this._parentPath;
  }
  /**
   * @deprecated Removed in Node v24, use `parentPath` instead.
   */
  get path() {
    warn("Dirent.path was removed in Node v24, use parentPath instead");
    return this._parentPath;
  }
  /**
   * @internal
   */
  static from(vfs, encoding) {
    const dirent = new _Dirent();
    const { base, dir } = parse$3(vfs.path);
    dirent._parentPath = dir || ".";
    dirent._name = base;
    dirent.ino = vfs.ino;
    dirent.type = vfs.type;
    dirent._encoding = encoding;
    return dirent;
  }
  isFile() {
    return this.type === DirType.REG;
  }
  isDirectory() {
    return this.type === DirType.DIR;
  }
  isBlockDevice() {
    return this.type === DirType.BLK;
  }
  isCharacterDevice() {
    return this.type === DirType.CHR;
  }
  isSymbolicLink() {
    return this.type === DirType.LNK;
  }
  isFIFO() {
    return this.type === DirType.FIFO;
  }
  isSocket() {
    return this.type === DirType.SOCK;
  }
};
__name(_Dirent, "Dirent");
let Dirent = _Dirent;
const _Dir = class _Dir {
  constructor(path2, context) {
    __publicField(this, "path");
    __publicField(this, "context");
    __publicField(this, "closed", false);
    __publicField(this, "_entries");
    this.path = path2;
    this.context = context;
  }
  checkClosed() {
    if (this.closed)
      throw withErrno("EBADF", "Can not use closed Dir");
  }
  close(cb) {
    this.closed = true;
    if (!cb) {
      return Promise.resolve();
    }
    cb(null);
  }
  /**
   * Synchronously close the directory's underlying resource handle.
   * Subsequent reads will result in errors.
   */
  closeSync() {
    this.closed = true;
  }
  async _read() {
    this.checkClosed();
    this._entries ?? (this._entries = await readdir$1.call(this.context, this.path, {
      withFileTypes: true
    }));
    if (!this._entries.length)
      return null;
    return this._entries.shift() ?? null;
  }
  read(cb) {
    if (!cb) {
      return this._read();
    }
    void this._read().then((value) => cb(null, value));
  }
  /**
   * Synchronously read the next directory entry via `readdir(3)` as a `Dirent`.
   * If there are no more directory entries to read, null will be returned.
   * Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms.
   */
  readSync() {
    this.checkClosed();
    this._entries ?? (this._entries = readdirSync.call(this.context, this.path, { withFileTypes: true }));
    if (!this._entries.length)
      return null;
    return this._entries.shift() ?? null;
  }
  async next() {
    const value = await this._read();
    if (value) {
      return { done: false, value };
    }
    await this.close();
    return { done: true, value: void 0 };
  }
  /**
   * Asynchronously iterates over the directory via `readdir(3)` until all entries have been read.
   */
  [Symbol.asyncIterator]() {
    return this;
  }
  [Symbol.dispose]() {
    if (this.closed)
      return;
    this.closeSync();
  }
  async [Symbol.asyncDispose]() {
    if (this.closed)
      return;
    await this.close();
  }
};
__name(_Dir, "Dir");
let Dir = _Dir;
var __addDisposableResource$1 = function(env2, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = /* @__PURE__ */ __name(function() {
      try {
        inner.call(this);
      } catch (e2) {
        return Promise.reject(e2);
      }
    }, "dispose");
    env2.stack.push({ value, dispose, async });
  } else if (async) {
    env2.stack.push({ async: true });
  }
  return value;
};
var __disposeResources$1 = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    __name(fail, "fail");
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
          } else s |= 1;
        } catch (e2) {
          fail(e2);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    __name(next, "next");
    return next();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
function renameSync(oldPath, newPath) {
  return rename$3.call(this, oldPath, newPath);
}
__name(renameSync, "renameSync");
function existsSync(path2) {
  path2 = normalizePath(path2);
  try {
    const { fs: fs2, path: resolvedPath } = resolve$1(this, path2);
    return fs2.existsSync(resolvedPath);
  } catch (e2) {
    if (e2.errno == Errno.ENOENT)
      return false;
    throw e2;
  }
}
__name(existsSync, "existsSync");
function statSync(path2, options) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolve$1(this, path2);
  let stats;
  try {
    stats = fs2.statSync(resolved);
  } catch (e2) {
    throw setUVMessage(Object.assign(e2, { path: path2 }));
  }
  if (checkAccess && !hasAccess(this, stats, R_OK))
    throw UV("EACCES", { syscall: "stat", path: path2 });
  return options?.bigint ? new BigIntStats(stats) : new Stats(stats);
}
__name(statSync, "statSync");
function lstatSync(path2, options) {
  path2 = normalizePath(path2);
  const { base, dir } = parse$3(path2);
  const { fs: fs2, path: parent } = resolve$1(this, dir);
  const stats = wrap$1(fs2, "statSync", path2)(base ? join(parent, base) : parent);
  if (checkAccess && !hasAccess(this, stats, R_OK))
    throw UV("EACCES", { syscall: "lstat", path: path2 });
  return options?.bigint ? new BigIntStats(stats) : new Stats(stats);
}
__name(lstatSync, "lstatSync");
function truncateSync(path2, len = 0) {
  const env_1 = { stack: [], error: void 0, hasError: false };
  try {
    const file = __addDisposableResource$1(env_1, open$4.call(this, path2, { flag: "r+" }), false);
    len || (len = 0);
    if (len < 0)
      throw UV("EINVAL", "truncate", path2.toString());
    file.truncateSync(len);
  } catch (e_1) {
    env_1.error = e_1;
    env_1.hasError = true;
  } finally {
    __disposeResources$1(env_1);
  }
}
__name(truncateSync, "truncateSync");
function unlinkSync(path2) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolveMount(path2, this);
  try {
    if (checkAccess && !hasAccess(this, fs2.statSync(resolved), W_OK)) {
      throw UV("EACCES", "unlink");
    }
    fs2.unlinkSync(resolved);
  } catch (e2) {
    throw setUVMessage(Object.assign(e2, { path: path2 }));
  }
  emitChange(this, "rename", path2.toString());
}
__name(unlinkSync, "unlinkSync");
function openSync(path2, flag, mode2 = F_OK) {
  return toFD(open$4.call(this, path2, { flag, mode: mode2 }));
}
__name(openSync, "openSync");
function lopenSync(path2, flag, mode2) {
  return toFD(open$4.call(this, path2, { flag, mode: mode2, preserveSymlinks: true }));
}
__name(lopenSync, "lopenSync");
function readFileSync(path2, _options = {}) {
  const env_2 = { stack: [], error: void 0, hasError: false };
  try {
    const options = normalizeOptions(_options, null, "r", 420);
    const flag = parse$2(options.flag);
    if (flag & O_WRONLY)
      throw UV("EBADF", "read", path2.toString());
    const file = __addDisposableResource$1(env_2, typeof path2 == "number" ? fromFD(this, path2) : open$4.call(this, path2.toString(), { flag: options.flag, mode: 420, preserveSymlinks: false }), false);
    const { size } = file.stat();
    const data = bufferExports.Buffer.alloc(size);
    file.readSync(data, 0, size, 0);
    return options.encoding ? data.toString(options.encoding) : data;
  } catch (e_2) {
    env_2.error = e_2;
    env_2.hasError = true;
  } finally {
    __disposeResources$1(env_2);
  }
}
__name(readFileSync, "readFileSync");
function writeFileSync(path2, data, _options = {}) {
  const env_3 = { stack: [], error: void 0, hasError: false };
  try {
    const options = normalizeOptions(_options, "utf8", "w+", 420);
    const flag = parse$2(options.flag);
    if (!(flag & O_WRONLY || flag & O_RDWR)) {
      throw new Exception(Errno.EINVAL, "Flag passed to writeFile must allow for writing");
    }
    if (typeof data != "string" && !options.encoding) {
      throw new Exception(Errno.EINVAL, "Encoding not specified");
    }
    const encodedData = typeof data == "string" ? bufferExports.Buffer.from(data, options.encoding) : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    if (!encodedData) {
      throw new Exception(Errno.EINVAL, "Data not specified");
    }
    const file = __addDisposableResource$1(env_3, typeof path2 == "number" ? fromFD(this, path2) : open$4.call(this, path2.toString(), {
      flag,
      mode: options.mode,
      preserveSymlinks: true
    }), false);
    file.writeSync(encodedData, 0, encodedData.byteLength, 0);
    emitChange(this, "change", path2.toString());
  } catch (e_3) {
    env_3.error = e_3;
    env_3.hasError = true;
  } finally {
    __disposeResources$1(env_3);
  }
}
__name(writeFileSync, "writeFileSync");
function appendFileSync(filename, data, _options = {}) {
  const options = normalizeOptions(_options, "utf8", "a+", 420);
  const flag = parse$2(options.flag);
  if (!(flag & O_APPEND)) {
    throw new Exception(Errno.EINVAL, "Flag passed to appendFile must allow for appending");
  }
  if (typeof data != "string" && !options.encoding) {
    throw new Exception(Errno.EINVAL, "Encoding not specified");
  }
  const encodedData = typeof data == "string" ? bufferExports.Buffer.from(data, options.encoding) : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  const file = typeof filename == "number" ? fromFD(this, filename) : open$4.call(this, normalizePath(filename), {
    flag,
    mode: options.mode,
    preserveSymlinks: true
  });
  file.writeSync(encodedData, 0, encodedData.byteLength);
  if (typeof file != "number")
    file.closeSync();
}
__name(appendFileSync, "appendFileSync");
function fstatSync(fd, options) {
  const stats = fromFD(this, fd).stat();
  return options?.bigint ? new BigIntStats(stats) : new Stats(stats);
}
__name(fstatSync, "fstatSync");
function closeSync(fd) {
  fromFD(this, fd).closeSync();
  deleteFD(this, fd);
}
__name(closeSync, "closeSync");
function ftruncateSync(fd, len = 0) {
  len || (len = 0);
  if (len < 0) {
    throw new Exception(Errno.EINVAL);
  }
  fromFD(this, fd).truncateSync(len);
}
__name(ftruncateSync, "ftruncateSync");
function fsyncSync(fd) {
  fromFD(this, fd).syncSync();
}
__name(fsyncSync, "fsyncSync");
function fdatasyncSync(fd) {
  fromFD(this, fd).datasyncSync();
}
__name(fdatasyncSync, "fdatasyncSync");
function writeSync(fd, data, posOrOff, lenOrEnc, pos) {
  let buffer2, offset, length, position;
  if (typeof data === "string") {
    position = typeof posOrOff === "number" ? posOrOff : null;
    const encoding = typeof lenOrEnc === "string" ? lenOrEnc : "utf8";
    offset = 0;
    buffer2 = bufferExports.Buffer.from(data, encoding);
    length = buffer2.byteLength;
  } else {
    buffer2 = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    offset = posOrOff;
    length = lenOrEnc;
    position = typeof pos === "number" ? pos : null;
  }
  const file = fromFD(this, fd);
  position ?? (position = file.position);
  const bytesWritten = file.writeSync(buffer2, offset, length, position);
  emitChange(this, "change", file.path);
  return bytesWritten;
}
__name(writeSync, "writeSync");
function readSync(fd, buffer2, options, length, position) {
  const file = fromFD(this, fd);
  const offset = typeof options == "object" ? options.offset : options;
  if (typeof options == "object") {
    length = options.length;
    position = options.position;
  }
  if (position && position > Number.MAX_SAFE_INTEGER)
    throw UV("EINVAL");
  if (typeof position == "bigint")
    position = Number(position);
  position = Number.isSafeInteger(position) ? position : file.position;
  return file.readSync(buffer2, offset, length, position);
}
__name(readSync, "readSync");
function fchownSync(fd, uid, gid) {
  fromFD(this, fd).chownSync(uid, gid);
}
__name(fchownSync, "fchownSync");
function fchmodSync(fd, mode2) {
  const numMode = normalizeMode(mode2, -1);
  if (numMode < 0) {
    throw new Exception(Errno.EINVAL, `Invalid mode.`);
  }
  fromFD(this, fd).chmodSync(numMode);
}
__name(fchmodSync, "fchmodSync");
function futimesSync(fd, atime, mtime) {
  fromFD(this, fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));
}
__name(futimesSync, "futimesSync");
function rmdirSync(path2) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolve$1(this, path2);
  const stats = wrap$1(fs2, "statSync", path2)(resolved);
  if (!isDirectory(stats))
    throw UV("ENOTDIR", "rmdir", path2);
  if (checkAccess && !hasAccess(this, stats, W_OK))
    throw UV("EACCES", "rmdir", path2);
  wrap$1(fs2, "rmdirSync", path2)(resolved);
  emitChange(this, "rename", path2.toString());
}
__name(rmdirSync, "rmdirSync");
function mkdirSync(path2, options) {
  options = typeof options === "object" ? options : { mode: options };
  const mode2 = normalizeMode(options?.mode, 511);
  return mkdir$4.call(this, path2, { ...options, mode: mode2 });
}
__name(mkdirSync, "mkdirSync");
function readdirSync(path2, options) {
  options = typeof options === "object" ? options : { encoding: options };
  path2 = normalizePath(path2);
  const entries2 = [];
  const rawEntries = readdir$3.call(this, path2, options ?? void 0);
  for (const raw of rawEntries) {
    if (options?.withFileTypes) {
      entries2.push(Dirent.from(raw, options.encoding));
    } else if (options?.encoding == "buffer") {
      entries2.push(bufferExports.Buffer.from(raw.path));
    } else {
      entries2.push(raw.path);
    }
  }
  return entries2;
}
__name(readdirSync, "readdirSync");
function linkSync(targetPath, linkPath) {
  return link$3.call(this, targetPath, linkPath);
}
__name(linkSync, "linkSync");
function symlinkSync(target, path2, type = "file") {
  const env_4 = { stack: [], error: void 0, hasError: false };
  try {
    if (!["file", "dir", "junction"].includes(type))
      throw new TypeError("Invalid symlink type: " + type);
    path2 = normalizePath(path2);
    const file = __addDisposableResource$1(env_4, open$4.call(this, path2, { flag: "wx", mode: 420 }), false);
    file.writeSync(encodeUTF8(normalizePath(target, true)));
    file.chmodSync(S_IFLNK);
  } catch (e_4) {
    env_4.error = e_4;
    env_4.hasError = true;
  } finally {
    __disposeResources$1(env_4);
  }
}
__name(symlinkSync, "symlinkSync");
function readlinkSync(path2, options) {
  const buf = bufferExports.Buffer.from(readlink$3.call(this, path2));
  const encoding = typeof options == "object" ? options?.encoding : options;
  if (encoding == "buffer") {
    return buf;
  }
  return buf.toString(encoding ?? "utf-8");
}
__name(readlinkSync, "readlinkSync");
function chownSync(path2, uid, gid) {
  const env_5 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource$1(env_5, open$4.call(this, path2, { flag: "r+", mode: F_OK }), false);
    handle.chownSync(uid, gid);
  } catch (e_5) {
    env_5.error = e_5;
    env_5.hasError = true;
  } finally {
    __disposeResources$1(env_5);
  }
}
__name(chownSync, "chownSync");
function lchownSync(path2, uid, gid) {
  const fd = lopenSync.call(this, path2, "r+");
  fchownSync.call(this, fd, uid, gid);
  closeSync.call(this, fd);
}
__name(lchownSync, "lchownSync");
function chmodSync(path2, mode2) {
  const fd = openSync.call(this, path2, "r+");
  fchmodSync.call(this, fd, mode2);
  closeSync.call(this, fd);
}
__name(chmodSync, "chmodSync");
function lchmodSync(path2, mode2) {
  const fd = lopenSync.call(this, path2, "r+");
  fchmodSync.call(this, fd, mode2);
  closeSync.call(this, fd);
}
__name(lchmodSync, "lchmodSync");
function utimesSync(path2, atime, mtime) {
  const fd = openSync.call(this, path2, "r+");
  futimesSync.call(this, fd, atime, mtime);
  closeSync.call(this, fd);
}
__name(utimesSync, "utimesSync");
function lutimesSync(path2, atime, mtime) {
  const fd = lopenSync.call(this, path2, "r+");
  futimesSync.call(this, fd, atime, mtime);
  closeSync.call(this, fd);
}
__name(lutimesSync, "lutimesSync");
function realpathSync(path2, options) {
  const encoding = typeof options == "string" ? options : options?.encoding ?? "utf8";
  path2 = normalizePath(path2);
  const { fullPath } = resolve$1(this, path2);
  if (encoding == "utf8" || encoding == "utf-8")
    return fullPath;
  const buf = bufferExports.Buffer.from(fullPath, "utf-8");
  if (encoding == "buffer")
    return buf;
  return buf.toString(encoding);
}
__name(realpathSync, "realpathSync");
function accessSync(path2, mode2 = 384) {
  if (!checkAccess)
    return;
  if (!hasAccess(this, statSync.call(this, path2), mode2)) {
    throw new Exception(Errno.EACCES);
  }
}
__name(accessSync, "accessSync");
function rmSync(path2, options) {
  path2 = normalizePath(path2);
  let stats;
  try {
    stats = lstatSync.bind(this)(path2);
  } catch (error) {
    if (error.code != "ENOENT" || !options?.force)
      throw error;
  }
  if (!stats)
    return;
  switch (stats.mode & S_IFMT) {
    case S_IFDIR:
      if (options?.recursive) {
        for (const entry of readdirSync.call(this, path2)) {
          rmSync.call(this, join(path2, entry), options);
        }
      }
      rmdirSync.call(this, path2);
      break;
    case S_IFREG:
    case S_IFLNK:
    case S_IFBLK:
    case S_IFCHR:
      unlinkSync.call(this, path2);
      break;
    case S_IFIFO:
    case S_IFSOCK:
    default:
      throw UV("ENOSYS", "rm", path2);
  }
}
__name(rmSync, "rmSync");
function mkdtempSync(prefix, options) {
  const encoding = typeof options === "object" ? options?.encoding : options || "utf8";
  const path2 = _tempDirName(prefix);
  mkdirSync.call(this, path2);
  return encoding == "buffer" ? bufferExports.Buffer.from(path2) : path2;
}
__name(mkdtempSync, "mkdtempSync");
function mkdtempDisposableSync(prefix, options) {
  const path2 = _tempDirName(prefix);
  mkdirSync.call(this, path2);
  const remove2 = /* @__PURE__ */ __name(() => rmSync(path2, { recursive: true, force: true }), "remove");
  return { path: path2, remove: remove2, [Symbol.dispose]: remove2 };
}
__name(mkdtempDisposableSync, "mkdtempDisposableSync");
function copyFileSync(source2, destination, flags) {
  source2 = normalizePath(source2);
  destination = normalizePath(destination);
  if (flags && flags & COPYFILE_EXCL && existsSync(destination))
    throw UV("EEXIST", "copyFile", destination);
  writeFileSync.call(this, destination, readFileSync(source2));
  emitChange(this, "rename", destination.toString());
}
__name(copyFileSync, "copyFileSync");
function readvSync(fd, buffers, position) {
  const file = fromFD(this, fd);
  let bytesRead = 0;
  for (const buffer2 of buffers) {
    bytesRead += file.readSync(buffer2, 0, buffer2.byteLength, position + bytesRead);
  }
  return bytesRead;
}
__name(readvSync, "readvSync");
function writevSync(fd, buffers, position) {
  const file = fromFD(this, fd);
  let bytesWritten = 0;
  for (const buffer2 of buffers) {
    bytesWritten += file.writeSync(new Uint8Array(buffer2.buffer), 0, buffer2.byteLength, position + bytesWritten);
  }
  return bytesWritten;
}
__name(writevSync, "writevSync");
function opendirSync(path2, options) {
  path2 = normalizePath(path2);
  return new Dir(path2, this);
}
__name(opendirSync, "opendirSync");
function cpSync(source2, destination, opts) {
  source2 = normalizePath(source2);
  destination = normalizePath(destination);
  const srcStats = lstatSync.call(this, source2);
  if (opts?.errorOnExist && existsSync.call(this, destination))
    throw UV("EEXIST", "cp", destination);
  switch (srcStats.mode & S_IFMT) {
    case S_IFDIR:
      if (!opts?.recursive)
        throw UV("EISDIR", "cp", source2);
      mkdirSync.call(this, destination, { recursive: true });
      for (const dirent of readdirSync.call(this, source2, { withFileTypes: true })) {
        if (opts.filter && !opts.filter(join(source2, dirent.name), join(destination, dirent.name))) {
          continue;
        }
        cpSync.call(this, join(source2, dirent.name), join(destination, dirent.name), opts);
      }
      break;
    case S_IFREG:
    case S_IFLNK:
      copyFileSync.call(this, source2, destination);
      break;
    case S_IFBLK:
    case S_IFCHR:
    case S_IFIFO:
    case S_IFSOCK:
    default:
      throw UV("ENOSYS", "cp", source2);
  }
  if (opts?.preserveTimestamps) {
    utimesSync.call(this, destination, srcStats.atime, srcStats.mtime);
  }
}
__name(cpSync, "cpSync");
function statfsSync(path2, options) {
  path2 = normalizePath(path2);
  const { fs: fs2 } = resolveMount(path2, this);
  return _statfs(fs2, options?.bigint);
}
__name(statfsSync, "statfsSync");
function globSync(pattern2, options = {}) {
  pattern2 = Array.isArray(pattern2) ? pattern2 : [pattern2];
  const { cwd = "/", withFileTypes = false, exclude = /* @__PURE__ */ __name(() => false, "exclude") } = options;
  const regexPatterns = pattern2.map(globToRegex);
  const results = [];
  function recursiveList(dir) {
    const entries2 = readdirSync(dir, { withFileTypes, encoding: "utf8" });
    for (const entry of entries2) {
      const fullPath = withFileTypes ? join(entry.parentPath, entry.name) : dir + "/" + entry;
      if (typeof exclude != "function" ? exclude.some((p) => matchesGlob(p, fullPath)) : exclude(withFileTypes ? entry : fullPath))
        continue;
      if (statSync(fullPath).isDirectory() && regexPatterns.some((pattern3) => pattern3.source.includes(".*"))) {
        recursiveList(fullPath);
      }
      if (regexPatterns.some((pattern3) => pattern3.test(fullPath.replace(/^\/+/g, "")))) {
        results.push(withFileTypes ? entry : fullPath.replace(/^\/+/g, ""));
      }
    }
  }
  __name(recursiveList, "recursiveList");
  recursiveList(cwd);
  return results;
}
__name(globSync, "globSync");
const _Watcher = class _Watcher extends EventEmitter$1 {
  /* eslint-enable @typescript-eslint/no-explicit-any */
  constructor(_context, path2) {
    super();
    __publicField(this, "_context");
    __publicField(this, "path");
    this._context = _context;
    this.path = path2;
  }
  /* eslint-disable @typescript-eslint/no-explicit-any */
  off(event, fn, context, once) {
    return super.off(event, fn, context, once);
  }
  removeListener(event, fn, context, once) {
    return super.removeListener(event, fn, context, once);
  }
  setMaxListeners() {
    throw UV("ENOSYS", "Watcher.setMaxListeners");
  }
  getMaxListeners() {
    throw UV("ENOSYS", "Watcher.getMaxListeners");
  }
  prependListener() {
    throw UV("ENOSYS", "Watcher.prependListener");
  }
  prependOnceListener() {
    throw UV("ENOSYS", "Watcher.prependOnceListener");
  }
  rawListeners() {
    throw UV("ENOSYS", "Watcher.rawListeners");
  }
  ref() {
    return this;
  }
  unref() {
    return this;
  }
};
__name(_Watcher, "Watcher");
let Watcher = _Watcher;
const _FSWatcher = class _FSWatcher extends Watcher {
  constructor(context, path2, options) {
    super(context, path2);
    __publicField(this, "options");
    __publicField(this, "realpath");
    this.options = options;
    this.realpath = context?.root ? join(context.root, path2) : path2;
    addWatcher(this.realpath, this);
  }
  close() {
    super.emit("close");
    removeWatcher(this.realpath, this);
  }
  [Symbol.dispose]() {
    this.close();
  }
};
__name(_FSWatcher, "FSWatcher");
let FSWatcher = _FSWatcher;
const _StatWatcher = class _StatWatcher extends Watcher {
  constructor(context, path2, options) {
    super(context, path2);
    __publicField(this, "options");
    __publicField(this, "intervalId");
    __publicField(this, "previous");
    this.options = options;
    this.start();
  }
  onInterval() {
    try {
      const current = statSync(this.path);
      if (!isStatsEqual(this.previous, current)) {
        this.emit("change", current, this.previous);
        this.previous = current;
      }
    } catch (e2) {
      this.emit("error", e2);
    }
  }
  start() {
    const interval = this.options.interval || 5e3;
    try {
      this.previous = statSync(this.path);
    } catch (e2) {
      this.emit("error", e2);
      return;
    }
    this.intervalId = setInterval(this.onInterval.bind(this), interval);
    if (!this.options.persistent && typeof this.intervalId == "object") {
      this.intervalId.unref();
    }
  }
  /**
   * @internal
   */
  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = void 0;
    }
    this.removeAllListeners();
  }
};
__name(_StatWatcher, "StatWatcher");
let StatWatcher = _StatWatcher;
const watchers = /* @__PURE__ */ new Map();
function addWatcher(path2, watcher) {
  const normalizedPath = normalizePath(path2);
  if (!watchers.has(normalizedPath)) {
    watchers.set(normalizedPath, /* @__PURE__ */ new Set());
  }
  watchers.get(normalizedPath).add(watcher);
}
__name(addWatcher, "addWatcher");
function removeWatcher(path2, watcher) {
  const normalizedPath = normalizePath(path2);
  if (watchers.has(normalizedPath)) {
    watchers.get(normalizedPath).delete(watcher);
    if (watchers.get(normalizedPath).size === 0) {
      watchers.delete(normalizedPath);
    }
  }
}
__name(removeWatcher, "removeWatcher");
function emitChange($, eventType, filename) {
  if ($)
    filename = join($.root ?? "/", filename);
  filename = normalizePath(filename);
  for (let path2 = filename; path2 != "/"; path2 = dirname(path2)) {
    const watchersForPath = watchers.get(path2);
    if (!watchersForPath)
      continue;
    for (const watcher of watchersForPath) {
      watcher.emit("change", eventType, relative.call(watcher._context, path2, filename) || basename(filename));
    }
  }
}
__name(emitChange, "emitChange");
async function resolve($, path2, preserveSymlinks, extra) {
  if (preserveSymlinks) {
    const resolved2 = resolveMount(path2, $, extra);
    const stats2 = await resolved2.fs.stat(resolved2.path).catch(() => void 0);
    return { ...resolved2, fullPath: path2, stats: stats2 };
  }
  try {
    const resolved2 = resolveMount(path2, $);
    const stats2 = await resolved2.fs.stat(resolved2.path);
    if (!isSymbolicLink(stats2)) {
      return { ...resolved2, fullPath: path2, stats: stats2 };
    }
    const target2 = resolve$2.call($, dirname(path2), await readlink$2.call($, path2));
    return await resolve($, target2, preserveSymlinks, extra);
  } catch {
  }
  const { base, dir } = parse$3(path2);
  const realDir = dir == "/" ? "/" : (await resolve($, dir, false, extra)).fullPath;
  const maybePath = join(realDir, base);
  const resolved = resolveMount(maybePath, $);
  const stats = await resolved.fs.stat(resolved.path).catch((e2) => {
    if (e2.code == "ENOENT")
      return;
    throw setUVMessage(Object.assign(e2, { syscall: "stat", path: maybePath }));
  });
  if (!stats)
    return { ...resolved, fullPath: path2 };
  if (!isSymbolicLink(stats)) {
    return { ...resolved, fullPath: maybePath, stats };
  }
  const target = resolve$2.call($, realDir, await readlink$2.call($, maybePath));
  return await resolve($, target, false, extra);
}
__name(resolve, "resolve");
async function open$3($, path2, opt) {
  path2 = normalizePath(path2);
  const mode2 = normalizeMode(opt.mode, 420), flag = parse$2(opt.flag);
  const $ex = { syscall: "open", path: path2 };
  const { fs: fs2, path: resolved, stats } = await resolve($, path2, opt.preserveSymlinks, $ex);
  if (!stats) {
    if (!(flag & O_CREAT))
      throw UV("ENOENT", $ex);
    const parentStats = await fs2.stat(dirname(resolved));
    if (checkAccess && !hasAccess($, parentStats, W_OK))
      throw UV("EACCES", "open", dirname(path2));
    if (!isDirectory(parentStats))
      throw UV("ENOTDIR", "open", dirname(path2));
    if (!opt.allowDirectory && mode2 & S_IFDIR)
      throw UV("EISDIR", "open", path2);
    const { euid: uid, egid: gid } = $?.credentials ?? defaultContext.credentials;
    const inode = await fs2.createFile(resolved, {
      mode: mode2,
      uid: parentStats.mode & S_ISUID ? parentStats.uid : uid,
      gid: parentStats.mode & S_ISGID ? parentStats.gid : gid
    });
    return new Handle($, path2, fs2, resolved, flag, inode);
  }
  if (checkAccess && !hasAccess($, stats, toMode(flag)))
    throw UV("EACCES", $ex);
  if (flag & O_EXCL)
    throw UV("EEXIST", $ex);
  const handle = new Handle($, path2, fs2, resolved, flag, stats);
  if (!opt.allowDirectory && mode2 & S_IFDIR)
    throw UV("EISDIR", "open", path2);
  if (flag & O_TRUNC)
    await handle.truncate(0);
  return handle;
}
__name(open$3, "open$3");
async function readlink$2(path2) {
  path2 = normalizePath(path2);
  const $ex = { syscall: "readlink", path: path2 };
  const { fs: fs2, stats, path: resolved } = await resolve(this, path2, true, $ex);
  if (!stats)
    throw UV("ENOENT", $ex);
  if (checkAccess && !hasAccess(this, stats, R_OK))
    throw UV("EACCES", $ex);
  if (!isSymbolicLink(stats))
    throw UV("EINVAL", $ex);
  const size = stats.size;
  const data = new Uint8Array(size);
  await fs2.read(resolved, data, 0, size);
  return decodeUTF8(data);
}
__name(readlink$2, "readlink$2");
async function mkdir$3(path2, options = {}) {
  path2 = normalizePath(path2);
  const { euid: uid, egid: gid } = this?.credentials ?? defaultContext.credentials;
  const { mode: mode2 = 511, recursive } = options;
  const { fs: fs2, path: resolved } = resolveMount(path2, this, { syscall: "mkdir" });
  const __create = /* @__PURE__ */ __name(async (path3, resolved2, parent) => {
    if (checkAccess && !hasAccess(this, parent, W_OK))
      throw UV("EACCES", "mkdir", path3);
    const inode = await fs2.mkdir(resolved2, {
      mode: mode2,
      uid: parent.mode & S_ISUID ? parent.uid : uid,
      gid: parent.mode & S_ISGID ? parent.gid : gid
    });
    emitChange(this, "rename", path3);
    return inode;
  }, "__create");
  if (!recursive) {
    await __create(path2, resolved, await fs2.stat(dirname(resolved)));
    return;
  }
  const dirs = [];
  let origDir = path2;
  for (let dir = resolved; !await fs2.exists(dir); dir = dirname(dir), origDir = dirname(origDir)) {
    dirs.unshift([origDir, dir]);
  }
  if (!dirs.length)
    return;
  const stats = [await fs2.stat(dirname(dirs[0][1]))];
  for (const [i, [path3, resolved2]] of dirs.entries()) {
    stats.push(await __create(path3, resolved2, stats[i]));
  }
  return dirs[0][0];
}
__name(mkdir$3, "mkdir$3");
async function readdir$2(path2, options = {}) {
  path2 = normalizePath(path2);
  const $ex = { syscall: "readdir", path: path2 };
  const { fs: fs2, path: resolved, stats } = await resolve(this, path2, false, $ex);
  if (!stats)
    throw UV("ENOENT", $ex);
  if (checkAccess && !hasAccess(this, stats, R_OK))
    throw UV("EACCES", $ex);
  if (!isDirectory(stats))
    throw UV("ENOTDIR", $ex);
  const entries2 = await fs2.readdir(resolved);
  const values = [];
  const addEntry = /* @__PURE__ */ __name(async (entry) => {
    const entryStats = await fs2.stat(join(resolved, entry)).catch((e2) => {
      if (e2.code == "ENOENT")
        return;
      throw e2;
    });
    if (!entryStats)
      return;
    const ent = new Dirent$1();
    ent.ino = entryStats.ino;
    ent.type = ifToDt(entryStats.mode);
    ent.path = entry;
    ent.name = basename(entry);
    values.push(ent);
    if (!options.recursive || !isDirectory(entryStats))
      return;
    const children = await fs2.readdir(join(resolved, entry));
    for (const child of children)
      await addEntry(join(entry, child));
  }, "addEntry");
  await Promise.all(entries2.map(addEntry));
  return values;
}
__name(readdir$2, "readdir$2");
async function rename$2(oldPath, newPath) {
  oldPath = normalizePath(oldPath);
  newPath = normalizePath(newPath);
  const $ex = { syscall: "rename", path: oldPath, dest: newPath };
  const src = await resolve(this, oldPath, true, $ex);
  const dst = resolveMount(newPath, this, $ex);
  if (src.fs.uuid !== dst.fs.uuid)
    throw UV("EXDEV", $ex);
  if (dst.path.startsWith(src.path + "/"))
    throw UV("EBUSY", $ex);
  if (!src.stats)
    throw UV("ENOENT", $ex);
  const fs2 = src.fs;
  const oldParent = await fs2.stat(dirname(src.path));
  const newParent = await fs2.stat(dirname(dst.path));
  const newStats = await fs2.stat(dst.path).catch((e2) => {
    if (e2.code == "ENOENT")
      return null;
    throw e2;
  });
  if (checkAccess && (!hasAccess(this, oldParent, R_OK) || !hasAccess(this, newParent, W_OK)))
    throw UV("EACCES", $ex);
  if (newStats && !isDirectory(src.stats) && isDirectory(newStats))
    throw UV("EISDIR", $ex);
  if (newStats && isDirectory(src.stats) && !isDirectory(newStats))
    throw UV("ENOTDIR", $ex);
  await src.fs.rename(src.path, dst.path);
  emitChange(this, "rename", oldPath);
  emitChange(this, "change", newPath);
}
__name(rename$2, "rename$2");
async function link$2(target, link2) {
  target = normalizePath(target);
  link2 = normalizePath(link2);
  const $ex = { syscall: "link", path: link2, dest: target };
  const { fs: fs2, path: resolved } = resolveMount(target, this, $ex);
  const dst = resolveMount(link2, this, $ex);
  if (fs2.uuid != dst.fs.uuid)
    throw UV("EXDEV", $ex);
  const stats = await fs2.stat(resolved);
  if (checkAccess) {
    if (!hasAccess(this, stats, R_OK))
      throw UV("EACCES", $ex);
    const dirStats = await fs2.stat(dirname(resolved));
    if (!hasAccess(this, dirStats, R_OK))
      throw UV("EACCES", $ex);
    const destStats = await fs2.stat(dirname(dst.path));
    if (!hasAccess(this, destStats, W_OK))
      throw UV("EACCES", $ex);
  }
  return await fs2.link(resolved, dst.path);
}
__name(link$2, "link$2");
const _Interface = class _Interface extends EventEmitter$1 {
  constructor(input, output2, completer, terminal = false) {
    super();
    __publicField(this, "input");
    __publicField(this, "output");
    __publicField(this, "terminal");
    __publicField(this, "line", "");
    __publicField(this, "_cursor", 0);
    __publicField(this, "_buffer", "");
    __publicField(this, "_closed", false);
    __publicField(this, "_paused", false);
    __publicField(this, "_prompt", "");
    __publicField(this, "_history", []);
    __publicField(this, "_historyIndex", -1);
    __publicField(this, "_currentLine", "");
    __publicField(this, "_onData", /* @__PURE__ */ __name((data) => {
      if (this._paused || this._closed)
        return;
      this._buffer += typeof data === "string" ? data : data.toString("utf8");
      for (let lineEnd = this._buffer.indexOf("\n"); lineEnd >= 0; lineEnd = this._buffer.indexOf("\n")) {
        let line3 = this._buffer.substring(0, lineEnd);
        if (line3.endsWith("\r")) {
          line3 = line3.substring(0, line3.length - 1);
        }
        this._buffer = this._buffer.substring(lineEnd + 1);
        this.line = line3;
        if (line3.trim() && !line3.trim().match(/^\s*$/) && this._history.at(-1) != line3) {
          this._history.push(line3);
          this._historyIndex = this._history.length;
          this.emit("history", this._history);
        }
        this.emit("line", line3);
      }
    }, "_onData"));
    this.input = input;
    this.output = output2;
    this.terminal = terminal;
    this.input.on("data", this._onData);
    this.input.on("end", this.close.bind(this));
    this.input.on("close", this.close.bind(this));
  }
  get cursor() {
    return this._cursor;
  }
  /**
   * Closes the interface and removes all event listeners
   */
  close() {
    if (this._closed)
      return;
    this._closed = true;
    this.input?.removeAllListeners?.();
    if (this._buffer.length) {
      const line3 = this._buffer;
      this._buffer = "";
      this.line = line3;
      this.emit("line", line3);
    }
    this.emit("history", this._history);
    this.emit("close");
    this.removeAllListeners();
  }
  /**
   * Pauses the input stream
   */
  pause() {
    if (this._paused)
      return this;
    this._paused = true;
    if ("pause" in this.input)
      this.input.pause();
    this.emit("pause");
    return this;
  }
  /**
   * Resumes the input stream
   */
  resume() {
    if (!this._paused)
      return this;
    this._paused = false;
    if ("resume" in this.input)
      this.input.resume();
    this.emit("resume");
    return this;
  }
  /**
   * Sets the prompt text
   */
  setPrompt(prompt) {
    this._prompt = prompt;
  }
  /**
   * Gets the current prompt text
   */
  getPrompt() {
    return this._prompt;
  }
  /**
   * Displays the prompt to the user
   */
  prompt(preserveCursor) {
    if (!this.output)
      return;
    if (!preserveCursor) {
      this.output.write(this._prompt);
      return;
    }
    const { cols } = this.getCursorPos();
    this.output.write(this._prompt);
    this._cursor = cols;
  }
  /**
   * Writes data to the interface and handles key events
   */
  write(data, key) {
    if (this._closed)
      return;
    if (data) {
      const str = typeof data === "string" ? data : data.toString("utf8");
      this._onData(str);
    }
    if (!key || !this.terminal)
      return;
    switch ((key.ctrl ? "^" : "") + key.name) {
      case "^c":
        this.emit("SIGINT");
        break;
      case "^z":
        this.emit("SIGTSTP");
        break;
      case "^q":
        this.emit("SIGCONT");
        break;
      case "home":
      case "^a":
        if (!this.output)
          return;
        moveCursor(this.output, -this._cursor, 0);
        this._cursor = 0;
        this._cursor = 0;
        break;
      case "^e":
      case "end": {
        if (!this.output)
          return;
        const dx = this.line.length - this._cursor;
        if (!dx)
          return;
        moveCursor(this.output, dx, 0);
        this._cursor = this.line.length;
        this._cursor = this.line.length;
        break;
      }
      case "^k": {
        if (!this.output)
          return;
        if (this._cursor >= this.line.length)
          return;
        const newLine = this.line.slice(0, this._cursor);
        clearLine(this.output, 1);
        this.line = newLine;
        break;
      }
      case "^u": {
        if (!this.output || !this._cursor)
          return;
        const newLine = this.line.slice(this._cursor);
        clearLine(this.output, 0);
        moveCursor(this.output, 0, 0);
        this.output.write(this._prompt + newLine);
        this.line = newLine;
        this._cursor = 0;
        this._cursor = 0;
        break;
      }
      case "^w": {
        if (!this.output || !this._cursor)
          return;
        let i = this._cursor - 1;
        while (i >= 0 && this.line[i] === " ")
          i--;
        while (i >= 0 && this.line[i] !== " ")
          i--;
        const newLine = this.line.slice(0, i + 1) + this.line.slice(this._cursor);
        const newCursorPos = i + 1;
        this._renderLine(newLine);
        this._cursor = newCursorPos;
        this._cursor = newCursorPos;
        moveCursor(this.output, -newLine.length, 0);
        moveCursor(this.output, newCursorPos, 0);
        break;
      }
      case "^return":
      case "^enter":
        this._onData("\n");
        break;
      case "return":
      case "enter":
        this._onData((!data ? "" : typeof data == "string" ? data : data.toString("utf8")) + "\n");
        break;
      case "up":
      case "down": {
        if (!this.output || !this._history.length)
          return;
        if (this._historyIndex === this._history.length) {
          this._currentLine = this.line || "";
        }
        if (key.name == "up" && this._historyIndex > 0) {
          this._historyIndex--;
        } else if (key.name == "down" && this._historyIndex < this._history.length - 1) {
          this._historyIndex++;
        } else if (key.name == "down" && this._historyIndex == this._history.length - 1) {
          this._historyIndex = this._history.length;
          this._renderLine(this._currentLine);
          return;
        } else {
          return;
        }
        const historyItem = this._history[this._historyIndex];
        this._renderLine(historyItem);
        break;
      }
      case "left":
      case "right": {
        const dx = key.name == "left" ? -1 : 1;
        if (!this.output)
          return;
        const newPos = Math.max(0, Math.min(this.line.length, this._cursor + dx));
        if (newPos == this._cursor)
          return;
        moveCursor(this.output, dx, 0);
        this._cursor = newPos;
        this._cursor = newPos;
        break;
      }
      case "backspace": {
        if (!this.output || !this._cursor)
          return;
        const newLine = this.line.slice(0, this._cursor - 1) + this.line.slice(this._cursor);
        this._renderLine(newLine);
        this._cursor = --this._cursor;
        if (this._cursor > 0) {
          moveCursor(this.output, -this._cursor, 0);
          moveCursor(this.output, this._cursor, 0);
        }
        break;
      }
      case "delete": {
        if (!this.output)
          return;
        if (this._cursor >= this.line.length)
          return;
        const newLine = this.line.slice(0, this._cursor) + this.line.slice(this._cursor + 1);
        clearLine(this.output, 0);
        moveCursor(this.output, 0, 0);
        this.output.write(this._prompt + newLine);
        this.line = newLine;
        moveCursor(this.output, -newLine.length, 0);
        moveCursor(this.output, this._cursor, 0);
        break;
      }
    }
  }
  _renderLine(text) {
    if (!this.output)
      return;
    clearLine(this.output, 0);
    moveCursor(this.output, 0, 0);
    this.output.write(this._prompt + text);
    this.line = text;
    this._cursor = text.length;
    this._cursor = text.length;
  }
  question(query, optionsOrCallback, maybeCallback) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback;
    if (this._closed || !this.output) {
      callback("");
      return;
    }
    this.output.write(query);
    this.once("line", callback);
  }
  /**
   * Gets the current cursor position
   */
  getCursorPos() {
    return { rows: 0, cols: this.cursor };
  }
  /**
   * Prepends a listener for the specified event
   */
  prependListener(event, listener) {
    const listeners = this.listeners(event);
    this.removeAllListeners(event);
    this.on(event, listener);
    listeners.forEach(this.on.bind(this, event));
    return this;
  }
  /**
   * Prepends a one-time listener for the specified event
   */
  prependOnceListener(event, listener) {
    const listeners = this.listeners(event);
    this.removeAllListeners(event);
    this.once(event, listener);
    listeners.forEach(this.on.bind(this, event));
    return this;
  }
  /**
   * Sets the maximum number of listeners
   */
  setMaxListeners() {
    warn("Interface.prototype.setMaxListeners is not supported");
    return this;
  }
  /**
   * Gets the maximum number of listeners
   */
  getMaxListeners() {
    warn("Interface.prototype.getMaxListeners is not supported");
    return 10;
  }
  [Symbol.asyncIterator]() {
    let done = false;
    return {
      next: /* @__PURE__ */ __name(async () => {
        if (done)
          return { done, value: void 0 };
        const { resolve: resolve2, promise } = Promise.withResolvers();
        this.once("line", (line3) => resolve2({ value: line3, done: false }));
        this.once("close", () => {
          done = true;
          resolve2({ value: void 0, done });
        });
        return promise;
      }, "next"),
      return: /* @__PURE__ */ __name(async (value) => {
        if (done)
          return { done, value };
        done = true;
        this.close();
        return { done, value };
      }, "return"),
      throw: /* @__PURE__ */ __name(async (error) => {
        if (!done) {
          done = true;
          this.close();
        }
        throw error;
      }, "throw"),
      [Symbol.asyncIterator]() {
        return this;
      },
      [Symbol.asyncDispose]: async () => {
        if (done)
          return;
        done = true;
        this.close();
      }
    };
  }
  [Symbol.dispose]() {
    this.close();
  }
  async [Symbol.asyncDispose]() {
    if (this._closed)
      return;
    const { resolve: resolve2, promise } = Promise.withResolvers();
    this.once("close", () => resolve2());
    this.close();
    await promise;
  }
  rawListeners(event) {
    return this.listeners(event);
  }
};
__name(_Interface, "Interface");
let Interface = _Interface;
function createInterface(input, output2, completer, terminal) {
  return "input" in input ? new Interface(input.input, input.output, input.completer, input.terminal) : new Interface(input, output2, completer, terminal);
}
__name(createInterface, "createInterface");
function clearLine(stream2, dir) {
  stream2.write(dir >= 0 ? "\r\x1B[K" : "\x1B[K");
  return true;
}
__name(clearLine, "clearLine");
function moveCursor(stream2, dx, dy) {
  if (!stream2.write)
    return false;
  let cmd = "";
  if (dx < 0) {
    cmd += `\x1B[${-dx}D`;
  } else if (dx > 0) {
    cmd += `\x1B[${dx}C`;
  }
  if (dy < 0) {
    cmd += `\x1B[${-dy}A`;
  } else if (dy > 0) {
    cmd += `\x1B[${dy}B`;
  }
  if (cmd)
    stream2.write(cmd);
  return true;
}
__name(moveCursor, "moveCursor");
var browser$4 = { exports: {} };
var stream = { exports: {} };
var primordials;
var hasRequiredPrimordials;
function requirePrimordials() {
  if (hasRequiredPrimordials) return primordials;
  hasRequiredPrimordials = 1;
  primordials = {
    ArrayIsArray(self2) {
      return Array.isArray(self2);
    },
    ArrayPrototypeIncludes(self2, el) {
      return self2.includes(el);
    },
    ArrayPrototypeIndexOf(self2, el) {
      return self2.indexOf(el);
    },
    ArrayPrototypeJoin(self2, sep2) {
      return self2.join(sep2);
    },
    ArrayPrototypeMap(self2, fn) {
      return self2.map(fn);
    },
    ArrayPrototypePop(self2, el) {
      return self2.pop(el);
    },
    ArrayPrototypePush(self2, el) {
      return self2.push(el);
    },
    ArrayPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    },
    Error,
    FunctionPrototypeCall(fn, thisArgs, ...args) {
      return fn.call(thisArgs, ...args);
    },
    FunctionPrototypeSymbolHasInstance(self2, instance2) {
      return Function.prototype[Symbol.hasInstance].call(self2, instance2);
    },
    MathFloor: Math.floor,
    Number,
    NumberIsInteger: Number.isInteger,
    NumberIsNaN: Number.isNaN,
    NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
    NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
    NumberParseInt: Number.parseInt,
    ObjectDefineProperties(self2, props) {
      return Object.defineProperties(self2, props);
    },
    ObjectDefineProperty(self2, name, prop) {
      return Object.defineProperty(self2, name, prop);
    },
    ObjectGetOwnPropertyDescriptor(self2, name) {
      return Object.getOwnPropertyDescriptor(self2, name);
    },
    ObjectKeys(obj) {
      return Object.keys(obj);
    },
    ObjectSetPrototypeOf(target, proto2) {
      return Object.setPrototypeOf(target, proto2);
    },
    Promise,
    PromisePrototypeCatch(self2, fn) {
      return self2.catch(fn);
    },
    PromisePrototypeThen(self2, thenFn, catchFn) {
      return self2.then(thenFn, catchFn);
    },
    PromiseReject(err2) {
      return Promise.reject(err2);
    },
    PromiseResolve(val) {
      return Promise.resolve(val);
    },
    ReflectApply: Reflect.apply,
    RegExpPrototypeTest(self2, value) {
      return self2.test(value);
    },
    SafeSet: Set,
    String,
    StringPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    },
    StringPrototypeToLowerCase(self2) {
      return self2.toLowerCase();
    },
    StringPrototypeToUpperCase(self2) {
      return self2.toUpperCase();
    },
    StringPrototypeTrim(self2) {
      return self2.trim();
    },
    Symbol,
    SymbolFor: Symbol.for,
    SymbolAsyncIterator: Symbol.asyncIterator,
    SymbolHasInstance: Symbol.hasInstance,
    SymbolIterator: Symbol.iterator,
    SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
    SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
    TypedArrayPrototypeSet(self2, buf, len) {
      return self2.set(buf, len);
    },
    Boolean,
    Uint8Array
  };
  return primordials;
}
__name(requirePrimordials, "requirePrimordials");
var util$1 = { exports: {} };
var browser$3 = { exports: {} };
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$3.exports;
  hasRequiredBrowser$4 = 1;
  const { AbortController, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
    /* otherwise */
    void 0
  );
  browser$3.exports = AbortController;
  browser$3.exports.AbortSignal = AbortSignal;
  browser$3.exports.default = AbortController;
  return browser$3.exports;
}
__name(requireBrowser$4, "requireBrowser$4");
var events = { exports: {} };
var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var R = typeof Reflect === "object" ? Reflect : null;
  var ReflectApply = R && typeof R.apply === "function" ? R.apply : /* @__PURE__ */ __name(function ReflectApply2(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }, "ReflectApply");
  var ReflectOwnKeys;
  if (R && typeof R.ownKeys === "function") {
    ReflectOwnKeys = R.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = /* @__PURE__ */ __name(function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    }, "ReflectOwnKeys");
  } else {
    ReflectOwnKeys = /* @__PURE__ */ __name(function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target);
    }, "ReflectOwnKeys");
  }
  function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
  }
  __name(ProcessEmitWarning, "ProcessEmitWarning");
  var NumberIsNaN = Number.isNaN || /* @__PURE__ */ __name(function NumberIsNaN2(value) {
    return value !== value;
  }, "NumberIsNaN");
  function EventEmitter2() {
    EventEmitter2.init.call(this);
  }
  __name(EventEmitter2, "EventEmitter");
  events.exports = EventEmitter2;
  events.exports.once = once;
  EventEmitter2.EventEmitter = EventEmitter2;
  EventEmitter2.prototype._events = void 0;
  EventEmitter2.prototype._eventsCount = 0;
  EventEmitter2.prototype._maxListeners = void 0;
  var defaultMaxListeners = 10;
  function checkListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }
  __name(checkListener, "checkListener");
  Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
    enumerable: true,
    get: /* @__PURE__ */ __name(function() {
      return defaultMaxListeners;
    }, "get"),
    set: /* @__PURE__ */ __name(function(arg) {
      if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
      }
      defaultMaxListeners = arg;
    }, "set")
  });
  EventEmitter2.init = function() {
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter2.prototype.setMaxListeners = /* @__PURE__ */ __name(function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    }
    this._maxListeners = n;
    return this;
  }, "setMaxListeners");
  function _getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter2.defaultMaxListeners;
    return that._maxListeners;
  }
  __name(_getMaxListeners, "_getMaxListeners");
  EventEmitter2.prototype.getMaxListeners = /* @__PURE__ */ __name(function getMaxListeners() {
    return _getMaxListeners(this);
  }, "getMaxListeners");
  EventEmitter2.prototype.emit = /* @__PURE__ */ __name(function emit(type) {
    var args = [];
    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
    var doError = type === "error";
    var events2 = this._events;
    if (events2 !== void 0)
      doError = doError && events2.error === void 0;
    else if (!doError)
      return false;
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        throw er;
      }
      var err2 = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
      err2.context = er;
      throw err2;
    }
    var handler = events2[type];
    if (handler === void 0)
      return false;
    if (typeof handler === "function") {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        ReflectApply(listeners[i], this, args);
    }
    return true;
  }, "emit");
  function _addListener(target, type, listener, prepend) {
    var m;
    var events2;
    var existing;
    checkListener(listener);
    events2 = target._events;
    if (events2 === void 0) {
      events2 = target._events = /* @__PURE__ */ Object.create(null);
      target._eventsCount = 0;
    } else {
      if (events2.newListener !== void 0) {
        target.emit(
          "newListener",
          type,
          listener.listener ? listener.listener : listener
        );
        events2 = target._events;
      }
      existing = events2[type];
    }
    if (existing === void 0) {
      existing = events2[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      m = _getMaxListeners(target);
      if (m > 0 && existing.length > m && !existing.warned) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        ProcessEmitWarning(w);
      }
    }
    return target;
  }
  __name(_addListener, "_addListener");
  EventEmitter2.prototype.addListener = /* @__PURE__ */ __name(function addListener2(type, listener) {
    return _addListener(this, type, listener, false);
  }, "addListener");
  EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
  EventEmitter2.prototype.prependListener = /* @__PURE__ */ __name(function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  }, "prependListener");
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }
  __name(onceWrapper, "onceWrapper");
  function _onceWrap(target, type, listener) {
    var state2 = { fired: false, wrapFn: void 0, target, type, listener };
    var wrapped = onceWrapper.bind(state2);
    wrapped.listener = listener;
    state2.wrapFn = wrapped;
    return wrapped;
  }
  __name(_onceWrap, "_onceWrap");
  EventEmitter2.prototype.once = /* @__PURE__ */ __name(function once2(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
  }, "once");
  EventEmitter2.prototype.prependOnceListener = /* @__PURE__ */ __name(function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  }, "prependOnceListener");
  EventEmitter2.prototype.removeListener = /* @__PURE__ */ __name(function removeListener2(type, listener) {
    var list2, events2, position, i, originalListener;
    checkListener(listener);
    events2 = this._events;
    if (events2 === void 0)
      return this;
    list2 = events2[type];
    if (list2 === void 0)
      return this;
    if (list2 === listener || list2.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else {
        delete events2[type];
        if (events2.removeListener)
          this.emit("removeListener", type, list2.listener || listener);
      }
    } else if (typeof list2 !== "function") {
      position = -1;
      for (i = list2.length - 1; i >= 0; i--) {
        if (list2[i] === listener || list2[i].listener === listener) {
          originalListener = list2[i].listener;
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list2.shift();
      else {
        spliceOne(list2, position);
      }
      if (list2.length === 1)
        events2[type] = list2[0];
      if (events2.removeListener !== void 0)
        this.emit("removeListener", type, originalListener || listener);
    }
    return this;
  }, "removeListener");
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(type) {
    var listeners, events2, i;
    events2 = this._events;
    if (events2 === void 0)
      return this;
    if (events2.removeListener === void 0) {
      if (arguments.length === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      } else if (events2[type] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else
          delete events2[type];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys = Object.keys(events2);
      var key;
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        if (key === "removeListener") continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners = events2[type];
    if (typeof listeners === "function") {
      this.removeListener(type, listeners);
    } else if (listeners !== void 0) {
      for (i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(type, listeners[i]);
      }
    }
    return this;
  }, "removeAllListeners");
  function _listeners(target, type, unwrap) {
    var events2 = target._events;
    if (events2 === void 0)
      return [];
    var evlistener = events2[type];
    if (evlistener === void 0)
      return [];
    if (typeof evlistener === "function")
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  __name(_listeners, "_listeners");
  EventEmitter2.prototype.listeners = /* @__PURE__ */ __name(function listeners(type) {
    return _listeners(this, type, true);
  }, "listeners");
  EventEmitter2.prototype.rawListeners = /* @__PURE__ */ __name(function rawListeners(type) {
    return _listeners(this, type, false);
  }, "rawListeners");
  EventEmitter2.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };
  EventEmitter2.prototype.listenerCount = listenerCount;
  function listenerCount(type) {
    var events2 = this._events;
    if (events2 !== void 0) {
      var evlistener = events2[type];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener !== void 0) {
        return evlistener.length;
      }
    }
    return 0;
  }
  __name(listenerCount, "listenerCount");
  EventEmitter2.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  }, "eventNames");
  function arrayClone(arr, n) {
    var copy2 = new Array(n);
    for (var i = 0; i < n; ++i)
      copy2[i] = arr[i];
    return copy2;
  }
  __name(arrayClone, "arrayClone");
  function spliceOne(list2, index) {
    for (; index + 1 < list2.length; index++)
      list2[index] = list2[index + 1];
    list2.pop();
  }
  __name(spliceOne, "spliceOne");
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }
  __name(unwrapListeners, "unwrapListeners");
  function once(emitter, name) {
    return new Promise(function(resolve2, reject) {
      function errorListener(err2) {
        emitter.removeListener(name, resolver);
        reject(err2);
      }
      __name(errorListener, "errorListener");
      function resolver() {
        if (typeof emitter.removeListener === "function") {
          emitter.removeListener("error", errorListener);
        }
        resolve2([].slice.call(arguments));
      }
      __name(resolver, "resolver");
      eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
      if (name !== "error") {
        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
      }
    });
  }
  __name(once, "once");
  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") {
      eventTargetAgnosticAddListener(emitter, "error", handler, flags);
    }
  }
  __name(addErrorHandlerIfEventEmitter, "addErrorHandlerIfEventEmitter");
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, /* @__PURE__ */ __name(function wrapListener(arg) {
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg);
      }, "wrapListener"));
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }
  __name(eventTargetAgnosticAddListener, "eventTargetAgnosticAddListener");
  return events.exports;
}
__name(requireEvents, "requireEvents");
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1.exports;
  hasRequiredUtil$1 = 1;
  (function(module) {
    const bufferModule = requireBuffer();
    const { kResistStopPropagation, SymbolDispose } = requirePrimordials();
    const AbortSignal = globalThis.AbortSignal || requireBrowser$4().AbortSignal;
    const AbortController = globalThis.AbortController || requireBrowser$4().AbortController;
    const AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    const Blob2 = globalThis.Blob || bufferModule.Blob;
    const isBlob = typeof Blob2 !== "undefined" ? /* @__PURE__ */ __name(function isBlob2(b) {
      return b instanceof Blob2;
    }, "isBlob") : /* @__PURE__ */ __name(function isBlob2(b) {
      return false;
    }, "isBlob");
    const validateAbortSignal = /* @__PURE__ */ __name((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    }, "validateAbortSignal");
    const validateFunction = /* @__PURE__ */ __name((value, name) => {
      if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    }, "validateFunction");
    const _AggregateError = class _AggregateError extends Error {
      constructor(errors2) {
        if (!Array.isArray(errors2)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors2}`);
        }
        let message = "";
        for (let i = 0; i < errors2.length; i++) {
          message += `    ${errors2[i].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors2;
      }
    };
    __name(_AggregateError, "AggregateError");
    let AggregateError = _AggregateError;
    module.exports = {
      AggregateError,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: /* @__PURE__ */ __name(function() {
        let resolve2;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve2 = res;
          reject = rej;
        });
        return {
          promise,
          resolve: resolve2,
          reject
        };
      }, "createDeferredPromise"),
      promisify(fn) {
        return new Promise((resolve2, reject) => {
          fn((err2, ...args) => {
            if (err2) {
              return reject(err2);
            }
            return resolve2(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format(format2, ...args) {
        return format2.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob,
      deprecate(fn, message) {
        return fn;
      },
      addAbortListener: requireEvents().addAbortListener || /* @__PURE__ */ __name(function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = /* @__PURE__ */ __name(() => {
            signal.removeEventListener("abort", listener);
          }, "removeEventListener");
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      }, "addAbortListener"),
      AbortSignalAny: AbortSignal.any || /* @__PURE__ */ __name(function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController();
        const abort = /* @__PURE__ */ __name(() => ac.abort(), "abort");
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort, {
            once: true
          });
        });
        ac.signal.addEventListener(
          "abort",
          () => {
            signals.forEach((signal) => signal.removeEventListener("abort", abort));
          },
          {
            once: true
          }
        );
        return ac.signal;
      }, "AbortSignalAny")
    };
    module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  })(util$1);
  return util$1.exports;
}
__name(requireUtil$1, "requireUtil$1");
var operators = {};
var errors;
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  const { format: format2, inspect: inspect2, AggregateError: CustomAggregateError } = requireUtil$1();
  const AggregateError = globalThis.AggregateError || CustomAggregateError;
  const kIsNodeError = Symbol("kIsNodeError");
  const kTypes = [
    "string",
    "function",
    "number",
    "object",
    // Accept 'Function' and 'Object' as alternative to the lower cased version.
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol"
  ];
  const classRegExp = /^([A-Z][a-z0-9]*)+$/;
  const nodeInternalPrefix = "__node_internal_";
  const codes = {};
  function assert(value, message) {
    if (!value) {
      throw new codes.ERR_INTERNAL_ASSERTION(message);
    }
  }
  __name(assert, "assert");
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  __name(addNumericalSeparator, "addNumericalSeparator");
  function getMessage(key, msg, args) {
    if (typeof msg === "function") {
      assert(
        msg.length <= args.length,
        // Default options do not count.
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
      );
      return msg(...args);
    }
    const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
    assert(
      expectedLength === args.length,
      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
    );
    if (args.length === 0) {
      return msg;
    }
    return format2(msg, ...args);
  }
  __name(getMessage, "getMessage");
  function E(code2, message, Base) {
    if (!Base) {
      Base = Error;
    }
    const _NodeError = class _NodeError extends Base {
      constructor(...args) {
        super(getMessage(code2, message, args));
      }
      toString() {
        return `${this.name} [${code2}]: ${this.message}`;
      }
    };
    __name(_NodeError, "NodeError");
    let NodeError = _NodeError;
    Object.defineProperties(NodeError.prototype, {
      name: {
        value: Base.name,
        writable: true,
        enumerable: false,
        configurable: true
      },
      toString: {
        value() {
          return `${this.name} [${code2}]: ${this.message}`;
        },
        writable: true,
        enumerable: false,
        configurable: true
      }
    });
    NodeError.prototype.code = code2;
    NodeError.prototype[kIsNodeError] = true;
    codes[code2] = NodeError;
  }
  __name(E, "E");
  function hideStackFrames(fn) {
    const hidden = nodeInternalPrefix + fn.name;
    Object.defineProperty(fn, "name", {
      value: hidden
    });
    return fn;
  }
  __name(hideStackFrames, "hideStackFrames");
  function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
      if (Array.isArray(outerError.errors)) {
        outerError.errors.push(innerError);
        return outerError;
      }
      const err2 = new AggregateError([outerError, innerError], outerError.message);
      err2.code = outerError.code;
      return err2;
    }
    return innerError || outerError;
  }
  __name(aggregateTwoErrors, "aggregateTwoErrors");
  const _AbortError = class _AbortError extends Error {
    constructor(message = "The operation was aborted", options = void 0) {
      if (options !== void 0 && typeof options !== "object") {
        throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
      }
      super(message, options);
      this.code = "ABORT_ERR";
      this.name = "AbortError";
    }
  };
  __name(_AbortError, "AbortError");
  let AbortError = _AbortError;
  E("ERR_ASSERTION", "%s", Error);
  E(
    "ERR_INVALID_ARG_TYPE",
    (name, expected, actual) => {
      assert(typeof name === "string", "'name' must be a string");
      if (!Array.isArray(expected)) {
        expected = [expected];
      }
      let msg = "The ";
      if (name.endsWith(" argument")) {
        msg += `${name} `;
      } else {
        msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
      }
      msg += "must be ";
      const types2 = [];
      const instances = [];
      const other = [];
      for (const value of expected) {
        assert(typeof value === "string", "All expected entries have to be of type string");
        if (kTypes.includes(value)) {
          types2.push(value.toLowerCase());
        } else if (classRegExp.test(value)) {
          instances.push(value);
        } else {
          assert(value !== "object", 'The value "object" should be written as "Object"');
          other.push(value);
        }
      }
      if (instances.length > 0) {
        const pos = types2.indexOf("object");
        if (pos !== -1) {
          types2.splice(types2, pos, 1);
          instances.push("Object");
        }
      }
      if (types2.length > 0) {
        switch (types2.length) {
          case 1:
            msg += `of type ${types2[0]}`;
            break;
          case 2:
            msg += `one of type ${types2[0]} or ${types2[1]}`;
            break;
          default: {
            const last = types2.pop();
            msg += `one of type ${types2.join(", ")}, or ${last}`;
          }
        }
        if (instances.length > 0 || other.length > 0) {
          msg += " or ";
        }
      }
      if (instances.length > 0) {
        switch (instances.length) {
          case 1:
            msg += `an instance of ${instances[0]}`;
            break;
          case 2:
            msg += `an instance of ${instances[0]} or ${instances[1]}`;
            break;
          default: {
            const last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
          }
        }
        if (other.length > 0) {
          msg += " or ";
        }
      }
      switch (other.length) {
        case 0:
          break;
        case 1:
          if (other[0].toLowerCase() !== other[0]) {
            msg += "an ";
          }
          msg += `${other[0]}`;
          break;
        case 2:
          msg += `one of ${other[0]} or ${other[1]}`;
          break;
        default: {
          const last = other.pop();
          msg += `one of ${other.join(", ")}, or ${last}`;
        }
      }
      if (actual == null) {
        msg += `. Received ${actual}`;
      } else if (typeof actual === "function" && actual.name) {
        msg += `. Received function ${actual.name}`;
      } else if (typeof actual === "object") {
        var _actual$constructor;
        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
          msg += `. Received an instance of ${actual.constructor.name}`;
        } else {
          const inspected = inspect2(actual, {
            depth: -1
          });
          msg += `. Received ${inspected}`;
        }
      } else {
        let inspected = inspect2(actual, {
          colors: false
        });
        if (inspected.length > 25) {
          inspected = `${inspected.slice(0, 25)}...`;
        }
        msg += `. Received type ${typeof actual} (${inspected})`;
      }
      return msg;
    },
    TypeError
  );
  E(
    "ERR_INVALID_ARG_VALUE",
    (name, value, reason = "is invalid") => {
      let inspected = inspect2(value);
      if (inspected.length > 128) {
        inspected = inspected.slice(0, 128) + "...";
      }
      const type = name.includes(".") ? "property" : "argument";
      return `The ${type} '${name}' ${reason}. Received ${inspected}`;
    },
    TypeError
  );
  E(
    "ERR_INVALID_RETURN_VALUE",
    (input, name, value) => {
      var _value$constructor;
      const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
      return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
    },
    TypeError
  );
  E(
    "ERR_MISSING_ARGS",
    (...args) => {
      assert(args.length > 0, "At least one arg needs to be specified");
      let msg;
      const len = args.length;
      args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
      switch (len) {
        case 1:
          msg += `The ${args[0]} argument`;
          break;
        case 2:
          msg += `The ${args[0]} and ${args[1]} arguments`;
          break;
        default:
          {
            const last = args.pop();
            msg += `The ${args.join(", ")}, and ${last} arguments`;
          }
          break;
      }
      return `${msg} must be specified`;
    },
    TypeError
  );
  E(
    "ERR_OUT_OF_RANGE",
    (str, range2, input) => {
      assert(range2, 'Missing "range" argument');
      let received;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > 2n ** 32n || input < -(2n ** 32n)) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      } else {
        received = inspect2(input);
      }
      return `The value of "${str}" is out of range. It must be ${range2}. Received ${received}`;
    },
    RangeError
  );
  E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
  E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
  E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
  E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
  E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
  E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
  E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
  E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
  E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
  E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
  errors = {
    AbortError,
    aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
    hideStackFrames,
    codes
  };
  return errors;
}
__name(requireErrors, "requireErrors");
var validators;
var hasRequiredValidators;
function requireValidators() {
  if (hasRequiredValidators) return validators;
  hasRequiredValidators = 1;
  const {
    ArrayIsArray,
    ArrayPrototypeIncludes,
    ArrayPrototypeJoin,
    ArrayPrototypeMap,
    NumberIsInteger,
    NumberIsNaN,
    NumberMAX_SAFE_INTEGER,
    NumberMIN_SAFE_INTEGER,
    NumberParseInt,
    ObjectPrototypeHasOwnProperty,
    RegExpPrototypeExec,
    String: String2,
    StringPrototypeToUpperCase,
    StringPrototypeTrim
  } = requirePrimordials();
  const {
    hideStackFrames,
    codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
  } = requireErrors();
  const { normalizeEncoding } = requireUtil$1();
  const { isAsyncFunction: isAsyncFunction2, isArrayBufferView } = requireUtil$1().types;
  const signals = {};
  function isInt32(value) {
    return value === (value | 0);
  }
  __name(isInt32, "isInt32");
  function isUint32(value) {
    return value === value >>> 0;
  }
  __name(isUint32, "isUint32");
  const octalReg = /^[0-7]+$/;
  const modeDesc = "must be a 32-bit unsigned integer or an octal string";
  function parseFileMode(value, name, def) {
    if (typeof value === "undefined") {
      value = def;
    }
    if (typeof value === "string") {
      if (RegExpPrototypeExec(octalReg, value) === null) {
        throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
      }
      value = NumberParseInt(value, 8);
    }
    validateUint32(value, name);
    return value;
  }
  __name(parseFileMode, "parseFileMode");
  const validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
    if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
  });
  const validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
    if (typeof value !== "number") {
      throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    }
    if (!NumberIsInteger(value)) {
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
  });
  const validateUint32 = hideStackFrames((value, name, positive = false) => {
    if (typeof value !== "number") {
      throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    }
    if (!NumberIsInteger(value)) {
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min = positive ? 1 : 0;
    const max = 4294967295;
    if (value < min || value > max) {
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
  });
  function validateString(value, name) {
    if (typeof value !== "string") throw new ERR_INVALID_ARG_TYPE2(name, "string", value);
  }
  __name(validateString, "validateString");
  function validateNumber(value, name, min = void 0, max) {
    if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
      throw new ERR_OUT_OF_RANGE(
        name,
        `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
        value
      );
    }
  }
  __name(validateNumber, "validateNumber");
  const validateOneOf = hideStackFrames((value, name, oneOf) => {
    if (!ArrayPrototypeIncludes(oneOf, value)) {
      const allowed = ArrayPrototypeJoin(
        ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
        ", "
      );
      const reason = "must be one of: " + allowed;
      throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
  });
  function validateBoolean(value, name) {
    if (typeof value !== "boolean") throw new ERR_INVALID_ARG_TYPE2(name, "boolean", value);
  }
  __name(validateBoolean, "validateBoolean");
  function getOwnPropertyValueOrDefault(options, key, defaultValue) {
    return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
  }
  __name(getOwnPropertyValueOrDefault, "getOwnPropertyValueOrDefault");
  const validateObject2 = hideStackFrames((value, name, options = null) => {
    const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
    const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
    const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
    if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
      throw new ERR_INVALID_ARG_TYPE2(name, "Object", value);
    }
  });
  const validateDictionary = hideStackFrames((value, name) => {
    if (value != null && typeof value !== "object" && typeof value !== "function") {
      throw new ERR_INVALID_ARG_TYPE2(name, "a dictionary", value);
    }
  });
  const validateArray = hideStackFrames((value, name, minLength = 0) => {
    if (!ArrayIsArray(value)) {
      throw new ERR_INVALID_ARG_TYPE2(name, "Array", value);
    }
    if (value.length < minLength) {
      const reason = `must be longer than ${minLength}`;
      throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
  });
  function validateStringArray(value, name) {
    validateArray(value, name);
    for (let i = 0; i < value.length; i++) {
      validateString(value[i], `${name}[${i}]`);
    }
  }
  __name(validateStringArray, "validateStringArray");
  function validateBooleanArray(value, name) {
    validateArray(value, name);
    for (let i = 0; i < value.length; i++) {
      validateBoolean(value[i], `${name}[${i}]`);
    }
  }
  __name(validateBooleanArray, "validateBooleanArray");
  function validateAbortSignalArray(value, name) {
    validateArray(value, name);
    for (let i = 0; i < value.length; i++) {
      const signal = value[i];
      const indexedName = `${name}[${i}]`;
      if (signal == null) {
        throw new ERR_INVALID_ARG_TYPE2(indexedName, "AbortSignal", signal);
      }
      validateAbortSignal(signal, indexedName);
    }
  }
  __name(validateAbortSignalArray, "validateAbortSignalArray");
  function validateSignalName(signal, name = "signal") {
    validateString(signal, name);
    if (signals[signal] === void 0) {
      if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
        throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
      }
      throw new ERR_UNKNOWN_SIGNAL(signal);
    }
  }
  __name(validateSignalName, "validateSignalName");
  const validateBuffer = hideStackFrames((buffer2, name = "buffer") => {
    if (!isArrayBufferView(buffer2)) {
      throw new ERR_INVALID_ARG_TYPE2(name, ["Buffer", "TypedArray", "DataView"], buffer2);
    }
  });
  function validateEncoding(data, encoding) {
    const normalizedEncoding = normalizeEncoding(encoding);
    const length = data.length;
    if (normalizedEncoding === "hex" && length % 2 !== 0) {
      throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
    }
  }
  __name(validateEncoding, "validateEncoding");
  function validatePort(port, name = "Port", allowZero = true) {
    if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
      throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
    }
    return port | 0;
  }
  __name(validatePort, "validatePort");
  const validateAbortSignal = hideStackFrames((signal, name) => {
    if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
      throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
    }
  });
  const validateFunction = hideStackFrames((value, name) => {
    if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
  });
  const validatePlainFunction = hideStackFrames((value, name) => {
    if (typeof value !== "function" || isAsyncFunction2(value)) throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
  });
  const validateUndefined = hideStackFrames((value, name) => {
    if (value !== void 0) throw new ERR_INVALID_ARG_TYPE2(name, "undefined", value);
  });
  function validateUnion(value, name, union) {
    if (!ArrayPrototypeIncludes(union, value)) {
      throw new ERR_INVALID_ARG_TYPE2(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
    }
  }
  __name(validateUnion, "validateUnion");
  const linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
  function validateLinkHeaderFormat(value, name) {
    if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
      throw new ERR_INVALID_ARG_VALUE(
        name,
        value,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
  }
  __name(validateLinkHeaderFormat, "validateLinkHeaderFormat");
  function validateLinkHeaderValue(hints) {
    if (typeof hints === "string") {
      validateLinkHeaderFormat(hints, "hints");
      return hints;
    } else if (ArrayIsArray(hints)) {
      const hintsLength = hints.length;
      let result = "";
      if (hintsLength === 0) {
        return result;
      }
      for (let i = 0; i < hintsLength; i++) {
        const link2 = hints[i];
        validateLinkHeaderFormat(link2, "hints");
        result += link2;
        if (i !== hintsLength - 1) {
          result += ", ";
        }
      }
      return result;
    }
    throw new ERR_INVALID_ARG_VALUE(
      "hints",
      hints,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    );
  }
  __name(validateLinkHeaderValue, "validateLinkHeaderValue");
  validators = {
    isInt32,
    isUint32,
    parseFileMode,
    validateArray,
    validateStringArray,
    validateBooleanArray,
    validateAbortSignalArray,
    validateBoolean,
    validateBuffer,
    validateDictionary,
    validateEncoding,
    validateFunction,
    validateInt32,
    validateInteger,
    validateNumber,
    validateObject: validateObject2,
    validateOneOf,
    validatePlainFunction,
    validatePort,
    validateSignalName,
    validateString,
    validateUint32,
    validateUndefined,
    validateUnion,
    validateAbortSignal,
    validateLinkHeaderValue
  };
  return validators;
}
__name(requireValidators, "requireValidators");
var endOfStream = { exports: {} };
var browser$2 = { exports: {} };
var hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$2.exports;
  hasRequiredBrowser$3 = 1;
  var process2 = browser$2.exports = {};
  var cachedSetTimeout2;
  var cachedClearTimeout2;
  function defaultSetTimout2() {
    throw new Error("setTimeout has not been defined");
  }
  __name(defaultSetTimout2, "defaultSetTimout");
  function defaultClearTimeout2() {
    throw new Error("clearTimeout has not been defined");
  }
  __name(defaultClearTimeout2, "defaultClearTimeout");
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout2 = setTimeout;
      } else {
        cachedSetTimeout2 = defaultSetTimout2;
      }
    } catch (e2) {
      cachedSetTimeout2 = defaultSetTimout2;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout2 = clearTimeout;
      } else {
        cachedClearTimeout2 = defaultClearTimeout2;
      }
    } catch (e2) {
      cachedClearTimeout2 = defaultClearTimeout2;
    }
  })();
  function runTimeout2(fun) {
    if (cachedSetTimeout2 === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
      cachedSetTimeout2 = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout2(fun, 0);
    } catch (e2) {
      try {
        return cachedSetTimeout2.call(null, fun, 0);
      } catch (e3) {
        return cachedSetTimeout2.call(this, fun, 0);
      }
    }
  }
  __name(runTimeout2, "runTimeout");
  function runClearTimeout2(marker) {
    if (cachedClearTimeout2 === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
      cachedClearTimeout2 = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout2(marker);
    } catch (e2) {
      try {
        return cachedClearTimeout2.call(null, marker);
      } catch (e3) {
        return cachedClearTimeout2.call(this, marker);
      }
    }
  }
  __name(runClearTimeout2, "runClearTimeout");
  var queue2 = [];
  var draining2 = false;
  var currentQueue2;
  var queueIndex2 = -1;
  function cleanUpNextTick2() {
    if (!draining2 || !currentQueue2) {
      return;
    }
    draining2 = false;
    if (currentQueue2.length) {
      queue2 = currentQueue2.concat(queue2);
    } else {
      queueIndex2 = -1;
    }
    if (queue2.length) {
      drainQueue2();
    }
  }
  __name(cleanUpNextTick2, "cleanUpNextTick");
  function drainQueue2() {
    if (draining2) {
      return;
    }
    var timeout = runTimeout2(cleanUpNextTick2);
    draining2 = true;
    var len = queue2.length;
    while (len) {
      currentQueue2 = queue2;
      queue2 = [];
      while (++queueIndex2 < len) {
        if (currentQueue2) {
          currentQueue2[queueIndex2].run();
        }
      }
      queueIndex2 = -1;
      len = queue2.length;
    }
    currentQueue2 = null;
    draining2 = false;
    runClearTimeout2(timeout);
  }
  __name(drainQueue2, "drainQueue");
  process2.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue2.push(new Item2(fun, args));
    if (queue2.length === 1 && !draining2) {
      runTimeout2(drainQueue2);
    }
  };
  function Item2(fun, array2) {
    this.fun = fun;
    this.array = array2;
  }
  __name(Item2, "Item");
  Item2.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process2.title = "browser";
  process2.browser = true;
  process2.env = {};
  process2.argv = [];
  process2.version = "";
  process2.versions = {};
  function noop2() {
  }
  __name(noop2, "noop");
  process2.on = noop2;
  process2.addListener = noop2;
  process2.once = noop2;
  process2.off = noop2;
  process2.removeListener = noop2;
  process2.removeAllListeners = noop2;
  process2.emit = noop2;
  process2.prependListener = noop2;
  process2.prependOnceListener = noop2;
  process2.listeners = function(name) {
    return [];
  };
  process2.binding = function(name) {
    throw new Error("process.binding is not supported");
  };
  process2.cwd = function() {
    return "/";
  };
  process2.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process2.umask = function() {
    return 0;
  };
  return browser$2.exports;
}
__name(requireBrowser$3, "requireBrowser$3");
var utils;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  const { SymbolAsyncIterator, SymbolIterator, SymbolFor } = requirePrimordials();
  const kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
  const kIsErrored = SymbolFor("nodejs.stream.errored");
  const kIsReadable = SymbolFor("nodejs.stream.readable");
  const kIsWritable = SymbolFor("nodejs.stream.writable");
  const kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
  const kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
  const kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
  function isReadableNodeStream(obj, strict = false) {
    var _obj$_readableState;
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
    (!obj._writableState || obj._readableState));
  }
  __name(isReadableNodeStream, "isReadableNodeStream");
  function isWritableNodeStream(obj) {
    var _obj$_writableState;
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
  }
  __name(isWritableNodeStream, "isWritableNodeStream");
  function isDuplexNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
  }
  __name(isDuplexNodeStream, "isDuplexNodeStream");
  function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
  }
  __name(isNodeStream, "isNodeStream");
  function isReadableStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
  }
  __name(isReadableStream, "isReadableStream");
  function isWritableStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
  }
  __name(isWritableStream, "isWritableStream");
  function isTransformStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
  }
  __name(isTransformStream, "isTransformStream");
  function isWebStream(obj) {
    return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
  }
  __name(isWebStream, "isWebStream");
  function isIterable2(obj, isAsync) {
    if (obj == null) return false;
    if (isAsync === true) return typeof obj[SymbolAsyncIterator] === "function";
    if (isAsync === false) return typeof obj[SymbolIterator] === "function";
    return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
  }
  __name(isIterable2, "isIterable");
  function isDestroyed(stream2) {
    if (!isNodeStream(stream2)) return null;
    const wState = stream2._writableState;
    const rState = stream2._readableState;
    const state2 = wState || rState;
    return !!(stream2.destroyed || stream2[kIsDestroyed] || state2 !== null && state2 !== void 0 && state2.destroyed);
  }
  __name(isDestroyed, "isDestroyed");
  function isWritableEnded(stream2) {
    if (!isWritableNodeStream(stream2)) return null;
    if (stream2.writableEnded === true) return true;
    const wState = stream2._writableState;
    if (wState !== null && wState !== void 0 && wState.errored) return false;
    if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean") return null;
    return wState.ended;
  }
  __name(isWritableEnded, "isWritableEnded");
  function isWritableFinished(stream2, strict) {
    if (!isWritableNodeStream(stream2)) return null;
    if (stream2.writableFinished === true) return true;
    const wState = stream2._writableState;
    if (wState !== null && wState !== void 0 && wState.errored) return false;
    if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean") return null;
    return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
  }
  __name(isWritableFinished, "isWritableFinished");
  function isReadableEnded(stream2) {
    if (!isReadableNodeStream(stream2)) return null;
    if (stream2.readableEnded === true) return true;
    const rState = stream2._readableState;
    if (!rState || rState.errored) return false;
    if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean") return null;
    return rState.ended;
  }
  __name(isReadableEnded, "isReadableEnded");
  function isReadableFinished(stream2, strict) {
    if (!isReadableNodeStream(stream2)) return null;
    const rState = stream2._readableState;
    if (rState !== null && rState !== void 0 && rState.errored) return false;
    if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean") return null;
    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
  }
  __name(isReadableFinished, "isReadableFinished");
  function isReadable(stream2) {
    if (stream2 && stream2[kIsReadable] != null) return stream2[kIsReadable];
    if (typeof (stream2 === null || stream2 === void 0 ? void 0 : stream2.readable) !== "boolean") return null;
    if (isDestroyed(stream2)) return false;
    return isReadableNodeStream(stream2) && stream2.readable && !isReadableFinished(stream2);
  }
  __name(isReadable, "isReadable");
  function isWritable(stream2) {
    if (stream2 && stream2[kIsWritable] != null) return stream2[kIsWritable];
    if (typeof (stream2 === null || stream2 === void 0 ? void 0 : stream2.writable) !== "boolean") return null;
    if (isDestroyed(stream2)) return false;
    return isWritableNodeStream(stream2) && stream2.writable && !isWritableEnded(stream2);
  }
  __name(isWritable, "isWritable");
  function isFinished(stream2, opts) {
    if (!isNodeStream(stream2)) {
      return null;
    }
    if (isDestroyed(stream2)) {
      return true;
    }
    if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream2)) {
      return false;
    }
    if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream2)) {
      return false;
    }
    return true;
  }
  __name(isFinished, "isFinished");
  function isWritableErrored(stream2) {
    var _stream$_writableStat, _stream$_writableStat2;
    if (!isNodeStream(stream2)) {
      return null;
    }
    if (stream2.writableErrored) {
      return stream2.writableErrored;
    }
    return (_stream$_writableStat = (_stream$_writableStat2 = stream2._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
  }
  __name(isWritableErrored, "isWritableErrored");
  function isReadableErrored(stream2) {
    var _stream$_readableStat, _stream$_readableStat2;
    if (!isNodeStream(stream2)) {
      return null;
    }
    if (stream2.readableErrored) {
      return stream2.readableErrored;
    }
    return (_stream$_readableStat = (_stream$_readableStat2 = stream2._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
  }
  __name(isReadableErrored, "isReadableErrored");
  function isClosed(stream2) {
    if (!isNodeStream(stream2)) {
      return null;
    }
    if (typeof stream2.closed === "boolean") {
      return stream2.closed;
    }
    const wState = stream2._writableState;
    const rState = stream2._readableState;
    if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
      return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
    }
    if (typeof stream2._closed === "boolean" && isOutgoingMessage(stream2)) {
      return stream2._closed;
    }
    return null;
  }
  __name(isClosed, "isClosed");
  function isOutgoingMessage(stream2) {
    return typeof stream2._closed === "boolean" && typeof stream2._defaultKeepAlive === "boolean" && typeof stream2._removedConnection === "boolean" && typeof stream2._removedContLen === "boolean";
  }
  __name(isOutgoingMessage, "isOutgoingMessage");
  function isServerResponse(stream2) {
    return typeof stream2._sent100 === "boolean" && isOutgoingMessage(stream2);
  }
  __name(isServerResponse, "isServerResponse");
  function isServerRequest(stream2) {
    var _stream$req;
    return typeof stream2._consuming === "boolean" && typeof stream2._dumped === "boolean" && ((_stream$req = stream2.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
  }
  __name(isServerRequest, "isServerRequest");
  function willEmitClose(stream2) {
    if (!isNodeStream(stream2)) return null;
    const wState = stream2._writableState;
    const rState = stream2._readableState;
    const state2 = wState || rState;
    return !state2 && isServerResponse(stream2) || !!(state2 && state2.autoDestroy && state2.emitClose && state2.closed === false);
  }
  __name(willEmitClose, "willEmitClose");
  function isDisturbed(stream2) {
    var _stream$kIsDisturbed;
    return !!(stream2 && ((_stream$kIsDisturbed = stream2[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream2.readableDidRead || stream2.readableAborted));
  }
  __name(isDisturbed, "isDisturbed");
  function isErrored(stream2) {
    var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
    return !!(stream2 && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream2[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream2.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream2.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream2._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream2._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream2._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream2._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
  }
  __name(isErrored, "isErrored");
  utils = {
    isDestroyed,
    kIsDestroyed,
    isDisturbed,
    kIsDisturbed,
    isErrored,
    kIsErrored,
    isReadable,
    kIsReadable,
    kIsClosedPromise,
    kControllerErrorFunction,
    kIsWritable,
    isClosed,
    isDuplexNodeStream,
    isFinished,
    isIterable: isIterable2,
    isReadableNodeStream,
    isReadableStream,
    isReadableEnded,
    isReadableFinished,
    isReadableErrored,
    isNodeStream,
    isWebStream,
    isWritable,
    isWritableNodeStream,
    isWritableStream,
    isWritableEnded,
    isWritableFinished,
    isWritableErrored,
    isServerRequest,
    isServerResponse,
    willEmitClose,
    isTransformStream
  };
  return utils;
}
__name(requireUtils, "requireUtils");
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream.exports;
  hasRequiredEndOfStream = 1;
  const process2 = requireBrowser$3();
  const { AbortError, codes } = requireErrors();
  const { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_PREMATURE_CLOSE } = codes;
  const { kEmptyObject, once } = requireUtil$1();
  const { validateAbortSignal, validateFunction, validateObject: validateObject2, validateBoolean } = requireValidators();
  const { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = requirePrimordials();
  const {
    isClosed,
    isReadable,
    isReadableNodeStream,
    isReadableStream,
    isReadableFinished,
    isReadableErrored,
    isWritable,
    isWritableNodeStream,
    isWritableStream,
    isWritableFinished,
    isWritableErrored,
    isNodeStream,
    willEmitClose: _willEmitClose,
    kIsClosedPromise
  } = requireUtils();
  let addAbortListener;
  function isRequest(stream2) {
    return stream2.setHeader && typeof stream2.abort === "function";
  }
  __name(isRequest, "isRequest");
  const nop2 = /* @__PURE__ */ __name(() => {
  }, "nop");
  function eos(stream2, options, callback) {
    var _options$readable, _options$writable;
    if (arguments.length === 2) {
      callback = options;
      options = kEmptyObject;
    } else if (options == null) {
      options = kEmptyObject;
    } else {
      validateObject2(options, "options");
    }
    validateFunction(callback, "callback");
    validateAbortSignal(options.signal, "options.signal");
    callback = once(callback);
    if (isReadableStream(stream2) || isWritableStream(stream2)) {
      return eosWeb(stream2, options, callback);
    }
    if (!isNodeStream(stream2)) {
      throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream2);
    }
    const readable2 = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream2);
    const writable2 = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream2);
    const wState = stream2._writableState;
    const rState = stream2._readableState;
    const onlegacyfinish = /* @__PURE__ */ __name(() => {
      if (!stream2.writable) {
        onfinish();
      }
    }, "onlegacyfinish");
    let willEmitClose = _willEmitClose(stream2) && isReadableNodeStream(stream2) === readable2 && isWritableNodeStream(stream2) === writable2;
    let writableFinished = isWritableFinished(stream2, false);
    const onfinish = /* @__PURE__ */ __name(() => {
      writableFinished = true;
      if (stream2.destroyed) {
        willEmitClose = false;
      }
      if (willEmitClose && (!stream2.readable || readable2)) {
        return;
      }
      if (!readable2 || readableFinished) {
        callback.call(stream2);
      }
    }, "onfinish");
    let readableFinished = isReadableFinished(stream2, false);
    const onend = /* @__PURE__ */ __name(() => {
      readableFinished = true;
      if (stream2.destroyed) {
        willEmitClose = false;
      }
      if (willEmitClose && (!stream2.writable || writable2)) {
        return;
      }
      if (!writable2 || writableFinished) {
        callback.call(stream2);
      }
    }, "onend");
    const onerror = /* @__PURE__ */ __name((err2) => {
      callback.call(stream2, err2);
    }, "onerror");
    let closed = isClosed(stream2);
    const onclose = /* @__PURE__ */ __name(() => {
      closed = true;
      const errored = isWritableErrored(stream2) || isReadableErrored(stream2);
      if (errored && typeof errored !== "boolean") {
        return callback.call(stream2, errored);
      }
      if (readable2 && !readableFinished && isReadableNodeStream(stream2, true)) {
        if (!isReadableFinished(stream2, false)) return callback.call(stream2, new ERR_STREAM_PREMATURE_CLOSE());
      }
      if (writable2 && !writableFinished) {
        if (!isWritableFinished(stream2, false)) return callback.call(stream2, new ERR_STREAM_PREMATURE_CLOSE());
      }
      callback.call(stream2);
    }, "onclose");
    const onclosed = /* @__PURE__ */ __name(() => {
      closed = true;
      const errored = isWritableErrored(stream2) || isReadableErrored(stream2);
      if (errored && typeof errored !== "boolean") {
        return callback.call(stream2, errored);
      }
      callback.call(stream2);
    }, "onclosed");
    const onrequest = /* @__PURE__ */ __name(() => {
      stream2.req.on("finish", onfinish);
    }, "onrequest");
    if (isRequest(stream2)) {
      stream2.on("complete", onfinish);
      if (!willEmitClose) {
        stream2.on("abort", onclose);
      }
      if (stream2.req) {
        onrequest();
      } else {
        stream2.on("request", onrequest);
      }
    } else if (writable2 && !wState) {
      stream2.on("end", onlegacyfinish);
      stream2.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream2.aborted === "boolean") {
      stream2.on("aborted", onclose);
    }
    stream2.on("end", onend);
    stream2.on("finish", onfinish);
    if (options.error !== false) {
      stream2.on("error", onerror);
    }
    stream2.on("close", onclose);
    if (closed) {
      process2.nextTick(onclose);
    } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
      if (!willEmitClose) {
        process2.nextTick(onclosed);
      }
    } else if (!readable2 && (!willEmitClose || isReadable(stream2)) && (writableFinished || isWritable(stream2) === false)) {
      process2.nextTick(onclosed);
    } else if (!writable2 && (!willEmitClose || isWritable(stream2)) && (readableFinished || isReadable(stream2) === false)) {
      process2.nextTick(onclosed);
    } else if (rState && stream2.req && stream2.aborted) {
      process2.nextTick(onclosed);
    }
    const cleanup = /* @__PURE__ */ __name(() => {
      callback = nop2;
      stream2.removeListener("aborted", onclose);
      stream2.removeListener("complete", onfinish);
      stream2.removeListener("abort", onclose);
      stream2.removeListener("request", onrequest);
      if (stream2.req) stream2.req.removeListener("finish", onfinish);
      stream2.removeListener("end", onlegacyfinish);
      stream2.removeListener("close", onlegacyfinish);
      stream2.removeListener("finish", onfinish);
      stream2.removeListener("end", onend);
      stream2.removeListener("error", onerror);
      stream2.removeListener("close", onclose);
    }, "cleanup");
    if (options.signal && !closed) {
      const abort = /* @__PURE__ */ __name(() => {
        const endCallback = callback;
        cleanup();
        endCallback.call(
          stream2,
          new AbortError(void 0, {
            cause: options.signal.reason
          })
        );
      }, "abort");
      if (options.signal.aborted) {
        process2.nextTick(abort);
      } else {
        addAbortListener = addAbortListener || requireUtil$1().addAbortListener;
        const disposable = addAbortListener(options.signal, abort);
        const originalCallback = callback;
        callback = once((...args) => {
          disposable[SymbolDispose]();
          originalCallback.apply(stream2, args);
        });
      }
    }
    return cleanup;
  }
  __name(eos, "eos");
  function eosWeb(stream2, options, callback) {
    let isAborted = false;
    let abort = nop2;
    if (options.signal) {
      abort = /* @__PURE__ */ __name(() => {
        isAborted = true;
        callback.call(
          stream2,
          new AbortError(void 0, {
            cause: options.signal.reason
          })
        );
      }, "abort");
      if (options.signal.aborted) {
        process2.nextTick(abort);
      } else {
        addAbortListener = addAbortListener || requireUtil$1().addAbortListener;
        const disposable = addAbortListener(options.signal, abort);
        const originalCallback = callback;
        callback = once((...args) => {
          disposable[SymbolDispose]();
          originalCallback.apply(stream2, args);
        });
      }
    }
    const resolverFn = /* @__PURE__ */ __name((...args) => {
      if (!isAborted) {
        process2.nextTick(() => callback.apply(stream2, args));
      }
    }, "resolverFn");
    PromisePrototypeThen(stream2[kIsClosedPromise].promise, resolverFn, resolverFn);
    return nop2;
  }
  __name(eosWeb, "eosWeb");
  function finished(stream2, opts) {
    var _opts;
    let autoCleanup = false;
    if (opts === null) {
      opts = kEmptyObject;
    }
    if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
      validateBoolean(opts.cleanup, "cleanup");
      autoCleanup = opts.cleanup;
    }
    return new Promise2((resolve2, reject) => {
      const cleanup = eos(stream2, opts, (err2) => {
        if (autoCleanup) {
          cleanup();
        }
        if (err2) {
          reject(err2);
        } else {
          resolve2();
        }
      });
    });
  }
  __name(finished, "finished");
  endOfStream.exports = eos;
  endOfStream.exports.finished = finished;
  return endOfStream.exports;
}
__name(requireEndOfStream, "requireEndOfStream");
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  const process2 = requireBrowser$3();
  const {
    aggregateTwoErrors,
    codes: { ERR_MULTIPLE_CALLBACK },
    AbortError
  } = requireErrors();
  const { Symbol: Symbol2 } = requirePrimordials();
  const { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = requireUtils();
  const kDestroy = Symbol2("kDestroy");
  const kConstruct = Symbol2("kConstruct");
  function checkError(err2, w, r) {
    if (err2) {
      err2.stack;
      if (w && !w.errored) {
        w.errored = err2;
      }
      if (r && !r.errored) {
        r.errored = err2;
      }
    }
  }
  __name(checkError, "checkError");
  function destroy(err2, cb) {
    const r = this._readableState;
    const w = this._writableState;
    const s = w || r;
    if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
      if (typeof cb === "function") {
        cb();
      }
      return this;
    }
    checkError(err2, w, r);
    if (w) {
      w.destroyed = true;
    }
    if (r) {
      r.destroyed = true;
    }
    if (!s.constructed) {
      this.once(kDestroy, function(er) {
        _destroy(this, aggregateTwoErrors(er, err2), cb);
      });
    } else {
      _destroy(this, err2, cb);
    }
    return this;
  }
  __name(destroy, "destroy");
  function _destroy(self2, err2, cb) {
    let called = false;
    function onDestroy(err3) {
      if (called) {
        return;
      }
      called = true;
      const r = self2._readableState;
      const w = self2._writableState;
      checkError(err3, w, r);
      if (w) {
        w.closed = true;
      }
      if (r) {
        r.closed = true;
      }
      if (typeof cb === "function") {
        cb(err3);
      }
      if (err3) {
        process2.nextTick(emitErrorCloseNT, self2, err3);
      } else {
        process2.nextTick(emitCloseNT, self2);
      }
    }
    __name(onDestroy, "onDestroy");
    try {
      self2._destroy(err2 || null, onDestroy);
    } catch (err3) {
      onDestroy(err3);
    }
  }
  __name(_destroy, "_destroy");
  function emitErrorCloseNT(self2, err2) {
    emitErrorNT(self2, err2);
    emitCloseNT(self2);
  }
  __name(emitErrorCloseNT, "emitErrorCloseNT");
  function emitCloseNT(self2) {
    const r = self2._readableState;
    const w = self2._writableState;
    if (w) {
      w.closeEmitted = true;
    }
    if (r) {
      r.closeEmitted = true;
    }
    if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
      self2.emit("close");
    }
  }
  __name(emitCloseNT, "emitCloseNT");
  function emitErrorNT(self2, err2) {
    const r = self2._readableState;
    const w = self2._writableState;
    if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
      return;
    }
    if (w) {
      w.errorEmitted = true;
    }
    if (r) {
      r.errorEmitted = true;
    }
    self2.emit("error", err2);
  }
  __name(emitErrorNT, "emitErrorNT");
  function undestroy() {
    const r = this._readableState;
    const w = this._writableState;
    if (r) {
      r.constructed = true;
      r.closed = false;
      r.closeEmitted = false;
      r.destroyed = false;
      r.errored = null;
      r.errorEmitted = false;
      r.reading = false;
      r.ended = r.readable === false;
      r.endEmitted = r.readable === false;
    }
    if (w) {
      w.constructed = true;
      w.destroyed = false;
      w.closed = false;
      w.closeEmitted = false;
      w.errored = null;
      w.errorEmitted = false;
      w.finalCalled = false;
      w.prefinished = false;
      w.ended = w.writable === false;
      w.ending = w.writable === false;
      w.finished = w.writable === false;
    }
  }
  __name(undestroy, "undestroy");
  function errorOrDestroy(stream2, err2, sync) {
    const r = stream2._readableState;
    const w = stream2._writableState;
    if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
      return this;
    }
    if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
      stream2.destroy(err2);
    else if (err2) {
      err2.stack;
      if (w && !w.errored) {
        w.errored = err2;
      }
      if (r && !r.errored) {
        r.errored = err2;
      }
      if (sync) {
        process2.nextTick(emitErrorNT, stream2, err2);
      } else {
        emitErrorNT(stream2, err2);
      }
    }
  }
  __name(errorOrDestroy, "errorOrDestroy");
  function construct(stream2, cb) {
    if (typeof stream2._construct !== "function") {
      return;
    }
    const r = stream2._readableState;
    const w = stream2._writableState;
    if (r) {
      r.constructed = false;
    }
    if (w) {
      w.constructed = false;
    }
    stream2.once(kConstruct, cb);
    if (stream2.listenerCount(kConstruct) > 1) {
      return;
    }
    process2.nextTick(constructNT, stream2);
  }
  __name(construct, "construct");
  function constructNT(stream2) {
    let called = false;
    function onConstruct(err2) {
      if (called) {
        errorOrDestroy(stream2, err2 !== null && err2 !== void 0 ? err2 : new ERR_MULTIPLE_CALLBACK());
        return;
      }
      called = true;
      const r = stream2._readableState;
      const w = stream2._writableState;
      const s = w || r;
      if (r) {
        r.constructed = true;
      }
      if (w) {
        w.constructed = true;
      }
      if (s.destroyed) {
        stream2.emit(kDestroy, err2);
      } else if (err2) {
        errorOrDestroy(stream2, err2, true);
      } else {
        process2.nextTick(emitConstructNT, stream2);
      }
    }
    __name(onConstruct, "onConstruct");
    try {
      stream2._construct((err2) => {
        process2.nextTick(onConstruct, err2);
      });
    } catch (err2) {
      process2.nextTick(onConstruct, err2);
    }
  }
  __name(constructNT, "constructNT");
  function emitConstructNT(stream2) {
    stream2.emit(kConstruct);
  }
  __name(emitConstructNT, "emitConstructNT");
  function isRequest(stream2) {
    return (stream2 === null || stream2 === void 0 ? void 0 : stream2.setHeader) && typeof stream2.abort === "function";
  }
  __name(isRequest, "isRequest");
  function emitCloseLegacy(stream2) {
    stream2.emit("close");
  }
  __name(emitCloseLegacy, "emitCloseLegacy");
  function emitErrorCloseLegacy(stream2, err2) {
    stream2.emit("error", err2);
    process2.nextTick(emitCloseLegacy, stream2);
  }
  __name(emitErrorCloseLegacy, "emitErrorCloseLegacy");
  function destroyer(stream2, err2) {
    if (!stream2 || isDestroyed(stream2)) {
      return;
    }
    if (!err2 && !isFinished(stream2)) {
      err2 = new AbortError();
    }
    if (isServerRequest(stream2)) {
      stream2.socket = null;
      stream2.destroy(err2);
    } else if (isRequest(stream2)) {
      stream2.abort();
    } else if (isRequest(stream2.req)) {
      stream2.req.abort();
    } else if (typeof stream2.destroy === "function") {
      stream2.destroy(err2);
    } else if (typeof stream2.close === "function") {
      stream2.close();
    } else if (err2) {
      process2.nextTick(emitErrorCloseLegacy, stream2, err2);
    } else {
      process2.nextTick(emitCloseLegacy, stream2);
    }
    if (!stream2.destroyed) {
      stream2[kIsDestroyed] = true;
    }
  }
  __name(destroyer, "destroyer");
  destroy_1 = {
    construct,
    destroyer,
    destroy,
    undestroy,
    errorOrDestroy
  };
  return destroy_1;
}
__name(requireDestroy, "requireDestroy");
var legacy;
var hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  const { ArrayIsArray, ObjectSetPrototypeOf } = requirePrimordials();
  const { EventEmitter: EE } = requireEvents();
  function Stream2(opts) {
    EE.call(this, opts);
  }
  __name(Stream2, "Stream");
  ObjectSetPrototypeOf(Stream2.prototype, EE.prototype);
  ObjectSetPrototypeOf(Stream2, EE);
  Stream2.prototype.pipe = function(dest, options) {
    const source2 = this;
    function ondata(chunk) {
      if (dest.writable && dest.write(chunk) === false && source2.pause) {
        source2.pause();
      }
    }
    __name(ondata, "ondata");
    source2.on("data", ondata);
    function ondrain() {
      if (source2.readable && source2.resume) {
        source2.resume();
      }
    }
    __name(ondrain, "ondrain");
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source2.on("end", onend);
      source2.on("close", onclose);
    }
    let didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }
    __name(onend, "onend");
    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === "function") dest.destroy();
    }
    __name(onclose, "onclose");
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, "error") === 0) {
        this.emit("error", er);
      }
    }
    __name(onerror, "onerror");
    prependListener(source2, "error", onerror);
    prependListener(dest, "error", onerror);
    function cleanup() {
      source2.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source2.removeListener("end", onend);
      source2.removeListener("close", onclose);
      source2.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source2.removeListener("end", cleanup);
      source2.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    __name(cleanup, "cleanup");
    source2.on("end", cleanup);
    source2.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source2);
    return dest;
  };
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  __name(prependListener, "prependListener");
  legacy = {
    Stream: Stream2,
    prependListener
  };
  return legacy;
}
__name(requireLegacy, "requireLegacy");
var addAbortSignal = { exports: {} };
var hasRequiredAddAbortSignal;
function requireAddAbortSignal() {
  if (hasRequiredAddAbortSignal) return addAbortSignal.exports;
  hasRequiredAddAbortSignal = 1;
  (function(module) {
    const { SymbolDispose } = requirePrimordials();
    const { AbortError, codes } = requireErrors();
    const { isNodeStream, isWebStream, kControllerErrorFunction } = requireUtils();
    const eos = requireEndOfStream();
    const { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2 } = codes;
    let addAbortListener;
    const validateAbortSignal = /* @__PURE__ */ __name((signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
      }
    }, "validateAbortSignal");
    module.exports.addAbortSignal = /* @__PURE__ */ __name(function addAbortSignal2(signal, stream2) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream2) && !isWebStream(stream2)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream2);
      }
      return module.exports.addAbortSignalNoValidate(signal, stream2);
    }, "addAbortSignal");
    module.exports.addAbortSignalNoValidate = function(signal, stream2) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream2;
      }
      const onAbort = isNodeStream(stream2) ? () => {
        stream2.destroy(
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream2[kControllerErrorFunction](
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || requireUtil$1().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream2, disposable[SymbolDispose]);
      }
      return stream2;
    };
  })(addAbortSignal);
  return addAbortSignal.exports;
}
__name(requireAddAbortSignal, "requireAddAbortSignal");
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  var _a2;
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  const { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = requirePrimordials();
  const { Buffer: Buffer3 } = requireBuffer();
  const { inspect: inspect2 } = requireUtil$1();
  buffer_list = (_a2 = class {
    constructor() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    push(v) {
      const entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;
      else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
    unshift(v) {
      const entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
    shift() {
      if (this.length === 0) return;
      const ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;
      else this.head = this.head.next;
      --this.length;
      return ret;
    }
    clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
    join(s) {
      if (this.length === 0) return "";
      let p = this.head;
      let ret = "" + p.data;
      while ((p = p.next) !== null) ret += s + p.data;
      return ret;
    }
    concat(n) {
      if (this.length === 0) return Buffer3.alloc(0);
      const ret = Buffer3.allocUnsafe(n >>> 0);
      let p = this.head;
      let i = 0;
      while (p) {
        TypedArrayPrototypeSet(ret, p.data, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }
    // Consumes a specified amount of bytes or characters from the buffered data.
    consume(n, hasStrings) {
      const data = this.head.data;
      if (n < data.length) {
        const slice = data.slice(0, n);
        this.head.data = data.slice(n);
        return slice;
      }
      if (n === data.length) {
        return this.shift();
      }
      return hasStrings ? this._getString(n) : this._getBuffer(n);
    }
    first() {
      return this.head.data;
    }
    *[SymbolIterator]() {
      for (let p = this.head; p; p = p.next) {
        yield p.data;
      }
    }
    // Consumes a specified amount of characters from the buffered data.
    _getString(n) {
      let ret = "";
      let p = this.head;
      let c = 0;
      do {
        const str = p.data;
        if (n > str.length) {
          ret += str;
          n -= str.length;
        } else {
          if (n === str.length) {
            ret += str;
            ++c;
            if (p.next) this.head = p.next;
            else this.head = this.tail = null;
          } else {
            ret += StringPrototypeSlice(str, 0, n);
            this.head = p;
            p.data = StringPrototypeSlice(str, n);
          }
          break;
        }
        ++c;
      } while ((p = p.next) !== null);
      this.length -= c;
      return ret;
    }
    // Consumes a specified amount of bytes from the buffered data.
    _getBuffer(n) {
      const ret = Buffer3.allocUnsafe(n);
      const retLen = n;
      let p = this.head;
      let c = 0;
      do {
        const buf = p.data;
        if (n > buf.length) {
          TypedArrayPrototypeSet(ret, buf, retLen - n);
          n -= buf.length;
        } else {
          if (n === buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            ++c;
            if (p.next) this.head = p.next;
            else this.head = this.tail = null;
          } else {
            TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
            this.head = p;
            p.data = buf.slice(n);
          }
          break;
        }
        ++c;
      } while ((p = p.next) !== null);
      this.length -= c;
      return ret;
    }
    // Make sure the linked list only shows the minimal necessary information.
    [Symbol.for("nodejs.util.inspect.custom")](_, options) {
      return inspect2(this, {
        ...options,
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      });
    }
  }, __name(_a2, "BufferList"), _a2);
  return buffer_list;
}
__name(requireBuffer_list, "requireBuffer_list");
var state;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  const { MathFloor, NumberIsInteger } = requirePrimordials();
  const { validateInteger } = requireValidators();
  const { ERR_INVALID_ARG_VALUE } = requireErrors().codes;
  let defaultHighWaterMarkBytes = 16 * 1024;
  let defaultHighWaterMarkObjectMode = 16;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  __name(highWaterMarkFrom, "highWaterMarkFrom");
  function getDefaultHighWaterMark(objectMode) {
    return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
  }
  __name(getDefaultHighWaterMark, "getDefaultHighWaterMark");
  function setDefaultHighWaterMark(objectMode, value) {
    validateInteger(value, "value", 0);
    if (objectMode) {
      defaultHighWaterMarkObjectMode = value;
    } else {
      defaultHighWaterMarkBytes = value;
    }
  }
  __name(setDefaultHighWaterMark, "setDefaultHighWaterMark");
  function getHighWaterMark(state2, options, duplexKey, isDuplex) {
    const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!NumberIsInteger(hwm) || hwm < 0) {
        const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
        throw new ERR_INVALID_ARG_VALUE(name, hwm);
      }
      return MathFloor(hwm);
    }
    return getDefaultHighWaterMark(state2.objectMode);
  }
  __name(getHighWaterMark, "getHighWaterMark");
  state = {
    getHighWaterMark,
    getDefaultHighWaterMark,
    setDefaultHighWaterMark
  };
  return state;
}
__name(requireState, "requireState");
var string_decoder = {};
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports) {
    var buffer2 = requireBuffer();
    var Buffer3 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    __name(copyProps, "copyProps");
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    __name(SafeBuffer, "SafeBuffer");
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
__name(requireSafeBuffer, "requireSafeBuffer");
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer3 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer3.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  __name(_normalizeEncoding, "_normalizeEncoding");
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  __name(normalizeEncoding, "normalizeEncoding");
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer3.allocUnsafe(nb);
  }
  __name(StringDecoder, "StringDecoder");
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  __name(utf8CheckByte, "utf8CheckByte");
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  __name(utf8CheckIncomplete, "utf8CheckIncomplete");
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  __name(utf8CheckExtraBytes, "utf8CheckExtraBytes");
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  __name(utf8FillLast, "utf8FillLast");
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  __name(utf8Text, "utf8Text");
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "�";
    return r;
  }
  __name(utf8End, "utf8End");
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  __name(utf16Text, "utf16Text");
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  __name(utf16End, "utf16End");
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  __name(base64Text, "base64Text");
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  __name(base64End, "base64End");
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  __name(simpleWrite, "simpleWrite");
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  __name(simpleEnd, "simpleEnd");
  return string_decoder;
}
__name(requireString_decoder, "requireString_decoder");
var from_1;
var hasRequiredFrom;
function requireFrom() {
  if (hasRequiredFrom) return from_1;
  hasRequiredFrom = 1;
  const process2 = requireBrowser$3();
  const { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = requirePrimordials();
  const { Buffer: Buffer3 } = requireBuffer();
  const { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_NULL_VALUES } = requireErrors().codes;
  function from(Readable, iterable, opts) {
    let iterator;
    if (typeof iterable === "string" || iterable instanceof Buffer3) {
      return new Readable({
        objectMode: true,
        ...opts,
        read() {
          this.push(iterable);
          this.push(null);
        }
      });
    }
    let isAsync;
    if (iterable && iterable[SymbolAsyncIterator]) {
      isAsync = true;
      iterator = iterable[SymbolAsyncIterator]();
    } else if (iterable && iterable[SymbolIterator]) {
      isAsync = false;
      iterator = iterable[SymbolIterator]();
    } else {
      throw new ERR_INVALID_ARG_TYPE2("iterable", ["Iterable"], iterable);
    }
    const readable2 = new Readable({
      objectMode: true,
      highWaterMark: 1,
      // TODO(ronag): What options should be allowed?
      ...opts
    });
    let reading = false;
    readable2._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    readable2._destroy = function(error, cb) {
      PromisePrototypeThen(
        close2(error),
        () => process2.nextTick(cb, error),
        // nextTick is here in case cb throws
        (e2) => process2.nextTick(cb, e2 || error)
      );
    };
    async function close2(error) {
      const hadError = error !== void 0 && error !== null;
      const hasThrow = typeof iterator.throw === "function";
      if (hadError && hasThrow) {
        const { value, done } = await iterator.throw(error);
        await value;
        if (done) {
          return;
        }
      }
      if (typeof iterator.return === "function") {
        const { value } = await iterator.return();
        await value;
      }
    }
    __name(close2, "close");
    async function next() {
      for (; ; ) {
        try {
          const { value, done } = isAsync ? await iterator.next() : iterator.next();
          if (done) {
            readable2.push(null);
          } else {
            const res = value && typeof value.then === "function" ? await value : value;
            if (res === null) {
              reading = false;
              throw new ERR_STREAM_NULL_VALUES();
            } else if (readable2.push(res)) {
              continue;
            } else {
              reading = false;
            }
          }
        } catch (err2) {
          readable2.destroy(err2);
        }
        break;
      }
    }
    __name(next, "next");
    return readable2;
  }
  __name(from, "from");
  from_1 = from;
  return from_1;
}
__name(requireFrom, "requireFrom");
var readable;
var hasRequiredReadable;
function requireReadable() {
  if (hasRequiredReadable) return readable;
  hasRequiredReadable = 1;
  const process2 = requireBrowser$3();
  const {
    ArrayPrototypeIndexOf,
    NumberIsInteger,
    NumberIsNaN,
    NumberParseInt,
    ObjectDefineProperties,
    ObjectKeys,
    ObjectSetPrototypeOf,
    Promise: Promise2,
    SafeSet,
    SymbolAsyncDispose,
    SymbolAsyncIterator,
    Symbol: Symbol2
  } = requirePrimordials();
  readable = Readable;
  Readable.ReadableState = ReadableState;
  const { EventEmitter: EE } = requireEvents();
  const { Stream: Stream2, prependListener } = requireLegacy();
  const { Buffer: Buffer3 } = requireBuffer();
  const { addAbortSignal: addAbortSignal2 } = requireAddAbortSignal();
  const eos = requireEndOfStream();
  let debug2 = requireUtil$1().debuglog("stream", (fn) => {
    debug2 = fn;
  });
  const BufferList = requireBuffer_list();
  const destroyImpl = requireDestroy();
  const { getHighWaterMark, getDefaultHighWaterMark } = requireState();
  const {
    aggregateTwoErrors,
    codes: {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_OUT_OF_RANGE,
      ERR_STREAM_PUSH_AFTER_EOF,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT
    },
    AbortError
  } = requireErrors();
  const { validateObject: validateObject2 } = requireValidators();
  const kPaused = Symbol2("kPaused");
  const { StringDecoder } = requireString_decoder();
  const from = requireFrom();
  ObjectSetPrototypeOf(Readable.prototype, Stream2.prototype);
  ObjectSetPrototypeOf(Readable, Stream2);
  const nop2 = /* @__PURE__ */ __name(() => {
  }, "nop");
  const { errorOrDestroy } = destroyImpl;
  const kObjectMode = 1 << 0;
  const kEnded = 1 << 1;
  const kEndEmitted = 1 << 2;
  const kReading = 1 << 3;
  const kConstructed = 1 << 4;
  const kSync = 1 << 5;
  const kNeedReadable = 1 << 6;
  const kEmittedReadable = 1 << 7;
  const kReadableListening = 1 << 8;
  const kResumeScheduled = 1 << 9;
  const kErrorEmitted = 1 << 10;
  const kEmitClose = 1 << 11;
  const kAutoDestroy = 1 << 12;
  const kDestroyed = 1 << 13;
  const kClosed = 1 << 14;
  const kCloseEmitted = 1 << 15;
  const kMultiAwaitDrain = 1 << 16;
  const kReadingMore = 1 << 17;
  const kDataEmitted = 1 << 18;
  function makeBitMapDescriptor(bit) {
    return {
      enumerable: false,
      get() {
        return (this.state & bit) !== 0;
      },
      set(value) {
        if (value) this.state |= bit;
        else this.state &= ~bit;
      }
    };
  }
  __name(makeBitMapDescriptor, "makeBitMapDescriptor");
  ObjectDefineProperties(ReadableState.prototype, {
    objectMode: makeBitMapDescriptor(kObjectMode),
    ended: makeBitMapDescriptor(kEnded),
    endEmitted: makeBitMapDescriptor(kEndEmitted),
    reading: makeBitMapDescriptor(kReading),
    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    constructed: makeBitMapDescriptor(kConstructed),
    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    sync: makeBitMapDescriptor(kSync),
    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    needReadable: makeBitMapDescriptor(kNeedReadable),
    emittedReadable: makeBitMapDescriptor(kEmittedReadable),
    readableListening: makeBitMapDescriptor(kReadableListening),
    resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
    // True if the error was already emitted and should not be thrown again.
    errorEmitted: makeBitMapDescriptor(kErrorEmitted),
    emitClose: makeBitMapDescriptor(kEmitClose),
    autoDestroy: makeBitMapDescriptor(kAutoDestroy),
    // Has it been destroyed.
    destroyed: makeBitMapDescriptor(kDestroyed),
    // Indicates whether the stream has finished destroying.
    closed: makeBitMapDescriptor(kClosed),
    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    closeEmitted: makeBitMapDescriptor(kCloseEmitted),
    multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
    // If true, a maybeReadMore has been scheduled.
    readingMore: makeBitMapDescriptor(kReadingMore),
    dataEmitted: makeBitMapDescriptor(kDataEmitted)
  });
  function ReadableState(options, stream2, isDuplex) {
    if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof requireDuplex();
    this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
    if (options && options.objectMode) this.state |= kObjectMode;
    if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;
    this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = [];
    this.flowing = null;
    this[kPaused] = null;
    if (options && options.emitClose === false) this.state &= ~kEmitClose;
    if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;
    this.errored = null;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.awaitDrainWriters = null;
    this.decoder = null;
    this.encoding = null;
    if (options && options.encoding) {
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  __name(ReadableState, "ReadableState");
  function Readable(options) {
    if (!(this instanceof Readable)) return new Readable(options);
    const isDuplex = this instanceof requireDuplex();
    this._readableState = new ReadableState(options, this, isDuplex);
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.construct === "function") this._construct = options.construct;
      if (options.signal && !isDuplex) addAbortSignal2(options.signal, this);
    }
    Stream2.call(this, options);
    destroyImpl.construct(this, () => {
      if (this._readableState.needReadable) {
        maybeReadMore(this, this._readableState);
      }
    });
  }
  __name(Readable, "Readable");
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err2, cb) {
    cb(err2);
  };
  Readable.prototype[EE.captureRejectionSymbol] = function(err2) {
    this.destroy(err2);
  };
  Readable.prototype[SymbolAsyncDispose] = function() {
    let error;
    if (!this.destroyed) {
      error = this.readableEnded ? null : new AbortError();
      this.destroy(error);
    }
    return new Promise2((resolve2, reject) => eos(this, (err2) => err2 && err2 !== error ? reject(err2) : resolve2(null)));
  };
  Readable.prototype.push = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, false);
  };
  Readable.prototype.unshift = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, true);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront) {
    debug2("readableAddChunk", chunk);
    const state2 = stream2._readableState;
    let err2;
    if ((state2.state & kObjectMode) === 0) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (state2.encoding !== encoding) {
          if (addToFront && state2.encoding) {
            chunk = Buffer3.from(chunk, encoding).toString(state2.encoding);
          } else {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "";
          }
        }
      } else if (chunk instanceof Buffer3) {
        encoding = "";
      } else if (Stream2._isUint8Array(chunk)) {
        chunk = Stream2._uint8ArrayToBuffer(chunk);
        encoding = "";
      } else if (chunk != null) {
        err2 = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
    }
    if (err2) {
      errorOrDestroy(stream2, err2);
    } else if (chunk === null) {
      state2.state &= ~kReading;
      onEofChunk(stream2, state2);
    } else if ((state2.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
      if (addToFront) {
        if ((state2.state & kEndEmitted) !== 0) errorOrDestroy(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
        else if (state2.destroyed || state2.errored) return false;
        else addChunk(stream2, state2, chunk, true);
      } else if (state2.ended) {
        errorOrDestroy(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state2.destroyed || state2.errored) {
        return false;
      } else {
        state2.state &= ~kReading;
        if (state2.decoder && !encoding) {
          chunk = state2.decoder.write(chunk);
          if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
          else maybeReadMore(stream2, state2);
        } else {
          addChunk(stream2, state2, chunk, false);
        }
      }
    } else if (!addToFront) {
      state2.state &= ~kReading;
      maybeReadMore(stream2, state2);
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  __name(readableAddChunk, "readableAddChunk");
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync && stream2.listenerCount("data") > 0) {
      if ((state2.state & kMultiAwaitDrain) !== 0) {
        state2.awaitDrainWriters.clear();
      } else {
        state2.awaitDrainWriters = null;
      }
      state2.dataEmitted = true;
      stream2.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if ((state2.state & kNeedReadable) !== 0) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  __name(addChunk, "addChunk");
  Readable.prototype.isPaused = function() {
    const state2 = this._readableState;
    return state2[kPaused] === true || state2.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    const decoder2 = new StringDecoder(enc);
    this._readableState.decoder = decoder2;
    this._readableState.encoding = this._readableState.decoder.encoding;
    const buffer2 = this._readableState.buffer;
    let content = "";
    for (const data of buffer2) {
      content += decoder2.write(data);
    }
    buffer2.clear();
    if (content !== "") buffer2.push(content);
    this._readableState.length = content.length;
    return this;
  };
  const MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n > MAX_HWM) {
      throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  __name(computeNewHighWaterMark, "computeNewHighWaterMark");
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if ((state2.state & kObjectMode) !== 0) return 1;
    if (NumberIsNaN(n)) {
      if (state2.flowing && state2.length) return state2.buffer.first().length;
      return state2.length;
    }
    if (n <= state2.length) return n;
    return state2.ended ? state2.length : 0;
  }
  __name(howMuchToRead, "howMuchToRead");
  Readable.prototype.read = function(n) {
    debug2("read", n);
    if (n === void 0) {
      n = NaN;
    } else if (!NumberIsInteger(n)) {
      n = NumberParseInt(n, 10);
    }
    const state2 = this._readableState;
    const nOrig = n;
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n !== 0) state2.state &= ~kEmittedReadable;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    let doRead = (state2.state & kNeedReadable) !== 0;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading || state2.destroyed || state2.errored || !state2.constructed) {
      doRead = false;
      debug2("reading, ended or constructing", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.state |= kReading | kSync;
      if (state2.length === 0) state2.state |= kNeedReadable;
      try {
        this._read(state2.highWaterMark);
      } catch (err2) {
        errorOrDestroy(this, err2);
      }
      state2.state &= ~kSync;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    let ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      if (state2.multiAwaitDrain) {
        state2.awaitDrainWriters.clear();
      } else {
        state2.awaitDrainWriters = null;
      }
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null && !state2.errorEmitted && !state2.closeEmitted) {
      state2.dataEmitted = true;
      this.emit("data", ret);
    }
    return ret;
  };
  function onEofChunk(stream2, state2) {
    debug2("onEofChunk");
    if (state2.ended) return;
    if (state2.decoder) {
      const chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream2);
    } else {
      state2.needReadable = false;
      state2.emittedReadable = true;
      emitReadable_(stream2);
    }
  }
  __name(onEofChunk, "onEofChunk");
  function emitReadable(stream2) {
    const state2 = stream2._readableState;
    debug2("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process2.nextTick(emitReadable_, stream2);
    }
  }
  __name(emitReadable, "emitReadable");
  function emitReadable_(stream2) {
    const state2 = stream2._readableState;
    debug2("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && !state2.errored && (state2.length || state2.ended)) {
      stream2.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream2);
  }
  __name(emitReadable_, "emitReadable_");
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore && state2.constructed) {
      state2.readingMore = true;
      process2.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  __name(maybeReadMore, "maybeReadMore");
  function maybeReadMore_(stream2, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      const len = state2.length;
      debug2("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  __name(maybeReadMore_, "maybeReadMore_");
  Readable.prototype._read = function(n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    const src = this;
    const state2 = this._readableState;
    if (state2.pipes.length === 1) {
      if (!state2.multiAwaitDrain) {
        state2.multiAwaitDrain = true;
        state2.awaitDrainWriters = new SafeSet(state2.awaitDrainWriters ? [state2.awaitDrainWriters] : []);
      }
    }
    state2.pipes.push(dest);
    debug2("pipe count=%d opts=%j", state2.pipes.length, pipeOpts);
    const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
    const endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) process2.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug2("onunpipe");
      if (readable2 === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    __name(onunpipe, "onunpipe");
    function onend() {
      debug2("onend");
      dest.end();
    }
    __name(onend, "onend");
    let ondrain;
    let cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      if (ondrain) {
        dest.removeListener("drain", ondrain);
      }
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (ondrain && state2.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    __name(cleanup, "cleanup");
    function pause() {
      if (!cleanedUp) {
        if (state2.pipes.length === 1 && state2.pipes[0] === dest) {
          debug2("false write response, pause", 0);
          state2.awaitDrainWriters = dest;
          state2.multiAwaitDrain = false;
        } else if (state2.pipes.length > 1 && state2.pipes.includes(dest)) {
          debug2("false write response, pause", state2.awaitDrainWriters.size);
          state2.awaitDrainWriters.add(dest);
        }
        src.pause();
      }
      if (!ondrain) {
        ondrain = pipeOnDrain(src, dest);
        dest.on("drain", ondrain);
      }
    }
    __name(pause, "pause");
    src.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      const ret = dest.write(chunk);
      debug2("dest.write", ret);
      if (ret === false) {
        pause();
      }
    }
    __name(ondata, "ondata");
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (dest.listenerCount("error") === 0) {
        const s = dest._writableState || dest._readableState;
        if (s && !s.errorEmitted) {
          errorOrDestroy(dest, er);
        } else {
          dest.emit("error", er);
        }
      }
    }
    __name(onerror, "onerror");
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    __name(onclose, "onclose");
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    __name(onfinish, "onfinish");
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src.unpipe(dest);
    }
    __name(unpipe, "unpipe");
    dest.emit("pipe", src);
    if (dest.writableNeedDrain === true) {
      pause();
    } else if (!state2.flowing) {
      debug2("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src, dest) {
    return /* @__PURE__ */ __name(function pipeOnDrainFunctionResult() {
      const state2 = src._readableState;
      if (state2.awaitDrainWriters === dest) {
        debug2("pipeOnDrain", 1);
        state2.awaitDrainWriters = null;
      } else if (state2.multiAwaitDrain) {
        debug2("pipeOnDrain", state2.awaitDrainWriters.size);
        state2.awaitDrainWriters.delete(dest);
      }
      if ((!state2.awaitDrainWriters || state2.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
        src.resume();
      }
    }, "pipeOnDrainFunctionResult");
  }
  __name(pipeOnDrain, "pipeOnDrain");
  Readable.prototype.unpipe = function(dest) {
    const state2 = this._readableState;
    const unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipes.length === 0) return this;
    if (!dest) {
      const dests = state2.pipes;
      state2.pipes = [];
      this.pause();
      for (let i = 0; i < dests.length; i++)
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    const index = ArrayPrototypeIndexOf(state2.pipes, dest);
    if (index === -1) return this;
    state2.pipes.splice(index, 1);
    if (state2.pipes.length === 0) this.pause();
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    const res = Stream2.prototype.on.call(this, ev, fn);
    const state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug2("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process2.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    const res = Stream2.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process2.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.off = Readable.prototype.removeListener;
  Readable.prototype.removeAllListeners = function(ev) {
    const res = Stream2.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process2.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    const state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && state2[kPaused] === false) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    } else if (!state2.readableListening) {
      state2.flowing = null;
    }
  }
  __name(updateReadableListening, "updateReadableListening");
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  __name(nReadingNextTick, "nReadingNextTick");
  Readable.prototype.resume = function() {
    const state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2[kPaused] = false;
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process2.nextTick(resume_, stream2, state2);
    }
  }
  __name(resume, "resume");
  function resume_(stream2, state2) {
    debug2("resume", state2.reading);
    if (!state2.reading) {
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  __name(resume_, "resume_");
  Readable.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState[kPaused] = true;
    return this;
  };
  function flow(stream2) {
    const state2 = stream2._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) ;
  }
  __name(flow, "flow");
  Readable.prototype.wrap = function(stream2) {
    let paused = false;
    stream2.on("data", (chunk) => {
      if (!this.push(chunk) && stream2.pause) {
        paused = true;
        stream2.pause();
      }
    });
    stream2.on("end", () => {
      this.push(null);
    });
    stream2.on("error", (err2) => {
      errorOrDestroy(this, err2);
    });
    stream2.on("close", () => {
      this.destroy();
    });
    stream2.on("destroy", () => {
      this.destroy();
    });
    this._read = () => {
      if (paused && stream2.resume) {
        paused = false;
        stream2.resume();
      }
    };
    const streamKeys = ObjectKeys(stream2);
    for (let j = 1; j < streamKeys.length; j++) {
      const i = streamKeys[j];
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = stream2[i].bind(stream2);
      }
    }
    return this;
  };
  Readable.prototype[SymbolAsyncIterator] = function() {
    return streamToAsyncIterator(this);
  };
  Readable.prototype.iterator = function(options) {
    if (options !== void 0) {
      validateObject2(options, "options");
    }
    return streamToAsyncIterator(this, options);
  };
  function streamToAsyncIterator(stream2, options) {
    if (typeof stream2.read !== "function") {
      stream2 = Readable.wrap(stream2, {
        objectMode: true
      });
    }
    const iter = createAsyncIterator(stream2, options);
    iter.stream = stream2;
    return iter;
  }
  __name(streamToAsyncIterator, "streamToAsyncIterator");
  async function* createAsyncIterator(stream2, options) {
    let callback = nop2;
    function next(resolve2) {
      if (this === stream2) {
        callback();
        callback = nop2;
      } else {
        callback = resolve2;
      }
    }
    __name(next, "next");
    stream2.on("readable", next);
    let error;
    const cleanup = eos(
      stream2,
      {
        writable: false
      },
      (err2) => {
        error = err2 ? aggregateTwoErrors(error, err2) : null;
        callback();
        callback = nop2;
      }
    );
    try {
      while (true) {
        const chunk = stream2.destroyed ? null : stream2.read();
        if (chunk !== null) {
          yield chunk;
        } else if (error) {
          throw error;
        } else if (error === null) {
          return;
        } else {
          await new Promise2(next);
        }
      }
    } catch (err2) {
      error = aggregateTwoErrors(error, err2);
      throw error;
    } finally {
      if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream2._readableState.autoDestroy)) {
        destroyImpl.destroyer(stream2, null);
      } else {
        stream2.off("readable", next);
        cleanup();
      }
    }
  }
  __name(createAsyncIterator, "createAsyncIterator");
  ObjectDefineProperties(Readable.prototype, {
    readable: {
      __proto__: null,
      get() {
        const r = this._readableState;
        return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
      },
      set(val) {
        if (this._readableState) {
          this._readableState.readable = !!val;
        }
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: false,
      get: /* @__PURE__ */ __name(function() {
        return this._readableState.dataEmitted;
      }, "get")
    },
    readableAborted: {
      __proto__: null,
      enumerable: false,
      get: /* @__PURE__ */ __name(function() {
        return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }, "get")
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: false,
      get: /* @__PURE__ */ __name(function() {
        return this._readableState.highWaterMark;
      }, "get")
    },
    readableBuffer: {
      __proto__: null,
      enumerable: false,
      get: /* @__PURE__ */ __name(function() {
        return this._readableState && this._readableState.buffer;
      }, "get")
    },
    readableFlowing: {
      __proto__: null,
      enumerable: false,
      get: /* @__PURE__ */ __name(function() {
        return this._readableState.flowing;
      }, "get"),
      set: /* @__PURE__ */ __name(function(state2) {
        if (this._readableState) {
          this._readableState.flowing = state2;
        }
      }, "set")
    },
    readableLength: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.objectMode : false;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : false;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.destroyed : false;
      },
      set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.endEmitted : false;
      }
    }
  });
  ObjectDefineProperties(ReadableState.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[kPaused] !== false;
      },
      set(value) {
        this[kPaused] = !!value;
      }
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    let ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.first();
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  __name(fromList, "fromList");
  function endReadable(stream2) {
    const state2 = stream2._readableState;
    debug2("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process2.nextTick(endReadableNT, state2, stream2);
    }
  }
  __name(endReadable, "endReadable");
  function endReadableNT(state2, stream2) {
    debug2("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.errored && !state2.closeEmitted && !state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.emit("end");
      if (stream2.writable && stream2.allowHalfOpen === false) {
        process2.nextTick(endWritableNT, stream2);
      } else if (state2.autoDestroy) {
        const wState = stream2._writableState;
        const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (wState.finished || wState.writable === false);
        if (autoDestroy) {
          stream2.destroy();
        }
      }
    }
  }
  __name(endReadableNT, "endReadableNT");
  function endWritableNT(stream2) {
    const writable2 = stream2.writable && !stream2.writableEnded && !stream2.destroyed;
    if (writable2) {
      stream2.end();
    }
  }
  __name(endWritableNT, "endWritableNT");
  Readable.from = function(iterable, opts) {
    return from(Readable, iterable, opts);
  };
  let webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === void 0) webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  __name(lazyWebStreams, "lazyWebStreams");
  Readable.fromWeb = function(readableStream, options) {
    return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
  };
  Readable.toWeb = function(streamReadable, options) {
    return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
  };
  Readable.wrap = function(src, options) {
    var _ref, _src$readableObjectMo;
    return new Readable({
      objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
      ...options,
      destroy(err2, callback) {
        destroyImpl.destroyer(src, err2);
        callback(err2);
      }
    }).wrap(src);
  };
  return readable;
}
__name(requireReadable, "requireReadable");
var writable;
var hasRequiredWritable;
function requireWritable() {
  if (hasRequiredWritable) return writable;
  hasRequiredWritable = 1;
  const process2 = requireBrowser$3();
  const {
    ArrayPrototypeSlice,
    Error: Error2,
    FunctionPrototypeSymbolHasInstance,
    ObjectDefineProperty,
    ObjectDefineProperties,
    ObjectSetPrototypeOf,
    StringPrototypeToLowerCase,
    Symbol: Symbol2,
    SymbolHasInstance
  } = requirePrimordials();
  writable = Writable;
  Writable.WritableState = WritableState;
  const { EventEmitter: EE } = requireEvents();
  const Stream2 = requireLegacy().Stream;
  const { Buffer: Buffer3 } = requireBuffer();
  const destroyImpl = requireDestroy();
  const { addAbortSignal: addAbortSignal2 } = requireAddAbortSignal();
  const { getHighWaterMark, getDefaultHighWaterMark } = requireState();
  const {
    ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
    ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED,
    ERR_STREAM_ALREADY_FINISHED,
    ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING
  } = requireErrors().codes;
  const { errorOrDestroy } = destroyImpl;
  ObjectSetPrototypeOf(Writable.prototype, Stream2.prototype);
  ObjectSetPrototypeOf(Writable, Stream2);
  function nop2() {
  }
  __name(nop2, "nop");
  const kOnFinished = Symbol2("kOnFinished");
  function WritableState(options, stream2, isDuplex) {
    if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof requireDuplex();
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
    this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    const noDecode = !!(options && options.decodeStrings === false);
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = onwrite.bind(void 0, stream2);
    this.writecb = null;
    this.writelen = 0;
    this.afterWriteTickInfo = null;
    resetBuffer(this);
    this.pendingcb = 0;
    this.constructed = true;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this[kOnFinished] = [];
  }
  __name(WritableState, "WritableState");
  function resetBuffer(state2) {
    state2.buffered = [];
    state2.bufferedIndex = 0;
    state2.allBuffers = true;
    state2.allNoop = true;
  }
  __name(resetBuffer, "resetBuffer");
  WritableState.prototype.getBuffer = /* @__PURE__ */ __name(function getBuffer() {
    return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
  }, "getBuffer");
  ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function Writable(options) {
    const isDuplex = this instanceof requireDuplex();
    if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
      if (typeof options.construct === "function") this._construct = options.construct;
      if (options.signal) addAbortSignal2(options.signal, this);
    }
    Stream2.call(this, options);
    destroyImpl.construct(this, () => {
      const state2 = this._writableState;
      if (!state2.writing) {
        clearBuffer(this, state2);
      }
      finishMaybe(this, state2);
    });
  }
  __name(Writable, "Writable");
  ObjectDefineProperty(Writable, SymbolHasInstance, {
    __proto__: null,
    value: /* @__PURE__ */ __name(function(object) {
      if (FunctionPrototypeSymbolHasInstance(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }, "value")
  });
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function _write(stream2, chunk, encoding, cb) {
    const state2 = stream2._writableState;
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = state2.defaultEncoding;
    } else {
      if (!encoding) encoding = state2.defaultEncoding;
      else if (encoding !== "buffer" && !Buffer3.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
      if (typeof cb !== "function") cb = nop2;
    }
    if (chunk === null) {
      throw new ERR_STREAM_NULL_VALUES();
    } else if (!state2.objectMode) {
      if (typeof chunk === "string") {
        if (state2.decodeStrings !== false) {
          chunk = Buffer3.from(chunk, encoding);
          encoding = "buffer";
        }
      } else if (chunk instanceof Buffer3) {
        encoding = "buffer";
      } else if (Stream2._isUint8Array(chunk)) {
        chunk = Stream2._uint8ArrayToBuffer(chunk);
        encoding = "buffer";
      } else {
        throw new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
    }
    let err2;
    if (state2.ending) {
      err2 = new ERR_STREAM_WRITE_AFTER_END();
    } else if (state2.destroyed) {
      err2 = new ERR_STREAM_DESTROYED("write");
    }
    if (err2) {
      process2.nextTick(cb, err2);
      errorOrDestroy(stream2, err2, true);
      return err2;
    }
    state2.pendingcb++;
    return writeOrBuffer(stream2, state2, chunk, encoding, cb);
  }
  __name(_write, "_write");
  Writable.prototype.write = function(chunk, encoding, cb) {
    return _write(this, chunk, encoding, cb) === true;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    const state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = /* @__PURE__ */ __name(function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = StringPrototypeToLowerCase(encoding);
    if (!Buffer3.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  }, "setDefaultEncoding");
  function writeOrBuffer(stream2, state2, chunk, encoding, callback) {
    const len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    const ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked || state2.errored || !state2.constructed) {
      state2.buffered.push({
        chunk,
        encoding,
        callback
      });
      if (state2.allBuffers && encoding !== "buffer") {
        state2.allBuffers = false;
      }
      if (state2.allNoop && callback !== nop2) {
        state2.allNoop = false;
      }
    } else {
      state2.writelen = len;
      state2.writecb = callback;
      state2.writing = true;
      state2.sync = true;
      stream2._write(chunk, encoding, state2.onwrite);
      state2.sync = false;
    }
    return ret && !state2.errored && !state2.destroyed;
  }
  __name(writeOrBuffer, "writeOrBuffer");
  function doWrite(stream2, state2, writev2, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev2) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  __name(doWrite, "doWrite");
  function onwriteError(stream2, state2, er, cb) {
    --state2.pendingcb;
    cb(er);
    errorBuffer(state2);
    errorOrDestroy(stream2, er);
  }
  __name(onwriteError, "onwriteError");
  function onwrite(stream2, er) {
    const state2 = stream2._writableState;
    const sync = state2.sync;
    const cb = state2.writecb;
    if (typeof cb !== "function") {
      errorOrDestroy(stream2, new ERR_MULTIPLE_CALLBACK());
      return;
    }
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
    if (er) {
      er.stack;
      if (!state2.errored) {
        state2.errored = er;
      }
      if (stream2._readableState && !stream2._readableState.errored) {
        stream2._readableState.errored = er;
      }
      if (sync) {
        process2.nextTick(onwriteError, stream2, state2, er, cb);
      } else {
        onwriteError(stream2, state2, er, cb);
      }
    } else {
      if (state2.buffered.length > state2.bufferedIndex) {
        clearBuffer(stream2, state2);
      }
      if (sync) {
        if (state2.afterWriteTickInfo !== null && state2.afterWriteTickInfo.cb === cb) {
          state2.afterWriteTickInfo.count++;
        } else {
          state2.afterWriteTickInfo = {
            count: 1,
            cb,
            stream: stream2,
            state: state2
          };
          process2.nextTick(afterWriteTick, state2.afterWriteTickInfo);
        }
      } else {
        afterWrite(stream2, state2, 1, cb);
      }
    }
  }
  __name(onwrite, "onwrite");
  function afterWriteTick({ stream: stream2, state: state2, count, cb }) {
    state2.afterWriteTickInfo = null;
    return afterWrite(stream2, state2, count, cb);
  }
  __name(afterWriteTick, "afterWriteTick");
  function afterWrite(stream2, state2, count, cb) {
    const needDrain = !state2.ending && !stream2.destroyed && state2.length === 0 && state2.needDrain;
    if (needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
    while (count-- > 0) {
      state2.pendingcb--;
      cb();
    }
    if (state2.destroyed) {
      errorBuffer(state2);
    }
    finishMaybe(stream2, state2);
  }
  __name(afterWrite, "afterWrite");
  function errorBuffer(state2) {
    if (state2.writing) {
      return;
    }
    for (let n = state2.bufferedIndex; n < state2.buffered.length; ++n) {
      var _state$errored;
      const { chunk, callback } = state2.buffered[n];
      const len = state2.objectMode ? 1 : chunk.length;
      state2.length -= len;
      callback(
        (_state$errored = state2.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
      );
    }
    const onfinishCallbacks = state2[kOnFinished].splice(0);
    for (let i = 0; i < onfinishCallbacks.length; i++) {
      var _state$errored2;
      onfinishCallbacks[i](
        (_state$errored2 = state2.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
      );
    }
    resetBuffer(state2);
  }
  __name(errorBuffer, "errorBuffer");
  function clearBuffer(stream2, state2) {
    if (state2.corked || state2.bufferProcessing || state2.destroyed || !state2.constructed) {
      return;
    }
    const { buffered, bufferedIndex, objectMode } = state2;
    const bufferedLength = buffered.length - bufferedIndex;
    if (!bufferedLength) {
      return;
    }
    let i = bufferedIndex;
    state2.bufferProcessing = true;
    if (bufferedLength > 1 && stream2._writev) {
      state2.pendingcb -= bufferedLength - 1;
      const callback = state2.allNoop ? nop2 : (err2) => {
        for (let n = i; n < buffered.length; ++n) {
          buffered[n].callback(err2);
        }
      };
      const chunks = state2.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
      chunks.allBuffers = state2.allBuffers;
      doWrite(stream2, state2, true, state2.length, chunks, "", callback);
      resetBuffer(state2);
    } else {
      do {
        const { chunk, encoding, callback } = buffered[i];
        buffered[i++] = null;
        const len = objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, callback);
      } while (i < buffered.length && !state2.writing);
      if (i === buffered.length) {
        resetBuffer(state2);
      } else if (i > 256) {
        buffered.splice(0, i);
        state2.bufferedIndex = 0;
      } else {
        state2.bufferedIndex = i;
      }
    }
    state2.bufferProcessing = false;
  }
  __name(clearBuffer, "clearBuffer");
  Writable.prototype._write = function(chunk, encoding, cb) {
    if (this._writev) {
      this._writev(
        [
          {
            chunk,
            encoding
          }
        ],
        cb
      );
    } else {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    }
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    const state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    let err2;
    if (chunk !== null && chunk !== void 0) {
      const ret = _write(this, chunk, encoding);
      if (ret instanceof Error2) {
        err2 = ret;
      }
    }
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (err2) ;
    else if (!state2.errored && !state2.ending) {
      state2.ending = true;
      finishMaybe(this, state2, true);
      state2.ended = true;
    } else if (state2.finished) {
      err2 = new ERR_STREAM_ALREADY_FINISHED("end");
    } else if (state2.destroyed) {
      err2 = new ERR_STREAM_DESTROYED("end");
    }
    if (typeof cb === "function") {
      if (err2 || state2.finished) {
        process2.nextTick(cb, err2);
      } else {
        state2[kOnFinished].push(cb);
      }
    }
    return this;
  };
  function needFinish(state2) {
    return state2.ending && !state2.destroyed && state2.constructed && state2.length === 0 && !state2.errored && state2.buffered.length === 0 && !state2.finished && !state2.writing && !state2.errorEmitted && !state2.closeEmitted;
  }
  __name(needFinish, "needFinish");
  function callFinal(stream2, state2) {
    let called = false;
    function onFinish(err2) {
      if (called) {
        errorOrDestroy(stream2, err2 !== null && err2 !== void 0 ? err2 : ERR_MULTIPLE_CALLBACK());
        return;
      }
      called = true;
      state2.pendingcb--;
      if (err2) {
        const onfinishCallbacks = state2[kOnFinished].splice(0);
        for (let i = 0; i < onfinishCallbacks.length; i++) {
          onfinishCallbacks[i](err2);
        }
        errorOrDestroy(stream2, err2, state2.sync);
      } else if (needFinish(state2)) {
        state2.prefinished = true;
        stream2.emit("prefinish");
        state2.pendingcb++;
        process2.nextTick(finish, stream2, state2);
      }
    }
    __name(onFinish, "onFinish");
    state2.sync = true;
    state2.pendingcb++;
    try {
      stream2._final(onFinish);
    } catch (err2) {
      onFinish(err2);
    }
    state2.sync = false;
  }
  __name(callFinal, "callFinal");
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function" && !state2.destroyed) {
        state2.finalCalled = true;
        callFinal(stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  __name(prefinish, "prefinish");
  function finishMaybe(stream2, state2, sync) {
    if (needFinish(state2)) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        if (sync) {
          state2.pendingcb++;
          process2.nextTick(
            (stream3, state3) => {
              if (needFinish(state3)) {
                finish(stream3, state3);
              } else {
                state3.pendingcb--;
              }
            },
            stream2,
            state2
          );
        } else if (needFinish(state2)) {
          state2.pendingcb++;
          finish(stream2, state2);
        }
      }
    }
  }
  __name(finishMaybe, "finishMaybe");
  function finish(stream2, state2) {
    state2.pendingcb--;
    state2.finished = true;
    const onfinishCallbacks = state2[kOnFinished].splice(0);
    for (let i = 0; i < onfinishCallbacks.length; i++) {
      onfinishCallbacks[i]();
    }
    stream2.emit("finish");
    if (state2.autoDestroy) {
      const rState = stream2._readableState;
      const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (rState.endEmitted || rState.readable === false);
      if (autoDestroy) {
        stream2.destroy();
      }
    }
  }
  __name(finish, "finish");
  ObjectDefineProperties(Writable.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : false;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : false;
      },
      set(value) {
        if (this._writableState) {
          this._writableState.destroyed = value;
        }
      }
    },
    writable: {
      __proto__: null,
      get() {
        const w = this._writableState;
        return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
      },
      set(val) {
        if (this._writableState) {
          this._writableState.writable = !!val;
        }
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : false;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : false;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : false;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const wState = this._writableState;
        if (!wState) return false;
        return !wState.destroyed && !wState.ending && wState.needDrain;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: false,
      get: /* @__PURE__ */ __name(function() {
        return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }, "get")
    }
  });
  const destroy = destroyImpl.destroy;
  Writable.prototype.destroy = function(err2, cb) {
    const state2 = this._writableState;
    if (!state2.destroyed && (state2.bufferedIndex < state2.buffered.length || state2[kOnFinished].length)) {
      process2.nextTick(errorBuffer, state2);
    }
    destroy.call(this, err2, cb);
    return this;
  };
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err2, cb) {
    cb(err2);
  };
  Writable.prototype[EE.captureRejectionSymbol] = function(err2) {
    this.destroy(err2);
  };
  let webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === void 0) webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  __name(lazyWebStreams, "lazyWebStreams");
  Writable.fromWeb = function(writableStream, options) {
    return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
  };
  Writable.toWeb = function(streamWritable) {
    return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
  };
  return writable;
}
__name(requireWritable, "requireWritable");
var duplexify;
var hasRequiredDuplexify;
function requireDuplexify() {
  if (hasRequiredDuplexify) return duplexify;
  hasRequiredDuplexify = 1;
  const process2 = requireBrowser$3();
  const bufferModule = requireBuffer();
  const {
    isReadable,
    isWritable,
    isIterable: isIterable2,
    isNodeStream,
    isReadableNodeStream,
    isWritableNodeStream,
    isDuplexNodeStream,
    isReadableStream,
    isWritableStream
  } = requireUtils();
  const eos = requireEndOfStream();
  const {
    AbortError,
    codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE }
  } = requireErrors();
  const { destroyer } = requireDestroy();
  const Duplex = requireDuplex();
  const Readable = requireReadable();
  const Writable = requireWritable();
  const { createDeferredPromise } = requireUtil$1();
  const from = requireFrom();
  const Blob2 = globalThis.Blob || bufferModule.Blob;
  const isBlob = typeof Blob2 !== "undefined" ? /* @__PURE__ */ __name(function isBlob2(b) {
    return b instanceof Blob2;
  }, "isBlob") : /* @__PURE__ */ __name(function isBlob2(b) {
    return false;
  }, "isBlob");
  const AbortController = globalThis.AbortController || requireBrowser$4().AbortController;
  const { FunctionPrototypeCall } = requirePrimordials();
  const _Duplexify = class _Duplexify extends Duplex {
    constructor(options) {
      super(options);
      if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
        this._readableState.readable = false;
        this._readableState.ended = true;
        this._readableState.endEmitted = true;
      }
      if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
        this._writableState.writable = false;
        this._writableState.ending = true;
        this._writableState.ended = true;
        this._writableState.finished = true;
      }
    }
  };
  __name(_Duplexify, "Duplexify");
  let Duplexify = _Duplexify;
  duplexify = /* @__PURE__ */ __name(function duplexify2(body2, name) {
    if (isDuplexNodeStream(body2)) {
      return body2;
    }
    if (isReadableNodeStream(body2)) {
      return _duplexify({
        readable: body2
      });
    }
    if (isWritableNodeStream(body2)) {
      return _duplexify({
        writable: body2
      });
    }
    if (isNodeStream(body2)) {
      return _duplexify({
        writable: false,
        readable: false
      });
    }
    if (isReadableStream(body2)) {
      return _duplexify({
        readable: Readable.fromWeb(body2)
      });
    }
    if (isWritableStream(body2)) {
      return _duplexify({
        writable: Writable.fromWeb(body2)
      });
    }
    if (typeof body2 === "function") {
      const { value, write: write2, final, destroy } = fromAsyncGen(body2);
      if (isIterable2(value)) {
        return from(Duplexify, value, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          write: write2,
          final,
          destroy
        });
      }
      const then2 = value === null || value === void 0 ? void 0 : value.then;
      if (typeof then2 === "function") {
        let d;
        const promise = FunctionPrototypeCall(
          then2,
          value,
          (val) => {
            if (val != null) {
              throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
            }
          },
          (err2) => {
            destroyer(d, err2);
          }
        );
        return d = new Duplexify({
          // TODO (ronag): highWaterMark?
          objectMode: true,
          readable: false,
          write: write2,
          final(cb) {
            final(async () => {
              try {
                await promise;
                process2.nextTick(cb, null);
              } catch (err2) {
                process2.nextTick(cb, err2);
              }
            });
          },
          destroy
        });
      }
      throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
    }
    if (isBlob(body2)) {
      return duplexify2(body2.arrayBuffer());
    }
    if (isIterable2(body2)) {
      return from(Duplexify, body2, {
        // TODO (ronag): highWaterMark?
        objectMode: true,
        writable: false
      });
    }
    if (isReadableStream(body2 === null || body2 === void 0 ? void 0 : body2.readable) && isWritableStream(body2 === null || body2 === void 0 ? void 0 : body2.writable)) {
      return Duplexify.fromWeb(body2);
    }
    if (typeof (body2 === null || body2 === void 0 ? void 0 : body2.writable) === "object" || typeof (body2 === null || body2 === void 0 ? void 0 : body2.readable) === "object") {
      const readable2 = body2 !== null && body2 !== void 0 && body2.readable ? isReadableNodeStream(body2 === null || body2 === void 0 ? void 0 : body2.readable) ? body2 === null || body2 === void 0 ? void 0 : body2.readable : duplexify2(body2.readable) : void 0;
      const writable2 = body2 !== null && body2 !== void 0 && body2.writable ? isWritableNodeStream(body2 === null || body2 === void 0 ? void 0 : body2.writable) ? body2 === null || body2 === void 0 ? void 0 : body2.writable : duplexify2(body2.writable) : void 0;
      return _duplexify({
        readable: readable2,
        writable: writable2
      });
    }
    const then = body2 === null || body2 === void 0 ? void 0 : body2.then;
    if (typeof then === "function") {
      let d;
      FunctionPrototypeCall(
        then,
        body2,
        (val) => {
          if (val != null) {
            d.push(val);
          }
          d.push(null);
        },
        (err2) => {
          destroyer(d, err2);
        }
      );
      return d = new Duplexify({
        objectMode: true,
        writable: false,
        read() {
        }
      });
    }
    throw new ERR_INVALID_ARG_TYPE2(
      name,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      body2
    );
  }, "duplexify");
  function fromAsyncGen(fn) {
    let { promise, resolve: resolve2 } = createDeferredPromise();
    const ac = new AbortController();
    const signal = ac.signal;
    const value = fn(
      (async function* () {
        while (true) {
          const _promise = promise;
          promise = null;
          const { chunk, done, cb } = await _promise;
          process2.nextTick(cb);
          if (done) return;
          if (signal.aborted)
            throw new AbortError(void 0, {
              cause: signal.reason
            });
          ({ promise, resolve: resolve2 } = createDeferredPromise());
          yield chunk;
        }
      })(),
      {
        signal
      }
    );
    return {
      value,
      write(chunk, encoding, cb) {
        const _resolve = resolve2;
        resolve2 = null;
        _resolve({
          chunk,
          done: false,
          cb
        });
      },
      final(cb) {
        const _resolve = resolve2;
        resolve2 = null;
        _resolve({
          done: true,
          cb
        });
      },
      destroy(err2, cb) {
        ac.abort();
        cb(err2);
      }
    };
  }
  __name(fromAsyncGen, "fromAsyncGen");
  function _duplexify(pair) {
    const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
    const w = pair.writable;
    let readable2 = !!isReadable(r);
    let writable2 = !!isWritable(w);
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err2) {
      const cb = onclose;
      onclose = null;
      if (cb) {
        cb(err2);
      } else if (err2) {
        d.destroy(err2);
      }
    }
    __name(onfinished, "onfinished");
    d = new Duplexify({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
      writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
      readable: readable2,
      writable: writable2
    });
    if (writable2) {
      eos(w, (err2) => {
        writable2 = false;
        if (err2) {
          destroyer(r, err2);
        }
        onfinished(err2);
      });
      d._write = function(chunk, encoding, callback) {
        if (w.write(chunk, encoding)) {
          callback();
        } else {
          ondrain = callback;
        }
      };
      d._final = function(callback) {
        w.end();
        onfinish = callback;
      };
      w.on("drain", function() {
        if (ondrain) {
          const cb = ondrain;
          ondrain = null;
          cb();
        }
      });
      w.on("finish", function() {
        if (onfinish) {
          const cb = onfinish;
          onfinish = null;
          cb();
        }
      });
    }
    if (readable2) {
      eos(r, (err2) => {
        readable2 = false;
        if (err2) {
          destroyer(r, err2);
        }
        onfinished(err2);
      });
      r.on("readable", function() {
        if (onreadable) {
          const cb = onreadable;
          onreadable = null;
          cb();
        }
      });
      r.on("end", function() {
        d.push(null);
      });
      d._read = function() {
        while (true) {
          const buf = r.read();
          if (buf === null) {
            onreadable = d._read;
            return;
          }
          if (!d.push(buf)) {
            return;
          }
        }
      };
    }
    d._destroy = function(err2, callback) {
      if (!err2 && onclose !== null) {
        err2 = new AbortError();
      }
      onreadable = null;
      ondrain = null;
      onfinish = null;
      if (onclose === null) {
        callback(err2);
      } else {
        onclose = callback;
        destroyer(w, err2);
        destroyer(r, err2);
      }
    };
    return d;
  }
  __name(_duplexify, "_duplexify");
  return duplexify;
}
__name(requireDuplexify, "requireDuplexify");
var duplex;
var hasRequiredDuplex;
function requireDuplex() {
  if (hasRequiredDuplex) return duplex;
  hasRequiredDuplex = 1;
  const {
    ObjectDefineProperties,
    ObjectGetOwnPropertyDescriptor,
    ObjectKeys,
    ObjectSetPrototypeOf
  } = requirePrimordials();
  duplex = Duplex;
  const Readable = requireReadable();
  const Writable = requireWritable();
  ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
  ObjectSetPrototypeOf(Duplex, Readable);
  {
    const keys = ObjectKeys(Writable.prototype);
    for (let i = 0; i < keys.length; i++) {
      const method = keys[i];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options) {
      this.allowHalfOpen = options.allowHalfOpen !== false;
      if (options.readable === false) {
        this._readableState.readable = false;
        this._readableState.ended = true;
        this._readableState.endEmitted = true;
      }
      if (options.writable === false) {
        this._writableState.writable = false;
        this._writableState.ending = true;
        this._writableState.ended = true;
        this._writableState.finished = true;
      }
    } else {
      this.allowHalfOpen = true;
    }
  }
  __name(Duplex, "Duplex");
  ObjectDefineProperties(Duplex.prototype, {
    writable: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set(value) {
        if (this._readableState && this._writableState) {
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      }
    }
  });
  let webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === void 0) webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  __name(lazyWebStreams, "lazyWebStreams");
  Duplex.fromWeb = function(pair, options) {
    return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
  };
  Duplex.toWeb = function(duplex2) {
    return lazyWebStreams().newReadableWritablePairFromDuplex(duplex2);
  };
  let duplexify2;
  Duplex.from = function(body2) {
    if (!duplexify2) {
      duplexify2 = requireDuplexify();
    }
    return duplexify2(body2, "body");
  };
  return duplex;
}
__name(requireDuplex, "requireDuplex");
var transform;
var hasRequiredTransform;
function requireTransform() {
  if (hasRequiredTransform) return transform;
  hasRequiredTransform = 1;
  const { ObjectSetPrototypeOf, Symbol: Symbol2 } = requirePrimordials();
  transform = Transform;
  const { ERR_METHOD_NOT_IMPLEMENTED } = requireErrors().codes;
  const Duplex = requireDuplex();
  const { getHighWaterMark } = requireState();
  ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
  ObjectSetPrototypeOf(Transform, Duplex);
  const kCallback = Symbol2("kCallback");
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
    if (readableHighWaterMark === 0) {
      options = {
        ...options,
        highWaterMark: null,
        readableHighWaterMark,
        // TODO (ronag): 0 is not optimal since we have
        // a "bug" where we check needDrain before calling _write and not after.
        // Refs: https://github.com/nodejs/node/pull/32887
        // Refs: https://github.com/nodejs/node/pull/35941
        writableHighWaterMark: options.writableHighWaterMark || 0
      };
    }
    Duplex.call(this, options);
    this._readableState.sync = false;
    this[kCallback] = null;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  __name(Transform, "Transform");
  function final(cb) {
    if (typeof this._flush === "function" && !this.destroyed) {
      this._flush((er, data) => {
        if (er) {
          if (cb) {
            cb(er);
          } else {
            this.destroy(er);
          }
          return;
        }
        if (data != null) {
          this.push(data);
        }
        this.push(null);
        if (cb) {
          cb();
        }
      });
    } else {
      this.push(null);
      if (cb) {
        cb();
      }
    }
  }
  __name(final, "final");
  function prefinish() {
    if (this._final !== final) {
      final.call(this);
    }
  }
  __name(prefinish, "prefinish");
  Transform.prototype._final = final;
  Transform.prototype._transform = function(chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
  };
  Transform.prototype._write = function(chunk, encoding, callback) {
    const rState = this._readableState;
    const wState = this._writableState;
    const length = rState.length;
    this._transform(chunk, encoding, (err2, val) => {
      if (err2) {
        callback(err2);
        return;
      }
      if (val != null) {
        this.push(val);
      }
      if (wState.ended || // Backwards compat.
      length === rState.length || // Backwards compat.
      rState.length < rState.highWaterMark) {
        callback();
      } else {
        this[kCallback] = callback;
      }
    });
  };
  Transform.prototype._read = function() {
    if (this[kCallback]) {
      const callback = this[kCallback];
      this[kCallback] = null;
      callback();
    }
  };
  return transform;
}
__name(requireTransform, "requireTransform");
var passthrough;
var hasRequiredPassthrough;
function requirePassthrough() {
  if (hasRequiredPassthrough) return passthrough;
  hasRequiredPassthrough = 1;
  const { ObjectSetPrototypeOf } = requirePrimordials();
  passthrough = PassThrough;
  const Transform = requireTransform();
  ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
  ObjectSetPrototypeOf(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  __name(PassThrough, "PassThrough");
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return passthrough;
}
__name(requirePassthrough, "requirePassthrough");
var pipeline_1;
var hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  const process2 = requireBrowser$3();
  const { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = requirePrimordials();
  const eos = requireEndOfStream();
  const { once } = requireUtil$1();
  const destroyImpl = requireDestroy();
  const Duplex = requireDuplex();
  const {
    aggregateTwoErrors,
    codes: {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_INVALID_RETURN_VALUE,
      ERR_MISSING_ARGS,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_PREMATURE_CLOSE
    },
    AbortError
  } = requireErrors();
  const { validateFunction, validateAbortSignal } = requireValidators();
  const {
    isIterable: isIterable2,
    isReadable,
    isReadableNodeStream,
    isNodeStream,
    isTransformStream,
    isWebStream,
    isReadableStream,
    isReadableFinished
  } = requireUtils();
  const AbortController = globalThis.AbortController || requireBrowser$4().AbortController;
  let PassThrough;
  let Readable;
  let addAbortListener;
  function destroyer(stream2, reading, writing) {
    let finished = false;
    stream2.on("close", () => {
      finished = true;
    });
    const cleanup = eos(
      stream2,
      {
        readable: reading,
        writable: writing
      },
      (err2) => {
        finished = !err2;
      }
    );
    return {
      destroy: /* @__PURE__ */ __name((err2) => {
        if (finished) return;
        finished = true;
        destroyImpl.destroyer(stream2, err2 || new ERR_STREAM_DESTROYED("pipe"));
      }, "destroy"),
      cleanup
    };
  }
  __name(destroyer, "destroyer");
  function popCallback(streams) {
    validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
    return streams.pop();
  }
  __name(popCallback, "popCallback");
  function makeAsyncIterable(val) {
    if (isIterable2(val)) {
      return val;
    } else if (isReadableNodeStream(val)) {
      return fromReadable(val);
    }
    throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable"], val);
  }
  __name(makeAsyncIterable, "makeAsyncIterable");
  async function* fromReadable(val) {
    if (!Readable) {
      Readable = requireReadable();
    }
    yield* Readable.prototype[SymbolAsyncIterator].call(val);
  }
  __name(fromReadable, "fromReadable");
  async function pumpToNode(iterable, writable2, finish, { end }) {
    let error;
    let onresolve = null;
    const resume = /* @__PURE__ */ __name((err2) => {
      if (err2) {
        error = err2;
      }
      if (onresolve) {
        const callback = onresolve;
        onresolve = null;
        callback();
      }
    }, "resume");
    const wait = /* @__PURE__ */ __name(() => new Promise2((resolve2, reject) => {
      if (error) {
        reject(error);
      } else {
        onresolve = /* @__PURE__ */ __name(() => {
          if (error) {
            reject(error);
          } else {
            resolve2();
          }
        }, "onresolve");
      }
    }), "wait");
    writable2.on("drain", resume);
    const cleanup = eos(
      writable2,
      {
        readable: false
      },
      resume
    );
    try {
      if (writable2.writableNeedDrain) {
        await wait();
      }
      for await (const chunk of iterable) {
        if (!writable2.write(chunk)) {
          await wait();
        }
      }
      if (end) {
        writable2.end();
        await wait();
      }
      finish();
    } catch (err2) {
      finish(error !== err2 ? aggregateTwoErrors(error, err2) : err2);
    } finally {
      cleanup();
      writable2.off("drain", resume);
    }
  }
  __name(pumpToNode, "pumpToNode");
  async function pumpToWeb(readable2, writable2, finish, { end }) {
    if (isTransformStream(writable2)) {
      writable2 = writable2.writable;
    }
    const writer = writable2.getWriter();
    try {
      for await (const chunk of readable2) {
        await writer.ready;
        writer.write(chunk).catch(() => {
        });
      }
      await writer.ready;
      if (end) {
        await writer.close();
      }
      finish();
    } catch (err2) {
      try {
        await writer.abort(err2);
        finish(err2);
      } catch (err3) {
        finish(err3);
      }
    }
  }
  __name(pumpToWeb, "pumpToWeb");
  function pipeline(...streams) {
    return pipelineImpl(streams, once(popCallback(streams)));
  }
  __name(pipeline, "pipeline");
  function pipelineImpl(streams, callback, opts) {
    if (streams.length === 1 && ArrayIsArray(streams[0])) {
      streams = streams[0];
    }
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    const ac = new AbortController();
    const signal = ac.signal;
    const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
    const lastStreamCleanup = [];
    validateAbortSignal(outerSignal, "options.signal");
    function abort() {
      finishImpl(new AbortError());
    }
    __name(abort, "abort");
    addAbortListener = addAbortListener || requireUtil$1().addAbortListener;
    let disposable;
    if (outerSignal) {
      disposable = addAbortListener(outerSignal, abort);
    }
    let error;
    let value;
    const destroys = [];
    let finishCount = 0;
    function finish(err2) {
      finishImpl(err2, --finishCount === 0);
    }
    __name(finish, "finish");
    function finishImpl(err2, final) {
      var _disposable;
      if (err2 && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
        error = err2;
      }
      if (!error && !final) {
        return;
      }
      while (destroys.length) {
        destroys.shift()(error);
      }
      (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
      ac.abort();
      if (final) {
        if (!error) {
          lastStreamCleanup.forEach((fn) => fn());
        }
        process2.nextTick(callback, error, value);
      }
    }
    __name(finishImpl, "finishImpl");
    let ret;
    for (let i = 0; i < streams.length; i++) {
      const stream2 = streams[i];
      const reading = i < streams.length - 1;
      const writing = i > 0;
      const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
      const isLastStream = i === streams.length - 1;
      if (isNodeStream(stream2)) {
        let onError = function(err2) {
          if (err2 && err2.name !== "AbortError" && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            finish(err2);
          }
        };
        __name(onError, "onError");
        if (end) {
          const { destroy, cleanup } = destroyer(stream2, reading, writing);
          destroys.push(destroy);
          if (isReadable(stream2) && isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        }
        stream2.on("error", onError);
        if (isReadable(stream2) && isLastStream) {
          lastStreamCleanup.push(() => {
            stream2.removeListener("error", onError);
          });
        }
      }
      if (i === 0) {
        if (typeof stream2 === "function") {
          ret = stream2({
            signal
          });
          if (!isIterable2(ret)) {
            throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
          }
        } else if (isIterable2(stream2) || isReadableNodeStream(stream2) || isTransformStream(stream2)) {
          ret = stream2;
        } else {
          ret = Duplex.from(stream2);
        }
      } else if (typeof stream2 === "function") {
        if (isTransformStream(ret)) {
          var _ret;
          ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
        } else {
          ret = makeAsyncIterable(ret);
        }
        ret = stream2(ret, {
          signal
        });
        if (reading) {
          if (!isIterable2(ret, true)) {
            throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
          }
        } else {
          var _ret2;
          if (!PassThrough) {
            PassThrough = requirePassthrough();
          }
          const pt = new PassThrough({
            objectMode: true
          });
          const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
          if (typeof then === "function") {
            finishCount++;
            then.call(
              ret,
              (val) => {
                value = val;
                if (val != null) {
                  pt.write(val);
                }
                if (end) {
                  pt.end();
                }
                process2.nextTick(finish);
              },
              (err2) => {
                pt.destroy(err2);
                process2.nextTick(finish, err2);
              }
            );
          } else if (isIterable2(ret, true)) {
            finishCount++;
            pumpToNode(ret, pt, finish, {
              end
            });
          } else if (isReadableStream(ret) || isTransformStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, pt, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
          }
          ret = pt;
          const { destroy, cleanup } = destroyer(ret, false, true);
          destroys.push(destroy);
          if (isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        }
      } else if (isNodeStream(stream2)) {
        if (isReadableNodeStream(ret)) {
          finishCount += 2;
          const cleanup = pipe2(ret, stream2, finish, {
            end
          });
          if (isReadable(stream2) && isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        } else if (isTransformStream(ret) || isReadableStream(ret)) {
          const toRead = ret.readable || ret;
          finishCount++;
          pumpToNode(toRead, stream2, finish, {
            end
          });
        } else if (isIterable2(ret)) {
          finishCount++;
          pumpToNode(ret, stream2, finish, {
            end
          });
        } else {
          throw new ERR_INVALID_ARG_TYPE2(
            "val",
            ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
            ret
          );
        }
        ret = stream2;
      } else if (isWebStream(stream2)) {
        if (isReadableNodeStream(ret)) {
          finishCount++;
          pumpToWeb(makeAsyncIterable(ret), stream2, finish, {
            end
          });
        } else if (isReadableStream(ret) || isIterable2(ret)) {
          finishCount++;
          pumpToWeb(ret, stream2, finish, {
            end
          });
        } else if (isTransformStream(ret)) {
          finishCount++;
          pumpToWeb(ret.readable, stream2, finish, {
            end
          });
        } else {
          throw new ERR_INVALID_ARG_TYPE2(
            "val",
            ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
            ret
          );
        }
        ret = stream2;
      } else {
        ret = Duplex.from(stream2);
      }
    }
    if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
      process2.nextTick(abort);
    }
    return ret;
  }
  __name(pipelineImpl, "pipelineImpl");
  function pipe2(src, dst, finish, { end }) {
    let ended = false;
    dst.on("close", () => {
      if (!ended) {
        finish(new ERR_STREAM_PREMATURE_CLOSE());
      }
    });
    src.pipe(dst, {
      end: false
    });
    if (end) {
      let endFn = function() {
        ended = true;
        dst.end();
      };
      __name(endFn, "endFn");
      if (isReadableFinished(src)) {
        process2.nextTick(endFn);
      } else {
        src.once("end", endFn);
      }
    } else {
      finish();
    }
    eos(
      src,
      {
        readable: true,
        writable: false
      },
      (err2) => {
        const rState = src._readableState;
        if (err2 && err2.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
          src.once("end", finish).once("error", finish);
        } else {
          finish(err2);
        }
      }
    );
    return eos(
      dst,
      {
        readable: false,
        writable: true
      },
      finish
    );
  }
  __name(pipe2, "pipe");
  pipeline_1 = {
    pipelineImpl,
    pipeline
  };
  return pipeline_1;
}
__name(requirePipeline, "requirePipeline");
var compose;
var hasRequiredCompose;
function requireCompose() {
  if (hasRequiredCompose) return compose;
  hasRequiredCompose = 1;
  const { pipeline } = requirePipeline();
  const Duplex = requireDuplex();
  const { destroyer } = requireDestroy();
  const {
    isNodeStream,
    isReadable,
    isWritable,
    isWebStream,
    isTransformStream,
    isWritableStream,
    isReadableStream
  } = requireUtils();
  const {
    AbortError,
    codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
  } = requireErrors();
  const eos = requireEndOfStream();
  compose = /* @__PURE__ */ __name(function compose2(...streams) {
    if (streams.length === 0) {
      throw new ERR_MISSING_ARGS("streams");
    }
    if (streams.length === 1) {
      return Duplex.from(streams[0]);
    }
    const orgStreams = [...streams];
    if (typeof streams[0] === "function") {
      streams[0] = Duplex.from(streams[0]);
    }
    if (typeof streams[streams.length - 1] === "function") {
      const idx = streams.length - 1;
      streams[idx] = Duplex.from(streams[idx]);
    }
    for (let n = 0; n < streams.length; ++n) {
      if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
        continue;
      }
      if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
        throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
      }
      if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
        throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
      }
    }
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err2) {
      const cb = onclose;
      onclose = null;
      if (cb) {
        cb(err2);
      } else if (err2) {
        d.destroy(err2);
      } else if (!readable2 && !writable2) {
        d.destroy();
      }
    }
    __name(onfinished, "onfinished");
    const head = streams[0];
    const tail = pipeline(streams, onfinished);
    const writable2 = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
    const readable2 = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
    d = new Duplex({
      // TODO (ronag): highWaterMark?
      writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
      readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
      writable: writable2,
      readable: readable2
    });
    if (writable2) {
      if (isNodeStream(head)) {
        d._write = function(chunk, encoding, callback) {
          if (head.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          head.end();
          onfinish = callback;
        };
        head.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
      } else if (isWebStream(head)) {
        const writable3 = isTransformStream(head) ? head.writable : head;
        const writer = writable3.getWriter();
        d._write = async function(chunk, encoding, callback) {
          try {
            await writer.ready;
            writer.write(chunk).catch(() => {
            });
            callback();
          } catch (err2) {
            callback(err2);
          }
        };
        d._final = async function(callback) {
          try {
            await writer.ready;
            writer.close().catch(() => {
            });
            onfinish = callback;
          } catch (err2) {
            callback(err2);
          }
        };
      }
      const toRead = isTransformStream(tail) ? tail.readable : tail;
      eos(toRead, () => {
        if (onfinish) {
          const cb = onfinish;
          onfinish = null;
          cb();
        }
      });
    }
    if (readable2) {
      if (isNodeStream(tail)) {
        tail.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        tail.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = tail.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      } else if (isWebStream(tail)) {
        const readable3 = isTransformStream(tail) ? tail.readable : tail;
        const reader = readable3.getReader();
        d._read = async function() {
          while (true) {
            try {
              const { value, done } = await reader.read();
              if (!d.push(value)) {
                return;
              }
              if (done) {
                d.push(null);
                return;
              }
            } catch {
              return;
            }
          }
        };
      }
    }
    d._destroy = function(err2, callback) {
      if (!err2 && onclose !== null) {
        err2 = new AbortError();
      }
      onreadable = null;
      ondrain = null;
      onfinish = null;
      if (onclose === null) {
        callback(err2);
      } else {
        onclose = callback;
        if (isNodeStream(tail)) {
          destroyer(tail, err2);
        }
      }
    };
    return d;
  }, "compose");
  return compose;
}
__name(requireCompose, "requireCompose");
var hasRequiredOperators;
function requireOperators() {
  if (hasRequiredOperators) return operators;
  hasRequiredOperators = 1;
  const AbortController = globalThis.AbortController || requireBrowser$4().AbortController;
  const {
    codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
    AbortError
  } = requireErrors();
  const { validateAbortSignal, validateInteger, validateObject: validateObject2 } = requireValidators();
  const kWeakHandler = requirePrimordials().Symbol("kWeak");
  const kResistStopPropagation = requirePrimordials().Symbol("kResistStopPropagation");
  const { finished } = requireEndOfStream();
  const staticCompose = requireCompose();
  const { addAbortSignalNoValidate } = requireAddAbortSignal();
  const { isWritable, isNodeStream } = requireUtils();
  const { deprecate } = requireUtil$1();
  const {
    ArrayPrototypePush,
    Boolean: Boolean2,
    MathFloor,
    Number: Number2,
    NumberIsNaN,
    Promise: Promise2,
    PromiseReject,
    PromiseResolve,
    PromisePrototypeThen,
    Symbol: Symbol2
  } = requirePrimordials();
  const kEmpty = Symbol2("kEmpty");
  const kEof = Symbol2("kEof");
  function compose2(stream2, options) {
    if (options != null) {
      validateObject2(options, "options");
    }
    if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    if (isNodeStream(stream2) && !isWritable(stream2)) {
      throw new ERR_INVALID_ARG_VALUE("stream", stream2, "must be writable");
    }
    const composedStream = staticCompose(this, stream2);
    if (options !== null && options !== void 0 && options.signal) {
      addAbortSignalNoValidate(options.signal, composedStream);
    }
    return composedStream;
  }
  __name(compose2, "compose");
  function map(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    }
    if (options != null) {
      validateObject2(options, "options");
    }
    if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    let concurrency = 1;
    if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
      concurrency = MathFloor(options.concurrency);
    }
    let highWaterMark = concurrency - 1;
    if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
      highWaterMark = MathFloor(options.highWaterMark);
    }
    validateInteger(concurrency, "options.concurrency", 1);
    validateInteger(highWaterMark, "options.highWaterMark", 0);
    highWaterMark += concurrency;
    return (/* @__PURE__ */ __name(async function* map2() {
      const signal = requireUtil$1().AbortSignalAny(
        [options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2)
      );
      const stream2 = this;
      const queue2 = [];
      const signalOpt = {
        signal
      };
      let next;
      let resume;
      let done = false;
      let cnt = 0;
      function onCatch() {
        done = true;
        afterItemProcessed();
      }
      __name(onCatch, "onCatch");
      function afterItemProcessed() {
        cnt -= 1;
        maybeResume();
      }
      __name(afterItemProcessed, "afterItemProcessed");
      function maybeResume() {
        if (resume && !done && cnt < concurrency && queue2.length < highWaterMark) {
          resume();
          resume = null;
        }
      }
      __name(maybeResume, "maybeResume");
      async function pump() {
        try {
          for await (let val of stream2) {
            if (done) {
              return;
            }
            if (signal.aborted) {
              throw new AbortError();
            }
            try {
              val = fn(val, signalOpt);
              if (val === kEmpty) {
                continue;
              }
              val = PromiseResolve(val);
            } catch (err2) {
              val = PromiseReject(err2);
            }
            cnt += 1;
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue2.push(val);
            if (next) {
              next();
              next = null;
            }
            if (!done && (queue2.length >= highWaterMark || cnt >= concurrency)) {
              await new Promise2((resolve2) => {
                resume = resolve2;
              });
            }
          }
          queue2.push(kEof);
        } catch (err2) {
          const val = PromiseReject(err2);
          PromisePrototypeThen(val, afterItemProcessed, onCatch);
          queue2.push(val);
        } finally {
          done = true;
          if (next) {
            next();
            next = null;
          }
        }
      }
      __name(pump, "pump");
      pump();
      try {
        while (true) {
          while (queue2.length > 0) {
            const val = await queue2[0];
            if (val === kEof) {
              return;
            }
            if (signal.aborted) {
              throw new AbortError();
            }
            if (val !== kEmpty) {
              yield val;
            }
            queue2.shift();
            maybeResume();
          }
          await new Promise2((resolve2) => {
            next = resolve2;
          });
        }
      } finally {
        done = true;
        if (resume) {
          resume();
          resume = null;
        }
      }
    }, "map")).call(this);
  }
  __name(map, "map");
  function asIndexedPairs(options = void 0) {
    if (options != null) {
      validateObject2(options, "options");
    }
    if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    return (/* @__PURE__ */ __name(async function* asIndexedPairs2() {
      let index = 0;
      for await (const val of this) {
        var _options$signal;
        if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
          throw new AbortError({
            cause: options.signal.reason
          });
        }
        yield [index++, val];
      }
    }, "asIndexedPairs")).call(this);
  }
  __name(asIndexedPairs, "asIndexedPairs");
  async function some(fn, options = void 0) {
    for await (const unused of filter.call(this, fn, options)) {
      return true;
    }
    return false;
  }
  __name(some, "some");
  async function every(fn, options = void 0) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    }
    return !await some.call(
      this,
      async (...args) => {
        return !await fn(...args);
      },
      options
    );
  }
  __name(every, "every");
  async function find(fn, options) {
    for await (const result of filter.call(this, fn, options)) {
      return result;
    }
    return void 0;
  }
  __name(find, "find");
  async function forEach(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    }
    async function forEachFn(value, options2) {
      await fn(value, options2);
      return kEmpty;
    }
    __name(forEachFn, "forEachFn");
    for await (const unused of map.call(this, forEachFn, options)) ;
  }
  __name(forEach, "forEach");
  function filter(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    }
    async function filterFn(value, options2) {
      if (await fn(value, options2)) {
        return value;
      }
      return kEmpty;
    }
    __name(filterFn, "filterFn");
    return map.call(this, filterFn, options);
  }
  __name(filter, "filter");
  const _ReduceAwareErrMissingArgs = class _ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
    constructor() {
      super("reduce");
      this.message = "Reduce of an empty stream requires an initial value";
    }
  };
  __name(_ReduceAwareErrMissingArgs, "ReduceAwareErrMissingArgs");
  let ReduceAwareErrMissingArgs = _ReduceAwareErrMissingArgs;
  async function reduce(reducer, initialValue, options) {
    var _options$signal2;
    if (typeof reducer !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("reducer", ["Function", "AsyncFunction"], reducer);
    }
    if (options != null) {
      validateObject2(options, "options");
    }
    if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    let hasInitialValue = arguments.length > 1;
    if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
      const err2 = new AbortError(void 0, {
        cause: options.signal.reason
      });
      this.once("error", () => {
      });
      await finished(this.destroy(err2));
      throw err2;
    }
    const ac = new AbortController();
    const signal = ac.signal;
    if (options !== null && options !== void 0 && options.signal) {
      const opts = {
        once: true,
        [kWeakHandler]: this,
        [kResistStopPropagation]: true
      };
      options.signal.addEventListener("abort", () => ac.abort(), opts);
    }
    let gotAnyItemFromStream = false;
    try {
      for await (const value of this) {
        var _options$signal3;
        gotAnyItemFromStream = true;
        if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
          throw new AbortError();
        }
        if (!hasInitialValue) {
          initialValue = value;
          hasInitialValue = true;
        } else {
          initialValue = await reducer(initialValue, value, {
            signal
          });
        }
      }
      if (!gotAnyItemFromStream && !hasInitialValue) {
        throw new ReduceAwareErrMissingArgs();
      }
    } finally {
      ac.abort();
    }
    return initialValue;
  }
  __name(reduce, "reduce");
  async function toArray(options) {
    if (options != null) {
      validateObject2(options, "options");
    }
    if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    const result = [];
    for await (const val of this) {
      var _options$signal4;
      if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
        throw new AbortError(void 0, {
          cause: options.signal.reason
        });
      }
      ArrayPrototypePush(result, val);
    }
    return result;
  }
  __name(toArray, "toArray");
  function flatMap(fn, options) {
    const values = map.call(this, fn, options);
    return (/* @__PURE__ */ __name(async function* flatMap2() {
      for await (const val of values) {
        yield* val;
      }
    }, "flatMap")).call(this);
  }
  __name(flatMap, "flatMap");
  function toIntegerOrInfinity(number) {
    number = Number2(number);
    if (NumberIsNaN(number)) {
      return 0;
    }
    if (number < 0) {
      throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
    }
    return number;
  }
  __name(toIntegerOrInfinity, "toIntegerOrInfinity");
  function drop(number, options = void 0) {
    if (options != null) {
      validateObject2(options, "options");
    }
    if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    number = toIntegerOrInfinity(number);
    return (/* @__PURE__ */ __name(async function* drop2() {
      var _options$signal5;
      if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
        throw new AbortError();
      }
      for await (const val of this) {
        var _options$signal6;
        if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
          throw new AbortError();
        }
        if (number-- <= 0) {
          yield val;
        }
      }
    }, "drop")).call(this);
  }
  __name(drop, "drop");
  function take(number, options = void 0) {
    if (options != null) {
      validateObject2(options, "options");
    }
    if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    number = toIntegerOrInfinity(number);
    return (/* @__PURE__ */ __name(async function* take2() {
      var _options$signal7;
      if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
        throw new AbortError();
      }
      for await (const val of this) {
        var _options$signal8;
        if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
          throw new AbortError();
        }
        if (number-- > 0) {
          yield val;
        }
        if (number <= 0) {
          return;
        }
      }
    }, "take")).call(this);
  }
  __name(take, "take");
  operators.streamReturningOperators = {
    asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
    drop,
    filter,
    flatMap,
    map,
    take,
    compose: compose2
  };
  operators.promiseReturningOperators = {
    every,
    forEach,
    reduce,
    toArray,
    some,
    find
  };
  return operators;
}
__name(requireOperators, "requireOperators");
var promises$1;
var hasRequiredPromises;
function requirePromises() {
  if (hasRequiredPromises) return promises$1;
  hasRequiredPromises = 1;
  const { ArrayPrototypePop, Promise: Promise2 } = requirePrimordials();
  const { isIterable: isIterable2, isNodeStream, isWebStream } = requireUtils();
  const { pipelineImpl: pl } = requirePipeline();
  const { finished } = requireEndOfStream();
  requireStream();
  function pipeline(...streams) {
    return new Promise2((resolve2, reject) => {
      let signal;
      let end;
      const lastArg = streams[streams.length - 1];
      if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable2(lastArg) && !isWebStream(lastArg)) {
        const options = ArrayPrototypePop(streams);
        signal = options.signal;
        end = options.end;
      }
      pl(
        streams,
        (err2, value) => {
          if (err2) {
            reject(err2);
          } else {
            resolve2(value);
          }
        },
        {
          signal,
          end
        }
      );
    });
  }
  __name(pipeline, "pipeline");
  promises$1 = {
    finished,
    pipeline
  };
  return promises$1;
}
__name(requirePromises, "requirePromises");
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return stream.exports;
  hasRequiredStream = 1;
  const { Buffer: Buffer3 } = requireBuffer();
  const { ObjectDefineProperty, ObjectKeys, ReflectApply } = requirePrimordials();
  const {
    promisify: { custom: customPromisify }
  } = requireUtil$1();
  const { streamReturningOperators, promiseReturningOperators } = requireOperators();
  const {
    codes: { ERR_ILLEGAL_CONSTRUCTOR }
  } = requireErrors();
  const compose2 = requireCompose();
  const { setDefaultHighWaterMark, getDefaultHighWaterMark } = requireState();
  const { pipeline } = requirePipeline();
  const { destroyer } = requireDestroy();
  const eos = requireEndOfStream();
  const promises2 = requirePromises();
  const utils2 = requireUtils();
  const Stream2 = stream.exports = requireLegacy().Stream;
  Stream2.isDestroyed = utils2.isDestroyed;
  Stream2.isDisturbed = utils2.isDisturbed;
  Stream2.isErrored = utils2.isErrored;
  Stream2.isReadable = utils2.isReadable;
  Stream2.isWritable = utils2.isWritable;
  Stream2.Readable = requireReadable();
  for (const key of ObjectKeys(streamReturningOperators)) {
    let fn = function(...args) {
      if (new.target) {
        throw ERR_ILLEGAL_CONSTRUCTOR();
      }
      return Stream2.Readable.from(ReflectApply(op, this, args));
    };
    __name(fn, "fn");
    const op = streamReturningOperators[key];
    ObjectDefineProperty(fn, "name", {
      __proto__: null,
      value: op.name
    });
    ObjectDefineProperty(fn, "length", {
      __proto__: null,
      value: op.length
    });
    ObjectDefineProperty(Stream2.Readable.prototype, key, {
      __proto__: null,
      value: fn,
      enumerable: false,
      configurable: true,
      writable: true
    });
  }
  for (const key of ObjectKeys(promiseReturningOperators)) {
    let fn = function(...args) {
      if (new.target) {
        throw ERR_ILLEGAL_CONSTRUCTOR();
      }
      return ReflectApply(op, this, args);
    };
    __name(fn, "fn");
    const op = promiseReturningOperators[key];
    ObjectDefineProperty(fn, "name", {
      __proto__: null,
      value: op.name
    });
    ObjectDefineProperty(fn, "length", {
      __proto__: null,
      value: op.length
    });
    ObjectDefineProperty(Stream2.Readable.prototype, key, {
      __proto__: null,
      value: fn,
      enumerable: false,
      configurable: true,
      writable: true
    });
  }
  Stream2.Writable = requireWritable();
  Stream2.Duplex = requireDuplex();
  Stream2.Transform = requireTransform();
  Stream2.PassThrough = requirePassthrough();
  Stream2.pipeline = pipeline;
  const { addAbortSignal: addAbortSignal2 } = requireAddAbortSignal();
  Stream2.addAbortSignal = addAbortSignal2;
  Stream2.finished = eos;
  Stream2.destroy = destroyer;
  Stream2.compose = compose2;
  Stream2.setDefaultHighWaterMark = setDefaultHighWaterMark;
  Stream2.getDefaultHighWaterMark = getDefaultHighWaterMark;
  ObjectDefineProperty(Stream2, "promises", {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get() {
      return promises2;
    }
  });
  ObjectDefineProperty(pipeline, customPromisify, {
    __proto__: null,
    enumerable: true,
    get() {
      return promises2.pipeline;
    }
  });
  ObjectDefineProperty(eos, customPromisify, {
    __proto__: null,
    enumerable: true,
    get() {
      return promises2.finished;
    }
  });
  Stream2.Stream = Stream2;
  Stream2._isUint8Array = /* @__PURE__ */ __name(function isUint8Array(value) {
    return value instanceof Uint8Array;
  }, "isUint8Array");
  Stream2._uint8ArrayToBuffer = /* @__PURE__ */ __name(function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }, "_uint8ArrayToBuffer");
  return stream.exports;
}
__name(requireStream, "requireStream");
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$4.exports;
  hasRequiredBrowser$2 = 1;
  (function(module) {
    const CustomStream = requireStream();
    const promises2 = requirePromises();
    const originalDestroy = CustomStream.Readable.destroy;
    module.exports = CustomStream.Readable;
    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    module.exports._isUint8Array = CustomStream._isUint8Array;
    module.exports.isDisturbed = CustomStream.isDisturbed;
    module.exports.isErrored = CustomStream.isErrored;
    module.exports.isReadable = CustomStream.isReadable;
    module.exports.Readable = CustomStream.Readable;
    module.exports.Writable = CustomStream.Writable;
    module.exports.Duplex = CustomStream.Duplex;
    module.exports.Transform = CustomStream.Transform;
    module.exports.PassThrough = CustomStream.PassThrough;
    module.exports.addAbortSignal = CustomStream.addAbortSignal;
    module.exports.finished = CustomStream.finished;
    module.exports.destroy = CustomStream.destroy;
    module.exports.destroy = originalDestroy;
    module.exports.pipeline = CustomStream.pipeline;
    module.exports.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises2;
      }
    });
    module.exports.Stream = CustomStream.Stream;
    module.exports.default = module.exports;
  })(browser$4);
  return browser$4.exports;
}
__name(requireBrowser$2, "requireBrowser$2");
var browserExports$1 = requireBrowser$2();
const _ReadStream = class _ReadStream extends browserExports$1.Readable {
  constructor(opts = {}, handleOrPromise) {
    super({ ...opts, encoding: opts.encoding ?? void 0 });
    __publicField(this, "pending", true);
    __publicField(this, "_path", "<unknown>");
    __publicField(this, "_bytesRead", 0);
    __publicField(this, "reader");
    __publicField(this, "ready");
    this.ready = Promise.resolve(handleOrPromise).then((handle) => {
      this._path = handle["vfs"].path;
      const internal = handle.readableWebStream({ start: opts.start, end: opts.end });
      this.reader = internal.getReader();
      this.pending = false;
    }).catch((err2) => {
      this.destroy(err2);
    });
  }
  async _read() {
    try {
      await this.ready;
      if (!this.reader)
        return;
      const { done, value } = await this.reader.read();
      if (done) {
        this.push(null);
        return;
      }
      this._bytesRead += value.byteLength;
      this.push(value);
    } catch (err2) {
      this.destroy(new Exception(Errno.EIO, err2.toString()));
    }
  }
  close(callback = () => null) {
    try {
      this.destroy();
      this.emit("close");
      callback(null);
    } catch (err2) {
      callback(new Exception(Errno.EIO, err2.toString()));
    }
  }
  get path() {
    return this._path;
  }
  get bytesRead() {
    return this._bytesRead;
  }
  wrap(oldStream) {
    super.wrap(oldStream);
    return this;
  }
};
__name(_ReadStream, "ReadStream");
let ReadStream = _ReadStream;
const _WriteStream = class _WriteStream extends browserExports$1.Writable {
  constructor(opts = {}, handleOrPromise) {
    super(opts);
    __publicField(this, "pending", true);
    __publicField(this, "_path", "<unknown>");
    __publicField(this, "_bytesWritten", 0);
    __publicField(this, "writer");
    __publicField(this, "ready");
    this.ready = Promise.resolve(handleOrPromise).then((handle) => {
      this._path = handle["vfs"].path;
      const internal = handle.writableWebStream({ start: opts.start });
      this.writer = internal.getWriter();
      this.pending = false;
    }).catch((err2) => this.destroy(err2));
  }
  async _write(chunk, encoding, callback) {
    await this.ready;
    if (!this.writer)
      return callback(warn(UV("EAGAIN", "write", this._path)));
    if (encoding != "buffer")
      return callback(warn(UV("ENOTSUP", "write", this._path)));
    const data = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    try {
      await this.writer.write(data);
      this._bytesWritten += chunk.byteLength;
      callback();
    } catch (error) {
      callback(new Exception(Errno.EIO, error.toString()));
    }
  }
  async _final(callback) {
    await this.ready;
    if (!this.writer)
      return callback();
    try {
      await this.writer.close();
      callback();
    } catch (error) {
      callback(new Exception(Errno.EIO, error.toString()));
    }
  }
  close(callback = () => null) {
    try {
      this.destroy();
      this.emit("close");
      callback(null);
    } catch (error) {
      callback(new Exception(Errno.EIO, error.toString()));
    }
  }
  get path() {
    return this._path;
  }
  get bytesWritten() {
    return this._bytesWritten;
  }
};
__name(_WriteStream, "WriteStream");
let WriteStream = _WriteStream;
var __addDisposableResource = function(env2, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = /* @__PURE__ */ __name(function() {
      try {
        inner.call(this);
      } catch (e2) {
        return Promise.reject(e2);
      }
    }, "dispose");
    env2.stack.push({ value, dispose, async });
  } else if (async) {
    env2.stack.push({ async: true });
  }
  return value;
};
var __disposeResources = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    __name(fail, "fail");
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
          } else s |= 1;
        } catch (e2) {
          fail(e2);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    __name(next, "next");
    return next();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
const _FileHandle = class _FileHandle {
  constructor(context, fd) {
    __publicField(this, "context");
    __publicField(this, "fd");
    __publicField(this, "vfs");
    this.context = context;
    this.fd = fd;
    this.vfs = fromFD(context, fd);
  }
  _emitChange() {
    emitChange(this.context, "change", this.vfs.path);
  }
  /**
   * Asynchronous fchown(2) - Change ownership of a file.
   */
  async chown(uid, gid) {
    await this.vfs.chown(uid, gid);
    this._emitChange();
  }
  /**
   * Asynchronous fchmod(2) - Change permissions of a file.
   * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
   */
  async chmod(mode2) {
    const numMode = normalizeMode(mode2, -1);
    if (numMode < 0)
      throw UV("EINVAL", "chmod", this.vfs.path);
    await this.vfs.chmod(numMode);
    this._emitChange();
  }
  /**
   * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
   */
  datasync() {
    return this.sync();
  }
  /**
   * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
   */
  async sync() {
    await this.vfs.sync();
  }
  /**
   * Asynchronous ftruncate(2) - Truncate a file to a specified length.
   * @param length If not specified, defaults to `0`.
   */
  async truncate(length = 0) {
    await this.vfs.truncate(length);
    this._emitChange();
  }
  /**
   * Asynchronously change file timestamps of the file.
   * @param atime The last access time. If a string is provided, it will be coerced to number.
   * @param mtime The last modified time. If a string is provided, it will be coerced to number.
   */
  async utimes(atime, mtime) {
    atime = normalizeTime(atime);
    mtime = normalizeTime(mtime);
    await this.vfs.utimes(atime, mtime);
    this._emitChange();
  }
  /**
   * Asynchronously append data to a file, creating the file if it does not exist. The underlying file will _not_ be closed automatically.
   * The `FileHandle` must have been opened for appending.
   * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.
   * @param _options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
   * - `encoding` defaults to `'utf8'`.
   * - `mode` defaults to `0o666`.
   * - `flag` defaults to `'a'`.
   */
  async appendFile(data, _options = {}) {
    const options = normalizeOptions(_options, "utf8", "a", 420);
    const flag = parse$2(options.flag);
    if (!(flag & O_APPEND))
      throw UV("EBADF", "write", this.vfs.path);
    const encodedData = typeof data == "string" ? bufferExports.Buffer.from(data, options.encoding) : data;
    await this.vfs.write(encodedData, 0, encodedData.length);
    this._emitChange();
  }
  async read(buffer2, offset, length, position) {
    if (typeof offset == "object" && offset != null) {
      position = offset.position;
      length = offset.length;
      offset = offset.offset;
    }
    if (!ArrayBuffer.isView(buffer2) && typeof buffer2 == "object") {
      position = buffer2.position;
      length = buffer2.length;
      offset = buffer2.offset;
      buffer2 = buffer2.buffer;
    }
    if (position && position > Number.MAX_SAFE_INTEGER)
      throw UV("EINVAL");
    if (typeof position == "bigint")
      position = Number(position);
    position = Number.isSafeInteger(position) ? position : this.vfs.position;
    buffer2 || (buffer2 = new Uint8Array(this.vfs.inode.size));
    offset ?? (offset = 0);
    const bytesRead = await this.vfs.read(buffer2, offset, length ?? buffer2.byteLength - offset, position);
    return { bytesRead, buffer: buffer2 };
  }
  async readFile(_options) {
    const options = normalizeOptions(_options, null, "r", 292);
    const flag = parse$2(options.flag);
    if (flag & O_WRONLY)
      throw UV("EBADF", "read", this.vfs.path);
    const { size } = await this.stat();
    const data = new Uint8Array(size);
    await this.vfs.read(data, 0, size, 0);
    const buffer2 = bufferExports.Buffer.from(data);
    return options.encoding ? buffer2.toString(options.encoding) : buffer2;
  }
  /**
   * Read file data using a `ReadableStream`.
   * The handle will not be closed automatically.
   */
  readableWebStream(options = {}) {
    if (this.vfs.isClosed)
      throw UV("EBADF", "readableWebStream", this.vfs.path);
    return this.vfs.fs.streamRead(this.vfs.internalPath, options);
  }
  /**
   * Not part of the Node.js API!
   *
   * Write file data using a `WritableStream`.
   * The handle will not be closed automatically.
   * @internal
   */
  writableWebStream(options = {}) {
    if (this.vfs.isClosed)
      throw UV("EBADF", "writableWebStream", this.vfs.path);
    if (this.vfs.inode.flags & InodeFlags.Immutable)
      throw UV("EPERM", "writableWebStream", this.vfs.path);
    return this.vfs.fs.streamWrite(this.vfs.internalPath, options);
  }
  /**
   * Creates a readline Interface object that allows reading the file line by line
   * @param options Options for creating a read stream
   * @returns A readline interface for reading the file line by line
   */
  readLines(options) {
    if (this.vfs.isClosed || this.vfs.flag & O_WRONLY)
      throw UV("EBADF", "read", this.vfs.path);
    return createInterface({ input: this.createReadStream(options), crlfDelay: Infinity });
  }
  [Symbol.asyncDispose]() {
    return this.close();
  }
  async stat(opts) {
    if (this.vfs.isClosed)
      throw UV("EBADF", "stat", this.vfs.path);
    if (checkAccess && !hasAccess(this.context, this.vfs.inode, R_OK))
      throw UV("EACCES", "stat", this.vfs.path);
    return opts?.bigint ? new BigIntStats(this.vfs.inode) : new Stats(this.vfs.inode);
  }
  /**
   * Asynchronously writes `string` to the file.
   * The `FileHandle` must have been opened for writing.
   * It is unsafe to call `write()` multiple times on the same file without waiting for the `Promise`
   * to be resolved (or rejected). For this scenario, `createWriteStream` is strongly recommended.
   */
  async write(data, options, lenOrEnc, position) {
    let buffer2, offset, length;
    if (typeof options == "object" && options != null) {
      lenOrEnc = options.length;
      position = options.position;
      options = options.offset;
    }
    if (typeof data === "string") {
      position = typeof options === "number" ? options : null;
      offset = 0;
      buffer2 = bufferExports.Buffer.from(data, typeof lenOrEnc === "string" ? lenOrEnc : "utf8");
      length = buffer2.length;
    } else {
      buffer2 = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
      offset = options ?? 0;
      length = typeof lenOrEnc == "number" ? lenOrEnc : buffer2.byteLength;
      position = typeof position === "number" ? position : null;
    }
    position ?? (position = this.vfs.position);
    const bytesWritten = await this.vfs.write(buffer2, offset, length, position);
    this._emitChange();
    return { buffer: data, bytesWritten };
  }
  /**
   * Asynchronously writes data to a file, replacing the file if it already exists. The underlying file will _not_ be closed automatically.
   * The `FileHandle` must have been opened for writing.
   * It is unsafe to call `writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected).
   * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.
   * @param _options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
   * - `encoding` defaults to `'utf8'`.
   * - `mode` defaults to `0o666`.
   * - `flag` defaults to `'w'`.
   */
  async writeFile(data, _options = {}) {
    const options = normalizeOptions(_options, "utf8", "w", 420);
    const flag = parse$2(options.flag);
    if (!(flag & O_WRONLY || flag & O_RDWR))
      throw UV("EBADF", "writeFile", this.vfs.path);
    const encodedData = typeof data == "string" ? bufferExports.Buffer.from(data, options.encoding) : data;
    await this.vfs.write(encodedData, 0, encodedData.length, 0);
    this._emitChange();
  }
  /**
   * Asynchronous close(2) - close a `FileHandle`.
   */
  async close() {
    await this.vfs.close();
    deleteFD(this.context, this.fd);
  }
  /**
   * Asynchronous `writev`. Writes from multiple buffers.
   * @param buffers An array of Uint8Array buffers.
   * @param position The position in the file where to begin writing.
   * @returns The number of bytes written.
   */
  async writev(buffers, position) {
    if (typeof position == "number")
      this.vfs.position = position;
    let bytesWritten = 0;
    for (const buffer2 of buffers) {
      bytesWritten += (await this.write(buffer2)).bytesWritten;
    }
    return { bytesWritten, buffers };
  }
  /**
   * Asynchronous `readv`. Reads into multiple buffers.
   * @param buffers An array of Uint8Array buffers.
   * @param position The position in the file where to begin reading.
   * @returns The number of bytes read.
   */
  async readv(buffers, position) {
    if (typeof position == "number")
      this.vfs.position = position;
    let bytesRead = 0;
    for (const buffer2 of buffers) {
      bytesRead += (await this.read(buffer2)).bytesRead;
    }
    return { bytesRead, buffers };
  }
  /**
   * Creates a stream for reading from the file.
   * @param options Options for the readable stream
   */
  createReadStream(options = {}) {
    if (this.vfs.isClosed || this.vfs.flag & O_WRONLY)
      throw UV("EBADF", "createReadStream", this.vfs.path);
    return new ReadStream(options, this);
  }
  /**
   * Creates a stream for writing to the file.
   * @param options Options for the writeable stream.
   */
  createWriteStream(options = {}) {
    if (this.vfs.isClosed)
      throw UV("EBADF", "createWriteStream", this.vfs.path);
    if (this.vfs.inode.flags & InodeFlags.Immutable)
      throw UV("EPERM", "createWriteStream", this.vfs.path);
    if (this.vfs.fs.attributes.has("readonly"))
      throw UV("EROFS", "createWriteStream", this.vfs.path);
    return new WriteStream(options, this);
  }
};
__name(_FileHandle, "FileHandle");
let FileHandle = _FileHandle;
async function rename$1(oldPath, newPath) {
  await rename$2.call(this, oldPath, newPath);
}
__name(rename$1, "rename$1");
async function exists$1(path2) {
  path2 = normalizePath(path2);
  try {
    const { fs: fs2, path: resolved } = await resolve(this, path2);
    return await fs2.exists(resolved);
  } catch (e2) {
    if (e2 instanceof Exception && e2.code == "ENOENT") {
      return false;
    }
    throw e2;
  }
}
__name(exists$1, "exists$1");
async function stat$2(path2, options) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = await resolve(this, path2);
  const $ex = { syscall: "stat", path: path2 };
  const stats = await fs2.stat(resolved).catch(rethrow($ex));
  if (checkAccess && !hasAccess(this, stats, R_OK))
    throw UV("EACCES", $ex);
  return options?.bigint ? new BigIntStats(stats) : new Stats(stats);
}
__name(stat$2, "stat$2");
async function lstat$1(path2, options) {
  path2 = normalizePath(path2);
  const $ex = { syscall: "lstat", path: path2 };
  const { base, dir } = parse$3(path2);
  const { fs: fs2, path: parent } = await resolve(this, dir);
  const stats = await fs2.stat(base ? join(parent, base) : parent).catch(rethrow($ex));
  if (checkAccess && !hasAccess(this, stats, R_OK))
    throw UV("EACCES", $ex);
  return options?.bigint ? new BigIntStats(stats) : new Stats(stats);
}
__name(lstat$1, "lstat$1");
async function truncate$1(path2, len = 0) {
  const env_1 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource(env_1, await open$2.call(this, path2, "r+"), true);
    await handle.truncate(len);
  } catch (e_1) {
    env_1.error = e_1;
    env_1.hasError = true;
  } finally {
    const result_1 = __disposeResources(env_1);
    if (result_1)
      await result_1;
  }
}
__name(truncate$1, "truncate$1");
async function unlink$1(path2) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolveMount(path2, this);
  const $ex = { syscall: "unlink", path: path2 };
  const stats = await fs2.stat(resolved).catch(rethrow($ex));
  if (checkAccess && !hasAccess(this, stats, W_OK))
    throw UV("EACCES", $ex);
  await fs2.unlink(resolved).catch(rethrow($ex));
  emitChange(this, "rename", path2.toString());
}
__name(unlink$1, "unlink$1");
async function open$2(path2, flag = "r", mode2 = 420) {
  const handle = await open$3(this, path2, { flag, mode: mode2 });
  return new FileHandle(this, toFD(handle));
}
__name(open$2, "open$2");
async function readFile$1(path2, _options) {
  const env_2 = { stack: [], error: void 0, hasError: false };
  try {
    const options = normalizeOptions(_options, null, "r", 292);
    const handle = __addDisposableResource(env_2, typeof path2 == "object" && "fd" in path2 ? path2 : await open$2.call(this, path2, options.flag, options.mode), true);
    return await handle.readFile(options);
  } catch (e_2) {
    env_2.error = e_2;
    env_2.hasError = true;
  } finally {
    const result_2 = __disposeResources(env_2);
    if (result_2)
      await result_2;
  }
}
__name(readFile$1, "readFile$1");
async function writeFile$1(path2, data, _options) {
  const env_3 = { stack: [], error: void 0, hasError: false };
  try {
    const options = normalizeOptions(_options, "utf8", "w+", 420);
    const handle = __addDisposableResource(env_3, path2 instanceof FileHandle ? path2 : await open$2.call(this, path2.toString(), options.flag, options.mode), true);
    const _data = typeof data == "string" ? data : data instanceof DataView ? new Uint8Array(data.buffer, data.byteOffset, data.byteLength) : data;
    if (typeof _data != "string" && !(_data instanceof Uint8Array))
      throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received ' + typeof data);
    await handle.writeFile(_data, options);
  } catch (e_3) {
    env_3.error = e_3;
    env_3.hasError = true;
  } finally {
    const result_3 = __disposeResources(env_3);
    if (result_3)
      await result_3;
  }
}
__name(writeFile$1, "writeFile$1");
async function appendFile$1(path2, data, _options) {
  const env_4 = { stack: [], error: void 0, hasError: false };
  try {
    const options = normalizeOptions(_options, "utf8", "a", 420);
    const flag = parse$2(options.flag);
    const $ex = { syscall: "write", path: path2 instanceof FileHandle ? path2["vfs"].path : path2.toString() };
    if (!(flag & O_APPEND))
      throw UV("EBADF", $ex);
    const encodedData = typeof data == "string" ? bufferExports.Buffer.from(data, options.encoding) : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    const handle = __addDisposableResource(env_4, typeof path2 == "object" && "fd" in path2 ? path2 : await open$2.call(this, path2, options.flag, options.mode), true);
    await handle.appendFile(encodedData, options);
  } catch (e_4) {
    env_4.error = e_4;
    env_4.hasError = true;
  } finally {
    const result_4 = __disposeResources(env_4);
    if (result_4)
      await result_4;
  }
}
__name(appendFile$1, "appendFile$1");
async function rmdir$2(path2) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = await resolve(this, path2);
  const $ex = { syscall: "rmdir", path: path2 };
  const stats = await fs2.stat(resolved).catch(rethrow($ex));
  if (!stats)
    throw UV("ENOENT", $ex);
  if (!isDirectory(stats))
    throw UV("ENOTDIR", $ex);
  if (checkAccess && !hasAccess(this, stats, W_OK))
    throw UV("EACCES", $ex);
  await fs2.rmdir(resolved).catch(rethrow($ex));
  emitChange(this, "rename", path2.toString());
}
__name(rmdir$2, "rmdir$2");
async function mkdir$2(path2, options) {
  options = typeof options === "object" ? options : { mode: options };
  const mode2 = normalizeMode(options?.mode, 511);
  return await mkdir$3.call(this, path2, { ...options, mode: mode2 });
}
__name(mkdir$2, "mkdir$2");
async function readdir$1(path2, options) {
  path2 = normalizePath(path2);
  const opt = typeof options === "object" && options != null ? options : { encoding: options, withFileTypes: false, recursive: false };
  const rawEntries = await readdir$2.call(this, path2, opt);
  const values = [];
  for (const entry of rawEntries) {
    if (opt.withFileTypes) {
      values.push(Dirent.from(entry, opt.encoding));
    } else if (opt.encoding == "buffer") {
      values.push(bufferExports.Buffer.from(entry.path));
    } else {
      values.push(entry.path);
    }
  }
  return values;
}
__name(readdir$1, "readdir$1");
async function link$1(path2, dest) {
  return await link$2.call(this, path2, dest);
}
__name(link$1, "link$1");
async function symlink$1(dest, path2, type = "file") {
  const env_5 = { stack: [], error: void 0, hasError: false };
  try {
    if (!["file", "dir", "junction"].includes(type))
      throw new TypeError("Invalid symlink type: " + type);
    path2 = normalizePath(path2);
    if (await exists$1.call(this, path2))
      throw UV("EEXIST", "symlink", path2);
    const handle = __addDisposableResource(env_5, await open$3(this, path2, { flag: "w+", mode: 420, preserveSymlinks: true }), true);
    const encoded = encodeUTF8(normalizePath(dest, true));
    await handle.write(encoded, 0, encoded.length, 0);
    await handle.chmod(S_IFLNK);
  } catch (e_5) {
    env_5.error = e_5;
    env_5.hasError = true;
  } finally {
    const result_5 = __disposeResources(env_5);
    if (result_5)
      await result_5;
  }
}
__name(symlink$1, "symlink$1");
async function readlink$1(path2, options) {
  path2 = normalizePath(path2);
  const buf = bufferExports.Buffer.from(await readlink$2.call(this, path2), "utf-8");
  const encoding = typeof options == "object" ? options?.encoding : options;
  return encoding == "buffer" ? buf : buf.toString(encoding ?? "utf-8");
}
__name(readlink$1, "readlink$1");
async function chown$2(path2, uid, gid) {
  const env_6 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource(env_6, await open$2.call(this, path2, "r+"), true);
    await handle.chown(uid, gid);
  } catch (e_6) {
    env_6.error = e_6;
    env_6.hasError = true;
  } finally {
    const result_6 = __disposeResources(env_6);
    if (result_6)
      await result_6;
  }
}
__name(chown$2, "chown$2");
async function lchown$1(path2, uid, gid) {
  const env_7 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource(env_7, await open$3(this, path2, {
      flag: "r+",
      mode: 420,
      preserveSymlinks: true,
      allowDirectory: true
    }), true);
    await handle.chown(uid, gid);
  } catch (e_7) {
    env_7.error = e_7;
    env_7.hasError = true;
  } finally {
    const result_7 = __disposeResources(env_7);
    if (result_7)
      await result_7;
  }
}
__name(lchown$1, "lchown$1");
async function chmod$2(path2, mode2) {
  const env_8 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource(env_8, await open$2.call(this, path2, "r+"), true);
    await handle.chmod(mode2);
  } catch (e_8) {
    env_8.error = e_8;
    env_8.hasError = true;
  } finally {
    const result_8 = __disposeResources(env_8);
    if (result_8)
      await result_8;
  }
}
__name(chmod$2, "chmod$2");
async function lchmod$1(path2, mode2) {
  const env_9 = { stack: [], error: void 0, hasError: false };
  try {
    mode2 = normalizeMode(mode2);
    const handle = __addDisposableResource(env_9, await open$3(this, path2, {
      flag: "r+",
      mode: 420,
      preserveSymlinks: true,
      allowDirectory: true
    }), true);
    await handle.chmod(mode2);
  } catch (e_9) {
    env_9.error = e_9;
    env_9.hasError = true;
  } finally {
    const result_9 = __disposeResources(env_9);
    if (result_9)
      await result_9;
  }
}
__name(lchmod$1, "lchmod$1");
async function utimes$1(path2, atime, mtime) {
  const env_10 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource(env_10, await open$3(this, path2, {
      flag: "r+",
      allowDirectory: true
    }), true);
    await handle.utimes(normalizeTime(atime), normalizeTime(mtime));
  } catch (e_10) {
    env_10.error = e_10;
    env_10.hasError = true;
  } finally {
    const result_10 = __disposeResources(env_10);
    if (result_10)
      await result_10;
  }
}
__name(utimes$1, "utimes$1");
async function lutimes$1(path2, atime, mtime) {
  const env_11 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource(env_11, await open$3(this, path2, {
      flag: "r+",
      mode: 420,
      preserveSymlinks: true,
      allowDirectory: true
    }), true);
    await handle.utimes(normalizeTime(atime), normalizeTime(mtime));
  } catch (e_11) {
    env_11.error = e_11;
    env_11.hasError = true;
  } finally {
    const result_11 = __disposeResources(env_11);
    if (result_11)
      await result_11;
  }
}
__name(lutimes$1, "lutimes$1");
async function realpath$1(path2, options) {
  const encoding = typeof options == "string" ? options : options?.encoding ?? "utf8";
  path2 = normalizePath(path2);
  const { fullPath } = await resolve(this, path2);
  if (encoding == "utf8" || encoding == "utf-8")
    return fullPath;
  const buf = bufferExports.Buffer.from(fullPath, "utf-8");
  if (encoding == "buffer")
    return buf;
  return buf.toString(encoding);
}
__name(realpath$1, "realpath$1");
function watch$1(filename, options = {}) {
  const watcher = new FSWatcher(this, filename.toString(), typeof options !== "string" ? options : { encoding: options });
  const eventQueue = [];
  let done = false;
  watcher.on("change", (eventType, filename2) => {
    eventQueue.shift()?.({ value: { eventType, filename: filename2 }, done: false });
  });
  function cleanup() {
    done = true;
    watcher.close();
    for (const resolve2 of eventQueue) {
      resolve2({ value: null, done });
    }
    eventQueue.length = 0;
    return Promise.resolve({ value: void 0, done: true });
  }
  __name(cleanup, "cleanup");
  return {
    async next() {
      if (done)
        return Promise.resolve({ value: void 0, done });
      const { promise, resolve: resolve2 } = Promise.withResolvers();
      eventQueue.push(resolve2);
      return promise;
    },
    return: cleanup,
    throw: cleanup,
    async [Symbol.asyncDispose]() {
      await cleanup();
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
__name(watch$1, "watch$1");
async function access$1(path2, mode2 = F_OK) {
  if (!checkAccess)
    return;
  const stats = await stat$2.call(this, path2);
  if (!stats.hasAccess(mode2, this))
    throw UV("EACCES", "access", path2.toString());
}
__name(access$1, "access$1");
async function rm$2(path2, options) {
  path2 = normalizePath(path2);
  const stats = await lstat$1.call(this, path2).catch((error) => {
    if (error.code == "ENOENT" && options?.force)
      return void 0;
    throw error;
  });
  if (!stats)
    return;
  switch (stats.mode & S_IFMT) {
    case S_IFDIR:
      if (options?.recursive) {
        for (const entry of await readdir$1.call(this, path2)) {
          await rm$2.call(this, join(path2, entry), options);
        }
      }
      await rmdir$2.call(this, path2);
      break;
    case S_IFREG:
    case S_IFLNK:
    case S_IFBLK:
    case S_IFCHR:
      await unlink$1.call(this, path2);
      break;
    case S_IFIFO:
    case S_IFSOCK:
    default:
      throw UV("ENOSYS", "rm", path2);
  }
}
__name(rm$2, "rm$2");
async function mkdtemp$1(prefix, options) {
  const encoding = typeof options === "object" ? options?.encoding : options || "utf8";
  const path2 = _tempDirName(prefix);
  await mkdir$2.call(this, path2);
  return encoding == "buffer" ? bufferExports.Buffer.from(path2) : path2;
}
__name(mkdtemp$1, "mkdtemp$1");
async function mkdtempDisposable(prefix, options) {
  const path2 = _tempDirName(prefix);
  await mkdir$2.call(this, path2);
  const remove2 = /* @__PURE__ */ __name(() => rm$2(path2, { recursive: true, force: true }), "remove");
  return { path: path2, remove: remove2, [Symbol.asyncDispose]: remove2 };
}
__name(mkdtempDisposable, "mkdtempDisposable");
async function copyFile$1(src, dest, mode2) {
  src = normalizePath(src);
  dest = normalizePath(dest);
  if (mode2 && mode2 & COPYFILE_EXCL && await exists$1.call(this, dest))
    throw UV("EEXIST", "copyFile", dest);
  await writeFile$1.call(this, dest, await readFile$1.call(this, src));
  emitChange(this, "rename", dest.toString());
}
__name(copyFile$1, "copyFile$1");
function opendir$1(path2, options) {
  path2 = normalizePath(path2);
  return Promise.resolve(new Dir(path2, this));
}
__name(opendir$1, "opendir$1");
async function cp$2(source2, destination, opts) {
  source2 = normalizePath(source2);
  destination = normalizePath(destination);
  const srcStats = await lstat$1.call(this, source2);
  if (opts?.errorOnExist && await exists$1.call(this, destination))
    throw UV("EEXIST", "cp", destination);
  switch (srcStats.mode & S_IFMT) {
    case S_IFDIR: {
      if (!opts?.recursive)
        throw UV("EISDIR", "cp", source2);
      const [entries2] = await Promise.all(
        [
          readdir$1.call(this, source2, { withFileTypes: true }),
          mkdir$2.call(this, destination, { recursive: true })
        ]
        // Ensure the destination directory exists
      );
      const _cp = /* @__PURE__ */ __name(async (dirent) => {
        if (opts.filter && !opts.filter(join(source2, dirent.name), join(destination, dirent.name))) {
          return;
        }
        await cp$2.call(this, join(source2, dirent.name), join(destination, dirent.name), opts);
      }, "_cp");
      await Promise.all(entries2.map(_cp));
      break;
    }
    case S_IFREG:
    case S_IFLNK:
      await copyFile$1.call(this, source2, destination);
      break;
    case S_IFBLK:
    case S_IFCHR:
    case S_IFIFO:
    case S_IFSOCK:
    default:
      throw UV("ENOSYS", "cp", source2);
  }
  if (opts?.preserveTimestamps) {
    await utimes$1.call(this, destination, srcStats.atime, srcStats.mtime);
  }
}
__name(cp$2, "cp$2");
async function statfs$1(path2, opts) {
  path2 = normalizePath(path2);
  const { fs: fs2 } = resolveMount(path2, this);
  return Promise.resolve(_statfs(fs2, opts?.bigint));
}
__name(statfs$1, "statfs$1");
function glob$1(pattern2, opt) {
  pattern2 = Array.isArray(pattern2) ? pattern2 : [pattern2];
  const { cwd = "/", withFileTypes = false, exclude = /* @__PURE__ */ __name(() => false, "exclude") } = opt || {};
  const regexPatterns = pattern2.map(globToRegex);
  async function* recursiveList(dir) {
    const entries2 = await readdir$1(dir, { withFileTypes, encoding: "utf8" });
    for (const entry of entries2) {
      const fullPath = withFileTypes ? join(entry.parentPath, entry.name) : dir + "/" + entry;
      if (typeof exclude != "function" ? exclude.some((p) => matchesGlob(p, fullPath)) : exclude(withFileTypes ? entry : fullPath))
        continue;
      if ((await stat$2(fullPath)).isDirectory() && regexPatterns.some((pattern3) => pattern3.source.includes(".*"))) {
        yield* recursiveList(fullPath);
      }
      if (regexPatterns.some((pattern3) => pattern3.test(fullPath.replace(/^\/+/g, "")))) {
        yield withFileTypes ? entry : fullPath.replace(/^\/+/g, "");
      }
    }
  }
  __name(recursiveList, "recursiveList");
  return recursiveList(cwd);
}
__name(glob$1, "glob$1");
const promises = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FileHandle,
  access: access$1,
  appendFile: appendFile$1,
  chmod: chmod$2,
  chown: chown$2,
  constants,
  copyFile: copyFile$1,
  cp: cp$2,
  exists: exists$1,
  glob: glob$1,
  lchmod: lchmod$1,
  lchown: lchown$1,
  link: link$1,
  lstat: lstat$1,
  lutimes: lutimes$1,
  mkdir: mkdir$2,
  mkdtemp: mkdtemp$1,
  mkdtempDisposable,
  open: open$2,
  opendir: opendir$1,
  readFile: readFile$1,
  readdir: readdir$1,
  readlink: readlink$1,
  realpath: realpath$1,
  rename: rename$1,
  rm: rm$2,
  rmdir: rmdir$2,
  stat: stat$2,
  statfs: statfs$1,
  symlink: symlink$1,
  truncate: truncate$1,
  unlink: unlink$1,
  utimes: utimes$1,
  watch: watch$1,
  writeFile: writeFile$1
}, Symbol.toStringTag, { value: "Module" }));
function configureFileSystem(fs2, config2) {
  if (config2.disableAsyncCache)
    fs2.attributes.set("no_async_preload");
  if (config2.caseFold)
    fs2.attributes.set("case_fold", config2.caseFold);
}
__name(configureFileSystem, "configureFileSystem");
function isMountConfig(arg) {
  return isBackendConfig(arg) || isBackend(arg) || arg instanceof FileSystem;
}
__name(isMountConfig, "isMountConfig");
async function resolveMountConfig(configuration, _depth = 0) {
  if (typeof configuration !== "object" || configuration == null) {
    throw err$1(withErrno("EINVAL", "Invalid options on mount configuration"));
  }
  if (!isMountConfig(configuration)) {
    throw err$1(withErrno("EINVAL", "Invalid mount configuration"));
  }
  if (configuration instanceof FileSystem) {
    await configuration.ready();
    return configuration;
  }
  if (isBackend(configuration)) {
    configuration = { backend: configuration };
  }
  for (const [key, value] of Object.entries(configuration)) {
    if (key == "backend")
      continue;
    if (!isMountConfig(value))
      continue;
    info("Resolving nested mount configuration: " + key);
    if (_depth > 10) {
      throw err$1(withErrno("EINVAL", "Invalid configuration, too deep and possibly infinite"));
    }
    configuration[key] = await resolveMountConfig(value, ++_depth);
  }
  const { backend } = configuration;
  if (typeof backend.isAvailable == "function" && !await backend.isAvailable(configuration)) {
    throw err$1(withErrno("EPERM", "Backend not available: " + backend.name));
  }
  checkOptions(backend, configuration);
  const mount2 = await backend.create(configuration);
  configureFileSystem(mount2, configuration);
  await mount2.ready();
  return mount2;
}
__name(resolveMountConfig, "resolveMountConfig");
async function mountWithMkdir(path2, fs2) {
  if (path2 == "/") {
    mount$1(path2, fs2);
    return;
  }
  const stats = await stat$2(path2).catch(() => null);
  if (!stats) {
    await mkdir$2(path2, { recursive: true });
  } else if (!stats.isDirectory()) {
    throw withErrno("ENOTDIR", "Missing directory at mount point: " + path2);
  }
  mount$1(path2, fs2);
}
__name(mountWithMkdir, "mountWithMkdir");
function addDevice(driver, options) {
  const devfs = mounts.get("/dev");
  if (!(devfs instanceof DeviceFS))
    throw crit(withErrno("ENOTSUP", "/dev does not exist or is not a device file system"));
  return devfs._createDevice(driver, options);
}
__name(addDevice, "addDevice");
const _defaultDirectories = ["/tmp", "/var", "/etc"];
async function configure$1(configuration) {
  Object.assign(defaultContext.credentials, createCredentials({
    uid: configuration.uid || 0,
    gid: configuration.gid || 0
  }));
  _setAccessChecks(!configuration.disableAccessChecks);
  if (configuration.log)
    configure$2(configuration.log);
  if (configuration.mounts) {
    for (const [_point, mountConfig] of Object.entries(configuration.mounts).sort(([a], [b]) => a.length > b.length ? 1 : -1)) {
      const point2 = _point.startsWith("/") ? _point : "/" + _point;
      if (isBackendConfig(mountConfig)) {
        mountConfig.disableAsyncCache ?? (mountConfig.disableAsyncCache = configuration.disableAsyncCache || false);
        mountConfig.caseFold ?? (mountConfig.caseFold = configuration.caseFold);
      }
      if (point2 == "/")
        umount$1("/");
      await mountWithMkdir(point2, await resolveMountConfig(mountConfig));
    }
  }
  for (const fs2 of mounts.values()) {
    configureFileSystem(fs2, configuration);
  }
  if (configuration.addDevices && !mounts.has("/dev")) {
    const devfs = new DeviceFS();
    devfs.addDefaults();
    await devfs.ready();
    await mountWithMkdir("/dev", devfs);
  }
  if (configuration.defaultDirectories) {
    for (const dir of _defaultDirectories) {
      if (await exists$1(dir)) {
        const stats = await stat$2(dir);
        if (!stats.isDirectory())
          warn("Default directory exists but is not a directory: " + dir);
      } else
        await mkdir$2(dir);
    }
  }
}
__name(configure$1, "configure$1");
const journalOperations = ["delete"];
Math.max(...journalOperations.map((op) => op.length));
const resourcesCache = /* @__PURE__ */ new Map();
async function _fetch(input, init2 = {}, bodyOptional = false) {
  const response = await fetch(input, init2).catch((error) => {
    throw { tag: "fetch", message: error.message };
  });
  if (!response.ok)
    throw { tag: "status", response };
  const raw = await response.arrayBuffer().catch((error) => {
    if (bodyOptional)
      return;
    throw { tag: "buffer", response, message: error.message };
  });
  return { response, data: raw ? new Uint8Array(raw) : void 0 };
}
__name(_fetch, "_fetch");
async function get$2(url, options, init2 = {}) {
  const req = new Request(url, init2);
  if (typeof options.start != "number" || typeof options.end != "number") {
    const { data } = await _fetch(url, init2);
    new Resource(url, data.byteLength, options, resourcesCache).add(data, 0);
    return data;
  }
  if (typeof options.size != "number") {
    options.warn?.(url + ": Size not provided, an additional HEAD request is being made");
    const { headers } = await fetch(req, { method: "HEAD" });
    const size2 = parseInt(headers.get("Content-Length") ?? "");
    if (typeof size2 != "number")
      throw {
        tag: "size",
        message: "Response is missing content-length header and no size was provided"
      };
    options.size = size2;
  }
  const { size, start, end } = options;
  const resource = resourcesCache.get(url) ?? new Resource(url, size, options, resourcesCache);
  req.headers.set("If-Range", (/* @__PURE__ */ new Date()).toUTCString());
  for (const { start: from, end: to } of resource.missing(start, end)) {
    const { data, response } = await _fetch(req, { headers: { Range: `bytes=${from}-${to}` } });
    if (response.status == 206) {
      resource.add(data, from);
      continue;
    }
    options.warn?.(url + ": Remote does not support range requests with bytes. Falling back to full data.");
    new Resource(url, size, options, resourcesCache).add(data, 0);
    return data.subarray(start, end);
  }
  resource.collect();
  const region = resource.regionAt(start);
  return region.data.subarray(start - region.offset, end - region.offset);
}
__name(get$2, "get$2");
function getCached(url, options) {
  const cache = resourcesCache.get(url);
  if (!cache) {
    if (options.size)
      return { data: new Uint8Array(0), missing: [{ start: 0, end: options.size ?? 0 }] };
    options.warn?.(url + ": Size not provided and cache is empty, can not determine missing range");
    return { data: void 0, missing: [] };
  }
  const { start = 0, end = cache.size } = options;
  const data = new Uint8Array(end - start);
  for (const region of cache.regions) {
    if (region.offset + region.data.byteLength <= start)
      continue;
    if (region.offset >= end)
      break;
    for (const range2 of region.ranges) {
      if (range2.end <= start)
        continue;
      if (range2.start >= end)
        break;
      const overlapStart = Math.max(range2.start, start);
      const overlapEnd = Math.min(range2.end, end);
      if (overlapStart >= overlapEnd)
        continue;
      data.set(region.data.subarray(overlapStart - region.offset, overlapEnd - region.offset), overlapStart - start);
    }
  }
  return { data, missing: cache.missing(start, end) };
}
__name(getCached, "getCached");
async function set$1(url, data, options, init2 = {}) {
  if (!resourcesCache.has(url)) {
    new Resource(url, options.size ?? data.byteLength, options, resourcesCache);
  }
  const resource = resourcesCache.get(url);
  const { offset = 0, method = "POST" } = options;
  if (!options.cacheOnly) {
    const headers = new Headers(init2.headers || {});
    if (!headers.get("Content-Type")) {
      headers.set("Content-Type", "application/octet-stream");
    }
    if (!headers.get("Content-Range") && (offset !== 0 || data.byteLength !== resource.size)) {
      const start = offset;
      const end = offset + data.byteLength - 1;
      const total = Math.max(resource.size, end + 1);
      headers.set("Content-Range", `bytes ${start}-${end}/${total}`);
    }
    await _fetch(new Request(url, {
      ...init2,
      method,
      headers,
      body: data.buffer instanceof ArrayBuffer ? data : Uint8Array.from(data)
    }), {}, true);
  }
  resource.add(data, offset);
}
__name(set$1, "set$1");
async function remove$2(url, options = {}, init2 = {}) {
  if (!options.cacheOnly)
    await _fetch(new Request(url, init2), { method: "DELETE" }, true);
  resourcesCache.delete(url);
}
__name(remove$2, "remove$2");
const _IndexFS = class _IndexFS extends FileSystem {
  constructor(id, name, index = new Index()) {
    super(id, name);
    __publicField(this, "index");
    this.index = index;
  }
  usage() {
    return this.index.usage();
  }
  /**
   * Finds all the paths in the index that need to be moved for a rename
   */
  pathsForRename(oldPath, newPath) {
    if (!this.index.has(oldPath))
      throw withErrno("ENOENT");
    if ((dirname(newPath) + "/").startsWith(oldPath + "/"))
      throw withErrno("EBUSY");
    const toRename = [];
    for (const [from, inode] of this.index.entries()) {
      const rel = relative(oldPath, from);
      if (rel.startsWith(".."))
        continue;
      let to = join(newPath, rel);
      if (to.endsWith("/"))
        to = to.slice(0, -1);
      toRename.push({ from, to, inode });
    }
    toRename.sort((a, b) => b.from.length - a.from.length);
    return toRename;
  }
  async rename(oldPath, newPath) {
    if (oldPath == newPath)
      return;
    const toRename = this.pathsForRename(oldPath, newPath);
    const contents = /* @__PURE__ */ new Map();
    for (const { from, to, inode } of toRename) {
      const data = new Uint8Array(inode.size);
      await this.read(from, data, 0, inode.size);
      contents.set(to, data);
      this.index.delete(from);
      await this.remove(from);
      if (this.index.has(to))
        await this.remove(to);
    }
    toRename.reverse();
    for (const { to, inode } of toRename) {
      const data = contents.get(to);
      this.index.set(to, inode);
      if ((inode.mode & S_IFMT) == S_IFDIR)
        await this._mkdir?.(to, inode);
      else
        await this.write(to, data, 0);
    }
  }
  renameSync(oldPath, newPath) {
    if (oldPath == newPath)
      return;
    const toRename = this.pathsForRename(oldPath, newPath);
    const contents = /* @__PURE__ */ new Map();
    for (const { from, to, inode } of toRename) {
      const data = new Uint8Array(inode.size);
      this.readSync(from, data, 0, inode.size);
      contents.set(to, data);
      this.index.delete(from);
      this.removeSync(from);
      if (this.index.has(to))
        this.removeSync(to);
    }
    toRename.reverse();
    for (const { to, inode } of toRename) {
      const data = contents.get(to);
      this.index.set(to, inode);
      if ((inode.mode & S_IFMT) == S_IFDIR)
        this._mkdirSync?.(to, inode);
      else
        this.writeSync(to, data, 0);
    }
  }
  async stat(path2) {
    const inode = this.index.get(path2);
    if (!inode)
      throw withErrno("ENOENT");
    return inode;
  }
  statSync(path2) {
    const inode = this.index.get(path2);
    if (!inode)
      throw withErrno("ENOENT");
    return inode;
  }
  async touch(path2, metadata) {
    const inode = this.index.get(path2) ?? _throw(withErrno("ENOENT"));
    inode.update(metadata);
  }
  touchSync(path2, metadata) {
    const inode = this.index.get(path2) ?? _throw(withErrno("ENOENT"));
    inode.update(metadata);
  }
  _remove(path2, isUnlink) {
    const inode = this.index.get(path2);
    if (!inode)
      throw withErrno("ENOENT");
    const isDir = (inode.mode & S_IFMT) == S_IFDIR;
    if (!isDir && !isUnlink)
      throw withErrno("ENOTDIR");
    if (isDir && isUnlink)
      throw withErrno("EISDIR");
    if (!isDir)
      this.index.delete(path2);
  }
  async unlink(path2) {
    this._remove(path2, true);
    await this.remove(path2);
  }
  unlinkSync(path2) {
    this._remove(path2, true);
    this.removeSync(path2);
  }
  async rmdir(path2) {
    this._remove(path2, false);
    const entries2 = await this.readdir(path2);
    if (entries2.length)
      throw withErrno("ENOTEMPTY");
    this.index.delete(path2);
    await this.remove(path2);
  }
  rmdirSync(path2) {
    this._remove(path2, false);
    if (this.readdirSync(path2).length)
      throw withErrno("ENOTEMPTY");
    this.index.delete(path2);
    this.removeSync(path2);
  }
  create(path2, options) {
    if (this.index.has(path2))
      throw withErrno("EEXIST");
    const parent = this.index.get(dirname(path2));
    if (!parent)
      throw withErrno("ENOENT");
    const id = this.index._alloc();
    const inode = new Inode({
      ino: id,
      data: id + 1,
      mode: options.mode,
      size: 0,
      uid: parent.mode & S_ISUID ? parent.uid : options.uid,
      gid: parent.mode & S_ISGID ? parent.gid : options.gid,
      nlink: 1
    });
    this.index.set(path2, inode);
    return inode;
  }
  async createFile(path2, options) {
    options.mode |= S_IFREG;
    return this.create(path2, options);
  }
  createFileSync(path2, options) {
    options.mode |= S_IFREG;
    return this.create(path2, options);
  }
  async mkdir(path2, options) {
    options.mode |= S_IFDIR;
    const inode = this.create(path2, options);
    await this._mkdir?.(path2, options);
    return inode;
  }
  mkdirSync(path2, options) {
    options.mode |= S_IFDIR;
    const inode = this.create(path2, options);
    this._mkdirSync?.(path2, options);
    return inode;
  }
  link(target, link2) {
    throw withErrno("ENOSYS");
  }
  linkSync(target, link2) {
    throw withErrno("ENOSYS");
  }
  async readdir(path2) {
    return Object.keys(this.index.directoryEntries(path2));
  }
  readdirSync(path2) {
    return Object.keys(this.index.directoryEntries(path2));
  }
  async sync() {
  }
  syncSync() {
  }
};
__name(_IndexFS, "IndexFS");
let IndexFS = _IndexFS;
function parseError(error) {
  if (!("tag" in error))
    throw err$1(withErrno("EIO", error.stack));
  switch (error.tag) {
    case "fetch":
      throw err$1(withErrno("EREMOTEIO", error.message));
    case "status":
      throw err$1(withErrno(error.response.status > 500 ? "EREMOTEIO" : "EIO", "Response status code is " + error.response.status));
    case "size":
      throw err$1(withErrno("EBADE", error.message));
    case "buffer":
      throw err$1(withErrno("EIO", "Failed to decode buffer"));
  }
}
__name(parseError, "parseError");
const _FetchFS = class _FetchFS extends IndexFS {
  constructor(index, baseUrl, requestInit = {}, remoteWrite) {
    super(544106099, "nfs", index);
    __publicField(this, "baseUrl");
    __publicField(this, "requestInit");
    __publicField(this, "remoteWrite");
    /**
     * @internal @hidden
     */
    __publicField(this, "_asyncDone", Promise.resolve());
    this.baseUrl = baseUrl;
    this.requestInit = requestInit;
    this.remoteWrite = remoteWrite;
  }
  _async(p) {
    this._asyncDone = this._asyncDone.then(() => p);
  }
  async remove(path2) {
    await remove$2(this.baseUrl + path2, { cacheOnly: !this.remoteWrite }, this.requestInit);
  }
  removeSync(path2) {
    this._async(remove$2(this.baseUrl + path2, { cacheOnly: !this.remoteWrite }, this.requestInit));
  }
  async read(path2, buffer2, offset = 0, end) {
    const inode = this.index.get(path2);
    if (!inode)
      throw withErrno("ENOENT");
    if (end - offset == 0)
      return;
    const data = await get$2(this.baseUrl + path2, { start: offset, end, size: inode.size, warn }, this.requestInit).catch(parseError).catch(() => void 0);
    if (!data)
      throw withErrno("ENODATA");
    buffer2.set(data);
  }
  readSync(path2, buffer2, offset = 0, end) {
    const inode = this.index.get(path2);
    if (!inode)
      throw withErrno("ENOENT");
    if (end - offset == 0)
      return;
    const { data, missing } = getCached(this.baseUrl + path2, { start: offset, end, size: inode.size, warn });
    if (!data)
      throw withErrno("ENODATA");
    if (missing.length) {
      this._async(get$2(this.baseUrl + path2, { start: offset, end, size: inode.size, warn }));
      throw withErrno("EAGAIN");
    }
    buffer2.set(data);
  }
  async write(path2, data, offset) {
    const inode = this.index.get(path2);
    if (!inode)
      throw withErrno("ENOENT");
    inode.update({ mtimeMs: Date.now(), size: Math.max(inode.size, data.byteLength + offset) });
    await set$1(this.baseUrl + path2, data, { offset, warn, cacheOnly: !this.remoteWrite }, this.requestInit).catch(parseError);
  }
  writeSync(path2, data, offset) {
    const inode = this.index.get(path2);
    if (!inode)
      throw withErrno("ENOENT");
    inode.update({ mtimeMs: Date.now(), size: Math.max(inode.size, data.byteLength + offset) });
    this._async(set$1(this.baseUrl + path2, data, { offset, warn, cacheOnly: !this.remoteWrite }, this.requestInit).catch(parseError));
  }
};
__name(_FetchFS, "FetchFS");
let FetchFS = _FetchFS;
const _Fetch = {
  name: "Fetch",
  options: {
    index: { type: ["string", "object"], required: false },
    baseUrl: { type: "string", required: true },
    requestInit: { type: "object", required: false },
    remoteWrite: { type: "boolean", required: false }
  },
  isAvailable() {
    return typeof globalThis.fetch == "function";
  },
  async create(options) {
    const url = new URL(options.baseUrl);
    url.pathname = normalizePath(url.pathname);
    let baseUrl = url.toString();
    if (baseUrl.at(-1) == "/")
      baseUrl = baseUrl.slice(0, -1);
    options.index ?? (options.index = "index.json");
    const index = new Index();
    if (typeof options.index != "string") {
      index.fromJSON(options.index);
    } else {
      const data = await get$2(options.index, { warn }, options.requestInit).catch(parseError);
      index.fromJSON(JSON.parse(decodeUTF8(data)));
    }
    const fs2 = new FetchFS(index, baseUrl, options.requestInit, options.remoteWrite);
    if (options.disableAsyncCache)
      return fs2;
    for (const [path2, node] of index) {
      if (!(node.mode & S_IFREG))
        continue;
      await get$2(baseUrl + path2, { warn }, options.requestInit).catch(parseError);
    }
    return fs2;
  }
};
const Fetch = _Fetch;
(function(env2, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = /* @__PURE__ */ __name(function() {
      try {
        inner.call(this);
      } catch (e2) {
        return Promise.reject(e2);
      }
    }, "dispose");
    env2.stack.push({ value, dispose, async });
  } else if (async) {
    env2.stack.push({ async: true });
  }
  return value;
});
/* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    __name(fail, "fail");
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
          } else s |= 1;
        } catch (e2) {
          fail(e2);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    __name(next, "next");
    return next();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
const crc32cTable = new Uint32Array(256);
for (let i = 0; i < 256; i++) {
  let value = i;
  for (let j = 0; j < 8; j++) {
    value = value & 1 ? 2197175160 ^ value >>> 1 : value >>> 1;
  }
  crc32cTable[i] = value;
}
function crc32c(data) {
  let crc = 4294967295;
  for (let i = 0; i < data.length; i++) {
    crc = crc >>> 8 ^ crc32cTable[(crc ^ data[i]) & 255];
  }
  return (crc ^ 4294967295) >>> 0;
}
__name(crc32c, "crc32c");
var __esDecorate$1 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers$1 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
(function(env2, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = /* @__PURE__ */ __name(function() {
      try {
        inner.call(this);
      } catch (e2) {
        return Promise.reject(e2);
      }
    }, "dispose");
    env2.stack.push({ value, dispose, async });
  } else if (async) {
    env2.stack.push({ async: true });
  }
  return value;
});
/* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    __name(fail, "fail");
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
          } else s |= 1;
        } catch (e2) {
          fail(e2);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    __name(next, "next");
    return next();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
const { format } = new Intl.NumberFormat("en-US", {
  notation: "compact",
  maximumFractionDigits: 2,
  unit: "byte",
  unitDisplay: "narrow"
});
let MetadataEntry = (() => {
  var _id_accessor_storage, _offset__accessor_storage, _offset_accessor_storage, _size_accessor_storage, _a3;
  var _a2, _b2, _c2, _d2;
  let _classDecorators = [struct$1.packed("MetadataEntry")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = $from(BufferView);
  let _id_decorators;
  let _id_initializers = [];
  let _id_extraInitializers = [];
  let _offset__decorators;
  let _offset__initializers = [];
  let _offset__extraInitializers = [];
  let _offset_decorators;
  let _offset_initializers = [];
  let _offset_extraInitializers = [];
  let _size_decorators;
  let _size_initializers = [];
  let _size_extraInitializers = [];
  _a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, _id_accessor_storage, __runInitializers$1(this, _id_initializers, void 0));
      __privateAdd(this, _offset__accessor_storage, (__runInitializers$1(this, _id_extraInitializers), __runInitializers$1(this, _offset__initializers, void 0)));
      __privateAdd(this, _offset_accessor_storage, (__runInitializers$1(this, _offset__extraInitializers), __runInitializers$1(this, _offset_initializers, void 0)));
      __privateAdd(this, _size_accessor_storage, (__runInitializers$1(this, _offset_extraInitializers), __runInitializers$1(this, _size_initializers, void 0)));
      __runInitializers$1(this, _size_extraInitializers);
    }
    /** Inode or data ID */
    get id() {
      return __privateGet(this, _id_accessor_storage);
    }
    set id(value) {
      __privateSet(this, _id_accessor_storage, value);
    }
    /** Reserved for 64-bit offset expansion */
    get offset_() {
      return __privateGet(this, _offset__accessor_storage);
    }
    set offset_(value) {
      __privateSet(this, _offset__accessor_storage, value);
    }
    /** Offset into the buffer the data is stored at. */
    get offset() {
      return __privateGet(this, _offset_accessor_storage);
    }
    set offset(value) {
      __privateSet(this, _offset_accessor_storage, value);
    }
    /** The size of the data */
    get size() {
      return __privateGet(this, _size_accessor_storage);
    }
    set size(value) {
      __privateSet(this, _size_accessor_storage, value);
    }
    toString() {
      return `<MetadataEntry @ 0x${this.byteOffset.toString(16).padStart(8, "0")}>`;
    }
  }, _id_accessor_storage = new WeakMap(), _offset__accessor_storage = new WeakMap(), _offset_accessor_storage = new WeakMap(), _size_accessor_storage = new WeakMap(), _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _id_decorators = [(_a2 = types).uint32.bind(_a2)];
    _offset__decorators = [(_b2 = types).uint32.bind(_b2)];
    _offset_decorators = [(_c2 = types).uint32.bind(_c2)];
    _size_decorators = [(_d2 = types).uint32.bind(_d2)];
    __esDecorate$1(_a3, null, _id_decorators, { kind: "accessor", name: "id", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "id" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.id, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.id = value;
    }, "set") }, metadata: _metadata }, _id_initializers, _id_extraInitializers);
    __esDecorate$1(_a3, null, _offset__decorators, { kind: "accessor", name: "offset_", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "offset_" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.offset_, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.offset_ = value;
    }, "set") }, metadata: _metadata }, _offset__initializers, _offset__extraInitializers);
    __esDecorate$1(_a3, null, _offset_decorators, { kind: "accessor", name: "offset", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "offset" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.offset, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.offset = value;
    }, "set") }, metadata: _metadata }, _offset_initializers, _offset_extraInitializers);
    __esDecorate$1(_a3, null, _size_decorators, { kind: "accessor", name: "size", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "size" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.size, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.size = value;
    }, "set") }, metadata: _metadata }, _size_initializers, _size_extraInitializers);
    __esDecorate$1(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    __runInitializers$1(_classThis, _classExtraInitializers);
  })(), _a3;
  return _classThis;
})();
const entries_per_block = 255;
const max_lock_attempts = 5;
let MetadataBlock = (() => {
  var _checksum_accessor_storage, _timestamp_accessor_storage, _previous_offset_accessor_storage, _items_accessor_storage, _locked_accessor_storage, _a3;
  var _a2, _b2, _c2, _d2;
  let _classDecorators = [struct$1.packed("MetadataBlock")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = $from.typed(Int32Array);
  let _checksum_decorators;
  let _checksum_initializers = [];
  let _checksum_extraInitializers = [];
  let _timestamp_decorators;
  let _timestamp_initializers = [];
  let _timestamp_extraInitializers = [];
  let _previous_offset_decorators;
  let _previous_offset_initializers = [];
  let _previous_offset_extraInitializers = [];
  let _items_decorators;
  let _items_initializers = [];
  let _items_extraInitializers = [];
  let _locked_decorators;
  let _locked_initializers = [];
  let _locked_extraInitializers = [];
  var MetadataBlock2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, _checksum_accessor_storage, __runInitializers$1(this, _checksum_initializers, void 0));
      __privateAdd(this, _timestamp_accessor_storage, (__runInitializers$1(this, _checksum_extraInitializers), __runInitializers$1(this, _timestamp_initializers, BigInt(Date.now()))));
      __privateAdd(this, _previous_offset_accessor_storage, (__runInitializers$1(this, _timestamp_extraInitializers), __runInitializers$1(this, _previous_offset_initializers, void 0)));
      __publicField(this, "_previous", __runInitializers$1(this, _previous_offset_extraInitializers));
      __privateAdd(this, _items_accessor_storage, __runInitializers$1(this, _items_initializers, void 0));
      __privateAdd(this, _locked_accessor_storage, (__runInitializers$1(this, _items_extraInitializers), __runInitializers$1(this, _locked_initializers, void 0)));
      __runInitializers$1(this, _locked_extraInitializers);
    }
    /**
     * The crc32c checksum for the metadata block.
     * @privateRemarks Keep this first!
     */
    get checksum() {
      return __privateGet(this, _checksum_accessor_storage);
    }
    set checksum(value) {
      __privateSet(this, _checksum_accessor_storage, value);
    }
    /** The (last) time this metadata block was updated */
    get timestamp() {
      return __privateGet(this, _timestamp_accessor_storage);
    }
    set timestamp(value) {
      __privateSet(this, _timestamp_accessor_storage, value);
    }
    /** Offset to the previous metadata block */
    get previous_offset() {
      return __privateGet(this, _previous_offset_accessor_storage);
    }
    set previous_offset(value) {
      __privateSet(this, _previous_offset_accessor_storage, value);
    }
    get previous() {
      if (!this.previous_offset)
        return;
      this._previous ?? (this._previous = new MetadataBlock2(this.buffer, this.previous_offset));
      return this._previous;
    }
    get offsetHex() {
      return "0x" + this.byteOffset.toString(16).padStart(8, "0");
    }
    /** Metadata entries. */
    get items() {
      return __privateGet(this, _items_accessor_storage);
    }
    set items(value) {
      __privateSet(this, _items_accessor_storage, value);
    }
    toString(long = false) {
      if (!long)
        return `<MetadataBlock @ ${this.offsetHex}>`;
      let text = [
        `---- Metadata block at ${this.offsetHex} ----`,
        `Checksum: 0x${this.checksum.toString(16).padStart(8, "0")}`,
        `Last updated: ${new Date(Number(this.timestamp)).toLocaleString()}`,
        `Previous block: 0x${this.previous_offset.toString(16).padStart(8, "0")}`,
        "Entries:"
      ].join("\n");
      for (const entry of this.items) {
        if (!entry.offset)
          continue;
        text += `
	0x${entry.id.toString(16).padStart(8, "0")}: ${format(entry.size).padStart(5)} at 0x${entry.offset.toString(16).padStart(8, "0")}`;
      }
      return text;
    }
    /**
     * If non-zero, this block is locked for writing.
     * Note a int32 is used for `Atomics.wait`
     */
    get locked() {
      return __privateGet(this, _locked_accessor_storage);
    }
    set locked(value) {
      __privateSet(this, _locked_accessor_storage, value);
    }
    /**
     * Wait for the block to be unlocked.
     */
    waitUnlocked(depth = 0) {
      if (depth > max_lock_attempts)
        throw crit(withErrno("EBUSY", `sbfs: exceeded max attempts waiting for metadata block at ${this.offsetHex} to be unlocked`));
      const i = this.length - 1;
      if (!Atomics.load(this, i))
        return;
      switch (Atomics.wait(this, i, 1)) {
        case "ok":
          break;
        case "not-equal":
          depth++;
          err$1(`sbfs: waiting for metadata block at ${this.offsetHex} to be unlocked (${depth}/${max_lock_attempts})`);
          return this.waitUnlocked(depth);
        case "timed-out":
          throw crit(withErrno("EBUSY", `sbfs: timed out waiting for metadata block at ${this.offsetHex} to be unlocked`));
      }
    }
    lock() {
      this.waitUnlocked();
      const i = offsetof(this, "locked");
      Atomics.store(this, i, 1);
      const release = /* @__PURE__ */ __name(() => {
        Atomics.store(this, i, 0);
        Atomics.notify(this, i, 1);
      }, "release");
      release[Symbol.dispose] = release;
      return release;
    }
  }, _checksum_accessor_storage = new WeakMap(), _timestamp_accessor_storage = new WeakMap(), _previous_offset_accessor_storage = new WeakMap(), _items_accessor_storage = new WeakMap(), _locked_accessor_storage = new WeakMap(), __name(_a3, "MetadataBlock"), _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _checksum_decorators = [(_a2 = types).uint32.bind(_a2)];
    _timestamp_decorators = [(_b2 = types).uint64.bind(_b2)];
    _previous_offset_decorators = [(_c2 = types).uint32.bind(_c2)];
    _items_decorators = [field(array(MetadataEntry, entries_per_block))];
    _locked_decorators = [(_d2 = types).int32.bind(_d2)];
    __esDecorate$1(_a3, null, _checksum_decorators, { kind: "accessor", name: "checksum", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "checksum" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.checksum, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.checksum = value;
    }, "set") }, metadata: _metadata }, _checksum_initializers, _checksum_extraInitializers);
    __esDecorate$1(_a3, null, _timestamp_decorators, { kind: "accessor", name: "timestamp", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "timestamp" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.timestamp, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.timestamp = value;
    }, "set") }, metadata: _metadata }, _timestamp_initializers, _timestamp_extraInitializers);
    __esDecorate$1(_a3, null, _previous_offset_decorators, { kind: "accessor", name: "previous_offset", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "previous_offset" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.previous_offset, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.previous_offset = value;
    }, "set") }, metadata: _metadata }, _previous_offset_initializers, _previous_offset_extraInitializers);
    __esDecorate$1(_a3, null, _items_decorators, { kind: "accessor", name: "items", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "items" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.items, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.items = value;
    }, "set") }, metadata: _metadata }, _items_initializers, _items_extraInitializers);
    __esDecorate$1(_a3, null, _locked_decorators, { kind: "accessor", name: "locked", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "locked" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.locked, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.locked = value;
    }, "set") }, metadata: _metadata }, _locked_initializers, _locked_extraInitializers);
    __esDecorate$1(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    MetadataBlock2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    __runInitializers$1(_classThis, _classExtraInitializers);
  })(), _a3);
  return MetadataBlock2 = _classThis;
})();
const sb_magic = 1651715706;
const usedBytes = 2;
(() => {
  var _checksum_accessor_storage, _magic_accessor_storage, _version_accessor_storage, _inode_format_accessor_storage, _flags_accessor_storage, _used_bytes_accessor_storage, _total_bytes_accessor_storage, _uuid_accessor_storage, _metadata_block_size_accessor_storage, _metadata_offset__accessor_storage, _metadata_offset_accessor_storage, _label_accessor_storage, __padding_accessor_storage, _a3;
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h, _j, _k;
  let _classDecorators = [struct$1.packed("Superblock")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = $from.typed(BigUint64Array);
  let _checksum_decorators;
  let _checksum_initializers = [];
  let _checksum_extraInitializers = [];
  let _magic_decorators;
  let _magic_initializers = [];
  let _magic_extraInitializers = [];
  let _version_decorators;
  let _version_initializers = [];
  let _version_extraInitializers = [];
  let _inode_format_decorators;
  let _inode_format_initializers = [];
  let _inode_format_extraInitializers = [];
  let _flags_decorators;
  let _flags_initializers = [];
  let _flags_extraInitializers = [];
  let _used_bytes_decorators;
  let _used_bytes_initializers = [];
  let _used_bytes_extraInitializers = [];
  let _total_bytes_decorators;
  let _total_bytes_initializers = [];
  let _total_bytes_extraInitializers = [];
  let _uuid_decorators;
  let _uuid_initializers = [];
  let _uuid_extraInitializers = [];
  let _metadata_block_size_decorators;
  let _metadata_block_size_initializers = [];
  let _metadata_block_size_extraInitializers = [];
  let _metadata_offset__decorators;
  let _metadata_offset__initializers = [];
  let _metadata_offset__extraInitializers = [];
  let _metadata_offset_decorators;
  let _metadata_offset_initializers = [];
  let _metadata_offset_extraInitializers = [];
  let _label_decorators;
  let _label_initializers = [];
  let _label_extraInitializers = [];
  let __padding_decorators;
  let __padding_initializers = [];
  let __padding_extraInitializers = [];
  var SuperBlock = (_a3 = class extends _classSuper {
    constructor(...args) {
      super(...args);
      __privateAdd(this, _checksum_accessor_storage, __runInitializers$1(this, _checksum_initializers, void 0));
      __privateAdd(this, _magic_accessor_storage, (__runInitializers$1(this, _checksum_extraInitializers), __runInitializers$1(this, _magic_initializers, void 0)));
      __privateAdd(this, _version_accessor_storage, (__runInitializers$1(this, _magic_extraInitializers), __runInitializers$1(this, _version_initializers, void 0)));
      __privateAdd(this, _inode_format_accessor_storage, (__runInitializers$1(this, _version_extraInitializers), __runInitializers$1(this, _inode_format_initializers, void 0)));
      __privateAdd(this, _flags_accessor_storage, (__runInitializers$1(this, _inode_format_extraInitializers), __runInitializers$1(this, _flags_initializers, void 0)));
      __privateAdd(this, _used_bytes_accessor_storage, (__runInitializers$1(this, _flags_extraInitializers), __runInitializers$1(this, _used_bytes_initializers, void 0)));
      __privateAdd(this, _total_bytes_accessor_storage, (__runInitializers$1(this, _used_bytes_extraInitializers), __runInitializers$1(this, _total_bytes_initializers, void 0)));
      __privateAdd(this, _uuid_accessor_storage, (__runInitializers$1(this, _total_bytes_extraInitializers), __runInitializers$1(this, _uuid_initializers, void 0)));
      __privateAdd(this, _metadata_block_size_accessor_storage, (__runInitializers$1(this, _uuid_extraInitializers), __runInitializers$1(this, _metadata_block_size_initializers, void 0)));
      __privateAdd(this, _metadata_offset__accessor_storage, (__runInitializers$1(this, _metadata_block_size_extraInitializers), __runInitializers$1(this, _metadata_offset__initializers, void 0)));
      __privateAdd(this, _metadata_offset_accessor_storage, (__runInitializers$1(this, _metadata_offset__extraInitializers), __runInitializers$1(this, _metadata_offset_initializers, void 0)));
      __publicField(this, "metadata", __runInitializers$1(this, _metadata_offset_extraInitializers));
      __privateAdd(this, _label_accessor_storage, __runInitializers$1(this, _label_initializers, void 0));
      __privateAdd(this, __padding_accessor_storage, (__runInitializers$1(this, _label_extraInitializers), __runInitializers$1(this, __padding_initializers, void 0)));
      __runInitializers$1(this, __padding_extraInitializers);
      if (this.magic != sb_magic) {
        warn("sbfs: Invalid magic value, assuming this is a fresh super block");
        const md = new MetadataBlock(this.buffer, sizeof(SuperBlock));
        Object.assign(this, {
          metadata: md,
          metadata_offset: md.byteOffset,
          used_bytes: BigInt(sizeof(SuperBlock) + sizeof(MetadataBlock)),
          total_bytes: BigInt(this.buffer.byteLength),
          magic: sb_magic,
          version: 1,
          inode_format: _inode_version,
          metadata_block_size: sizeof(MetadataBlock),
          uuid: encodeUUID(crypto.randomUUID())
        });
        _update(this);
        _update(md);
        return;
      }
      if (this.checksum !== checksum(this))
        throw crit(withErrno("EIO", "sbfs: checksum mismatch for super block"));
      this.metadata = new MetadataBlock(this.buffer, this.metadata_offset);
      if (this.metadata.checksum !== checksum(this.metadata))
        throw crit(withErrno("EIO", `sbfs: checksum mismatch for metadata block (saved ${this.metadata.checksum.toString(16).padStart(8, "0")}, computed ${checksum(this.metadata).toString(16).padStart(8, "0")})`));
      if (this.inode_format != _inode_version)
        throw crit(withErrno("EIO", "sbfs: inode format mismatch"));
      if (this.metadata_block_size != sizeof(MetadataBlock))
        throw crit(withErrno("EIO", "sbfs: metadata block size mismatch"));
    }
    /**
     * The crc32c checksum for the super block.
     * @privateRemarks Keep this first!
     */
    get checksum() {
      return __privateGet(this, _checksum_accessor_storage);
    }
    set checksum(value) {
      __privateSet(this, _checksum_accessor_storage, value);
    }
    /** Signature for the superblock. */
    get magic() {
      return __privateGet(this, _magic_accessor_storage);
    }
    set magic(value) {
      __privateSet(this, _magic_accessor_storage, value);
    }
    /** The version of the on-disk format */
    get version() {
      return __privateGet(this, _version_accessor_storage);
    }
    set version(value) {
      __privateSet(this, _version_accessor_storage, value);
    }
    /** Which format of `Inode` is used */
    get inode_format() {
      return __privateGet(this, _inode_format_accessor_storage);
    }
    set inode_format(value) {
      __privateSet(this, _inode_format_accessor_storage, value);
    }
    /** Flags for the file system. Currently unused */
    get flags() {
      return __privateGet(this, _flags_accessor_storage);
    }
    set flags(value) {
      __privateSet(this, _flags_accessor_storage, value);
    }
    /** The number of used bytes, including the super block and metadata */
    get used_bytes() {
      return __privateGet(this, _used_bytes_accessor_storage);
    }
    set used_bytes(value) {
      __privateSet(this, _used_bytes_accessor_storage, value);
    }
    /** The total size of the entire file system, including the super block and metadata */
    get total_bytes() {
      return __privateGet(this, _total_bytes_accessor_storage);
    }
    set total_bytes(value) {
      __privateSet(this, _total_bytes_accessor_storage, value);
    }
    /** A UUID for this file system */
    get uuid() {
      return __privateGet(this, _uuid_accessor_storage);
    }
    set uuid(value) {
      __privateSet(this, _uuid_accessor_storage, value);
    }
    /**
     * The size in bytes of a metadata block.
     * Not currently configurable.
     */
    get metadata_block_size() {
      return __privateGet(this, _metadata_block_size_accessor_storage);
    }
    set metadata_block_size(value) {
      __privateSet(this, _metadata_block_size_accessor_storage, value);
    }
    /** Reserved for 64-bit offset expansion */
    get metadata_offset_() {
      return __privateGet(this, _metadata_offset__accessor_storage);
    }
    set metadata_offset_(value) {
      __privateSet(this, _metadata_offset__accessor_storage, value);
    }
    /** Offset of the current metadata block */
    get metadata_offset() {
      return __privateGet(this, _metadata_offset_accessor_storage);
    }
    set metadata_offset(value) {
      __privateSet(this, _metadata_offset_accessor_storage, value);
    }
    /** An optional label for the file system */
    get label() {
      return __privateGet(this, _label_accessor_storage);
    }
    set label(value) {
      __privateSet(this, _label_accessor_storage, value);
    }
    /** Padded to 256 bytes */
    get _padding() {
      return __privateGet(this, __padding_accessor_storage);
    }
    set _padding(value) {
      __privateSet(this, __padding_accessor_storage, value);
    }
    /**
     * Rotate out the current metadata block.
     * Allocates a new metadata block, moves the current one to backup,
     * and updates used_bytes accordingly.
     * @returns the new metadata block
     */
    rotateMetadata() {
      const padding = this.used_bytes % BigInt(4);
      Atomics.add(this, usedBytes, padding);
      const offset = Number(Atomics.add(this, usedBytes, BigInt(sizeof(MetadataBlock))));
      const metadata = new MetadataBlock(this.buffer, offset);
      metadata.previous_offset = this.metadata_offset;
      this.metadata = metadata;
      this.metadata_offset = metadata.byteOffset;
      _update(metadata);
      _update(this);
      return metadata;
    }
    /**
     * Checks to see if `length` bytes are unused, starting at `offset`.
     * @internal Not for external use!
     */
    isUnused(offset, length) {
      if (!length)
        return true;
      if (offset + length > this.total_bytes || offset < sizeof(SuperBlock))
        return false;
      for (let block = this.metadata; block; block = block.previous) {
        if (offset < block.byteOffset + sizeof(MetadataBlock) && offset + length > block.byteOffset)
          return false;
        for (const entry of block.items) {
          if (!entry.offset)
            continue;
          if (offset >= entry.offset && offset < entry.offset + entry.size || offset + length > entry.offset && offset + length <= entry.offset + entry.size || offset <= entry.offset && offset + length >= entry.offset + entry.size) {
            return false;
          }
        }
      }
      return true;
    }
  }, _checksum_accessor_storage = new WeakMap(), _magic_accessor_storage = new WeakMap(), _version_accessor_storage = new WeakMap(), _inode_format_accessor_storage = new WeakMap(), _flags_accessor_storage = new WeakMap(), _used_bytes_accessor_storage = new WeakMap(), _total_bytes_accessor_storage = new WeakMap(), _uuid_accessor_storage = new WeakMap(), _metadata_block_size_accessor_storage = new WeakMap(), _metadata_offset__accessor_storage = new WeakMap(), _metadata_offset_accessor_storage = new WeakMap(), _label_accessor_storage = new WeakMap(), __padding_accessor_storage = new WeakMap(), __name(_a3, "SuperBlock"), _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _checksum_decorators = [(_a2 = types).uint32.bind(_a2)];
    _magic_decorators = [(_b2 = types).uint32.bind(_b2)];
    _version_decorators = [(_c2 = types).uint16.bind(_c2)];
    _inode_format_decorators = [(_d2 = types).uint16.bind(_d2)];
    _flags_decorators = [(_e2 = types).uint32.bind(_e2)];
    _used_bytes_decorators = [(_f2 = types).uint64.bind(_f2)];
    _total_bytes_decorators = [(_g2 = types).uint64.bind(_g2)];
    _uuid_decorators = [types.uint8(16)];
    _metadata_block_size_decorators = [(_h = types).uint32.bind(_h)];
    _metadata_offset__decorators = [(_j = types).uint32.bind(_j)];
    _metadata_offset_decorators = [(_k = types).uint32.bind(_k)];
    _label_decorators = [types.char(64)];
    __padding_decorators = [types.char(132)];
    __esDecorate$1(_a3, null, _checksum_decorators, { kind: "accessor", name: "checksum", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "checksum" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.checksum, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.checksum = value;
    }, "set") }, metadata: _metadata }, _checksum_initializers, _checksum_extraInitializers);
    __esDecorate$1(_a3, null, _magic_decorators, { kind: "accessor", name: "magic", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "magic" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.magic, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.magic = value;
    }, "set") }, metadata: _metadata }, _magic_initializers, _magic_extraInitializers);
    __esDecorate$1(_a3, null, _version_decorators, { kind: "accessor", name: "version", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "version" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.version, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.version = value;
    }, "set") }, metadata: _metadata }, _version_initializers, _version_extraInitializers);
    __esDecorate$1(_a3, null, _inode_format_decorators, { kind: "accessor", name: "inode_format", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "inode_format" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.inode_format, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.inode_format = value;
    }, "set") }, metadata: _metadata }, _inode_format_initializers, _inode_format_extraInitializers);
    __esDecorate$1(_a3, null, _flags_decorators, { kind: "accessor", name: "flags", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "flags" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.flags, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.flags = value;
    }, "set") }, metadata: _metadata }, _flags_initializers, _flags_extraInitializers);
    __esDecorate$1(_a3, null, _used_bytes_decorators, { kind: "accessor", name: "used_bytes", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "used_bytes" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.used_bytes, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.used_bytes = value;
    }, "set") }, metadata: _metadata }, _used_bytes_initializers, _used_bytes_extraInitializers);
    __esDecorate$1(_a3, null, _total_bytes_decorators, { kind: "accessor", name: "total_bytes", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "total_bytes" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.total_bytes, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.total_bytes = value;
    }, "set") }, metadata: _metadata }, _total_bytes_initializers, _total_bytes_extraInitializers);
    __esDecorate$1(_a3, null, _uuid_decorators, { kind: "accessor", name: "uuid", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "uuid" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.uuid, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.uuid = value;
    }, "set") }, metadata: _metadata }, _uuid_initializers, _uuid_extraInitializers);
    __esDecorate$1(_a3, null, _metadata_block_size_decorators, { kind: "accessor", name: "metadata_block_size", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "metadata_block_size" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.metadata_block_size, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.metadata_block_size = value;
    }, "set") }, metadata: _metadata }, _metadata_block_size_initializers, _metadata_block_size_extraInitializers);
    __esDecorate$1(_a3, null, _metadata_offset__decorators, { kind: "accessor", name: "metadata_offset_", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "metadata_offset_" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.metadata_offset_, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.metadata_offset_ = value;
    }, "set") }, metadata: _metadata }, _metadata_offset__initializers, _metadata_offset__extraInitializers);
    __esDecorate$1(_a3, null, _metadata_offset_decorators, { kind: "accessor", name: "metadata_offset", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "metadata_offset" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.metadata_offset, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.metadata_offset = value;
    }, "set") }, metadata: _metadata }, _metadata_offset_initializers, _metadata_offset_extraInitializers);
    __esDecorate$1(_a3, null, _label_decorators, { kind: "accessor", name: "label", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "label" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.label, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.label = value;
    }, "set") }, metadata: _metadata }, _label_initializers, _label_extraInitializers);
    __esDecorate$1(_a3, null, __padding_decorators, { kind: "accessor", name: "_padding", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "_padding" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj._padding, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj._padding = value;
    }, "set") }, metadata: _metadata }, __padding_initializers, __padding_extraInitializers);
    __esDecorate$1(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    SuperBlock = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    __runInitializers$1(_classThis, _classExtraInitializers);
  })(), _a3);
  return SuperBlock = _classThis;
})();
function checksum(value) {
  return crc32c(new Uint8Array(value.buffer, value.byteOffset + 4, sizeof(value) - 4));
}
__name(checksum, "checksum");
function _update(value) {
  if (value instanceof MetadataBlock)
    value.timestamp = BigInt(Date.now());
  value.checksum = checksum(value);
}
__name(_update, "_update");
const nop = /* @__PURE__ */ __name(() => {
}, "nop");
async function collectAsyncIterator(it) {
  const results = [];
  for await (const result of it) {
    results.push(result);
  }
  return results;
}
__name(collectAsyncIterator, "collectAsyncIterator");
function rename(oldPath, newPath, cb = nop) {
  rename$1.call(this, oldPath, newPath).then(() => cb(null)).catch(cb);
}
__name(rename, "rename");
function exists(path2, cb = nop) {
  exists$1.call(this, path2).then(cb).catch(() => cb(false));
}
__name(exists, "exists");
function stat$1(path2, options, callback = nop) {
  callback = typeof options == "function" ? options : callback;
  stat$2.call(this, path2, typeof options != "function" ? options : {}).then((stats) => callback(null, stats)).catch(callback);
}
__name(stat$1, "stat$1");
function lstat(path2, options, callback = nop) {
  callback = typeof options == "function" ? options : callback;
  lstat$1.call(this, path2, typeof options != "function" ? options : {}).then((stats) => callback(null, stats)).catch(callback);
}
__name(lstat, "lstat");
function truncate(path2, cbLen = 0, cb = nop) {
  cb = typeof cbLen === "function" ? cbLen : cb;
  const len = typeof cbLen === "number" ? cbLen : 0;
  truncate$1.call(this, path2, len).then(() => cb(null)).catch(cb);
}
__name(truncate, "truncate");
function unlink(path2, cb = nop) {
  unlink$1.call(this, path2).then(() => cb(null)).catch(cb);
}
__name(unlink, "unlink");
function open$1(path2, flag, cbMode, cb = nop) {
  const mode2 = normalizeMode(cbMode, 420);
  cb = typeof cbMode === "function" ? cbMode : cb;
  open$2.call(this, path2, flag, mode2).then((handle) => cb(null, handle.fd)).catch(cb);
}
__name(open$1, "open$1");
function readFile(filename, options, cb = nop) {
  cb = typeof options === "function" ? options : cb;
  readFile$1.call(this, filename, typeof options === "function" ? null : options).then((data) => cb(null, data)).catch(cb);
}
__name(readFile, "readFile");
function writeFile(filename, data, cbEncOpts, cb = nop) {
  cb = typeof cbEncOpts === "function" ? cbEncOpts : cb;
  writeFile$1.call(this, filename, data, typeof cbEncOpts != "function" ? cbEncOpts : null).then(() => cb(null)).catch(cb);
}
__name(writeFile, "writeFile");
function appendFile(filename, data, cbEncOpts, cb = nop) {
  const optionsOrEncoding = typeof cbEncOpts != "function" ? cbEncOpts : void 0;
  cb = typeof cbEncOpts === "function" ? cbEncOpts : cb;
  appendFile$1.call(this, filename, data, optionsOrEncoding).then(() => cb(null)).catch(cb);
}
__name(appendFile, "appendFile");
function fstat(fd, options, cb = nop) {
  cb = typeof options == "function" ? options : cb;
  new FileHandle(this, fd).stat().then((stats) => cb(null, typeof options == "object" && options?.bigint ? new BigIntStats(stats) : stats)).catch(cb);
}
__name(fstat, "fstat");
function close(fd, cb = nop) {
  new FileHandle(this, fd).close().then(() => cb(null)).catch(cb);
}
__name(close, "close");
function ftruncate(fd, lenOrCB, cb = nop) {
  const length = typeof lenOrCB === "number" ? lenOrCB : 0;
  cb = typeof lenOrCB === "function" ? lenOrCB : cb;
  const file = new FileHandle(this, fd);
  if (length < 0)
    throw withErrno("EINVAL");
  file.truncate(length).then(() => cb(null)).catch(cb);
}
__name(ftruncate, "ftruncate");
function fsync(fd, cb = nop) {
  new FileHandle(this, fd).sync().then(() => cb(null)).catch(cb);
}
__name(fsync, "fsync");
function fdatasync(fd, cb = nop) {
  new FileHandle(this, fd).datasync().then(() => cb(null)).catch(cb);
}
__name(fdatasync, "fdatasync");
function write(fd, data, cbPosOff, cbLenEnc, cbPosEnc, cb = nop) {
  let buffer2, offset, length, position, encoding;
  const handle = new FileHandle(this, fd);
  if (typeof data === "string") {
    encoding = "utf8";
    switch (typeof cbPosOff) {
      case "function":
        cb = cbPosOff;
        break;
      case "number":
        position = cbPosOff;
        encoding = typeof cbLenEnc === "string" ? cbLenEnc : "utf8";
        cb = typeof cbPosEnc === "function" ? cbPosEnc : cb;
        break;
      default:
        cb = typeof cbLenEnc === "function" ? cbLenEnc : typeof cbPosEnc === "function" ? cbPosEnc : cb;
        cb(withErrno("EINVAL"));
        return;
    }
    buffer2 = bufferExports.Buffer.from(data);
    offset = 0;
    length = buffer2.length;
    const _cb = cb;
    handle.write(buffer2, offset, length, position).then(({ bytesWritten }) => _cb(null, bytesWritten, buffer2.toString(encoding))).catch(_cb);
  } else {
    buffer2 = bufferExports.Buffer.from(data.buffer);
    offset = cbPosOff;
    length = cbLenEnc;
    position = typeof cbPosEnc === "number" ? cbPosEnc : null;
    const _cb = typeof cbPosEnc === "function" ? cbPosEnc : cb;
    void handle.write(buffer2, offset, length, position).then(({ bytesWritten }) => _cb(null, bytesWritten, buffer2)).catch(_cb);
  }
}
__name(write, "write");
function read(fd, buffer2, offset, length, position, cb = nop) {
  new FileHandle(this, fd).read(buffer2, offset, length, position).then(({ bytesRead, buffer: buffer3 }) => cb(null, bytesRead, buffer3)).catch(cb);
}
__name(read, "read");
function fchown(fd, uid, gid, cb = nop) {
  new FileHandle(this, fd).chown(uid, gid).then(() => cb(null)).catch(cb);
}
__name(fchown, "fchown");
function fchmod(fd, mode2, cb) {
  new FileHandle(this, fd).chmod(mode2).then(() => cb(null)).catch(cb);
}
__name(fchmod, "fchmod");
function futimes(fd, atime, mtime, cb = nop) {
  new FileHandle(this, fd).utimes(atime, mtime).then(() => cb(null)).catch(cb);
}
__name(futimes, "futimes");
function rmdir$1(path2, cb = nop) {
  rmdir$2.call(this, path2).then(() => cb(null)).catch(cb);
}
__name(rmdir$1, "rmdir$1");
function mkdir$1(path2, mode2, cb = nop) {
  mkdir$2.call(this, path2, mode2).then(() => cb(null)).catch(cb);
}
__name(mkdir$1, "mkdir$1");
function readdir(path2, _options, cb = nop) {
  cb = typeof _options == "function" ? _options : cb;
  const options = typeof _options != "function" ? _options : {};
  readdir$1.call(this, path2, options).then((entries2) => cb(null, entries2)).catch(cb);
}
__name(readdir, "readdir");
function link(existing, newpath, cb = nop) {
  link$1.call(this, existing, newpath).then(() => cb(null)).catch(cb);
}
__name(link, "link");
function symlink(target, path2, typeOrCB, cb = nop) {
  const type = typeof typeOrCB === "string" ? typeOrCB : "file";
  cb = typeof typeOrCB === "function" ? typeOrCB : cb;
  symlink$1.call(this, target, path2, type).then(() => cb(null)).catch(cb);
}
__name(symlink, "symlink");
function readlink(path2, options, callback = nop) {
  callback = typeof options == "function" ? options : callback;
  readlink$1.call(this, path2).then((result) => callback(null, result)).catch(callback);
}
__name(readlink, "readlink");
function chown$1(path2, uid, gid, cb = nop) {
  chown$2.call(this, path2, uid, gid).then(() => cb(null)).catch(cb);
}
__name(chown$1, "chown$1");
function lchown(path2, uid, gid, cb = nop) {
  lchown$1.call(this, path2, uid, gid).then(() => cb(null)).catch(cb);
}
__name(lchown, "lchown");
function chmod$1(path2, mode2, cb = nop) {
  chmod$2.call(this, path2, mode2).then(() => cb(null)).catch(cb);
}
__name(chmod$1, "chmod$1");
function lchmod(path2, mode2, cb = nop) {
  lchmod$1.call(this, path2, mode2).then(() => cb(null)).catch(cb);
}
__name(lchmod, "lchmod");
function utimes(path2, atime, mtime, cb = nop) {
  utimes$1.call(this, path2, atime, mtime).then(() => cb(null)).catch(cb);
}
__name(utimes, "utimes");
function lutimes(path2, atime, mtime, cb = nop) {
  lutimes$1.call(this, path2, atime, mtime).then(() => cb(null)).catch(cb);
}
__name(lutimes, "lutimes");
function realpath(path2, arg2, cb = nop) {
  cb = typeof arg2 === "function" ? arg2 : cb;
  realpath$1.call(this, path2, typeof arg2 === "function" ? null : arg2).then((result) => cb(null, result)).catch(cb);
}
__name(realpath, "realpath");
function access(path2, cbMode, cb = nop) {
  const mode2 = typeof cbMode === "number" ? cbMode : R_OK;
  cb = typeof cbMode === "function" ? cbMode : cb;
  access$1.call(this, path2, mode2).then(() => cb(null)).catch(cb);
}
__name(access, "access");
const statWatchers = /* @__PURE__ */ new Map();
function watchFile(path2, options, listener) {
  const normalizedPath = normalizePath(path2);
  const opts = typeof options != "function" ? options : {};
  if (typeof options == "function") {
    listener = options;
  }
  if (!listener)
    throw UV("EINVAL", "watch", path2.toString());
  if (statWatchers.has(normalizedPath)) {
    const entry = statWatchers.get(normalizedPath);
    if (entry) {
      entry.listeners.add(listener);
    }
    return;
  }
  const watcher = new StatWatcher(this, normalizedPath, opts);
  watcher.on("change", (curr, prev) => {
    const entry = statWatchers.get(normalizedPath);
    if (!entry) {
      return;
    }
    for (const listener2 of entry.listeners) {
      listener2(curr, prev);
    }
  });
  statWatchers.set(normalizedPath, { watcher, listeners: /* @__PURE__ */ new Set() });
}
__name(watchFile, "watchFile");
function unwatchFile(path2, listener = nop) {
  const normalizedPath = normalizePath(path2);
  const entry = statWatchers.get(normalizedPath);
  if (entry) {
    if (listener && listener !== nop) {
      entry.listeners.delete(listener);
    } else {
      entry.listeners.clear();
    }
    if (entry.listeners.size === 0) {
      entry.watcher.stop();
      statWatchers.delete(normalizedPath);
    }
  }
}
__name(unwatchFile, "unwatchFile");
function watch(path2, options, listener) {
  const watcher = new FSWatcher(this, normalizePath(path2), typeof options == "object" ? options : {});
  listener = typeof options == "function" ? options : listener;
  watcher.on("change", listener || nop);
  return watcher;
}
__name(watch, "watch");
function createReadStream(path2, options) {
  options = typeof options == "object" ? options : { encoding: options };
  const _handle = open$2.call(this, path2, "r", options?.mode);
  return new ReadStream({ ...options, autoClose: true }, _handle);
}
__name(createReadStream, "createReadStream");
function createWriteStream(path2, options) {
  options = typeof options == "object" ? options : { encoding: options };
  const _handle = open$2.call(this, path2, "w", options?.mode);
  return new WriteStream(options, _handle);
}
__name(createWriteStream, "createWriteStream");
function rm$1(path2, options, callback = nop) {
  callback = typeof options === "function" ? options : callback;
  rm$2.call(this, path2, typeof options === "function" ? void 0 : options).then(() => callback(null)).catch(callback);
}
__name(rm$1, "rm$1");
function mkdtemp(prefix, options, callback = nop) {
  callback = typeof options === "function" ? options : callback;
  mkdtemp$1.call(this, prefix, typeof options != "function" ? options : null).then((result) => callback(null, result)).catch(callback);
}
__name(mkdtemp, "mkdtemp");
function copyFile(src, dest, flags, callback = nop) {
  callback = typeof flags === "function" ? flags : callback;
  copyFile$1.call(this, src, dest, typeof flags === "function" ? void 0 : flags).then(() => callback(null)).catch(callback);
}
__name(copyFile, "copyFile");
function readv(fd, buffers, position, cb = nop) {
  cb = typeof position === "function" ? position : cb;
  new FileHandle(this, fd).readv(buffers, typeof position === "function" ? void 0 : position).then(({ buffers: buffers2, bytesRead }) => cb(null, bytesRead, buffers2)).catch(cb);
}
__name(readv, "readv");
function writev(fd, buffers, position, cb = nop) {
  cb = typeof position === "function" ? position : cb;
  new FileHandle(this, fd).writev(buffers, typeof position === "function" ? void 0 : position).then(({ buffers: buffers2, bytesWritten }) => cb(null, bytesWritten, buffers2)).catch(cb);
}
__name(writev, "writev");
function opendir(path2, options, cb = nop) {
  cb = typeof options === "function" ? options : cb;
  opendir$1.call(this, path2, typeof options === "function" ? void 0 : options).then((result) => cb(null, result)).catch(cb);
}
__name(opendir, "opendir");
function cp$1(source2, destination, opts, callback = nop) {
  callback = typeof opts === "function" ? opts : callback;
  cp$2.call(this, source2, destination, typeof opts === "function" ? void 0 : opts).then(() => callback(null)).catch(callback);
}
__name(cp$1, "cp$1");
function statfs(path2, options, callback = nop) {
  callback = typeof options === "function" ? options : callback;
  statfs$1.call(this, path2, typeof options === "function" ? void 0 : options).then((result) => callback(null, result)).catch(callback);
}
__name(statfs, "statfs");
async function openAsBlob(path2, options) {
  const handle = await open$2.call(this, path2.toString(), "r");
  const buffer2 = await handle.readFile();
  await handle.close();
  return new Blob([buffer2], options);
}
__name(openAsBlob, "openAsBlob");
function glob(pattern2, options, callback = nop) {
  callback = typeof options == "function" ? options : callback;
  const it = glob$1.call(this, pattern2, typeof options === "function" ? void 0 : options);
  collectAsyncIterator(it).then((results) => callback(null, results ?? [])).catch((e2) => callback(e2));
}
__name(glob, "glob");
const fs$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BigIntStatsFs,
  Dir,
  Dirent,
  ReadStream,
  Stats,
  StatsFs,
  WriteStream,
  access,
  accessSync,
  appendFile,
  appendFileSync,
  chmod: chmod$1,
  chmodSync,
  chown: chown$1,
  chownSync,
  close,
  closeSync,
  constants,
  copyFile,
  copyFileSync,
  cp: cp$1,
  cpSync,
  createReadStream,
  createWriteStream,
  exists,
  existsSync,
  fchmod,
  fchmodSync,
  fchown,
  fchownSync,
  fdatasync,
  fdatasyncSync,
  fstat,
  fstatSync,
  fsync,
  fsyncSync,
  ftruncate,
  ftruncateSync,
  futimes,
  futimesSync,
  glob,
  globSync,
  lchmod,
  lchmodSync,
  lchown,
  lchownSync,
  link,
  linkSync,
  lopenSync,
  lstat,
  lstatSync,
  lutimes,
  lutimesSync,
  mkdir: mkdir$1,
  mkdirSync,
  mkdtemp,
  mkdtempDisposableSync,
  mkdtempSync,
  open: open$1,
  openAsBlob,
  openSync,
  opendir,
  opendirSync,
  promises,
  read,
  readFile,
  readFileSync,
  readSync,
  readdir,
  readdirSync,
  readlink,
  readlinkSync,
  readv,
  readvSync,
  realpath,
  realpathSync,
  rename,
  renameSync,
  rm: rm$1,
  rmSync,
  rmdir: rmdir$1,
  rmdirSync,
  stat: stat$1,
  statSync,
  statfs,
  statfsSync,
  symlink,
  symlinkSync,
  truncate,
  truncateSync,
  unlink,
  unlinkSync,
  unwatchFile,
  utimes,
  utimesSync,
  watch,
  watchFile,
  write,
  writeFile,
  writeFileSync,
  writeSync,
  writev,
  writevSync
}, Symbol.toStringTag, { value: "Module" }));
const _allowedRestrictedNames = [];
function checkName($, name, path2, syscall) {
  if (!name.startsWith("user.") && !_allowedRestrictedNames.includes(name))
    throw UV("ENOTSUP", syscall, path2);
}
__name(checkName, "checkName");
async function get$1(path2, name, opt = {}) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolveMount(path2, this);
  checkName(this, name, path2, "xattr.get");
  const inode = await fs2.stat(resolved).catch(rethrow("xattr.get", path2));
  if (checkAccess && !hasAccess(this, inode, R_OK))
    throw UV("EACCES", "xattr.get", path2);
  inode.attributes ?? (inode.attributes = new Attributes());
  const value = inode.attributes.get(name);
  if (!value)
    throw UV("ENODATA", "xattr.get", path2);
  const buffer2 = bufferExports.Buffer.from(value);
  return opt.encoding == "buffer" || !opt.encoding ? buffer2 : buffer2.toString(opt.encoding);
}
__name(get$1, "get$1");
function getSync(path2, name, opt = {}) {
  path2 = normalizePath(path2);
  checkName(this, name, path2, "xattr.get");
  const { fs: fs2, path: resolved } = resolveMount(path2, this);
  let inode;
  try {
    inode = fs2.statSync(resolved);
  } catch (e2) {
    throw setUVMessage(Object.assign(e2, { path: path2 }));
  }
  if (checkAccess && !hasAccess(this, inode, R_OK))
    throw UV("EACCES", "xattr.get", path2);
  inode.attributes ?? (inode.attributes = new Attributes());
  const value = inode.attributes.get(name);
  if (!value)
    throw UV("ENODATA", "xattr.get", path2);
  const buffer2 = bufferExports.Buffer.from(value);
  return opt.encoding == "buffer" || !opt.encoding ? buffer2 : buffer2.toString(opt.encoding);
}
__name(getSync, "getSync");
async function set(path2, name, value, opt = {}) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolveMount(path2, this);
  checkName(this, name, path2, "xattr.set");
  const inode = await fs2.stat(resolved).catch(rethrow("xattr.set", path2));
  if (checkAccess && !hasAccess(this, inode, W_OK))
    throw UV("EACCES", "xattr.set", path2);
  inode.attributes ?? (inode.attributes = new Attributes());
  const attr = inode.attributes.get(name);
  if (opt.create && attr)
    throw UV("EEXIST", "xattr.set", path2);
  if (opt.replace && !attr)
    throw UV("ENODATA", "xattr.set", path2);
  inode.attributes.set(name, bufferExports.Buffer.from(value));
  await fs2.touch(resolved, inode).catch(rethrow("xattr.set", path2));
}
__name(set, "set");
function setSync(path2, name, value, opt = {}) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolveMount(path2, this);
  checkName(this, name, path2, "xattr.set");
  let inode;
  try {
    inode = fs2.statSync(resolved);
  } catch (e2) {
    throw setUVMessage(Object.assign(e2, { path: path2 }));
  }
  if (checkAccess && !hasAccess(this, inode, W_OK))
    throw UV("EACCES", "xattr.set", path2);
  inode.attributes ?? (inode.attributes = new Attributes());
  const attr = inode.attributes.get(name);
  if (opt.create && attr)
    throw UV("EEXIST", "xattr.set", path2);
  if (opt.replace && !attr)
    throw UV("ENODATA", "xattr.set", path2);
  inode.attributes.set(name, bufferExports.Buffer.from(value));
  try {
    fs2.touchSync(resolved, inode);
  } catch (e2) {
    throw setUVMessage(Object.assign(e2, { path: path2 }));
  }
}
__name(setSync, "setSync");
async function remove$1(path2, name) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolveMount(path2, this);
  checkName(this, name, path2, "xattr.remove");
  const inode = await fs2.stat(resolved).catch(rethrow("xattr.remove", path2));
  if (checkAccess && !hasAccess(this, inode, W_OK))
    throw UV("EACCES", "xattr.remove", path2);
  inode.attributes ?? (inode.attributes = new Attributes());
  const attr = inode.attributes.get(name);
  if (!attr)
    throw UV("ENODATA", "xattr.remove", path2);
  inode.attributes.remove(name);
  await fs2.touch(resolved, inode);
}
__name(remove$1, "remove$1");
function removeSync(path2, name) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolveMount(path2, this);
  checkName(this, name, path2, "xattr.remove");
  let inode;
  try {
    inode = fs2.statSync(resolved);
  } catch (e2) {
    throw setUVMessage(Object.assign(e2, { path: path2 }));
  }
  if (checkAccess && !hasAccess(this, inode, W_OK))
    throw UV("EACCES", "xattr.remove", path2);
  inode.attributes ?? (inode.attributes = new Attributes());
  const attr = inode.attributes.get(name);
  if (!attr)
    throw UV("ENODATA", "xattr.remove", path2);
  inode.attributes.remove(name);
  try {
    fs2.touchSync(resolved, inode);
  } catch (e2) {
    throw setUVMessage(Object.assign(e2, { path: path2 }));
  }
}
__name(removeSync, "removeSync");
async function list(path2) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolveMount(path2, this);
  const inode = await fs2.stat(resolved).catch(rethrow("xattr.list", path2));
  if (!inode.attributes)
    return [];
  return inode.attributes.keys().toArray();
}
__name(list, "list");
function listSync(path2) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolveMount(path2, this);
  let inode;
  try {
    inode = fs2.statSync(resolved);
  } catch (e2) {
    throw setUVMessage(Object.assign(e2, { path: path2 }));
  }
  if (!inode.attributes)
    return [];
  return inode.attributes.keys().toArray();
}
__name(listSync, "listSync");
const xattr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get: get$1,
  getSync,
  list,
  listSync,
  remove: remove$1,
  removeSync,
  set,
  setSync
}, Symbol.toStringTag, { value: "Module" }));
let _nextId = 1;
const boundContexts = /* @__PURE__ */ new Map();
function bindContext({ root = this?.root || "/", pwd: pwd2 = this?.pwd || "/", credentials = structuredClone(defaultContext.credentials) } = {}) {
  const parent = this ?? defaultContext;
  const ctx = {
    id: _nextId++,
    root,
    pwd: pwd2,
    credentials: createCredentials(credentials),
    descriptors: /* @__PURE__ */ new Map(),
    parent,
    children: []
  };
  const bound = {
    ...ctx,
    fs: {
      ...bindFunctions(fs$1, ctx),
      promises: bindFunctions(promises, ctx),
      xattr: bindFunctions(xattr, ctx)
    },
    path: bindFunctions(path, ctx),
    bind: /* @__PURE__ */ __name((init2) => {
      const child = bindContext.call(ctx, init2);
      ctx.children.push(child);
      return child;
    }, "bind")
  };
  boundContexts.set(ctx.id, bound);
  return bound;
}
__name(bindContext, "bindContext");
(function(env2, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = /* @__PURE__ */ __name(function() {
      try {
        inner.call(this);
      } catch (e2) {
        return Promise.reject(e2);
      }
    }, "dispose");
    env2.stack.push({ value, dispose, async });
  } else if (async) {
    env2.stack.push({ async: true });
  }
  return value;
});
/* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    __name(fail, "fail");
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
          } else s |= 1;
        } catch (e2) {
          fail(e2);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    __name(next, "next");
    return next();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
var __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var XFlag;
(function(XFlag2) {
  XFlag2[XFlag2["RealTime"] = 1] = "RealTime";
  XFlag2[XFlag2["PreAlloc"] = 2] = "PreAlloc";
  XFlag2[XFlag2["Immutable"] = 8] = "Immutable";
  XFlag2[XFlag2["Append"] = 16] = "Append";
  XFlag2[XFlag2["Sync"] = 32] = "Sync";
  XFlag2[XFlag2["NoAtime"] = 64] = "NoAtime";
  XFlag2[XFlag2["NoDump"] = 128] = "NoDump";
  XFlag2[XFlag2["RtInherit"] = 256] = "RtInherit";
  XFlag2[XFlag2["ProjInherit"] = 512] = "ProjInherit";
  XFlag2[XFlag2["NoSymlinks"] = 1024] = "NoSymlinks";
  XFlag2[XFlag2["ExtSize"] = 2048] = "ExtSize";
  XFlag2[XFlag2["ExtSzInherit"] = 4096] = "ExtSzInherit";
  XFlag2[XFlag2["NoDefrag"] = 8192] = "NoDefrag";
  XFlag2[XFlag2["FileStream"] = 16384] = "FileStream";
  XFlag2[XFlag2["Dax"] = 32768] = "Dax";
  XFlag2[XFlag2["CowExtSize"] = 65536] = "CowExtSize";
  XFlag2[XFlag2["HasAttr"] = 2147483648] = "HasAttr";
})(XFlag || (XFlag = {}));
let fsxattr = (() => {
  var _xflags_accessor_storage, _extsize_accessor_storage, _nextents_accessor_storage, _projid_accessor_storage, _cowextsize_accessor_storage, _pad_accessor_storage, _a3;
  var _a2, _b2, _c2, _d2, _e2;
  let _classDecorators = [struct$1("fsxattr")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = $from(BufferView);
  let _xflags_decorators;
  let _xflags_initializers = [];
  let _xflags_extraInitializers = [];
  let _extsize_decorators;
  let _extsize_initializers = [];
  let _extsize_extraInitializers = [];
  let _nextents_decorators;
  let _nextents_initializers = [];
  let _nextents_extraInitializers = [];
  let _projid_decorators;
  let _projid_initializers = [];
  let _projid_extraInitializers = [];
  let _cowextsize_decorators;
  let _cowextsize_initializers = [];
  let _cowextsize_extraInitializers = [];
  let _pad_decorators;
  let _pad_initializers = [];
  let _pad_extraInitializers = [];
  var fsxattr2 = (_a3 = class extends _classSuper {
    constructor(inode = _throw(new Exception(Errno.EINVAL, "fsxattr must be initialized with an inode"))) {
      super(new ArrayBuffer(sizeof(fsxattr2)));
      __privateAdd(this, _xflags_accessor_storage, __runInitializers(this, _xflags_initializers, void 0));
      __privateAdd(this, _extsize_accessor_storage, (__runInitializers(this, _xflags_extraInitializers), __runInitializers(this, _extsize_initializers, void 0)));
      __privateAdd(this, _nextents_accessor_storage, (__runInitializers(this, _extsize_extraInitializers), __runInitializers(this, _nextents_initializers, void 0)));
      __privateAdd(this, _projid_accessor_storage, (__runInitializers(this, _nextents_extraInitializers), __runInitializers(this, _projid_initializers, void 0)));
      __privateAdd(this, _cowextsize_accessor_storage, (__runInitializers(this, _projid_extraInitializers), __runInitializers(this, _cowextsize_initializers, void 0)));
      __privateAdd(this, _pad_accessor_storage, (__runInitializers(this, _cowextsize_extraInitializers), __runInitializers(this, _pad_initializers, [])));
      __runInitializers(this, _pad_extraInitializers);
      this.extsize = inode.size;
      this.nextents = 1;
      this.projid = inode.uid;
      this.cowextsize = inode.size;
      for (const name of Object.keys(InodeFlags)) {
        if (!(inode.flags & InodeFlags[name]))
          continue;
        if (name in XFlag)
          this.xflags |= XFlag[name];
      }
    }
    /** xflags field value */
    get xflags() {
      return __privateGet(this, _xflags_accessor_storage);
    }
    set xflags(value) {
      __privateSet(this, _xflags_accessor_storage, value);
    }
    /** extsize field value */
    get extsize() {
      return __privateGet(this, _extsize_accessor_storage);
    }
    set extsize(value) {
      __privateSet(this, _extsize_accessor_storage, value);
    }
    /** nextents field value */
    get nextents() {
      return __privateGet(this, _nextents_accessor_storage);
    }
    set nextents(value) {
      __privateSet(this, _nextents_accessor_storage, value);
    }
    /** project identifier */
    get projid() {
      return __privateGet(this, _projid_accessor_storage);
    }
    set projid(value) {
      __privateSet(this, _projid_accessor_storage, value);
    }
    /** CoW extsize field value */
    get cowextsize() {
      return __privateGet(this, _cowextsize_accessor_storage);
    }
    set cowextsize(value) {
      __privateSet(this, _cowextsize_accessor_storage, value);
    }
    get pad() {
      return __privateGet(this, _pad_accessor_storage);
    }
    set pad(value) {
      __privateSet(this, _pad_accessor_storage, value);
    }
  }, _xflags_accessor_storage = new WeakMap(), _extsize_accessor_storage = new WeakMap(), _nextents_accessor_storage = new WeakMap(), _projid_accessor_storage = new WeakMap(), _cowextsize_accessor_storage = new WeakMap(), _pad_accessor_storage = new WeakMap(), __name(_a3, "fsxattr"), _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _xflags_decorators = [(_a2 = types).uint32.bind(_a2)];
    _extsize_decorators = [(_b2 = types).uint32.bind(_b2)];
    _nextents_decorators = [(_c2 = types).uint32.bind(_c2)];
    _projid_decorators = [(_d2 = types).uint32.bind(_d2)];
    _cowextsize_decorators = [(_e2 = types).uint32.bind(_e2)];
    _pad_decorators = [types.char(8)];
    __esDecorate(_a3, null, _xflags_decorators, { kind: "accessor", name: "xflags", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "xflags" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.xflags, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.xflags = value;
    }, "set") }, metadata: _metadata }, _xflags_initializers, _xflags_extraInitializers);
    __esDecorate(_a3, null, _extsize_decorators, { kind: "accessor", name: "extsize", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "extsize" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.extsize, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.extsize = value;
    }, "set") }, metadata: _metadata }, _extsize_initializers, _extsize_extraInitializers);
    __esDecorate(_a3, null, _nextents_decorators, { kind: "accessor", name: "nextents", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "nextents" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.nextents, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.nextents = value;
    }, "set") }, metadata: _metadata }, _nextents_initializers, _nextents_extraInitializers);
    __esDecorate(_a3, null, _projid_decorators, { kind: "accessor", name: "projid", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "projid" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.projid, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.projid = value;
    }, "set") }, metadata: _metadata }, _projid_initializers, _projid_extraInitializers);
    __esDecorate(_a3, null, _cowextsize_decorators, { kind: "accessor", name: "cowextsize", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "cowextsize" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.cowextsize, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.cowextsize = value;
    }, "set") }, metadata: _metadata }, _cowextsize_initializers, _cowextsize_extraInitializers);
    __esDecorate(_a3, null, _pad_decorators, { kind: "accessor", name: "pad", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "pad" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.pad, "get"), set: /* @__PURE__ */ __name((obj, value) => {
      obj.pad = value;
    }, "set") }, metadata: _metadata }, _pad_initializers, _pad_extraInitializers);
    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    fsxattr2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    __runInitializers(_classThis, _classExtraInitializers);
  })(), _a3);
  return fsxattr2 = _classThis;
})();
var FileFlag;
(function(FileFlag2) {
  FileFlag2[FileFlag2["SecureRm"] = 1] = "SecureRm";
  FileFlag2[FileFlag2["Undelete"] = 2] = "Undelete";
  FileFlag2[FileFlag2["Compress"] = 4] = "Compress";
  FileFlag2[FileFlag2["Sync"] = 8] = "Sync";
  FileFlag2[FileFlag2["Immutable"] = 16] = "Immutable";
  FileFlag2[FileFlag2["Append"] = 32] = "Append";
  FileFlag2[FileFlag2["NoDump"] = 64] = "NoDump";
  FileFlag2[FileFlag2["NoAtime"] = 128] = "NoAtime";
  FileFlag2[FileFlag2["Dirty"] = 256] = "Dirty";
  FileFlag2[FileFlag2["CompressBlk"] = 512] = "CompressBlk";
  FileFlag2[FileFlag2["NoCompress"] = 1024] = "NoCompress";
  FileFlag2[FileFlag2["Encrypt"] = 2048] = "Encrypt";
  FileFlag2[FileFlag2["Btree"] = 4096] = "Btree";
  FileFlag2[FileFlag2["Index"] = 4096] = "Index";
  FileFlag2[FileFlag2["IMagic"] = 8192] = "IMagic";
  FileFlag2[FileFlag2["JournalData"] = 16384] = "JournalData";
  FileFlag2[FileFlag2["NoTail"] = 32768] = "NoTail";
  FileFlag2[FileFlag2["DirSync"] = 65536] = "DirSync";
  FileFlag2[FileFlag2["TopDir"] = 131072] = "TopDir";
  FileFlag2[FileFlag2["HugeFile"] = 262144] = "HugeFile";
  FileFlag2[FileFlag2["Extent"] = 524288] = "Extent";
  FileFlag2[FileFlag2["Verity"] = 1048576] = "Verity";
  FileFlag2[FileFlag2["EaInode"] = 2097152] = "EaInode";
  FileFlag2[FileFlag2["EofBlocks"] = 4194304] = "EofBlocks";
  FileFlag2[FileFlag2["NoCow"] = 8388608] = "NoCow";
  FileFlag2[FileFlag2["Dax"] = 33554432] = "Dax";
  FileFlag2[FileFlag2["InlineData"] = 268435456] = "InlineData";
  FileFlag2[FileFlag2["ProjInherit"] = 536870912] = "ProjInherit";
  FileFlag2[FileFlag2["CaseFold"] = 1073741824] = "CaseFold";
  FileFlag2[FileFlag2["Reserved"] = 2147483648] = "Reserved";
})(FileFlag || (FileFlag = {}));
var IOC;
(function(IOC2) {
  IOC2[IOC2["GetFlags"] = 2148034049] = "GetFlags";
  IOC2[IOC2["SetFlags"] = 1074292226] = "SetFlags";
  IOC2[IOC2["GetVersion"] = 2148038145] = "GetVersion";
  IOC2[IOC2["SetVersion"] = 1074296322] = "SetVersion";
  IOC2[IOC2["Fiemap"] = 3223348747] = "Fiemap";
  IOC2[IOC2["GetXattr"] = 2149341215] = "GetXattr";
  IOC2[IOC2["SetXattr"] = 1075599392] = "SetXattr";
  IOC2[IOC2["GetLabel"] = 2164298801] = "GetLabel";
  IOC2[IOC2["SetLabel"] = 1090556978] = "SetLabel";
  IOC2[IOC2["GetUUID"] = 2148603136] = "GetUUID";
  IOC2[IOC2["GetSysfsPath"] = 2155943169] = "GetSysfsPath";
})(IOC || (IOC = {}));
var IOC32;
(function(IOC322) {
  IOC322[IOC322["GetFlags"] = 2147771905] = "GetFlags";
  IOC322[IOC322["SetFlags"] = 1074030082] = "SetFlags";
  IOC322[IOC322["GetVersion"] = 2147776001] = "GetVersion";
  IOC322[IOC322["SetVersion"] = 1074034178] = "SetVersion";
})(IOC32 || (IOC32 = {}));
async function ioctl(path2, command, ...args) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolveMount(path2, this);
  try {
    const inode = new Inode(await fs2.stat(resolved));
    switch (command) {
      case IOC.GetFlags:
      case IOC32.GetFlags:
        return inode.flags;
      case IOC.SetFlags:
      case IOC32.SetFlags:
        inode.flags = args[0];
        await fs2.touch(resolved, inode);
        return void 0;
      case IOC.GetVersion:
      case IOC32.GetVersion:
        return inode.version;
      case IOC.SetVersion:
      case IOC32.SetVersion:
        inode.version = args[0];
        await fs2.touch(resolved, inode);
        return void 0;
      case IOC.Fiemap:
        break;
      case IOC.GetXattr:
        return new fsxattr(inode);
      case IOC.SetXattr:
        break;
      case IOC.GetLabel:
        return fs2.label;
      case IOC.SetLabel:
        fs2.label = args[0];
        return void 0;
      case IOC.GetUUID:
        return fs2.uuid;
      case IOC.GetSysfsPath:
        return `/sys/fs/${fs2.name}/${fs2.uuid}`;
    }
  } catch (e2) {
    throw setUVMessage(Object.assign(e2, { syscall: "ioctl", path: path2 }));
  }
  throw UV("ENOTSUP", "ioctl", path2);
}
__name(ioctl, "ioctl");
function ioctlSync(path2, command, ...args) {
  path2 = normalizePath(path2);
  const { fs: fs2, path: resolved } = resolveMount(path2, this);
  try {
    const inode = new Inode(fs2.statSync(resolved));
    switch (command) {
      case IOC.GetFlags:
      case IOC32.GetFlags:
        return inode.flags;
      case IOC.SetFlags:
      case IOC32.SetFlags:
        inode.flags = args[0];
        fs2.touchSync(resolved, inode);
        return void 0;
      case IOC.GetVersion:
      case IOC32.GetVersion:
        return inode.version;
      case IOC.SetVersion:
      case IOC32.SetVersion:
        inode.version = args[0];
        fs2.touchSync(resolved, inode);
        return void 0;
      case IOC.Fiemap:
        break;
      case IOC.GetXattr:
        return new fsxattr(inode);
      case IOC.SetXattr:
        break;
      case IOC.GetLabel:
        return fs2.label;
      case IOC.SetLabel:
        fs2.label = args[0];
        return void 0;
      case IOC.GetUUID:
        return fs2.uuid;
      case IOC.GetSysfsPath:
        return `/sys/fs/${fs2.name}/${fs2.uuid}`;
    }
  } catch (e2) {
    throw setUVMessage(Object.assign(e2, { syscall: "ioctl", path: path2 }));
  }
  throw UV("ENOTSUP", "ioctl", path2);
}
__name(ioctlSync, "ioctlSync");
const fs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BigIntStatsFs,
  Dir,
  Dirent,
  get IOC() {
    return IOC;
  },
  get IOC32() {
    return IOC32;
  },
  ReadStream,
  Stats,
  StatsFs,
  WriteStream,
  access,
  accessSync,
  appendFile,
  appendFileSync,
  chmod: chmod$1,
  chmodSync,
  chown: chown$1,
  chownSync,
  chroot,
  close,
  closeSync,
  constants,
  copyFile,
  copyFileSync,
  cp: cp$1,
  cpSync,
  createReadStream,
  createWriteStream,
  exists,
  existsSync,
  fchmod,
  fchmodSync,
  fchown,
  fchownSync,
  fdatasync,
  fdatasyncSync,
  fstat,
  fstatSync,
  fsync,
  fsyncSync,
  ftruncate,
  ftruncateSync,
  futimes,
  futimesSync,
  glob,
  globSync,
  ioctl,
  ioctlSync,
  lchmod,
  lchmodSync,
  lchown,
  lchownSync,
  link,
  linkSync,
  lopenSync,
  lstat,
  lstatSync,
  lutimes,
  lutimesSync,
  mkdir: mkdir$1,
  mkdirSync,
  mkdtemp,
  mkdtempDisposableSync,
  mkdtempSync,
  mount: mount$1,
  open: open$1,
  openAsBlob,
  openSync,
  opendir,
  opendirSync,
  promises,
  read,
  readFile,
  readFileSync,
  readSync,
  readdir,
  readdirSync,
  readlink,
  readlinkSync,
  readv,
  readvSync,
  realpath,
  realpathSync,
  rename,
  renameSync,
  rm: rm$1,
  rmSync,
  rmdir: rmdir$1,
  rmdirSync,
  stat: stat$1,
  statSync,
  statfs,
  statfsSync,
  symlink,
  symlinkSync,
  truncate,
  truncateSync,
  umount: umount$1,
  unlink,
  unlinkSync,
  unwatchFile,
  utimes,
  utimesSync,
  watch,
  watchFile,
  write,
  writeFile,
  writeFileSync,
  writeSync,
  writev,
  writevSync,
  xattr
}, Symbol.toStringTag, { value: "Module" }));
const version = "2.4.2";
const $pkg = {
  version
};
/*!
 * @zenfs/core — https://npmjs.com/package/@zenfs/core
 * Copyright © James Prevett and other ZenFS contributors.
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
globalThis.__zenfs__ = Object.assign(Object.create(fs), { _version: $pkg.version });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = /* @__PURE__ */ __name(function() {
  __assign = Object.assign || /* @__PURE__ */ __name(function __assign2(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p];
    }
    return t2;
  }, "__assign");
  return __assign.apply(this, arguments);
}, "__assign");
var NotyfNotification = (
  /** @class */
  (function() {
    function NotyfNotification2(options) {
      this.options = options;
      this.listeners = {};
    }
    __name(NotyfNotification2, "NotyfNotification");
    NotyfNotification2.prototype.on = function(eventType, cb) {
      var callbacks = this.listeners[eventType] || [];
      this.listeners[eventType] = callbacks.concat([cb]);
    };
    NotyfNotification2.prototype.triggerEvent = function(eventType, event) {
      var _this = this;
      var callbacks = this.listeners[eventType] || [];
      callbacks.forEach(function(cb) {
        return cb({ target: _this, event });
      });
    };
    return NotyfNotification2;
  })()
);
var NotyfArrayEvent;
(function(NotyfArrayEvent2) {
  NotyfArrayEvent2[NotyfArrayEvent2["Add"] = 0] = "Add";
  NotyfArrayEvent2[NotyfArrayEvent2["Remove"] = 1] = "Remove";
})(NotyfArrayEvent || (NotyfArrayEvent = {}));
var NotyfArray = (
  /** @class */
  (function() {
    function NotyfArray2() {
      this.notifications = [];
    }
    __name(NotyfArray2, "NotyfArray");
    NotyfArray2.prototype.push = function(elem) {
      this.notifications.push(elem);
      this.updateFn(elem, NotyfArrayEvent.Add, this.notifications);
    };
    NotyfArray2.prototype.splice = function(index, num) {
      var elem = this.notifications.splice(index, num)[0];
      this.updateFn(elem, NotyfArrayEvent.Remove, this.notifications);
      return elem;
    };
    NotyfArray2.prototype.indexOf = function(elem) {
      return this.notifications.indexOf(elem);
    };
    NotyfArray2.prototype.onUpdate = function(fn) {
      this.updateFn = fn;
    };
    return NotyfArray2;
  })()
);
var NotyfEvent;
(function(NotyfEvent2) {
  NotyfEvent2["Dismiss"] = "dismiss";
  NotyfEvent2["Click"] = "click";
})(NotyfEvent || (NotyfEvent = {}));
var DEFAULT_OPTIONS = {
  types: [
    {
      type: "success",
      className: "notyf__toast--success",
      backgroundColor: "#3dc763",
      icon: {
        className: "notyf__icon--success",
        tagName: "i"
      }
    },
    {
      type: "error",
      className: "notyf__toast--error",
      backgroundColor: "#ed3d3d",
      icon: {
        className: "notyf__icon--error",
        tagName: "i"
      }
    }
  ],
  duration: 2e3,
  ripple: true,
  position: {
    x: "right",
    y: "bottom"
  },
  dismissible: false
};
var NotyfView = (
  /** @class */
  (function() {
    function NotyfView2() {
      this.notifications = [];
      this.events = {};
      this.X_POSITION_FLEX_MAP = {
        left: "flex-start",
        center: "center",
        right: "flex-end"
      };
      this.Y_POSITION_FLEX_MAP = {
        top: "flex-start",
        center: "center",
        bottom: "flex-end"
      };
      var docFrag = document.createDocumentFragment();
      var notyfContainer = this._createHTMLElement({ tagName: "div", className: "notyf" });
      docFrag.appendChild(notyfContainer);
      document.body.appendChild(docFrag);
      this.container = notyfContainer;
      this.animationEndEventName = this._getAnimationEndEventName();
      this._createA11yContainer();
    }
    __name(NotyfView2, "NotyfView");
    NotyfView2.prototype.on = function(event, cb) {
      var _a2;
      this.events = __assign(__assign({}, this.events), (_a2 = {}, _a2[event] = cb, _a2));
    };
    NotyfView2.prototype.update = function(notification, type) {
      if (type === NotyfArrayEvent.Add) {
        this.addNotification(notification);
      } else if (type === NotyfArrayEvent.Remove) {
        this.removeNotification(notification);
      }
    };
    NotyfView2.prototype.removeNotification = function(notification) {
      var _this = this;
      var renderedNotification = this._popRenderedNotification(notification);
      var node;
      if (!renderedNotification) {
        return;
      }
      node = renderedNotification.node;
      node.classList.add("notyf__toast--disappear");
      var handleEvent;
      node.addEventListener(this.animationEndEventName, handleEvent = /* @__PURE__ */ __name(function(event) {
        if (event.target === node) {
          node.removeEventListener(_this.animationEndEventName, handleEvent);
          _this.container.removeChild(node);
        }
      }, "handleEvent"));
    };
    NotyfView2.prototype.addNotification = function(notification) {
      var node = this._renderNotification(notification);
      this.notifications.push({ notification, node });
      this._announce(notification.options.message || "Notification");
    };
    NotyfView2.prototype._renderNotification = function(notification) {
      var _a2;
      var card = this._buildNotificationCard(notification);
      var className = notification.options.className;
      if (className) {
        (_a2 = card.classList).add.apply(_a2, className.split(" "));
      }
      this.container.appendChild(card);
      return card;
    };
    NotyfView2.prototype._popRenderedNotification = function(notification) {
      var idx = -1;
      for (var i = 0; i < this.notifications.length && idx < 0; i++) {
        if (this.notifications[i].notification === notification) {
          idx = i;
        }
      }
      if (idx !== -1) {
        return this.notifications.splice(idx, 1)[0];
      }
      return;
    };
    NotyfView2.prototype.getXPosition = function(options) {
      var _a2;
      return ((_a2 = options === null || options === void 0 ? void 0 : options.position) === null || _a2 === void 0 ? void 0 : _a2.x) || "right";
    };
    NotyfView2.prototype.getYPosition = function(options) {
      var _a2;
      return ((_a2 = options === null || options === void 0 ? void 0 : options.position) === null || _a2 === void 0 ? void 0 : _a2.y) || "bottom";
    };
    NotyfView2.prototype.adjustContainerAlignment = function(options) {
      var align = this.X_POSITION_FLEX_MAP[this.getXPosition(options)];
      var justify = this.Y_POSITION_FLEX_MAP[this.getYPosition(options)];
      var style = this.container.style;
      style.setProperty("justify-content", justify);
      style.setProperty("align-items", align);
    };
    NotyfView2.prototype._buildNotificationCard = function(notification) {
      var _this = this;
      var options = notification.options;
      var iconOpts = options.icon;
      this.adjustContainerAlignment(options);
      var notificationElem = this._createHTMLElement({ tagName: "div", className: "notyf__toast" });
      var ripple = this._createHTMLElement({ tagName: "div", className: "notyf__ripple" });
      var wrapper = this._createHTMLElement({ tagName: "div", className: "notyf__wrapper" });
      var message = this._createHTMLElement({ tagName: "div", className: "notyf__message" });
      message.innerHTML = options.message || "";
      var mainColor = options.background || options.backgroundColor;
      if (iconOpts) {
        var iconContainer = this._createHTMLElement({ tagName: "div", className: "notyf__icon" });
        if (typeof iconOpts === "string" || iconOpts instanceof String)
          iconContainer.innerHTML = new String(iconOpts).valueOf();
        if (typeof iconOpts === "object") {
          var _a2 = iconOpts.tagName, tagName = _a2 === void 0 ? "i" : _a2, className_1 = iconOpts.className, text = iconOpts.text, _b2 = iconOpts.color, color = _b2 === void 0 ? mainColor : _b2;
          var iconElement = this._createHTMLElement({ tagName, className: className_1, text });
          if (color)
            iconElement.style.color = color;
          iconContainer.appendChild(iconElement);
        }
        wrapper.appendChild(iconContainer);
      }
      wrapper.appendChild(message);
      notificationElem.appendChild(wrapper);
      if (mainColor) {
        if (options.ripple) {
          ripple.style.background = mainColor;
          notificationElem.appendChild(ripple);
        } else {
          notificationElem.style.background = mainColor;
        }
      }
      if (options.dismissible) {
        var dismissWrapper = this._createHTMLElement({ tagName: "div", className: "notyf__dismiss" });
        var dismissButton = this._createHTMLElement({
          tagName: "button",
          className: "notyf__dismiss-btn"
        });
        dismissWrapper.appendChild(dismissButton);
        wrapper.appendChild(dismissWrapper);
        notificationElem.classList.add("notyf__toast--dismissible");
        dismissButton.addEventListener("click", function(event) {
          var _a3, _b3;
          (_b3 = (_a3 = _this.events)[NotyfEvent.Dismiss]) === null || _b3 === void 0 ? void 0 : _b3.call(_a3, { target: notification, event });
          event.stopPropagation();
        });
      }
      notificationElem.addEventListener("click", function(event) {
        var _a3, _b3;
        return (_b3 = (_a3 = _this.events)[NotyfEvent.Click]) === null || _b3 === void 0 ? void 0 : _b3.call(_a3, { target: notification, event });
      });
      var className = this.getYPosition(options) === "top" ? "upper" : "lower";
      notificationElem.classList.add("notyf__toast--" + className);
      return notificationElem;
    };
    NotyfView2.prototype._createHTMLElement = function(_a2) {
      var tagName = _a2.tagName, className = _a2.className, text = _a2.text;
      var elem = document.createElement(tagName);
      if (className) {
        elem.className = className;
      }
      elem.textContent = text || null;
      return elem;
    };
    NotyfView2.prototype._createA11yContainer = function() {
      var a11yContainer = this._createHTMLElement({ tagName: "div", className: "notyf-announcer" });
      a11yContainer.setAttribute("aria-atomic", "true");
      a11yContainer.setAttribute("aria-live", "polite");
      a11yContainer.style.border = "0";
      a11yContainer.style.clip = "rect(0 0 0 0)";
      a11yContainer.style.height = "1px";
      a11yContainer.style.margin = "-1px";
      a11yContainer.style.overflow = "hidden";
      a11yContainer.style.padding = "0";
      a11yContainer.style.position = "absolute";
      a11yContainer.style.width = "1px";
      a11yContainer.style.outline = "0";
      document.body.appendChild(a11yContainer);
      this.a11yContainer = a11yContainer;
    };
    NotyfView2.prototype._announce = function(message) {
      var _this = this;
      this.a11yContainer.textContent = "";
      setTimeout(function() {
        _this.a11yContainer.textContent = message;
      }, 100);
    };
    NotyfView2.prototype._getAnimationEndEventName = function() {
      var el = document.createElement("_fake");
      var transitions = {
        MozTransition: "animationend",
        OTransition: "oAnimationEnd",
        WebkitTransition: "webkitAnimationEnd",
        transition: "animationend"
      };
      var t2;
      for (t2 in transitions) {
        if (el.style[t2] !== void 0) {
          return transitions[t2];
        }
      }
      return "animationend";
    };
    return NotyfView2;
  })()
);
var Notyf = (
  /** @class */
  (function() {
    function Notyf2(opts) {
      var _this = this;
      this.dismiss = this._removeNotification;
      this.notifications = new NotyfArray();
      this.view = new NotyfView();
      var types2 = this.registerTypes(opts);
      this.options = __assign(__assign({}, DEFAULT_OPTIONS), opts);
      this.options.types = types2;
      this.notifications.onUpdate(function(elem, type) {
        return _this.view.update(elem, type);
      });
      this.view.on(NotyfEvent.Dismiss, function(_a2) {
        var target = _a2.target, event = _a2.event;
        _this._removeNotification(target);
        target["triggerEvent"](NotyfEvent.Dismiss, event);
      });
      this.view.on(NotyfEvent.Click, function(_a2) {
        var target = _a2.target, event = _a2.event;
        return target["triggerEvent"](NotyfEvent.Click, event);
      });
    }
    __name(Notyf2, "Notyf");
    Notyf2.prototype.error = function(payload) {
      var options = this.normalizeOptions("error", payload);
      return this.open(options);
    };
    Notyf2.prototype.success = function(payload) {
      var options = this.normalizeOptions("success", payload);
      return this.open(options);
    };
    Notyf2.prototype.open = function(options) {
      var defaultOpts = this.options.types.find(function(_a2) {
        var type = _a2.type;
        return type === options.type;
      }) || {};
      var config2 = __assign(__assign({}, defaultOpts), options);
      this.assignProps(["ripple", "position", "dismissible"], config2);
      var notification = new NotyfNotification(config2);
      this._pushNotification(notification);
      return notification;
    };
    Notyf2.prototype.dismissAll = function() {
      while (this.notifications.splice(0, 1))
        ;
    };
    Notyf2.prototype.assignProps = function(props, config2) {
      var _this = this;
      props.forEach(function(prop) {
        config2[prop] = config2[prop] == null ? _this.options[prop] : config2[prop];
      });
    };
    Notyf2.prototype._pushNotification = function(notification) {
      var _this = this;
      this.notifications.push(notification);
      var duration = notification.options.duration !== void 0 ? notification.options.duration : this.options.duration;
      if (duration) {
        setTimeout(function() {
          return _this._removeNotification(notification);
        }, duration);
      }
    };
    Notyf2.prototype._removeNotification = function(notification) {
      var index = this.notifications.indexOf(notification);
      if (index !== -1) {
        this.notifications.splice(index, 1);
      }
    };
    Notyf2.prototype.normalizeOptions = function(type, payload) {
      var options = { type };
      if (typeof payload === "string") {
        options.message = payload;
      } else if (typeof payload === "object") {
        options = __assign(__assign({}, options), payload);
      }
      return options;
    };
    Notyf2.prototype.registerTypes = function(opts) {
      var incomingTypes = (opts && opts.types || []).slice();
      var finalDefaultTypes = DEFAULT_OPTIONS.types.map(function(defaultType) {
        var userTypeIdx = -1;
        incomingTypes.forEach(function(t2, idx) {
          if (t2.type === defaultType.type)
            userTypeIdx = idx;
        });
        var userType = userTypeIdx !== -1 ? incomingTypes.splice(userTypeIdx, 1)[0] : {};
        return __assign(__assign({}, defaultType), userType);
      });
      return finalDefaultTypes.concat(incomingTypes);
    };
    return Notyf2;
  })()
);
const _Auth = class _Auth {
  constructor() {
    __publicField(this, "passkey", {
      // Create a new credential
      create: /* @__PURE__ */ __name(async (options) => {
        try {
          return await navigator.credentials.create({ publicKey: options });
        } catch (error) {
          console.error("Error creating credential:", error);
          return null;
        }
      }, "create"),
      // Get an existing credential
      get: /* @__PURE__ */ __name(async (options) => {
        try {
          return await navigator.credentials.get({ publicKey: options });
        } catch (error) {
          console.error("Error getting credential:", error);
          return null;
        }
      }, "get"),
      // Check if WebAuthn is supported in the current browser
      isSupported: /* @__PURE__ */ __name(() => {
        return !!window.PublicKeyCredential;
      }, "isSupported"),
      // Register a new credential
      register: /* @__PURE__ */ __name(async (credential) => {
        await navigator.credentials.store(credential);
      }, "register"),
      // Full test of passkey functionality
      fullTest: /* @__PURE__ */ __name(async () => {
        const credential = await this.passkey.create({
          challenge: new Uint8Array(32),
          rp: { name: "Example RP" },
          user: { id: new Uint8Array(16), name: "example@example.com", displayName: "Example User" },
          pubKeyCredParams: [{ type: "public-key", alg: -7 }]
        });
        console.log(credential);
      }, "fullTest")
    });
    __publicField(this, "password", {
      create: /* @__PURE__ */ __name(async (options) => {
        return await navigator.credentials.create({ password: options });
      }, "create")
    });
  }
};
__name(_Auth, "Auth");
let Auth = _Auth;
const _Components = class _Components {
  constructor() {
    __publicField(this, "_components", /* @__PURE__ */ new Map());
  }
  get components() {
    return this._components;
  }
  get names() {
    return Array.from(this._components.keys());
  }
  define(name, component) {
    this._components.set(name, component);
    return globalThis.customElements.define(name, component);
  }
  get(name) {
    return this._components.get(name);
  }
  getName(component) {
    return globalThis.customElements.getName(component);
  }
  has(name) {
    return this._components.has(name);
  }
  upgrade(root) {
    return globalThis.customElements.upgrade(root);
  }
  whenDefined(name) {
    return globalThis.customElements.whenDefined(name);
  }
};
__name(_Components, "Components");
let Components = _Components;
const pkg$c = {
  name: "audio",
  version: "0.1.0",
  description: "Web Audio API device driver"
};
async function cli$c(options) {
  options.kernel.log.debug(`${pkg$c.name} CLI`, options.args);
  const usage = `
Usage: audio <command>

Commands:
  test    Play a test sequence of beeps
  --help  Show this help message
`;
  if (!options.args.length || options.args[0] === "--help") {
    options.terminal.writeln(usage);
    return 0;
  }
  switch (options.args[0]) {
    case "test":
      await test$2(options.kernel, options.shell);
      break;
    default:
      options.terminal.writeln(`Unknown command: ${options.args[0]}`);
      options.terminal.writeln(usage);
      return 1;
  }
  return 0;
}
__name(cli$c, "cli$c");
async function test$2(kernel, shell) {
  const sampleRate = 44100;
  const noteLength = 0.25;
  const shortNoteLength = 0.125;
  const gap = 0.05;
  const finalGap = 0.3;
  const notes = [
    783.99,
    // G5
    523.25,
    // C5
    523.25,
    // C5
    659.25,
    // E5
    587.33,
    // D5
    0,
    // Rest
    698.46,
    // F5
    783.99
    // G5
  ];
  const durations = [
    noteLength,
    shortNoteLength,
    shortNoteLength,
    noteLength,
    noteLength,
    finalGap,
    noteLength,
    noteLength
  ];
  const totalSamples = Math.floor(sampleRate * (durations.reduce((a, b) => a + b, 0) + gap * (notes.length - 1)));
  const header = new ArrayBuffer(44);
  const view2 = new DataView(header);
  view2.setUint32(0, 1380533830, false);
  view2.setUint32(4, 36 + totalSamples * 2, true);
  view2.setUint32(8, 1463899717, false);
  view2.setUint32(12, 1718449184, false);
  view2.setUint32(16, 16, true);
  view2.setUint16(20, 1, true);
  view2.setUint16(22, 1, true);
  view2.setUint32(24, sampleRate, true);
  view2.setUint32(28, sampleRate * 2, true);
  view2.setUint16(32, 2, true);
  view2.setUint16(34, 16, true);
  view2.setUint32(36, 1684108385, false);
  view2.setUint32(40, totalSamples * 2, true);
  const audioData = new ArrayBuffer(totalSamples * 2);
  const audioView = new DataView(audioData);
  let offset = 0;
  for (let i = 0; i < notes.length; i++) {
    const freq = notes[i];
    const samples = Math.floor(sampleRate * (durations[i] || 0));
    for (let j = 0; j < samples; j++) {
      const t2 = j / sampleRate;
      const sample = freq === 0 ? 0 : Math.sin(2 * Math.PI * (freq || 0) * t2) * 32767;
      audioView.setInt16(offset * 2, sample, true);
      offset++;
    }
    if (i < notes.length - 1) {
      const gapSamples = Math.floor(sampleRate * gap);
      for (let j = 0; j < gapSamples; j++) {
        audioView.setInt16(offset * 2, 0, true);
        offset++;
      }
    }
  }
  const finalBuffer = new Uint8Array(header.byteLength + audioData.byteLength);
  finalBuffer.set(new Uint8Array(header), 0);
  finalBuffer.set(new Uint8Array(audioData), header.byteLength);
  try {
    kernel.terminal.writeln("Playing test beeps...");
    const fd = await shell.context.fs.promises.open("/dev/audio", "w", 438);
    await fd.write(finalBuffer);
    await fd.close();
  } catch (error) {
    kernel.terminal.writeln(`Error playing audio: ${error}`);
    return 1;
  }
  return 0;
}
__name(test$2, "test$2");
async function getDrivers$c(kernel) {
  const drivers = [];
  drivers.push({
    name: "audio",
    init: /* @__PURE__ */ __name(() => ({
      major: 14,
      minor: 4,
      data: {
        version: pkg$c.version,
        kernel: kernel.id,
        context: new AudioContext()
      }
    }), "init"),
    read: /* @__PURE__ */ __name((file, buffer2, offset, length) => {
      const deviceData = file.data;
      if (!deviceData.context)
        return 0;
      try {
        if (!navigator.mediaDevices?.getUserMedia) {
          return 0;
        }
        if (!deviceData.stream || !deviceData.recorder) {
          navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: false,
              noiseSuppression: false,
              autoGainControl: false
            }
          }).then((stream2) => {
            deviceData.stream = stream2;
            deviceData.recorder = new MediaRecorder(stream2);
            deviceData.recorder.ondataavailable = (event) => {
              event.data.arrayBuffer().then((buffer3) => {
                deviceData.latestAudioData = new Uint8Array(buffer3);
              });
            };
            deviceData.recorder.start(100);
          }).catch((err2) => {
            console.error("Failed to initialize audio input:", err2);
          });
          return 0;
        }
        if (!deviceData.latestAudioData)
          return 0;
        const view2 = new Uint8Array(buffer2.buffer);
        const bytesToCopy = Math.min(length, deviceData.latestAudioData.length);
        view2.set(deviceData.latestAudioData.subarray(0, bytesToCopy), offset);
        return bytesToCopy;
      } catch (error) {
        console.error("Audio input error:", error);
        return 0;
      }
    }, "read"),
    write: /* @__PURE__ */ __name((file, buffer2, offset) => {
      const deviceData = file.data;
      if (!deviceData.context)
        return 0;
      try {
        const tempBuffer = buffer2.slice(offset);
        const audioData = new ArrayBuffer(tempBuffer.length);
        new Uint8Array(audioData).set(tempBuffer);
        deviceData.context.decodeAudioData(audioData, (audioBuffer) => {
          if (!deviceData.context)
            return 0;
          const sourceNode = deviceData.context.createBufferSource();
          sourceNode.buffer = audioBuffer;
          sourceNode.connect(deviceData.context.destination);
          deviceData.sourceNode = sourceNode;
          sourceNode.start();
        }, (error) => {
          console.error("Audio decoding error:", error);
        });
        return audioData.byteLength;
      } catch (error) {
        console.error("Audio playback error:", error);
        return 0;
      }
    }, "write")
  });
  return drivers;
}
__name(getDrivers$c, "getDrivers$c");
const AudioDevice = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cli: cli$c,
  getDrivers: getDrivers$c,
  pkg: pkg$c
}, Symbol.toStringTag, { value: "Module" }));
function isObject$6(input) {
  return typeof input === "object" && input !== null;
}
__name(isObject$6, "isObject$6");
function isArrayLike$5(input) {
  return isObject$6(input) && typeof input.length === "number";
}
__name(isArrayLike$5, "isArrayLike$5");
function arrayify$4(input) {
  if (Array.isArray(input)) {
    return input;
  } else if (input === void 0) {
    return [];
  } else if (isArrayLike$5(input) || input instanceof Set) {
    return Array.from(input);
  } else {
    return [input];
  }
}
__name(arrayify$4, "arrayify$4");
const csi$4 = "\x1B[";
const ansi$4 = {};
ansi$4.style = {
  reset: "\x1B[0m",
  bold: "\x1B[1m",
  italic: "\x1B[3m",
  underline: "\x1B[4m",
  fontDefault: "\x1B[10m",
  font2: "\x1B[11m",
  font3: "\x1B[12m",
  font4: "\x1B[13m",
  font5: "\x1B[14m",
  font6: "\x1B[15m",
  imageNegative: "\x1B[7m",
  imagePositive: "\x1B[27m",
  black: "\x1B[30m",
  red: "\x1B[31m",
  green: "\x1B[32m",
  yellow: "\x1B[33m",
  blue: "\x1B[34m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  white: "\x1B[37m",
  grey: "\x1B[90m",
  gray: "\x1B[90m",
  brightRed: "\x1B[91m",
  brightGreen: "\x1B[92m",
  brightYellow: "\x1B[93m",
  brightBlue: "\x1B[94m",
  brightMagenta: "\x1B[95m",
  brightCyan: "\x1B[96m",
  brightWhite: "\x1B[97m",
  "bg-black": "\x1B[40m",
  "bg-red": "\x1B[41m",
  "bg-green": "\x1B[42m",
  "bg-yellow": "\x1B[43m",
  "bg-blue": "\x1B[44m",
  "bg-magenta": "\x1B[45m",
  "bg-cyan": "\x1B[46m",
  "bg-white": "\x1B[47m",
  "bg-grey": "\x1B[100m",
  "bg-gray": "\x1B[100m",
  "bg-brightRed": "\x1B[101m",
  "bg-brightGreen": "\x1B[102m",
  "bg-brightYellow": "\x1B[103m",
  "bg-brightBlue": "\x1B[104m",
  "bg-brightMagenta": "\x1B[105m",
  "bg-brightCyan": "\x1B[106m",
  "bg-brightWhite": "\x1B[107m"
};
ansi$4.rgb = function(r, g, b) {
  return `\x1B[38;2;${r};${g};${b}m`;
};
ansi$4.bgRgb = function(r, g, b) {
  return `\x1B[48;2;${r};${g};${b}m`;
};
ansi$4.styles = function(styles2) {
  styles2 = arrayify$4(styles2);
  return styles2.map(function(effect) {
    const rgbMatches = effect.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    const bgRgbMatches = effect.match(/bg-rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (bgRgbMatches) {
      const [full, r, g, b] = bgRgbMatches;
      return ansi$4.bgRgb(r, g, b);
    } else if (rgbMatches) {
      const [full, r, g, b] = rgbMatches;
      return ansi$4.rgb(r, g, b);
    } else {
      return ansi$4.style[effect];
    }
  }).join("");
};
ansi$4.format = function(str, styleArray) {
  const re2 = /\[([\w\s-\(\),]+)\]{([^]*?)}/;
  let matches;
  str = String(str);
  if (!str) return "";
  while (matches = str.match(re2)) {
    const inlineStyles = matches[1].split(/\s+/);
    const inlineString = matches[2];
    str = str.replace(matches[0], ansi$4.format(inlineString, inlineStyles));
  }
  return styleArray && styleArray.length ? ansi$4.styles(styleArray) + str + ansi$4.style.reset : str;
};
ansi$4.cursor = {
  /**
   * Moves the cursor `lines` cells up. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  up: /* @__PURE__ */ __name(function(lines) {
    return csi$4 + (lines || 1) + "A";
  }, "up"),
  /**
   * Moves the cursor `lines` cells down. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  down: /* @__PURE__ */ __name(function(lines) {
    return csi$4 + (lines || 1) + "B";
  }, "down"),
  /**
   * Moves the cursor `lines` cells forward. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  forward: /* @__PURE__ */ __name(function(lines) {
    return csi$4 + (lines || 1) + "C";
  }, "forward"),
  /**
   * Moves the cursor `lines` cells back. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  back: /* @__PURE__ */ __name(function(lines) {
    return csi$4 + (lines || 1) + "D";
  }, "back"),
  /**
   * Moves cursor to beginning of the line n lines down.
   * @param [lines=1] {number}
   * @return {string}
   */
  nextLine: /* @__PURE__ */ __name(function(lines) {
    return csi$4 + (lines || 1) + "E";
  }, "nextLine"),
  /**
   * Moves cursor to beginning of the line n lines up.
   * @param [lines=1] {number}
   * @return {string}
   */
  previousLine: /* @__PURE__ */ __name(function(lines) {
    return csi$4 + (lines || 1) + "F";
  }, "previousLine"),
  /**
   * Moves the cursor to column n.
   * @param n {number} - column number
   * @return {string}
   */
  horizontalAbsolute: /* @__PURE__ */ __name(function(n) {
    return csi$4 + n + "G";
  }, "horizontalAbsolute"),
  /**
   * Moves the cursor to row n, column m. The values are 1-based, and default to 1 (top left corner) if omitted.
   * @param n {number} - row number
   * @param m {number} - column number
   * @return {string}
   */
  position: /* @__PURE__ */ __name(function(n, m) {
    return csi$4 + (n || 1) + ";" + (m || 1) + "H";
  }, "position"),
  /**
   * Hides the cursor
   */
  hide: csi$4 + "?25l",
  /**
   * Shows the cursor
   */
  show: csi$4 + "?25h"
};
ansi$4.erase = {
  /**
   * Clears part of the screen. If n is 0 (or missing), clear from cursor to end of screen. If n is 1, clear from cursor to beginning of the screen. If n is 2, clear entire screen.
   * @param n {number}
   * @return {string}
   */
  display: /* @__PURE__ */ __name(function(n) {
    return csi$4 + (n || 0) + "J";
  }, "display"),
  /**
   * Erases part of the line. If n is zero (or missing), clear from cursor to the end of the line. If n is one, clear from cursor to beginning of the line. If n is two, clear entire line. Cursor position does not change.
   * @param n {number}
   * @return {string}
   */
  inLine: /* @__PURE__ */ __name(function(n) {
    return csi$4 + (n || 0) + "K";
  }, "inLine")
};
const pkg$b = {
  name: "battery",
  version: "0.1.0",
  description: "Battery device driver"
};
async function cli$b(options) {
  const { args, terminal } = options;
  const usage = `
Usage: /dev/battery <command>

Commands:
  status              Show full battery status
  charging            Show if battery is currently charging
  chargingTime        Show time until battery is fully charged
  dischargingTime     Show time until battery is empty
  level               Show current battery level percentage
  --help              Show this help message
`;
  if (!("getBattery" in navigator)) {
    terminal.writeln("Battery API not available");
    return 1;
  }
  if (!args.length || args[0] === "--help") {
    terminal.writeln(usage);
    return 0;
  }
  const battery = await navigator.getBattery();
  try {
    switch (args[0]) {
      case "status":
        terminal.writeln(`${ansi$4.style.bold}🔋 Battery Status:${ansi$4.style.reset}
      🔌 Charging: ${battery.charging ? ansi$4.style.green + "Yes" : ansi$4.style.red + "No"}${ansi$4.style.reset}
      ⏱️ Charging Time: ${battery.chargingTime === Infinity ? ansi$4.style.gray + "N/A" : ansi$4.style.cyan + battery.chargingTime}${ansi$4.style.reset}
      ⌛ Discharging Time: ${battery.dischargingTime === Infinity ? ansi$4.style.gray + "N/A" : ansi$4.style.cyan + battery.dischargingTime}${ansi$4.style.reset}
      📊 Level: ${ansi$4.style[battery.level > 0.5 ? "green" : battery.level > 0.2 ? "yellow" : "red"]}${(battery.level * 100).toFixed(1)}%${ansi$4.style.reset}`);
        break;
      case "charging":
        terminal.writeln(`${battery.charging}`);
        break;
      case "chargingTime":
        terminal.writeln(`${battery.chargingTime}`);
        break;
      case "dischargingTime":
        terminal.writeln(`${battery.dischargingTime}`);
        break;
      case "level":
        terminal.writeln(`${battery.level * 100}%`);
        break;
      default:
        terminal.writeln(`Unknown command: ${args[0]}`);
        terminal.writeln(usage);
        return 1;
    }
    return 0;
  } catch (error) {
    terminal.writeln(`Error: ${error instanceof Error ? error.message : String(error)}`);
    return 1;
  }
}
__name(cli$b, "cli$b");
async function getDrivers$b(kernel) {
  const drivers = [];
  if ("getBattery" in navigator) {
    const battery = await navigator.getBattery();
    drivers.push({
      name: "battery",
      init: /* @__PURE__ */ __name(() => ({
        major: 10,
        minor: 100,
        data: {
          kernelId: kernel.id,
          charging: battery.charging,
          chargingTime: battery.chargingTime,
          dischargingTime: battery.dischargingTime,
          level: battery.level
        }
      }), "init"),
      read: /* @__PURE__ */ __name((_, buffer2) => {
        const view2 = new Uint8Array(buffer2.buffer, 0, 4);
        view2.set([Math.round(battery.level * 100), Number(battery.charging), battery.chargingTime, battery.dischargingTime]);
        return 4;
      }, "read"),
      write: /* @__PURE__ */ __name(() => 0, "write")
    });
  }
  return drivers;
}
__name(getDrivers$b, "getDrivers$b");
const BatteryDevice = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cli: cli$b,
  getDrivers: getDrivers$b,
  pkg: pkg$b
}, Symbol.toStringTag, { value: "Module" }));
const pkg$a = {
  name: "bluetooth",
  version: "0.1.0",
  description: "Web Bluetooth API device driver"
};
async function cli$a(options) {
  const { args, terminal, kernel } = options;
  if (!navigator?.bluetooth) {
    terminal.writeln("Bluetooth API not available");
    return 1;
  }
  async function ensureBluetoothPermission() {
    if (kernel.storage.local.getItem("permission:bluetooth") === "1")
      return true;
    if (kernel.storage.session.getItem("hide:permission:bluetooth") === "1")
      return false;
    return new Promise((resolve2) => {
      const win = kernel.windows.create({
        id: "bluetooth-permission",
        title: "Bluetooth Permission",
        modal: true,
        height: 250,
        html: `
          <p style='font-weight:bold; text-align:center'>Do you want to enable Bluetooth?</p>
          <button class="request-permission-bluetooth btn-success">Enable Bluetooth</button>
          <button class="request-permission-bluetooth-cancel btn-cancel">Cancel</button>
        `
      });
      win.dom.querySelector(".request-permission-bluetooth").addEventListener("click", async () => {
        try {
          await navigator.bluetooth.requestDevice({ acceptAllDevices: true });
          kernel.storage.local.setItem("permission:bluetooth", "1");
          win.close();
          resolve2(true);
        } catch (error) {
          kernel.log.error("Error requesting Bluetooth device", error);
          kernel.storage.session.removeItem("permission:bluetooth");
          win.close();
          const dialog = kernel.windows.dialog({
            title: "⚠️ Error",
            height: 250,
            html: `
              <p>Error requesting Bluetooth device</p>
              <code>${error}</code>
              <button class="request-permission-bluetooth-error-close btn-cancel">Close</button>
            `
          });
          dialog.dom.querySelector(".request-permission-bluetooth-error-close").addEventListener("click", () => dialog.close());
          resolve2(false);
        }
      });
      win.dom.querySelector(".request-permission-bluetooth-cancel").addEventListener("click", () => {
        win.close();
        resolve2(false);
      });
    });
  }
  __name(ensureBluetoothPermission, "ensureBluetoothPermission");
  if (args[0] !== "--help" && !await ensureBluetoothPermission()) {
    terminal.writeln("Bluetooth permission denied");
    return 1;
  }
  const usage = `
Usage: /dev/bluetooth <command>

Commands:
  scan [service]           Scan for Bluetooth devices, optionally filtering by service UUID
  connect <id>             Connect to a specific Bluetooth device by ID
  disconnect <id>          Disconnect from a specific Bluetooth device
  services <id>            List services available on connected device
  characteristics <id>     List characteristics for a service
  read <id> <char>         Read value from characteristic
  write <id> <char> <val>  Write value to characteristic
  notify <id> <char>       Subscribe to notifications from characteristic
  list                     List connected devices
  --help                   Show this help message
`;
  if (!args.length || args[0] === "--help") {
    terminal.writeln(usage);
    return 0;
  }
  try {
    switch (args[0]) {
      case "scan": {
        const filters = [];
        if (args[1]) {
          filters.push({ services: [args[1]] });
        }
        try {
          terminal.writeln("Requesting Bluetooth device...");
          const device = await navigator.bluetooth.requestDevice({
            filters: filters.length ? filters : void 0,
            acceptAllDevices: !filters.length,
            optionalServices: ["generic_access"]
          });
          if (!device) {
            terminal.writeln("No device selected");
            return 1;
          }
          terminal.writeln(`Found device: ${device.name || "Unnamed"} (${device.id})`);
        } catch (error) {
          if (error instanceof DOMException && error.name === "NotFoundError") {
            terminal.writeln("No Bluetooth devices found or user cancelled");
            return 1;
          }
          throw error;
        }
        break;
      }
      case "connect": {
        if (!args[1]) {
          terminal.writeln("Device ID required");
          return 1;
        }
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ services: [args[1]] }]
        });
        await device.gatt?.connect();
        terminal.writeln(`Connected to ${device.name || "Unnamed"}`);
        break;
      }
      case "disconnect": {
        if (!args[1]) {
          terminal.writeln("Device ID required");
          return 1;
        }
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ services: [args[1]] }]
        });
        await device.gatt?.disconnect();
        terminal.writeln(`Disconnected from ${device.name || "Unnamed"}`);
        break;
      }
      case "services": {
        if (!args[1]) {
          terminal.writeln("Device ID required");
          return 1;
        }
        try {
          const devices = await navigator.bluetooth.getDevices();
          const device = devices.find((d) => d.id === args[1]);
          if (!device) {
            terminal.writeln("Device not found. Make sure it was previously paired using the scan command");
            return 1;
          }
          const server = await device.gatt?.connect();
          if (!server) {
            terminal.writeln("Could not connect to device");
            return 1;
          }
          const services = await server.getPrimaryServices();
          terminal.writeln("Available services:");
          services?.forEach((service) => {
            terminal.writeln(`  ${service.uuid}`);
          });
        } catch (error) {
          terminal.writeln(`Error getting services: ${error instanceof Error ? error.message : String(error)}`);
          return 1;
        }
        break;
      }
      case "characteristics": {
        if (!args[1] || !args[2]) {
          terminal.writeln("Device ID and service UUID required");
          return 1;
        }
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ services: [args[1]] }]
        });
        const server = await device.gatt?.connect();
        const service = await server?.getPrimaryService(args[2]);
        const characteristics = await service?.getCharacteristics();
        terminal.writeln("Available characteristics:");
        characteristics?.forEach((char) => {
          terminal.writeln(`  ${char.uuid}`);
        });
        break;
      }
      case "read": {
        if (!args[1] || !args[2] || !args[3]) {
          terminal.writeln("Device ID, service UUID and characteristic UUID required");
          return 1;
        }
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ services: [args[1]] }]
        });
        const server = await device.gatt?.connect();
        const service = await server?.getPrimaryService(args[2]);
        const characteristic = await service?.getCharacteristic(args[3]);
        const value = await characteristic?.readValue();
        terminal.writeln(`Value: ${new TextDecoder().decode(value)}`);
        break;
      }
      case "write": {
        if (!args[1] || !args[2] || !args[3] || !args[4]) {
          terminal.writeln("Device ID, service UUID, characteristic UUID and value required");
          return 1;
        }
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ services: [args[1]] }]
        });
        const server = await device.gatt?.connect();
        const service = await server?.getPrimaryService(args[2]);
        const characteristic = await service?.getCharacteristic(args[3]);
        await characteristic?.writeValue(new TextEncoder().encode(args[4]));
        terminal.writeln("Value written successfully");
        break;
      }
      case "notify": {
        if (!args[1] || !args[2] || !args[3]) {
          terminal.writeln("Device ID, service UUID and characteristic UUID required");
          return 1;
        }
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ services: [args[1]] }]
        });
        const server = await device.gatt?.connect();
        const service = await server?.getPrimaryService(args[2]);
        const characteristic = await service?.getCharacteristic(args[3]);
        await characteristic?.startNotifications();
        characteristic?.addEventListener("characteristicvaluechanged", (event) => {
          const value = event.target.value;
          terminal.writeln(`Notification: ${new TextDecoder().decode(value)}`);
        });
        terminal.writeln("Listening for notifications...");
        break;
      }
      case "list": {
        const devices = await navigator.bluetooth.getDevices();
        if (!devices.length) {
          terminal.writeln("No connected devices");
          return 0;
        }
        terminal.writeln("Connected devices:");
        devices.forEach((device) => {
          terminal.writeln(`  ${device.name || "Unnamed"} (${device.id})`);
        });
        break;
      }
      default:
        terminal.writeln(`Unknown command: ${args[0]}`);
        terminal.writeln(usage);
        return 1;
    }
    return 0;
  } catch (error) {
    terminal.writeln(`Error: ${error instanceof Error ? error.message : String(error)}`);
    return 1;
  }
}
__name(cli$a, "cli$a");
async function getDrivers$a(kernel) {
  const drivers = [{
    name: "bluetooth",
    init: /* @__PURE__ */ __name(() => ({
      major: 216,
      minor: 0,
      data: {
        kernelId: kernel.id,
        available: !!navigator?.bluetooth
      }
    }), "init"),
    read: /* @__PURE__ */ __name(() => {
      return 0;
    }, "read"),
    write: /* @__PURE__ */ __name(() => {
      return 0;
    }, "write")
  }];
  return drivers;
}
__name(getDrivers$a, "getDrivers$a");
const BluetoothDevice = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cli: cli$a,
  getDrivers: getDrivers$a,
  pkg: pkg$a
}, Symbol.toStringTag, { value: "Module" }));
function isObject$5(input) {
  return typeof input === "object" && input !== null;
}
__name(isObject$5, "isObject$5");
function isArrayLike$4(input) {
  return isObject$5(input) && typeof input.length === "number";
}
__name(isArrayLike$4, "isArrayLike$4");
function arrayify$3(input) {
  if (Array.isArray(input)) {
    return input;
  } else if (input === void 0) {
    return [];
  } else if (isArrayLike$4(input) || input instanceof Set) {
    return Array.from(input);
  } else {
    return [input];
  }
}
__name(arrayify$3, "arrayify$3");
const csi$3 = "\x1B[";
const ansi$3 = {};
ansi$3.style = {
  reset: "\x1B[0m",
  bold: "\x1B[1m",
  italic: "\x1B[3m",
  underline: "\x1B[4m",
  fontDefault: "\x1B[10m",
  font2: "\x1B[11m",
  font3: "\x1B[12m",
  font4: "\x1B[13m",
  font5: "\x1B[14m",
  font6: "\x1B[15m",
  imageNegative: "\x1B[7m",
  imagePositive: "\x1B[27m",
  black: "\x1B[30m",
  red: "\x1B[31m",
  green: "\x1B[32m",
  yellow: "\x1B[33m",
  blue: "\x1B[34m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  white: "\x1B[37m",
  grey: "\x1B[90m",
  gray: "\x1B[90m",
  brightRed: "\x1B[91m",
  brightGreen: "\x1B[92m",
  brightYellow: "\x1B[93m",
  brightBlue: "\x1B[94m",
  brightMagenta: "\x1B[95m",
  brightCyan: "\x1B[96m",
  brightWhite: "\x1B[97m",
  "bg-black": "\x1B[40m",
  "bg-red": "\x1B[41m",
  "bg-green": "\x1B[42m",
  "bg-yellow": "\x1B[43m",
  "bg-blue": "\x1B[44m",
  "bg-magenta": "\x1B[45m",
  "bg-cyan": "\x1B[46m",
  "bg-white": "\x1B[47m",
  "bg-grey": "\x1B[100m",
  "bg-gray": "\x1B[100m",
  "bg-brightRed": "\x1B[101m",
  "bg-brightGreen": "\x1B[102m",
  "bg-brightYellow": "\x1B[103m",
  "bg-brightBlue": "\x1B[104m",
  "bg-brightMagenta": "\x1B[105m",
  "bg-brightCyan": "\x1B[106m",
  "bg-brightWhite": "\x1B[107m"
};
ansi$3.rgb = function(r, g, b) {
  return `\x1B[38;2;${r};${g};${b}m`;
};
ansi$3.bgRgb = function(r, g, b) {
  return `\x1B[48;2;${r};${g};${b}m`;
};
ansi$3.styles = function(styles2) {
  styles2 = arrayify$3(styles2);
  return styles2.map(function(effect) {
    const rgbMatches = effect.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    const bgRgbMatches = effect.match(/bg-rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (bgRgbMatches) {
      const [full, r, g, b] = bgRgbMatches;
      return ansi$3.bgRgb(r, g, b);
    } else if (rgbMatches) {
      const [full, r, g, b] = rgbMatches;
      return ansi$3.rgb(r, g, b);
    } else {
      return ansi$3.style[effect];
    }
  }).join("");
};
ansi$3.format = function(str, styleArray) {
  const re2 = /\[([\w\s-\(\),]+)\]{([^]*?)}/;
  let matches;
  str = String(str);
  if (!str) return "";
  while (matches = str.match(re2)) {
    const inlineStyles = matches[1].split(/\s+/);
    const inlineString = matches[2];
    str = str.replace(matches[0], ansi$3.format(inlineString, inlineStyles));
  }
  return styleArray && styleArray.length ? ansi$3.styles(styleArray) + str + ansi$3.style.reset : str;
};
ansi$3.cursor = {
  /**
   * Moves the cursor `lines` cells up. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  up: /* @__PURE__ */ __name(function(lines) {
    return csi$3 + (lines || 1) + "A";
  }, "up"),
  /**
   * Moves the cursor `lines` cells down. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  down: /* @__PURE__ */ __name(function(lines) {
    return csi$3 + (lines || 1) + "B";
  }, "down"),
  /**
   * Moves the cursor `lines` cells forward. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  forward: /* @__PURE__ */ __name(function(lines) {
    return csi$3 + (lines || 1) + "C";
  }, "forward"),
  /**
   * Moves the cursor `lines` cells back. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  back: /* @__PURE__ */ __name(function(lines) {
    return csi$3 + (lines || 1) + "D";
  }, "back"),
  /**
   * Moves cursor to beginning of the line n lines down.
   * @param [lines=1] {number}
   * @return {string}
   */
  nextLine: /* @__PURE__ */ __name(function(lines) {
    return csi$3 + (lines || 1) + "E";
  }, "nextLine"),
  /**
   * Moves cursor to beginning of the line n lines up.
   * @param [lines=1] {number}
   * @return {string}
   */
  previousLine: /* @__PURE__ */ __name(function(lines) {
    return csi$3 + (lines || 1) + "F";
  }, "previousLine"),
  /**
   * Moves the cursor to column n.
   * @param n {number} - column number
   * @return {string}
   */
  horizontalAbsolute: /* @__PURE__ */ __name(function(n) {
    return csi$3 + n + "G";
  }, "horizontalAbsolute"),
  /**
   * Moves the cursor to row n, column m. The values are 1-based, and default to 1 (top left corner) if omitted.
   * @param n {number} - row number
   * @param m {number} - column number
   * @return {string}
   */
  position: /* @__PURE__ */ __name(function(n, m) {
    return csi$3 + (n || 1) + ";" + (m || 1) + "H";
  }, "position"),
  /**
   * Hides the cursor
   */
  hide: csi$3 + "?25l",
  /**
   * Shows the cursor
   */
  show: csi$3 + "?25h"
};
ansi$3.erase = {
  /**
   * Clears part of the screen. If n is 0 (or missing), clear from cursor to end of screen. If n is 1, clear from cursor to beginning of the screen. If n is 2, clear entire screen.
   * @param n {number}
   * @return {string}
   */
  display: /* @__PURE__ */ __name(function(n) {
    return csi$3 + (n || 0) + "J";
  }, "display"),
  /**
   * Erases part of the line. If n is zero (or missing), clear from cursor to the end of the line. If n is one, clear from cursor to beginning of the line. If n is two, clear entire line. Cursor position does not change.
   * @param n {number}
   * @return {string}
   */
  inLine: /* @__PURE__ */ __name(function(n) {
    return csi$3 + (n || 0) + "K";
  }, "inLine")
};
const pkg$9 = {
  name: "gamepad",
  version: "0.1.0",
  description: ""
};
async function cli$9(options) {
  const { args, terminal } = options;
  const usage = `
Usage: /dev/gamepad <command>

Commands:
  list                List connected gamepads
  info <id>           Show information about a specific gamepad
  --help              Show this help message
`;
  if (!("getGamepads" in navigator)) {
    terminal.writeln("Gamepad API not available");
    return 1;
  }
  if (!args.length || args[0] === "--help") {
    terminal.writeln(usage);
    return 0;
  }
  try {
    switch (args[0]) {
      case "list":
        const gamepads = navigator.getGamepads();
        const connectedPads = Array.from(gamepads).filter(Boolean);
        if (!connectedPads.length) {
          terminal.writeln("No gamepads connected");
          break;
        }
        terminal.writeln(`${ansi$3.style.bold}🎮 Connected Gamepads:${ansi$3.style.reset}`);
        connectedPads.forEach((gamepad2) => {
          if (!gamepad2)
            return;
          terminal.writeln(`
      🎮 Index: ${ansi$3.style.cyan}${gamepad2.index}${ansi$3.style.reset}
      📝 ID: ${ansi$3.style.cyan}${gamepad2.id}${ansi$3.style.reset}
      🔌 Connected: ${ansi$3.style.cyan}${gamepad2.connected}${ansi$3.style.reset}
      🎯 Buttons: ${ansi$3.style.cyan}${gamepad2.buttons.length}${ansi$3.style.reset}
      📊 Axes: ${ansi$3.style.cyan}${gamepad2.axes.length}${ansi$3.style.reset}`);
        });
        break;
      case "info":
        if (!args[1]) {
          terminal.writeln("Please provide a gamepad index");
          return 1;
        }
        const gamepads2 = navigator.getGamepads();
        const index = Number(args[1]);
        const gamepad = gamepads2[index];
        if (!gamepad) {
          terminal.writeln(`No gamepad found at index ${index}`);
          return 1;
        }
        terminal.writeln(`${ansi$3.style.bold}Gamepad Information:${ansi$3.style.reset}
      Index: ${gamepad.index}
      ID: ${gamepad.id}
      Connected: ${gamepad.connected}
      Mapping: ${gamepad.mapping}
      Buttons: ${gamepad.buttons.length}
      Axes: ${gamepad.axes.length}`);
        break;
      default:
        terminal.writeln(`Unknown command: ${args[0]}`);
        terminal.writeln(usage);
        return 1;
    }
    return 0;
  } catch (error) {
    terminal.writeln(`Error: ${error instanceof Error ? error.message : String(error)}`);
    return 1;
  }
}
__name(cli$9, "cli$9");
async function getDrivers$9(kernel) {
  const drivers = [{
    name: "gamepad",
    init: /* @__PURE__ */ __name(() => ({
      major: 13,
      minor: 1,
      data: { kernelId: kernel.id, version: pkg$9.version }
    }), "init"),
    read: /* @__PURE__ */ __name(() => 0, "read"),
    write: /* @__PURE__ */ __name(() => 0, "write")
  }];
  return drivers;
}
__name(getDrivers$9, "getDrivers$9");
const GamepadDevice = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cli: cli$9,
  getDrivers: getDrivers$9,
  pkg: pkg$9
}, Symbol.toStringTag, { value: "Module" }));
function isObject$4(input) {
  return typeof input === "object" && input !== null;
}
__name(isObject$4, "isObject$4");
function isArrayLike$3(input) {
  return isObject$4(input) && typeof input.length === "number";
}
__name(isArrayLike$3, "isArrayLike$3");
function arrayify$2(input) {
  if (Array.isArray(input)) {
    return input;
  } else if (input === void 0) {
    return [];
  } else if (isArrayLike$3(input) || input instanceof Set) {
    return Array.from(input);
  } else {
    return [input];
  }
}
__name(arrayify$2, "arrayify$2");
const csi$2 = "\x1B[";
const ansi$2 = {};
ansi$2.style = {
  reset: "\x1B[0m",
  bold: "\x1B[1m",
  italic: "\x1B[3m",
  underline: "\x1B[4m",
  fontDefault: "\x1B[10m",
  font2: "\x1B[11m",
  font3: "\x1B[12m",
  font4: "\x1B[13m",
  font5: "\x1B[14m",
  font6: "\x1B[15m",
  imageNegative: "\x1B[7m",
  imagePositive: "\x1B[27m",
  black: "\x1B[30m",
  red: "\x1B[31m",
  green: "\x1B[32m",
  yellow: "\x1B[33m",
  blue: "\x1B[34m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  white: "\x1B[37m",
  grey: "\x1B[90m",
  gray: "\x1B[90m",
  brightRed: "\x1B[91m",
  brightGreen: "\x1B[92m",
  brightYellow: "\x1B[93m",
  brightBlue: "\x1B[94m",
  brightMagenta: "\x1B[95m",
  brightCyan: "\x1B[96m",
  brightWhite: "\x1B[97m",
  "bg-black": "\x1B[40m",
  "bg-red": "\x1B[41m",
  "bg-green": "\x1B[42m",
  "bg-yellow": "\x1B[43m",
  "bg-blue": "\x1B[44m",
  "bg-magenta": "\x1B[45m",
  "bg-cyan": "\x1B[46m",
  "bg-white": "\x1B[47m",
  "bg-grey": "\x1B[100m",
  "bg-gray": "\x1B[100m",
  "bg-brightRed": "\x1B[101m",
  "bg-brightGreen": "\x1B[102m",
  "bg-brightYellow": "\x1B[103m",
  "bg-brightBlue": "\x1B[104m",
  "bg-brightMagenta": "\x1B[105m",
  "bg-brightCyan": "\x1B[106m",
  "bg-brightWhite": "\x1B[107m"
};
ansi$2.rgb = function(r, g, b) {
  return `\x1B[38;2;${r};${g};${b}m`;
};
ansi$2.bgRgb = function(r, g, b) {
  return `\x1B[48;2;${r};${g};${b}m`;
};
ansi$2.styles = function(styles2) {
  styles2 = arrayify$2(styles2);
  return styles2.map(function(effect) {
    const rgbMatches = effect.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    const bgRgbMatches = effect.match(/bg-rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (bgRgbMatches) {
      const [full, r, g, b] = bgRgbMatches;
      return ansi$2.bgRgb(r, g, b);
    } else if (rgbMatches) {
      const [full, r, g, b] = rgbMatches;
      return ansi$2.rgb(r, g, b);
    } else {
      return ansi$2.style[effect];
    }
  }).join("");
};
ansi$2.format = function(str, styleArray) {
  const re2 = /\[([\w\s-\(\),]+)\]{([^]*?)}/;
  let matches;
  str = String(str);
  if (!str) return "";
  while (matches = str.match(re2)) {
    const inlineStyles = matches[1].split(/\s+/);
    const inlineString = matches[2];
    str = str.replace(matches[0], ansi$2.format(inlineString, inlineStyles));
  }
  return styleArray && styleArray.length ? ansi$2.styles(styleArray) + str + ansi$2.style.reset : str;
};
ansi$2.cursor = {
  /**
   * Moves the cursor `lines` cells up. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  up: /* @__PURE__ */ __name(function(lines) {
    return csi$2 + (lines || 1) + "A";
  }, "up"),
  /**
   * Moves the cursor `lines` cells down. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  down: /* @__PURE__ */ __name(function(lines) {
    return csi$2 + (lines || 1) + "B";
  }, "down"),
  /**
   * Moves the cursor `lines` cells forward. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  forward: /* @__PURE__ */ __name(function(lines) {
    return csi$2 + (lines || 1) + "C";
  }, "forward"),
  /**
   * Moves the cursor `lines` cells back. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  back: /* @__PURE__ */ __name(function(lines) {
    return csi$2 + (lines || 1) + "D";
  }, "back"),
  /**
   * Moves cursor to beginning of the line n lines down.
   * @param [lines=1] {number}
   * @return {string}
   */
  nextLine: /* @__PURE__ */ __name(function(lines) {
    return csi$2 + (lines || 1) + "E";
  }, "nextLine"),
  /**
   * Moves cursor to beginning of the line n lines up.
   * @param [lines=1] {number}
   * @return {string}
   */
  previousLine: /* @__PURE__ */ __name(function(lines) {
    return csi$2 + (lines || 1) + "F";
  }, "previousLine"),
  /**
   * Moves the cursor to column n.
   * @param n {number} - column number
   * @return {string}
   */
  horizontalAbsolute: /* @__PURE__ */ __name(function(n) {
    return csi$2 + n + "G";
  }, "horizontalAbsolute"),
  /**
   * Moves the cursor to row n, column m. The values are 1-based, and default to 1 (top left corner) if omitted.
   * @param n {number} - row number
   * @param m {number} - column number
   * @return {string}
   */
  position: /* @__PURE__ */ __name(function(n, m) {
    return csi$2 + (n || 1) + ";" + (m || 1) + "H";
  }, "position"),
  /**
   * Hides the cursor
   */
  hide: csi$2 + "?25l",
  /**
   * Shows the cursor
   */
  show: csi$2 + "?25h"
};
ansi$2.erase = {
  /**
   * Clears part of the screen. If n is 0 (or missing), clear from cursor to end of screen. If n is 1, clear from cursor to beginning of the screen. If n is 2, clear entire screen.
   * @param n {number}
   * @return {string}
   */
  display: /* @__PURE__ */ __name(function(n) {
    return csi$2 + (n || 0) + "J";
  }, "display"),
  /**
   * Erases part of the line. If n is zero (or missing), clear from cursor to the end of the line. If n is one, clear from cursor to beginning of the line. If n is two, clear entire line. Cursor position does not change.
   * @param n {number}
   * @return {string}
   */
  inLine: /* @__PURE__ */ __name(function(n) {
    return csi$2 + (n || 0) + "K";
  }, "inLine")
};
const pkg$8 = {
  name: "geo",
  version: "0.1.0",
  description: "Geolocation device driver"
};
async function cli$8(options) {
  const { args, terminal } = options;
  const usage = `
Usage: /dev/geo <command>

Commands:
  position           Show current position
  watch              Start watching position changes
  unwatch            Stop watching position changes
  --help             Show this help message
`;
  if (!("geolocation" in navigator)) {
    terminal.writeln("Geolocation API not available");
    return 1;
  }
  if (!args.length || args[0] === "--help") {
    terminal.writeln(usage);
    return 0;
  }
  try {
    switch (args[0]) {
      case "position":
        const position = await new Promise((resolve2, reject) => {
          navigator.geolocation.getCurrentPosition(resolve2, reject);
        });
        terminal.writeln(`${ansi$2.style.bold}📍 Current Position:${ansi$2.style.reset}
      🌍 Latitude: ${ansi$2.style.cyan}${position.coords.latitude}${ansi$2.style.reset}
      🌍 Longitude: ${ansi$2.style.cyan}${position.coords.longitude}${ansi$2.style.reset}
      📏 Accuracy: ${ansi$2.style.cyan}${position.coords.accuracy}m${ansi$2.style.reset}
      🏔️ Altitude: ${position.coords.altitude ? ansi$2.style.cyan + position.coords.altitude + "m" : ansi$2.style.gray + "N/A"}${ansi$2.style.reset}
      🎯 Altitude Accuracy: ${position.coords.altitudeAccuracy ? ansi$2.style.cyan + position.coords.altitudeAccuracy + "m" : ansi$2.style.gray + "N/A"}${ansi$2.style.reset}
      🧭 Heading: ${position.coords.heading ? ansi$2.style.cyan + position.coords.heading + "°" : ansi$2.style.gray + "N/A"}${ansi$2.style.reset}
      🚀 Speed: ${position.coords.speed ? ansi$2.style.cyan + position.coords.speed + "m/s" : ansi$2.style.gray + "N/A"}${ansi$2.style.reset}`);
        break;
      case "watch":
        const watchId = navigator.geolocation.watchPosition(
          (position2) => {
            terminal.writeln(`📍 Position Update: ${position2.coords.latitude}, ${position2.coords.longitude}`);
          },
          (error) => {
            terminal.writeln(`Error: ${error.message}`);
          }
        );
        terminal.writeln(`Started watching position (ID: ${watchId})`);
        break;
      case "unwatch":
        if (!args[1]) {
          terminal.writeln("Please provide a watch ID");
          return 1;
        }
        navigator.geolocation.clearWatch(Number(args[1]));
        terminal.writeln(`Stopped watching position (ID: ${args[1]})`);
        break;
      default:
        terminal.writeln(`Unknown command: ${args[0]}`);
        terminal.writeln(usage);
        return 1;
    }
    return 0;
  } catch (error) {
    terminal.writeln(`Error: ${error instanceof Error ? error.message : String(error)}`);
    return 1;
  }
}
__name(cli$8, "cli$8");
async function getDrivers$8(kernel) {
  const drivers = [];
  if ("geolocation" in navigator) {
    let lastPosition = {
      latitude: 0,
      longitude: 0,
      accuracy: 0,
      altitude: null
    };
    const permission = await navigator.permissions.query({ name: "geolocation" });
    if (permission.state === "granted") {
      navigator.geolocation.watchPosition(
        (position) => {
          lastPosition = {
            ...position.coords,
            toJSON: /* @__PURE__ */ __name(function() {
              return JSON.stringify({
                latitude: this.latitude,
                longitude: this.longitude,
                accuracy: this.accuracy,
                altitude: this.altitude
              });
            }, "toJSON")
          };
        },
        (error) => {
          console.warn("Geolocation error:", error);
        }
      );
    }
    drivers.push({
      name: "geo",
      init: /* @__PURE__ */ __name(() => ({
        major: 10,
        minor: 101,
        data: {
          kernelId: kernel.id,
          version: pkg$8.version
        }
      }), "init"),
      read: /* @__PURE__ */ __name((_, buffer2) => {
        const view2 = new Float64Array(buffer2.buffer, 0, 4);
        view2.set([
          lastPosition.latitude,
          lastPosition.longitude,
          lastPosition.accuracy,
          lastPosition.altitude || 0
        ]);
        return 32;
      }, "read"),
      write: /* @__PURE__ */ __name(() => 0, "write")
    });
  }
  return drivers;
}
__name(getDrivers$8, "getDrivers$8");
const GeoDevice = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cli: cli$8,
  getDrivers: getDrivers$8,
  pkg: pkg$8
}, Symbol.toStringTag, { value: "Module" }));
const pkg$7 = {
  name: "gpu",
  version: "0.1.0",
  description: "WebGPU device driver"
};
async function cli$7(options) {
  options.kernel.log.debug(`${pkg$7.name} CLI`, options.args);
  const usage = `
Usage: gpu <command>

Commands:
  test    Run a WebGPU test that renders a triangle
  --help  Show this help message

Enable WebGPU hardware acceleration at chrome://flags/#enable-webgpu-developer-features
Launch chrome using: google-chrome --enable-unsafe-webgpu --enable-features=Vulkan,UseSkiaRenderer
`;
  if (!options.args.length || options.args[0] === "--help") {
    options.terminal.writeln(usage);
    return 0;
  }
  switch (options.args[0]) {
    case "test":
      await test$1(options.kernel);
      break;
    default:
      options.terminal.writeln(`Unknown command: ${options.args[0]}`);
      options.terminal.writeln(usage);
      return 1;
  }
  return 0;
}
__name(cli$7, "cli$7");
async function getDrivers$7(kernel) {
  const drivers = [];
  if ("gpu" in navigator) {
    const adapter = await navigator.gpu.requestAdapter();
    if (adapter) {
      const device = await adapter.requestDevice();
      drivers.push({
        name: "gpu",
        init: /* @__PURE__ */ __name(() => ({
          major: adapter.info?.vendor === "nvidia" ? 195 : 10,
          minor: 0,
          data: {
            adapter,
            device,
            kernelId: kernel.id,
            features: Array.from(adapter.features),
            limits: Object.fromEntries(
              Object.entries(adapter.limits).map(([k, v]) => [k, String(v)])
            )
          }
        }), "init"),
        read: /* @__PURE__ */ __name(() => 0, "read"),
        write: /* @__PURE__ */ __name(() => 0, "write")
      });
    }
  }
  return drivers;
}
__name(getDrivers$7, "getDrivers$7");
async function test$1(kernel) {
  if (!("gpu" in navigator)) throw new Error("WebGPU not available");
  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) throw new Error("No adapter found");
  const device = await adapter.requestDevice();
  if (!device) throw new Error("No device found");
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("webgpu");
  if (!context) throw new Error("No context found");
  const format2 = navigator.gpu.getPreferredCanvasFormat();
  context.configure({ device, format: format2 });
  const vertexShaderCode = `
    @vertex
    fn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> @builtin(position) vec4<f32> {
      var pos = array<vec2<f32>, 3>(
        vec2<f32>(0.0, 0.5),
        vec2<f32>(-0.5, -0.5),
        vec2<f32>(0.5, -0.5)
      );
      return vec4<f32>(pos[VertexIndex], 0.0, 1.0);
    }
  `;
  const pipeline = device.createRenderPipeline({
    vertex: {
      module: device.createShaderModule({ code: vertexShaderCode }),
      entryPoint: "vertex_main"
    },
    fragment: {
      module: device.createShaderModule({
        code: `
          @fragment
          fn fragment_main() -> @location(0) vec4<f32> {
            return vec4<f32>(1.0, 0.0, 0.0, 1.0);
          }
        `
      }),
      entryPoint: "fragment_main",
      targets: [{ format: format2 }]
    },
    primitive: {
      topology: "triangle-list"
    },
    layout: "auto"
  });
  const vertexBuffer = device.createBuffer({
    size: 3 * 2 * Float32Array.BYTES_PER_ELEMENT,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
  });
  const vertexArray = new Float32Array([
    0,
    0.5,
    -0.5,
    -0.5,
    0.5,
    -0.5
  ]);
  device.queue.writeBuffer(vertexBuffer, 0, vertexArray);
  const commandEncoder = device.createCommandEncoder();
  const pass = commandEncoder.beginRenderPass({
    colorAttachments: [{
      view: context.getCurrentTexture().createView(),
      loadOp: "clear",
      storeOp: "store"
    }]
  });
  pass.setPipeline(pipeline);
  pass.setVertexBuffer(0, vertexBuffer);
  pass.draw(3, 1, 0, 0);
  pass.end();
  device.queue.submit([commandEncoder.finish()]);
  if (kernel.terminal?.element) kernel.terminal.element.style.display = "none";
  canvas.style.position = "absolute";
  canvas.style.top = "0";
  canvas.style.left = "0";
  canvas.style.zIndex = "1000";
  document.body.appendChild(canvas);
  setTimeout(() => {
    if (kernel.terminal?.element) kernel.terminal.element.style.display = "";
    canvas.remove();
    kernel.terminal.focus();
  }, 2e3);
}
__name(test$1, "test$1");
const GPUDevice = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cli: cli$7,
  getDrivers: getDrivers$7,
  pkg: pkg$7
}, Symbol.toStringTag, { value: "Module" }));
function isObject$3(input) {
  return typeof input === "object" && input !== null;
}
__name(isObject$3, "isObject$3");
function isArrayLike$2(input) {
  return isObject$3(input) && typeof input.length === "number";
}
__name(isArrayLike$2, "isArrayLike$2");
function arrayify$1(input) {
  if (Array.isArray(input)) {
    return input;
  } else if (input === void 0) {
    return [];
  } else if (isArrayLike$2(input) || input instanceof Set) {
    return Array.from(input);
  } else {
    return [input];
  }
}
__name(arrayify$1, "arrayify$1");
const csi$1 = "\x1B[";
const ansi$1 = {};
ansi$1.style = {
  reset: "\x1B[0m",
  bold: "\x1B[1m",
  italic: "\x1B[3m",
  underline: "\x1B[4m",
  fontDefault: "\x1B[10m",
  font2: "\x1B[11m",
  font3: "\x1B[12m",
  font4: "\x1B[13m",
  font5: "\x1B[14m",
  font6: "\x1B[15m",
  imageNegative: "\x1B[7m",
  imagePositive: "\x1B[27m",
  black: "\x1B[30m",
  red: "\x1B[31m",
  green: "\x1B[32m",
  yellow: "\x1B[33m",
  blue: "\x1B[34m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  white: "\x1B[37m",
  grey: "\x1B[90m",
  gray: "\x1B[90m",
  brightRed: "\x1B[91m",
  brightGreen: "\x1B[92m",
  brightYellow: "\x1B[93m",
  brightBlue: "\x1B[94m",
  brightMagenta: "\x1B[95m",
  brightCyan: "\x1B[96m",
  brightWhite: "\x1B[97m",
  "bg-black": "\x1B[40m",
  "bg-red": "\x1B[41m",
  "bg-green": "\x1B[42m",
  "bg-yellow": "\x1B[43m",
  "bg-blue": "\x1B[44m",
  "bg-magenta": "\x1B[45m",
  "bg-cyan": "\x1B[46m",
  "bg-white": "\x1B[47m",
  "bg-grey": "\x1B[100m",
  "bg-gray": "\x1B[100m",
  "bg-brightRed": "\x1B[101m",
  "bg-brightGreen": "\x1B[102m",
  "bg-brightYellow": "\x1B[103m",
  "bg-brightBlue": "\x1B[104m",
  "bg-brightMagenta": "\x1B[105m",
  "bg-brightCyan": "\x1B[106m",
  "bg-brightWhite": "\x1B[107m"
};
ansi$1.rgb = function(r, g, b) {
  return `\x1B[38;2;${r};${g};${b}m`;
};
ansi$1.bgRgb = function(r, g, b) {
  return `\x1B[48;2;${r};${g};${b}m`;
};
ansi$1.styles = function(styles2) {
  styles2 = arrayify$1(styles2);
  return styles2.map(function(effect) {
    const rgbMatches = effect.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    const bgRgbMatches = effect.match(/bg-rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (bgRgbMatches) {
      const [full, r, g, b] = bgRgbMatches;
      return ansi$1.bgRgb(r, g, b);
    } else if (rgbMatches) {
      const [full, r, g, b] = rgbMatches;
      return ansi$1.rgb(r, g, b);
    } else {
      return ansi$1.style[effect];
    }
  }).join("");
};
ansi$1.format = function(str, styleArray) {
  const re2 = /\[([\w\s-\(\),]+)\]{([^]*?)}/;
  let matches;
  str = String(str);
  if (!str) return "";
  while (matches = str.match(re2)) {
    const inlineStyles = matches[1].split(/\s+/);
    const inlineString = matches[2];
    str = str.replace(matches[0], ansi$1.format(inlineString, inlineStyles));
  }
  return styleArray && styleArray.length ? ansi$1.styles(styleArray) + str + ansi$1.style.reset : str;
};
ansi$1.cursor = {
  /**
   * Moves the cursor `lines` cells up. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  up: /* @__PURE__ */ __name(function(lines) {
    return csi$1 + (lines || 1) + "A";
  }, "up"),
  /**
   * Moves the cursor `lines` cells down. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  down: /* @__PURE__ */ __name(function(lines) {
    return csi$1 + (lines || 1) + "B";
  }, "down"),
  /**
   * Moves the cursor `lines` cells forward. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  forward: /* @__PURE__ */ __name(function(lines) {
    return csi$1 + (lines || 1) + "C";
  }, "forward"),
  /**
   * Moves the cursor `lines` cells back. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  back: /* @__PURE__ */ __name(function(lines) {
    return csi$1 + (lines || 1) + "D";
  }, "back"),
  /**
   * Moves cursor to beginning of the line n lines down.
   * @param [lines=1] {number}
   * @return {string}
   */
  nextLine: /* @__PURE__ */ __name(function(lines) {
    return csi$1 + (lines || 1) + "E";
  }, "nextLine"),
  /**
   * Moves cursor to beginning of the line n lines up.
   * @param [lines=1] {number}
   * @return {string}
   */
  previousLine: /* @__PURE__ */ __name(function(lines) {
    return csi$1 + (lines || 1) + "F";
  }, "previousLine"),
  /**
   * Moves the cursor to column n.
   * @param n {number} - column number
   * @return {string}
   */
  horizontalAbsolute: /* @__PURE__ */ __name(function(n) {
    return csi$1 + n + "G";
  }, "horizontalAbsolute"),
  /**
   * Moves the cursor to row n, column m. The values are 1-based, and default to 1 (top left corner) if omitted.
   * @param n {number} - row number
   * @param m {number} - column number
   * @return {string}
   */
  position: /* @__PURE__ */ __name(function(n, m) {
    return csi$1 + (n || 1) + ";" + (m || 1) + "H";
  }, "position"),
  /**
   * Hides the cursor
   */
  hide: csi$1 + "?25l",
  /**
   * Shows the cursor
   */
  show: csi$1 + "?25h"
};
ansi$1.erase = {
  /**
   * Clears part of the screen. If n is 0 (or missing), clear from cursor to end of screen. If n is 1, clear from cursor to beginning of the screen. If n is 2, clear entire screen.
   * @param n {number}
   * @return {string}
   */
  display: /* @__PURE__ */ __name(function(n) {
    return csi$1 + (n || 0) + "J";
  }, "display"),
  /**
   * Erases part of the line. If n is zero (or missing), clear from cursor to the end of the line. If n is one, clear from cursor to beginning of the line. If n is two, clear entire line. Cursor position does not change.
   * @param n {number}
   * @return {string}
   */
  inLine: /* @__PURE__ */ __name(function(n) {
    return csi$1 + (n || 0) + "K";
  }, "inLine")
};
const pkg$6 = {
  name: "hid",
  version: "0.1.0",
  description: "Human Interface Device (HID) driver"
};
async function cli$6(options) {
  const { args, terminal } = options;
  const usage = `
Usage: /dev/hid <command>

Commands:
  list                List available HID devices
  request             Request a new HID device connection
  connect <id>        Connect to a specific device
  disconnect <id>     Disconnect from a specific device
  info <id>           Show information about a connected device
  read <id>           Read from a device
  write <id> <data>   Write data to a device
  --help              Show this help message
`;
  if (!("hid" in navigator)) {
    terminal.writeln("WebHID API not available");
    return 1;
  }
  if (!args.length || args[0] === "--help") {
    terminal.writeln(usage);
    return 0;
  }
  try {
    switch (args[0]) {
      case "list":
        const devices = await navigator.hid.getDevices();
        const uniqueDevices = Array.from(new Map(devices.map((d) => [d.productId, d])).values());
        if (!uniqueDevices.length) {
          terminal.writeln("No HID devices connected");
          break;
        }
        terminal.writeln(`${ansi$1.style.bold}🎮 Connected HID Devices:${ansi$1.style.reset}`);
        uniqueDevices.forEach((device2) => {
          terminal.writeln(`
      📱 Device ID: ${ansi$1.style.cyan}${device2.productId}${ansi$1.style.reset}
      📝 Name: ${ansi$1.style.cyan}${device2.productName}${ansi$1.style.reset}
      🏢 Manufacturer: ${ansi$1.style.cyan}${device2.vendorId}${ansi$1.style.reset}
      🔌 Connected: ${ansi$1.style.cyan}${device2.opened ? "Yes" : "No"}${ansi$1.style.reset}`);
        });
        break;
      case "request":
        const device = await navigator.hid.requestDevice({
          filters: []
          // Accept all devices
        });
        terminal.writeln(`Device requested: ${device[0]?.productName || "No device selected"}`);
        break;
      case "connect":
        if (!args[1]) {
          terminal.writeln("Please provide a device ID");
          return 1;
        }
        const connectDevices = await navigator.hid.getDevices();
        const deviceToConnect = connectDevices.find((d) => d.productId === Number(args[1]));
        if (!deviceToConnect) {
          terminal.writeln(`Device with ID ${args[1]} not found`);
          return 1;
        }
        if (deviceToConnect.opened) {
          terminal.writeln("Device is already connected");
          return 0;
        }
        await deviceToConnect.open();
        terminal.writeln(`Connected to device: ${deviceToConnect.productName}`);
        break;
      case "disconnect":
        if (!args[1]) {
          terminal.writeln("Please provide a device ID");
          return 1;
        }
        const disconnectDevices = await navigator.hid.getDevices();
        const deviceToDisconnect = disconnectDevices.find((d) => d.productId === Number(args[1]));
        if (!deviceToDisconnect) {
          terminal.writeln(`Device with ID ${args[1]} not found`);
          return 1;
        }
        if (!deviceToDisconnect.opened) {
          terminal.writeln("Device is already disconnected");
          return 0;
        }
        await deviceToDisconnect.close();
        terminal.writeln(`Disconnected from device: ${deviceToDisconnect.productName}`);
        break;
      case "info":
        if (!args[1]) {
          terminal.writeln("Please provide a device ID");
          return 1;
        }
        const devices2 = await navigator.hid.getDevices();
        const targetDevice = devices2.find((d) => d.productId === Number(args[1]));
        if (!targetDevice) {
          terminal.writeln(`Device with ID ${args[1]} not found`);
          return 1;
        }
        terminal.writeln(`${ansi$1.style.bold}Device Information:${ansi$1.style.reset}
      Product ID: ${targetDevice.productId}
      Vendor ID: ${targetDevice.vendorId}
      Product Name: ${targetDevice.productName}
      Connected: ${targetDevice.opened}`);
        break;
      default:
        terminal.writeln(`Unknown command: ${args[0]}`);
        terminal.writeln(usage);
        return 1;
    }
    return 0;
  } catch (error) {
    terminal.writeln(`Error: ${error instanceof Error ? error.message : String(error)}`);
    return 1;
  }
}
__name(cli$6, "cli$6");
async function getDrivers$6(kernel) {
  const deviceMap = /* @__PURE__ */ new Map();
  const drivers = [{
    name: "hid",
    init: /* @__PURE__ */ __name(() => ({
      major: 13,
      minor: 64,
      data: {
        kernelId: kernel.id,
        version: pkg$6.version
      }
    }), "init"),
    read: /* @__PURE__ */ __name((_, buffer2) => {
      const view2 = new Uint32Array(buffer2.buffer, 0, 1);
      view2[0] = deviceMap.size;
      return 4;
    }, "read"),
    write: /* @__PURE__ */ __name(() => 0, "write")
  }];
  if ("hid" in navigator) {
    try {
      const devices = await navigator.hid.getDevices();
      devices.forEach((device) => deviceMap.set(device.productId, device));
    } catch (error) {
      console.warn("HID error:", error);
    }
    navigator.hid.addEventListener("connect", (event) => {
      deviceMap.set(event.device.productId, event.device);
    });
    navigator.hid.addEventListener("disconnect", (event) => {
      deviceMap.delete(event.device.productId);
    });
    for (const device of deviceMap.values()) {
      drivers.push({
        name: `hid-${device.productName}-${device.vendorId}-${device.productId}`,
        init: /* @__PURE__ */ __name(() => ({
          major: 13,
          minor: 64 + drivers.length,
          data: {
            kernelId: kernel.id,
            version: pkg$6.version
          }
        }), "init"),
        read: /* @__PURE__ */ __name(() => 0, "read"),
        write: /* @__PURE__ */ __name(() => 0, "write")
      });
    }
  }
  return drivers;
}
__name(getDrivers$6, "getDrivers$6");
const HIDDevice = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cli: cli$6,
  getDrivers: getDrivers$6,
  pkg: pkg$6
}, Symbol.toStringTag, { value: "Module" }));
const pkg$5 = {
  name: "midi",
  version: "0.1.0",
  description: "MIDI device driver"
};
async function getMIDIAccess() {
  if (!navigator.requestMIDIAccess) {
    throw new Error("Web MIDI API not available");
  }
  return navigator.requestMIDIAccess();
}
__name(getMIDIAccess, "getMIDIAccess");
async function cli$5(options) {
  const { args, terminal } = options;
  const usage = `
Usage: /dev/midi <command>

Commands:
  list                List all MIDI devices
  request             Request permission to access MIDI devices
  connect <id>        Connect to a specific MIDI device by ID
  disconnect <id>     Disconnect from a specific MIDI device
  --help             Show this help message
`;
  if (!navigator.requestMIDIAccess) {
    terminal.writeln("Web MIDI API not available");
    return 1;
  }
  if (!args.length || args[0] === "--help") {
    terminal.writeln(usage);
    return 0;
  }
  try {
    switch (args[0]) {
      case "list": {
        const midiAccess = await getMIDIAccess();
        const inputs = Array.from(midiAccess.inputs.values());
        const outputs = Array.from(midiAccess.outputs.values());
        if (!inputs.length && !outputs.length) {
          terminal.writeln("No MIDI devices found");
          return 0;
        }
        if (inputs.length) {
          terminal.writeln("\nMIDI Inputs:");
          for (const input of inputs) {
            terminal.writeln(`  ${input.name || "Unknown Device"} (${input.id})`);
            terminal.writeln(`    Manufacturer: ${input.manufacturer || "Unknown"}`);
            terminal.writeln(`    State: ${input.state}
`);
          }
        }
        if (outputs.length) {
          terminal.writeln("\nMIDI Outputs:");
          for (const output2 of outputs) {
            terminal.writeln(`  ${output2.name || "Unknown Device"} (${output2.id})`);
            terminal.writeln(`    Manufacturer: ${output2.manufacturer || "Unknown"}`);
            terminal.writeln(`    State: ${output2.state}
`);
          }
        }
        break;
      }
      case "request": {
        try {
          const midiAccess = await getMIDIAccess();
          terminal.writeln("MIDI access granted");
          terminal.writeln(`Sysex: ${midiAccess.sysexEnabled ? "Enabled" : "Disabled"}`);
        } catch (err2) {
          terminal.writeln("Failed to get MIDI access");
          throw err2;
        }
        break;
      }
      case "connect": {
        if (!args[1]) {
          terminal.writeln("Please specify a device ID");
          return 1;
        }
        const midiAccess = await getMIDIAccess();
        const device = midiAccess.inputs.get(args[1]) || midiAccess.outputs.get(args[1]);
        if (!device) {
          terminal.writeln(`No device found with ID ${args[1]}`);
          return 1;
        }
        if (device.state === "connected") {
          terminal.writeln(`Device ${device.name} is already connected`);
        } else {
          device.open();
          terminal.writeln(`Connected to ${device.name}`);
        }
        break;
      }
      case "disconnect": {
        if (!args[1]) {
          terminal.writeln("Please specify a device ID");
          return 1;
        }
        const midiAccess = await getMIDIAccess();
        const device = midiAccess.inputs.get(args[1]) || midiAccess.outputs.get(args[1]);
        if (!device) {
          terminal.writeln(`No device found with ID ${args[1]}`);
          return 1;
        }
        if (device.state === "disconnected") {
          terminal.writeln(`Device ${device.name} is already disconnected`);
        } else {
          device.close();
          terminal.writeln(`Disconnected from ${device.name}`);
        }
        break;
      }
      default:
        terminal.writeln(`Unknown command: ${args[0]}`);
        terminal.writeln(usage);
        return 1;
    }
    return 0;
  } catch (error) {
    terminal.writeln(`Error: ${error instanceof Error ? error.message : String(error)}`);
    return 1;
  }
}
__name(cli$5, "cli$5");
async function getDrivers$5(kernel) {
  const drivers = [{
    name: "midi",
    init: /* @__PURE__ */ __name(() => ({
      major: 35,
      minor: 0,
      data: { kernelId: kernel.id }
    }), "init"),
    read: /* @__PURE__ */ __name(() => 0, "read"),
    write: /* @__PURE__ */ __name(() => 0, "write")
  }];
  return drivers;
}
__name(getDrivers$5, "getDrivers$5");
const MIDIDevice = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cli: cli$5,
  getDrivers: getDrivers$5,
  pkg: pkg$5
}, Symbol.toStringTag, { value: "Module" }));
const pkg$4 = {
  name: "presentation",
  version: "0.1.0",
  description: "Web Presentation API device driver"
};
let activeRequest = null;
let activeConnection = null;
async function cli$4(options) {
  const usage = `
Usage: /dev/presentation <command>

Commands:
  list [url]            List available presentation displays (optional URL)
  start [url]           Start presenting the specified URL
  --help                Show this help message
`;
  if (!options.args.length || options.args[0] === "--help") {
    options.terminal.writeln(usage);
    return 0;
  }
  switch (options.args[0]) {
    case "list":
      await listDisplays(options.kernel, options.args[1] || globalThis.location.href);
      break;
    case "start":
      await startPresentation(options.kernel, options.args[1] || globalThis.location.href);
      break;
    default:
      options.terminal.writeln(`Unknown command: ${options.args[0]}`);
      options.terminal.writeln(usage);
      return 1;
  }
  return 0;
}
__name(cli$4, "cli$4");
async function getDrivers$4() {
  const drivers = [];
  if ("presentation" in navigator) {
    drivers.push({
      name: "presentation",
      init: /* @__PURE__ */ __name(() => ({
        major: 10,
        minor: 156
      }), "init"),
      read: /* @__PURE__ */ __name(() => 0, "read"),
      write: /* @__PURE__ */ __name(() => 0, "write")
    });
  }
  return drivers;
}
__name(getDrivers$4, "getDrivers$4");
async function listDisplays(kernel, presentationUrl) {
  if (!("PresentationRequest" in globalThis)) throw new Error("PresentationRequest API not supported");
  try {
    const url = new URL(presentationUrl);
    const request = new globalThis.PresentationRequest([url.toString()]);
    const availability = await request.getAvailability();
    kernel.terminal.writeln(`Available displays: ${availability ? "Yes" : "No"}`);
    if (availability) {
      const connectionState = activeConnection ? "Connected" : "Not connected";
      kernel.terminal.writeln(`Connection state: ${connectionState}`);
    }
  } catch (error) {
    kernel.terminal.writeln(`Error checking displays: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
__name(listDisplays, "listDisplays");
async function startPresentation(kernel, presentationUrl) {
  if (!("PresentationRequest" in globalThis)) throw new Error("PresentationRequest API not supported");
  try {
    if (activeConnection) {
      activeConnection.close();
      activeConnection = null;
    }
    const url = new URL(presentationUrl);
    const request = new globalThis.PresentationRequest([url.toString()]);
    activeRequest = request;
    const available = await request.getAvailability();
    if (!available) throw new Error("No presentation displays available");
    const connection = await request.start();
    activeConnection = connection;
    kernel.terminal.writeln(`Presentation started: ${url}`);
    connection.addEventListener("close", () => {
      activeConnection = null;
      kernel.terminal.writeln("Presentation closed");
    });
    connection.addEventListener("terminate", () => {
      activeConnection = null;
      kernel.terminal.writeln("Presentation terminated");
    });
  } catch (error) {
    activeRequest = null;
    activeConnection = null;
    kernel.terminal.writeln(`Error starting presentation: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
__name(startPresentation, "startPresentation");
const PresentationDevice = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cli: cli$4,
  getDrivers: getDrivers$4,
  pkg: pkg$4
}, Symbol.toStringTag, { value: "Module" }));
function isObject$2(input) {
  return typeof input === "object" && input !== null;
}
__name(isObject$2, "isObject$2");
function isArrayLike$1(input) {
  return isObject$2(input) && typeof input.length === "number";
}
__name(isArrayLike$1, "isArrayLike$1");
function arrayify(input) {
  if (Array.isArray(input)) {
    return input;
  } else if (input === void 0) {
    return [];
  } else if (isArrayLike$1(input) || input instanceof Set) {
    return Array.from(input);
  } else {
    return [input];
  }
}
__name(arrayify, "arrayify");
const csi = "\x1B[";
const ansi = {};
ansi.style = {
  reset: "\x1B[0m",
  bold: "\x1B[1m",
  italic: "\x1B[3m",
  underline: "\x1B[4m",
  fontDefault: "\x1B[10m",
  font2: "\x1B[11m",
  font3: "\x1B[12m",
  font4: "\x1B[13m",
  font5: "\x1B[14m",
  font6: "\x1B[15m",
  imageNegative: "\x1B[7m",
  imagePositive: "\x1B[27m",
  black: "\x1B[30m",
  red: "\x1B[31m",
  green: "\x1B[32m",
  yellow: "\x1B[33m",
  blue: "\x1B[34m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  white: "\x1B[37m",
  grey: "\x1B[90m",
  gray: "\x1B[90m",
  brightRed: "\x1B[91m",
  brightGreen: "\x1B[92m",
  brightYellow: "\x1B[93m",
  brightBlue: "\x1B[94m",
  brightMagenta: "\x1B[95m",
  brightCyan: "\x1B[96m",
  brightWhite: "\x1B[97m",
  "bg-black": "\x1B[40m",
  "bg-red": "\x1B[41m",
  "bg-green": "\x1B[42m",
  "bg-yellow": "\x1B[43m",
  "bg-blue": "\x1B[44m",
  "bg-magenta": "\x1B[45m",
  "bg-cyan": "\x1B[46m",
  "bg-white": "\x1B[47m",
  "bg-grey": "\x1B[100m",
  "bg-gray": "\x1B[100m",
  "bg-brightRed": "\x1B[101m",
  "bg-brightGreen": "\x1B[102m",
  "bg-brightYellow": "\x1B[103m",
  "bg-brightBlue": "\x1B[104m",
  "bg-brightMagenta": "\x1B[105m",
  "bg-brightCyan": "\x1B[106m",
  "bg-brightWhite": "\x1B[107m"
};
ansi.rgb = function(r, g, b) {
  return `\x1B[38;2;${r};${g};${b}m`;
};
ansi.bgRgb = function(r, g, b) {
  return `\x1B[48;2;${r};${g};${b}m`;
};
ansi.styles = function(styles2) {
  styles2 = arrayify(styles2);
  return styles2.map(function(effect) {
    const rgbMatches = effect.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    const bgRgbMatches = effect.match(/bg-rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (bgRgbMatches) {
      const [full, r, g, b] = bgRgbMatches;
      return ansi.bgRgb(r, g, b);
    } else if (rgbMatches) {
      const [full, r, g, b] = rgbMatches;
      return ansi.rgb(r, g, b);
    } else {
      return ansi.style[effect];
    }
  }).join("");
};
ansi.format = function(str, styleArray) {
  const re2 = /\[([\w\s-\(\),]+)\]{([^]*?)}/;
  let matches;
  str = String(str);
  if (!str) return "";
  while (matches = str.match(re2)) {
    const inlineStyles = matches[1].split(/\s+/);
    const inlineString = matches[2];
    str = str.replace(matches[0], ansi.format(inlineString, inlineStyles));
  }
  return styleArray && styleArray.length ? ansi.styles(styleArray) + str + ansi.style.reset : str;
};
ansi.cursor = {
  /**
   * Moves the cursor `lines` cells up. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  up: /* @__PURE__ */ __name(function(lines) {
    return csi + (lines || 1) + "A";
  }, "up"),
  /**
   * Moves the cursor `lines` cells down. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  down: /* @__PURE__ */ __name(function(lines) {
    return csi + (lines || 1) + "B";
  }, "down"),
  /**
   * Moves the cursor `lines` cells forward. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  forward: /* @__PURE__ */ __name(function(lines) {
    return csi + (lines || 1) + "C";
  }, "forward"),
  /**
   * Moves the cursor `lines` cells back. If the cursor is already at the edge of the screen, this has no effect
   * @param [lines=1] {number}
   * @return {string}
   */
  back: /* @__PURE__ */ __name(function(lines) {
    return csi + (lines || 1) + "D";
  }, "back"),
  /**
   * Moves cursor to beginning of the line n lines down.
   * @param [lines=1] {number}
   * @return {string}
   */
  nextLine: /* @__PURE__ */ __name(function(lines) {
    return csi + (lines || 1) + "E";
  }, "nextLine"),
  /**
   * Moves cursor to beginning of the line n lines up.
   * @param [lines=1] {number}
   * @return {string}
   */
  previousLine: /* @__PURE__ */ __name(function(lines) {
    return csi + (lines || 1) + "F";
  }, "previousLine"),
  /**
   * Moves the cursor to column n.
   * @param n {number} - column number
   * @return {string}
   */
  horizontalAbsolute: /* @__PURE__ */ __name(function(n) {
    return csi + n + "G";
  }, "horizontalAbsolute"),
  /**
   * Moves the cursor to row n, column m. The values are 1-based, and default to 1 (top left corner) if omitted.
   * @param n {number} - row number
   * @param m {number} - column number
   * @return {string}
   */
  position: /* @__PURE__ */ __name(function(n, m) {
    return csi + (n || 1) + ";" + (m || 1) + "H";
  }, "position"),
  /**
   * Hides the cursor
   */
  hide: csi + "?25l",
  /**
   * Shows the cursor
   */
  show: csi + "?25h"
};
ansi.erase = {
  /**
   * Clears part of the screen. If n is 0 (or missing), clear from cursor to end of screen. If n is 1, clear from cursor to beginning of the screen. If n is 2, clear entire screen.
   * @param n {number}
   * @return {string}
   */
  display: /* @__PURE__ */ __name(function(n) {
    return csi + (n || 0) + "J";
  }, "display"),
  /**
   * Erases part of the line. If n is zero (or missing), clear from cursor to the end of the line. If n is one, clear from cursor to beginning of the line. If n is two, clear entire line. Cursor position does not change.
   * @param n {number}
   * @return {string}
   */
  inLine: /* @__PURE__ */ __name(function(n) {
    return csi + (n || 0) + "K";
  }, "inLine")
};
const pkg$3 = {
  name: "sensors",
  version: "0.1.0",
  description: "Device sensors driver"
};
async function cli$3(options) {
  const { args, terminal } = options;
  const usage = `
Usage: /dev/sensors <command>

Commands:
  list               List available sensors
  read <sensor>      Read current sensor values
  watch <sensor>     Start watching sensor changes
  unwatch <id>       Stop watching sensor changes
  --help             Show this help message
`;
  if (!args.length || args[0] === "--help") {
    terminal.writeln(usage);
    return 0;
  }
  try {
    switch (args[0]) {
      case "list":
        const sensors = [];
        if ("Accelerometer" in globalThis) sensors.push("accelerometer");
        if ("Gyroscope" in globalThis) sensors.push("gyroscope");
        if ("LinearAccelerationSensor" in globalThis) sensors.push("linear");
        if ("AbsoluteOrientationSensor" in globalThis) sensors.push("orientation");
        terminal.writeln(`${ansi.style.bold}📱 Available Sensors:${ansi.style.reset}`);
        sensors.forEach((sensor2) => terminal.writeln(`  - ${sensor2}`));
        break;
      case "read":
        if (!args[1]) {
          terminal.writeln("Please specify a sensor");
          return 1;
        }
        const sensorToRead = args[1];
        if (!isSensorType(sensorToRead)) {
          terminal.writeln(`Invalid sensor type: ${args[1]}`);
          terminal.writeln("Available sensors: accelerometer, gyroscope, linear, orientation");
          return 1;
        }
        await readSensor(sensorToRead, terminal);
        break;
      case "watch":
        if (!args[1]) {
          terminal.writeln("Please specify a sensor");
          return 1;
        }
        const sensorToWatch = args[1];
        if (!isSensorType(sensorToWatch)) {
          terminal.writeln(`Invalid sensor type: ${args[1]}`);
          terminal.writeln("Available sensors: accelerometer, gyroscope, linear, orientation");
          return 1;
        }
        const newWatchId = await watchSensor(sensorToWatch, terminal);
        terminal.writeln(`Started watching ${args[1]} (ID: ${newWatchId})`);
        break;
      case "unwatch":
        if (!args[1]) {
          terminal.writeln("Please provide a watch ID");
          return 1;
        }
        const watchIdToRemove = Number(args[1]);
        const sensor = activeSensors.get(watchIdToRemove);
        if (sensor) {
          sensor.stop();
          activeSensors.delete(watchIdToRemove);
          terminal.writeln(`Stopped watching sensor (ID: ${watchIdToRemove})`);
        } else {
          terminal.writeln(`No sensor found with ID: ${watchIdToRemove}`);
          return 1;
        }
        break;
      default:
        terminal.writeln(`Unknown command: ${args[0]}`);
        terminal.writeln(usage);
        return 1;
    }
    return 0;
  } catch (error) {
    terminal.writeln(`Error: ${error instanceof Error ? error.message : String(error)}`);
    return 1;
  }
}
__name(cli$3, "cli$3");
async function getDrivers$3(kernel) {
  const drivers = [{
    name: "sensors",
    init: /* @__PURE__ */ __name(() => ({ major: 0, minor: 0, data: { kernelId: kernel.id, version: pkg$3.version } }), "init"),
    read: /* @__PURE__ */ __name(() => 0, "read"),
    write: /* @__PURE__ */ __name(() => 0, "write")
  }];
  return drivers;
}
__name(getDrivers$3, "getDrivers$3");
const activeSensors = /* @__PURE__ */ new Map();
let watchCounter = 0;
async function readSensor(sensorType, terminal) {
  try {
    let sensor;
    switch (sensorType) {
      case "accelerometer":
        sensor = new Accelerometer({ frequency: 60 });
        break;
      case "gyroscope":
        sensor = new Gyroscope({ frequency: 60 });
        break;
      case "linear":
        sensor = new LinearAccelerationSensor({ frequency: 60 });
        break;
      case "orientation":
        sensor = new AbsoluteOrientationSensor({ frequency: 60 });
        break;
      default:
        terminal.writeln(`Invalid sensor type: ${sensorType}`);
        return;
    }
    let permissions = [];
    switch (sensorType) {
      case "orientation":
        permissions = [
          navigator.permissions.query({ name: "accelerometer" }),
          navigator.permissions.query({ name: "magnetometer" }),
          navigator.permissions.query({ name: "gyroscope" })
        ];
        break;
      case "accelerometer":
      case "linear":
        permissions = [navigator.permissions.query({ name: "accelerometer" })];
        break;
      case "gyroscope":
        permissions = [navigator.permissions.query({ name: "gyroscope" })];
        break;
    }
    const results = await Promise.all(permissions);
    if (!results.every((result) => result.state === "granted")) {
      terminal.writeln("Required sensor permissions not granted");
      return;
    }
    return new Promise((resolve2) => {
      const handleReading = /* @__PURE__ */ __name(function() {
        displaySensorData(sensor, sensorType, terminal);
        sensor.stop();
        sensor.removeEventListener("reading", handleReading);
        resolve2();
      }, "handleReading");
      const handleError = /* @__PURE__ */ __name((error) => {
        terminal.writeln(`Sensor error: ${error.message}`);
        sensor.stop();
        sensor.removeEventListener("reading", handleReading);
        sensor.removeEventListener("error", handleError);
        resolve2();
      }, "handleError");
      sensor.addEventListener("reading", handleReading);
      sensor.addEventListener("error", handleError);
      sensor.start();
      terminal.writeln("Reading sensor...");
      setTimeout(() => {
        sensor.stop();
        sensor.removeEventListener("reading", handleReading);
        sensor.removeEventListener("error", handleError);
        terminal.writeln("Sensor reading timed out");
        resolve2();
      }, 5e3);
    });
  } catch (error) {
    terminal.writeln(`Error reading sensor: ${error instanceof Error ? error.message : String(error)}`);
  }
}
__name(readSensor, "readSensor");
async function watchSensor(sensorType, terminal) {
  try {
    const sensor = await createSensor(sensorType);
    if (!sensor) {
      terminal.writeln(`Sensor ${sensorType} not available`);
      return -1;
    }
    const watchId = ++watchCounter;
    activeSensors.set(watchId, sensor);
    const handleReading = /* @__PURE__ */ __name(function(_) {
      displaySensorData(sensor, sensorType, terminal);
    }, "handleReading");
    sensor.addEventListener("reading", handleReading);
    sensor.start();
    return watchId;
  } catch (error) {
    terminal.writeln(`Error watching sensor: ${error instanceof Error ? error.message : String(error)}`);
    return -1;
  }
}
__name(watchSensor, "watchSensor");
async function requestSensorPermissions(sensorType) {
  try {
    let permissions = [];
    switch (sensorType) {
      case "orientation":
        permissions = [
          navigator.permissions.query({ name: "accelerometer" }),
          navigator.permissions.query({ name: "magnetometer" }),
          navigator.permissions.query({ name: "gyroscope" })
        ];
        break;
      case "accelerometer":
        permissions = [navigator.permissions.query({ name: "accelerometer" })];
        break;
      case "gyroscope":
        permissions = [navigator.permissions.query({ name: "gyroscope" })];
        break;
      case "linear":
        permissions = [navigator.permissions.query({ name: "accelerometer" })];
        break;
    }
    const results = await Promise.all(permissions);
    return results.every((result) => result.state === "granted");
  } catch (error) {
    console.error("Error requesting permissions:", error);
    return false;
  }
}
__name(requestSensorPermissions, "requestSensorPermissions");
async function createSensor(sensorType) {
  const hasPermission = await requestSensorPermissions(sensorType);
  if (!hasPermission) {
    console.log(`No permissions granted for ${sensorType}`);
    return null;
  }
  let sensor;
  switch (sensorType) {
    case "accelerometer":
      sensor = new Accelerometer({ frequency: 60 });
      console.log("Created accelerometer:", sensor);
      return sensor;
    case "gyroscope":
      sensor = new Gyroscope({ frequency: 60 });
      console.log("Created gyroscope:", sensor);
      return sensor;
    case "linear":
      sensor = new LinearAccelerationSensor({ frequency: 60 });
      console.log("Created linear sensor:", sensor);
      return sensor;
    case "orientation":
      sensor = new AbsoluteOrientationSensor({ frequency: 60 });
      console.log("Created orientation sensor:", sensor);
      return sensor;
    default:
      return null;
  }
}
__name(createSensor, "createSensor");
function displaySensorData(sensor, sensorType, terminal) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  switch (sensorType) {
    case "accelerometer":
    case "linear":
      terminal.writeln(`${ansi.style.bold}📊 ${sensorType.charAt(0).toUpperCase() + sensorType.slice(1)} Reading:${ansi.style.reset}
        🕒 Time: ${ansi.style.cyan}${timestamp}${ansi.style.reset}
        X: ${ansi.style.cyan}${sensor.x.toFixed(2)}${ansi.style.reset} m/s²
        Y: ${ansi.style.cyan}${sensor.y.toFixed(2)}${ansi.style.reset} m/s²
        Z: ${ansi.style.cyan}${sensor.z.toFixed(2)}${ansi.style.reset} m/s²`);
      break;
    case "gyroscope":
      terminal.writeln(`${ansi.style.bold}📊 Gyroscope Reading:${ansi.style.reset}
        🕒 Time: ${ansi.style.cyan}${timestamp}${ansi.style.reset}
        X: ${ansi.style.cyan}${sensor.x.toFixed(2)}${ansi.style.reset} rad/s
        Y: ${ansi.style.cyan}${sensor.y.toFixed(2)}${ansi.style.reset} rad/s
        Z: ${ansi.style.cyan}${sensor.z.toFixed(2)}${ansi.style.reset} rad/s`);
      break;
    case "orientation":
      terminal.writeln(`${ansi.style.bold}📊 Orientation Reading:${ansi.style.reset}
        🕒 Time: ${ansi.style.cyan}${timestamp}${ansi.style.reset}
        Quaternion:
        X: ${ansi.style.cyan}${sensor.quaternion[0].toFixed(3)}${ansi.style.reset}
        Y: ${ansi.style.cyan}${sensor.quaternion[1].toFixed(3)}${ansi.style.reset}
        Z: ${ansi.style.cyan}${sensor.quaternion[2].toFixed(3)}${ansi.style.reset}
        W: ${ansi.style.cyan}${sensor.quaternion[3].toFixed(3)}${ansi.style.reset}`);
      break;
  }
}
__name(displaySensorData, "displaySensorData");
function isSensorType(value) {
  return ["accelerometer", "gyroscope", "linear", "orientation"].includes(value);
}
__name(isSensorType, "isSensorType");
const SensorsDevice = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cli: cli$3,
  getDrivers: getDrivers$3,
  pkg: pkg$3
}, Symbol.toStringTag, { value: "Module" }));
const availablePorts = /* @__PURE__ */ new Set();
const pkg$2 = {
  name: "serial",
  version: "0.1.0",
  description: "Web Serial device driver",
  help: `
  Note: This is experimental technology

  Please check the compatibility table at:
  https://developer.mozilla.org/en-US/docs/Web/API/Navigator/serial#browser_compatibility

  Usage:
    serial devices                       List paired serial devices
    serial request <options>             Request serial device (blank for user choice)

  Options:
    --help                               Print this help message
    --product                            Product ID of the serial device
    --vendor                             Vendor ID of the serial device
    --version                            Print the version information
  `
};
async function cli$2(options) {
  const { args, terminal } = options;
  if (typeof navigator === "undefined" || !navigator.serial) {
    terminal.writeln("Error: Client does not support Web Serial");
    return 1;
  }
  switch (args[0]) {
    case "devices": {
      const devices = await navigator.serial.getPorts();
      const data = await Promise.all(
        devices.map(async (device, index) => {
          const { usbProductId, usbVendorId } = await device.getInfo();
          return { index, usbProductId, usbVendorId };
        })
      );
      terminal.writeln(JSON.stringify(data, null, 2));
      return 0;
    }
    case "request": {
      const vendorIndex = args.indexOf("--vendor");
      const productIndex = args.indexOf("--product");
      const filter = {};
      if (vendorIndex !== -1 && args[vendorIndex + 1]) {
        filter.usbVendorId = parseInt(args[vendorIndex + 1] || "");
      }
      if (productIndex !== -1 && args[productIndex + 1]) {
        filter.usbProductId = parseInt(args[productIndex + 1] || "");
      }
      try {
        const device = await navigator.serial.requestPort({
          filters: Object.keys(filter).length ? [filter] : []
        });
        terminal.writeln(`Device connected: ${JSON.stringify(await device.getInfo())}`);
        return 0;
      } catch (err2) {
        terminal.writeln(`Error: Failed to request device: ${err2}`);
        return 1;
      }
    }
    default:
      terminal.writeln(pkg$2.help);
      return 0;
  }
}
__name(cli$2, "cli$2");
async function createDriver(name) {
  return {
    name,
    init: /* @__PURE__ */ __name(() => {
      return {
        major: 4,
        minor: 64
      };
    }, "init"),
    read: /* @__PURE__ */ __name((_, buffer2, offset, end) => {
      navigator.serial.getPorts().then((ports) => {
        const port = ports[offset];
        if (!port) return;
        port.readable?.getReader().read().then(({ value, done }) => {
          if (done || !value) return;
          const view2 = new Uint8Array(buffer2.buffer);
          const bytesToCopy = Math.min(end, value.length);
          view2.set(new Uint8Array(value.buffer, 0, bytesToCopy), offset);
        });
      });
      return end;
    }, "read"),
    write: /* @__PURE__ */ __name(() => {
      return 0;
    }, "write")
  };
}
__name(createDriver, "createDriver");
async function getDrivers$2(kernel) {
  if (typeof navigator === "undefined" || !navigator.serial) return [];
  navigator.serial.addEventListener("connect", async (event) => {
    kernel.events.emit("device:connect", event.target);
    if (event.target && !availablePorts.has(event.target)) {
      availablePorts.add(event.target);
    }
    console.log({ availablePorts });
  });
  const drivers = [await createDriver("serial")];
  const ports = await navigator.serial.getPorts();
  for (let i = 0; i < ports.length; i++) drivers.push(await createDriver(`ttyS${i}`));
  return drivers;
}
__name(getDrivers$2, "getDrivers$2");
const SerialDevice = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cli: cli$2,
  getDrivers: getDrivers$2,
  pkg: pkg$2
}, Symbol.toStringTag, { value: "Module" }));
const pkg$1 = {
  name: "usb",
  version: "0.1.0",
  description: "USB device driver"
};
async function cli$1(options) {
  const { args, terminal } = options;
  const usage = `
Usage: /dev/usb <command>

Commands:
  list                List all connected USB devices
  request             Request permission to access a USB device
  connect <id>        Connect to a specific USB device by vendor/product ID (e.g. 1234:5678)
  disconnect <id>     Disconnect from a specific USB device
  --help              Show this help message
`;
  if (!navigator.usb) {
    terminal.writeln("WebUSB API not available");
    return 1;
  }
  if (!args.length || args[0] === "--help") {
    terminal.writeln(usage);
    return 0;
  }
  try {
    switch (args[0]) {
      case "list": {
        const devices = await navigator.usb.getDevices();
        if (!devices.length) {
          terminal.writeln("No USB devices found");
          return 0;
        }
        terminal.writeln("Connected USB devices:");
        for (const device of devices) {
          terminal.writeln(`  ${device.productName || "Unknown Device"} (${device.vendorId.toString(16)}:${device.productId.toString(16)})`);
          terminal.writeln(`    Manufacturer: ${device.manufacturerName || "Unknown"}`);
          terminal.writeln(`    Serial: ${device.serialNumber || "Unknown"}`);
          terminal.writeln(`    Status: ${device.opened ? "Connected" : "Disconnected"}
`);
        }
        break;
      }
      case "request": {
        try {
          const device = await navigator.usb.requestDevice({ filters: [] });
          terminal.writeln(`Requested access to: ${device.productName || "Unknown Device"}`);
        } catch (err2) {
          if (err2 instanceof Error && err2.name === "NotFoundError") {
            terminal.writeln("No device was selected");
          } else {
            throw err2;
          }
        }
        break;
      }
      case "connect": {
        if (!args[1]) {
          terminal.writeln("Please specify a device ID (e.g. usb connect 1234:5678)");
          return 1;
        }
        const [vendorId, productId] = args[1].split(":").map((x) => parseInt(x, 16));
        const devices = await navigator.usb.getDevices();
        const device = devices.find((d) => d.vendorId === vendorId && d.productId === productId);
        if (!device) {
          terminal.writeln(`No device found with ID ${args[1]}`);
          return 1;
        }
        await device.open();
        terminal.writeln(`Connected to ${device.productName || "Unknown Device"}`);
        break;
      }
      case "disconnect": {
        if (!args[1]) {
          terminal.writeln("Please specify a device ID (e.g. usb disconnect 1234:5678)");
          return 1;
        }
        const [vendorId, productId] = args[1].split(":").map((x) => parseInt(x, 16));
        const devices = await navigator.usb.getDevices();
        const device = devices.find((d) => d.vendorId === vendorId && d.productId === productId);
        if (!device) {
          terminal.writeln(`No device found with ID ${args[1]}`);
          return 1;
        }
        await device.close();
        terminal.writeln(`Disconnected from ${device.productName || "Unknown Device"}`);
        break;
      }
      default:
        terminal.writeln(`Unknown command: ${args[0]}`);
        terminal.writeln(usage);
        return 1;
    }
    return 0;
  } catch (error) {
    terminal.writeln(`Error: ${error instanceof Error ? error.message : String(error)}`);
    return 1;
  }
}
__name(cli$1, "cli$1");
async function getDrivers$1(kernel) {
  const drivers = [
    {
      name: "usb",
      init: /* @__PURE__ */ __name(() => ({
        major: 8,
        minor: 0,
        data: { kernelId: kernel.id }
      }), "init"),
      read: /* @__PURE__ */ __name(() => 0, "read"),
      write: /* @__PURE__ */ __name(() => 0, "write")
    }
  ];
  if (navigator.usb) {
    const devices = await navigator.usb.getDevices();
    for (const device of devices) {
      drivers.push({
        name: `usb-${device.productName}-${device.vendorId}-${device.productId}`,
        init: /* @__PURE__ */ __name(() => ({
          major: 8,
          minor: device.vendorId + device.productId,
          data: { device, kernelId: kernel.id }
        }), "init"),
        read: /* @__PURE__ */ __name(() => 0, "read"),
        write: /* @__PURE__ */ __name(() => 0, "write")
      });
    }
  }
  return drivers;
}
__name(getDrivers$1, "getDrivers$1");
const USBDevice = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cli: cli$1,
  getDrivers: getDrivers$1,
  pkg: pkg$1
}, Symbol.toStringTag, { value: "Module" }));
const pkg = {
  name: "webgl",
  version: "0.1.0",
  description: "WebGL device driver"
};
async function cli(options) {
  const usage = `
Usage: /dev/webgl <command>

Commands:
  info      Show WebGL information
  test      Run a WebGL test that renders a rotating square
  --help    Show this help message
`;
  if (!options.args.length || options.args[0] === "--help") {
    options.terminal.writeln(usage);
    return 0;
  }
  try {
    switch (options.args[0]) {
      case "test":
        await test(options.kernel);
        break;
      case "info":
        await showInfo(options.kernel);
        break;
      default:
        options.terminal.writeln(`Unknown command: ${options.args[0]}`);
        options.terminal.writeln(usage);
        return 1;
    }
  } catch (error) {
    options.terminal.writeln(`Error: ${error instanceof Error ? error.message : String(error)}`);
    return 1;
  }
  return 0;
}
__name(cli, "cli");
async function getDrivers(kernel) {
  const drivers = [];
  try {
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    if (context instanceof WebGLRenderingContext) {
      drivers.push({
        name: "webgl",
        init: /* @__PURE__ */ __name(() => ({
          major: 1,
          minor: 0,
          data: {
            context,
            info: {
              vendor: context.getParameter(context.VENDOR),
              renderer: context.getParameter(context.RENDERER),
              version: context.getParameter(context.VERSION),
              extensions: context.getSupportedExtensions() || []
            }
          }
        }), "init"),
        read: /* @__PURE__ */ __name(() => 0, "read"),
        write: /* @__PURE__ */ __name(() => 0, "write")
      });
    }
  } catch (error) {
    kernel.log.error(`Failed to initialize WebGL device: ${error}`);
  }
  return drivers;
}
__name(getDrivers, "getDrivers");
async function showInfo(kernel) {
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
  if (!context) {
    throw new Error("WebGL not available");
  }
  const info2 = {
    vendor: context.getParameter(context.VENDOR),
    renderer: context.getParameter(context.RENDERER),
    version: context.getParameter(context.VERSION),
    shadingLanguage: context.getParameter(context.SHADING_LANGUAGE_VERSION),
    extensions: context.getSupportedExtensions() || []
  };
  kernel.terminal?.writeln("\nWebGL Information:");
  kernel.terminal?.writeln(`Vendor: ${info2.vendor}`);
  kernel.terminal?.writeln(`Renderer: ${info2.renderer}`);
  kernel.terminal?.writeln(`Version: ${info2.version}`);
  kernel.terminal?.writeln(`Shading Language: ${info2.shadingLanguage}`);
  kernel.terminal?.writeln("\nSupported Extensions:");
  info2.extensions.forEach((ext) => kernel.terminal?.writeln(`  ${ext}`));
}
__name(showInfo, "showInfo");
async function test(kernel) {
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
  if (!context) {
    throw new Error("WebGL not available");
  }
  if (kernel.terminal?.element) kernel.terminal.element.style.display = "none";
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  canvas.style.position = "absolute";
  canvas.style.top = "0";
  canvas.style.left = "0";
  canvas.style.zIndex = "1000";
  document.body.appendChild(canvas);
  await runWebGLTest(context);
  setTimeout(() => {
    if (kernel.terminal?.element) kernel.terminal.element.style.display = "";
    canvas.remove();
    kernel.terminal?.focus();
  }, 3e3);
}
__name(test, "test");
async function runWebGLTest(context) {
  const canvas = context.canvas;
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  canvas.style.position = "absolute";
  canvas.style.top = "0";
  canvas.style.left = "0";
  document.body.appendChild(canvas);
  setTimeout(() => document.body.removeChild(canvas), 3e3);
  context.viewport(0, 0, canvas.width, canvas.height);
  context.clearColor(0, 1, 0, 1);
  context.clear(context.COLOR_BUFFER_BIT);
  const vertices = new Float32Array([10, 10, 100, 10, 10, 100, 100, 100]);
  const vertexBuffer = context.createBuffer();
  context.bindBuffer(context.ARRAY_BUFFER, vertexBuffer);
  context.bufferData(context.ARRAY_BUFFER, vertices, context.STATIC_DRAW);
  const vertexShaderSource = `
    attribute vec2 a_position;
    uniform float u_rotation;
    void main() {
      float s = sin(u_rotation);
      float c = cos(u_rotation);
      mat2 rotationMatrix = mat2(c, -s, s, c);
      vec2 rotatedPosition = rotationMatrix * (a_position - vec2(55.0, 55.0)) + vec2(55.0, 55.0);
      gl_Position = vec4(rotatedPosition / vec2(55.0, 55.0) - vec2(1.0, 1.0), 0, 1);
    }
  `;
  const fragmentShaderSource = `
    precision mediump float;
    void main() {
      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    }
  `;
  const vertexShader = context.createShader(context.VERTEX_SHADER);
  context.shaderSource(vertexShader, vertexShaderSource);
  context.compileShader(vertexShader);
  const fragmentShader = context.createShader(context.FRAGMENT_SHADER);
  context.shaderSource(fragmentShader, fragmentShaderSource);
  context.compileShader(fragmentShader);
  const program = context.createProgram();
  context.attachShader(program, vertexShader);
  context.attachShader(program, fragmentShader);
  context.linkProgram(program);
  context.useProgram(program);
  const positionAttributeLocation = context.getAttribLocation(program, "a_position");
  const rotationUniformLocation = context.getUniformLocation(program, "u_rotation");
  context.enableVertexAttribArray(positionAttributeLocation);
  context.vertexAttribPointer(positionAttributeLocation, 2, context.FLOAT, false, 0, 0);
  let rotation = 0;
  const animate = /* @__PURE__ */ __name(() => {
    rotation += 0.05;
    context.uniform1f(rotationUniformLocation, rotation);
    context.clear(context.COLOR_BUFFER_BIT);
    context.drawArrays(context.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(animate);
  }, "animate");
  animate();
}
__name(runWebGLTest, "runWebGLTest");
const WebGLDevice = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cli,
  getDrivers,
  pkg
}, Symbol.toStringTag, { value: "Module" }));
const DefaultDevices = {
  audio: AudioDevice,
  battery: BatteryDevice,
  bluetooth: BluetoothDevice,
  gamepad: GamepadDevice,
  geo: GeoDevice,
  gpu: GPUDevice,
  hid: HIDDevice,
  midi: MIDIDevice,
  presentation: PresentationDevice,
  sensors: SensorsDevice,
  serial: SerialDevice,
  usb: USBDevice,
  webgl: WebGLDevice
};
const DefaultDomOptions = { topbar: true };
const _Dom = class _Dom {
  constructor(_options = DefaultDomOptions) {
    __publicField(this, "_document", globalThis.document);
    __publicField(this, "_window", globalThis.window);
    __publicField(this, "_topbar", false);
    __publicField(this, "_topbarShow", false);
    const options = { ...DefaultDomOptions, ..._options };
    this._topbar = options.topbar ?? true;
  }
  get document() {
    return this._document;
  }
  get window() {
    return this._window;
  }
  async topbar(show) {
    if (!this._topbar) return;
    const { default: topbar } = await import("./topbar.min-dPgpASvz.js").then((n) => n.t);
    this._topbarShow = show ?? !this._topbarShow;
    if (this._topbarShow) topbar.show();
    else topbar.hide();
  }
};
__name(_Dom, "Dom");
let Dom = _Dom;
function errnoForDOMException(ex) {
  switch (ex.name) {
    case "TypeMismatchError":
      return "EPERM";
    case "IndexSizeError":
    case "HierarchyRequestError":
    case "InvalidCharacterError":
    case "InvalidStateError":
    case "SyntaxError":
    case "NamespaceError":
    case "ConstraintError":
    case "VersionError":
    case "URLMismatchError":
    case "InvalidNodeTypeError":
      return "EINVAL";
    case "WrongDocumentError":
      return "EXDEV";
    case "NoModificationAllowedError":
    case "InvalidModificationError":
    case "InvalidAccessError":
    case "SecurityError":
    case "NotAllowedError":
      return "EACCES";
    case "NotFoundError":
      return "ENOENT";
    case "NotSupportedError":
      return "ENOTSUP";
    case "InUseAttributeError":
      return "EBUSY";
    case "NetworkError":
      return "ENETDOWN";
    case "AbortError":
      return "EINTR";
    case "QuotaExceededError":
      return "ENOSPC";
    case "TimeoutError":
      return "ETIMEDOUT";
    case "ReadOnlyError":
      return "EROFS";
    case "DataCloneError":
    case "EncodingError":
    case "NotReadableError":
    case "DataError":
    case "TransactionInactiveError":
    case "OperationError":
    case "UnknownError":
    default:
      return "EIO";
  }
}
__name(errnoForDOMException, "errnoForDOMException");
function convertException(ex, path2) {
  if (ex instanceof Exception)
    return ex;
  const code2 = ex instanceof DOMException ? Errno[errnoForDOMException(ex)] : Errno.EIO;
  const error = new Exception(code2, ex.message);
  error.stack = ex.stack;
  Error.captureStackTrace?.(error, convertException);
  error.cause = ex.cause;
  return error;
}
__name(convertException, "convertException");
function wrap(request) {
  return new Promise((resolve2, reject) => {
    request.onsuccess = () => resolve2(request.result);
    request.onerror = (e2) => {
      e2.preventDefault();
      reject(convertException(request.error));
    };
  });
}
__name(wrap, "wrap");
const _IndexedDBTransaction = class _IndexedDBTransaction extends Transaction {
  /**
   * Run a asynchronous operation from a sync context. Not magic and subject to (race) conditions.
   * @internal
   */
  async(promise) {
    this.asyncDone = this.asyncDone.then(() => promise);
  }
  constructor(tx, store) {
    super(store);
    this.tx = tx;
    this.store = store;
    this.asyncDone = Promise.resolve();
    this._idb = tx.objectStore(store.name);
  }
  async keys() {
    return (await wrap(this._idb.getAllKeys())).map(Number);
  }
  async get(id) {
    const data = await wrap(this._idb.get(id));
    if (data)
      this.store.cache.set(id, new Uint8Array(data));
    return data;
  }
  getSync(id, offset, end) {
    if (!this.store.cache.has(id))
      return;
    const data = new Uint8Array(this.store.cache.get(id));
    end ?? (end = data.byteLength);
    return data.subarray(offset, end);
  }
  async set(id, data) {
    this.store.cache.set(id, new Uint8Array(data));
    await wrap(this._idb.put(data, id));
  }
  setSync(id, data) {
    this.async(this.set(id, data));
  }
  remove(id) {
    this.store.cache.delete(id);
    return wrap(this._idb.delete(id));
  }
  removeSync(id) {
    this.store.cache.delete(id);
    this.async(this.remove(id));
  }
  async commit() {
    await this.asyncDone;
    const { promise, resolve: resolve2, reject } = Promise.withResolvers();
    this.tx.oncomplete = () => resolve2();
    this.tx.onerror = () => reject(convertException(this.tx.error));
    this.tx.commit();
    return promise;
  }
  async abort() {
    await this.asyncDone;
    const { promise, resolve: resolve2, reject } = Promise.withResolvers();
    this.tx.onabort = () => resolve2();
    this.tx.onerror = () => reject(convertException(this.tx.error));
    this.tx.abort();
    return promise;
  }
};
__name(_IndexedDBTransaction, "IndexedDBTransaction");
let IndexedDBTransaction = _IndexedDBTransaction;
async function createDB(name, indexedDB = globalThis.indexedDB) {
  const req = indexedDB.open(name);
  req.onupgradeneeded = () => {
    const db = req.result;
    if (db.objectStoreNames.contains(name)) {
      warn("Found unexpected object store: " + name);
      db.deleteObjectStore(name);
    }
    db.createObjectStore(name);
  };
  return await wrap(req);
}
__name(createDB, "createDB");
const _IndexedDBStore = class _IndexedDBStore {
  constructor(db) {
    this.db = db;
    this.cache = /* @__PURE__ */ new Map();
  }
  sync() {
    return Promise.resolve();
  }
  get name() {
    return this.db.name;
  }
  transaction() {
    const tx = this.db.transaction(this.name, "readwrite");
    return new IndexedDBTransaction(tx, this);
  }
};
__name(_IndexedDBStore, "IndexedDBStore");
let IndexedDBStore = _IndexedDBStore;
const idbTests = /* @__PURE__ */ new WeakMap();
async function testAvailability(idbFactory) {
  if (!(idbFactory instanceof IDBFactory))
    return false;
  try {
    const req = idbFactory.open("__zenfs_test");
    await wrap(req);
    return true;
  } catch {
    return false;
  } finally {
    idbFactory?.deleteDatabase("__zenfs_test");
  }
}
__name(testAvailability, "testAvailability");
const _IndexedDB = {
  name: "IndexedDB",
  options: {
    storeName: { type: "string", required: false },
    idbFactory: { type: "object", required: false }
  },
  async isAvailable({ idbFactory = globalThis.indexedDB }) {
    if (idbTests.has(idbFactory))
      return idbTests.get(idbFactory);
    const result = testAvailability(idbFactory);
    idbTests.set(idbFactory, result);
    return result;
  },
  async create(options) {
    const db = await createDB(options.storeName || "zenfs", options.idbFactory);
    const store = new IndexedDBStore(db);
    const fs2 = new StoreFS(store);
    if (options?.disableAsyncCache) {
      notice("Async preloading disabled for IndexedDB");
      return fs2;
    }
    const tx = store.transaction();
    for (const id of await tx.keys()) {
      await tx.get(id);
    }
    return fs2;
  }
};
const IndexedDB = _IndexedDB;
/*! @gera2ld/tarjs v0.3.1 | MIT License */
const encoder = new TextEncoder();
const utf8Encode = /* @__PURE__ */ __name((input) => encoder.encode(input), "utf8Encode");
const decoder = new TextDecoder();
const utf8Decode = /* @__PURE__ */ __name((input) => decoder.decode(input), "utf8Decode");
function getArrayBuffer(file) {
  if (typeof file === "string") return utf8Encode(file).buffer;
  if (file instanceof ArrayBuffer) return file;
  if (ArrayBuffer.isView(file)) return new Uint8Array(file).buffer;
  return file.arrayBuffer();
}
__name(getArrayBuffer, "getArrayBuffer");
const _TarReader = class _TarReader {
  constructor(buffer2, fileInfos) {
    __privateAdd(this, _buffer);
    this.fileInfos = fileInfos;
    __privateSet(this, _buffer, buffer2);
  }
  static async load(file) {
    const buffer2 = await getArrayBuffer(file);
    const fileInfos = loadTarFile(buffer2);
    return new _TarReader(buffer2, fileInfos);
  }
  getTextFile(filename) {
    const item = this.fileInfos.find((info2) => info2.name === filename);
    if (!item) throw new Error(`File not found: ${filename}`);
    return readTextFile(__privateGet(this, _buffer), item.headerOffset + 512, item.size);
  }
  getFileBlob(filename, mimetype = "") {
    const item = this.fileInfos.find((info2) => info2.name === filename);
    if (!item) throw new Error(`File not found: ${filename}`);
    return readFileBlob(__privateGet(this, _buffer), item.headerOffset + 512, item.size, mimetype);
  }
};
_buffer = new WeakMap();
__name(_TarReader, "TarReader");
let TarReader = _TarReader;
function loadTarFile(buffer2) {
  const fileInfos = [];
  let offset = 0;
  while (offset < buffer2.byteLength - 512) {
    const fileName = readFileName(buffer2, offset);
    if (!fileName) break;
    const fileType = readFileType(buffer2, offset);
    const fileSize = readFileSize(buffer2, offset);
    fileInfos.push({
      name: fileName,
      type: fileType,
      size: fileSize,
      headerOffset: offset
    });
    offset += 512 + 512 * Math.floor((fileSize + 511) / 512);
  }
  return fileInfos;
}
__name(loadTarFile, "loadTarFile");
function readString(buffer2, offset, maxSize) {
  let size = 0;
  let view2 = new Uint8Array(buffer2, offset, maxSize);
  while (size < maxSize && view2[size]) size += 1;
  view2 = new Uint8Array(buffer2, offset, size);
  return utf8Decode(view2);
}
__name(readString, "readString");
function readFileName(buffer2, offset) {
  return readString(buffer2, offset, 100);
}
__name(readFileName, "readFileName");
function readFileType(buffer2, offset) {
  const view2 = new Uint8Array(buffer2, offset + 156, 1);
  return view2[0];
}
__name(readFileType, "readFileType");
function readFileSize(buffer2, offset) {
  const view2 = new Uint8Array(buffer2, offset + 124, 12);
  const sizeStr = utf8Decode(view2);
  return parseInt(sizeStr, 8);
}
__name(readFileSize, "readFileSize");
function readFileBlob(buffer2, offset, size, mimetype) {
  const view2 = new Uint8Array(buffer2, offset, size);
  return new Blob([view2], {
    type: mimetype
  });
}
__name(readFileBlob, "readFileBlob");
function readTextFile(buffer2, offset, size) {
  const view2 = new Uint8Array(buffer2, offset, size);
  return utf8Decode(view2);
}
__name(readTextFile, "readTextFile");
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
__name(zero$1, "zero$1");
const STORED_BLOCK$1 = 0;
const STATIC_TREES$1 = 1;
const DYN_TREES$1 = 2;
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1$1 = 15;
const Buf_size$1 = 16;
const MAX_BL_BITS$1 = 7;
const END_BLOCK$1 = 256;
const REP_3_6$1 = 16;
const REPZ_3_10$1 = 17;
const REPZ_11_138$1 = 18;
const extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
const extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
const extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code$1 = new Array(DIST_CODE_LEN);
zero$1(_dist_code$1);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
__name(StaticTreeDesc, "StaticTreeDesc");
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
__name(TreeDesc, "TreeDesc");
const d_code = /* @__PURE__ */ __name((dist) => {
  return dist < 256 ? _dist_code$1[dist] : _dist_code$1[256 + (dist >>> 7)];
}, "d_code");
const put_short = /* @__PURE__ */ __name((s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
}, "put_short");
const send_bits = /* @__PURE__ */ __name((s, value, length) => {
  if (s.bi_valid > Buf_size$1 - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size$1 - s.bi_valid;
    s.bi_valid += length - Buf_size$1;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
}, "send_bits");
const send_code = /* @__PURE__ */ __name((s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
}, "send_code");
const bi_reverse = /* @__PURE__ */ __name((code2, len) => {
  let res = 0;
  do {
    res |= code2 & 1;
    code2 >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}, "bi_reverse");
const bi_flush = /* @__PURE__ */ __name((s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}, "bi_flush");
const gen_bitlen = /* @__PURE__ */ __name((s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
}, "gen_bitlen");
const gen_codes = /* @__PURE__ */ __name((tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1$1 + 1);
  let code2 = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1$1; bits++) {
    code2 = code2 + bl_count[bits - 1] << 1;
    next_code[bits] = code2;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
}, "gen_codes");
const tr_static_init = /* @__PURE__ */ __name(() => {
  let n;
  let bits;
  let length;
  let code2;
  let dist;
  const bl_count = new Array(MAX_BITS$1$1 + 1);
  length = 0;
  for (code2 = 0; code2 < LENGTH_CODES$1 - 1; code2++) {
    base_length[code2] = length;
    for (n = 0; n < 1 << extra_lbits[code2]; n++) {
      _length_code[length++] = code2;
    }
  }
  _length_code[length - 1] = code2;
  dist = 0;
  for (code2 = 0; code2 < 16; code2++) {
    base_dist[code2] = dist;
    for (n = 0; n < 1 << extra_dbits[code2]; n++) {
      _dist_code$1[dist++] = code2;
    }
  }
  dist >>= 7;
  for (; code2 < D_CODES$1; code2++) {
    base_dist[code2] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code2] - 7; n++) {
      _dist_code$1[256 + dist++] = code2;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS$1);
}, "tr_static_init");
const init_block = /* @__PURE__ */ __name((s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK$1 * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
}, "init_block");
const bi_windup = /* @__PURE__ */ __name((s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}, "bi_windup");
const smaller$1 = /* @__PURE__ */ __name((tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
}, "smaller$1");
const pqdownheap = /* @__PURE__ */ __name((s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller$1(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller$1(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
}, "pqdownheap");
const compress_block = /* @__PURE__ */ __name((s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code2;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code2 = _length_code[lc];
        send_code(s, code2 + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code2];
        if (extra !== 0) {
          lc -= base_length[code2];
          send_bits(s, lc, extra);
        }
        dist--;
        code2 = d_code(dist);
        send_code(s, code2, dtree);
        extra = extra_dbits[code2];
        if (extra !== 0) {
          dist -= base_dist[code2];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK$1, ltree);
}, "compress_block");
const build_tree = /* @__PURE__ */ __name((s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
}, "build_tree");
const scan_tree = /* @__PURE__ */ __name((s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6$1 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10$1 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138$1 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}, "scan_tree");
const send_tree = /* @__PURE__ */ __name((s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6$1, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10$1, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138$1, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}, "send_tree");
const build_bl_tree = /* @__PURE__ */ __name((s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}, "build_bl_tree");
const send_all_trees = /* @__PURE__ */ __name((s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
}, "send_all_trees");
const detect_data_type = /* @__PURE__ */ __name((s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
}, "detect_data_type");
let static_init_done = false;
const _tr_init$1 = /* @__PURE__ */ __name((s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
}, "_tr_init$1");
const _tr_stored_block$1 = /* @__PURE__ */ __name((s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK$1 << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
}, "_tr_stored_block$1");
const _tr_align$1 = /* @__PURE__ */ __name((s) => {
  send_bits(s, STATIC_TREES$1 << 1, 3);
  send_code(s, END_BLOCK$1, static_ltree);
  bi_flush(s);
}, "_tr_align$1");
const _tr_flush_block$1 = /* @__PURE__ */ __name((s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES$1 << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES$1 << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
}, "_tr_flush_block$1");
const _tr_tally$1 = /* @__PURE__ */ __name((s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
}, "_tr_tally$1");
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32 = /* @__PURE__ */ __name((adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}, "adler32");
var adler32_1 = adler32;
const makeTable = /* @__PURE__ */ __name(() => {
  let c, table2 = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table2[n] = c;
  }
  return table2;
}, "makeTable");
const crcTable = new Uint32Array(makeTable());
const crc32 = /* @__PURE__ */ __name((crc, buf, len, pos) => {
  const t2 = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t2[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}, "crc32");
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH: Z_PARTIAL_FLUSH$1,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED: Z_FILTERED$1,
  Z_HUFFMAN_ONLY: Z_HUFFMAN_ONLY$1,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
const MAX_MEM_LEVEL$1 = 9;
const MAX_WBITS$1 = 15;
const DEF_MEM_LEVEL$1 = 8;
const LENGTH_CODES$2 = 29;
const LITERALS$2 = 256;
const L_CODES$2 = LITERALS$2 + 1 + LENGTH_CODES$2;
const D_CODES$2 = 30;
const BL_CODES$2 = 19;
const HEAP_SIZE$2 = 2 * L_CODES$2 + 1;
const MAX_BITS$2 = 15;
const MIN_MATCH$2 = 3;
const MAX_MATCH$2 = 258;
const MIN_LOOKAHEAD$1 = MAX_MATCH$2 + MIN_MATCH$2 + 1;
const PRESET_DICT$2 = 32;
const INIT_STATE$1 = 42;
const GZIP_STATE = 57;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE$1 = 113;
const FINISH_STATE$1 = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err = /* @__PURE__ */ __name((strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
}, "err");
const rank = /* @__PURE__ */ __name((f) => {
  return f * 2 - (f > 4 ? 9 : 0);
}, "rank");
const zero = /* @__PURE__ */ __name((buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}, "zero");
const slide_hash = /* @__PURE__ */ __name((s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
}, "slide_hash");
let HASH_ZLIB = /* @__PURE__ */ __name((s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask, "HASH_ZLIB");
let HASH = HASH_ZLIB;
const flush_pending = /* @__PURE__ */ __name((strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}, "flush_pending");
const flush_block_only = /* @__PURE__ */ __name((s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}, "flush_block_only");
const put_byte = /* @__PURE__ */ __name((s, b) => {
  s.pending_buf[s.pending++] = b;
}, "put_byte");
const putShortMSB = /* @__PURE__ */ __name((s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
}, "putShortMSB");
const read_buf = /* @__PURE__ */ __name((strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
}, "read_buf");
const longest_match = /* @__PURE__ */ __name((s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD$1 ? s.strstart - (s.w_size - MIN_LOOKAHEAD$1) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH$2;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH$2 - (strend - scan);
    scan = strend - MAX_MATCH$2;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}, "longest_match");
const fill_window = /* @__PURE__ */ __name((s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD$1)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH$2) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$2 - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH$2) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD$1 && s.strm.avail_in !== 0);
}, "fill_window");
const deflate_stored = /* @__PURE__ */ __name((s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
}, "deflate_stored");
const deflate_fast = /* @__PURE__ */ __name((s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD$1) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD$1 && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$2) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$2 - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD$1) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH$2) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$2);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH$2) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$2 - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH$2 - 1 ? s.strstart : MIN_MATCH$2 - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}, "deflate_fast");
const deflate_slow = /* @__PURE__ */ __name((s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD$1) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD$1 && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$2) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$2 - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH$2 - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD$1) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED$1 || s.match_length === MIN_MATCH$2 && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH$2 - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH$2 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH$2;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$2);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$2 - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH$2 - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH$2 - 1 ? s.strstart : MIN_MATCH$2 - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}, "deflate_slow");
const deflate_rle = /* @__PURE__ */ __name((s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH$2) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH$2 && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH$2 && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH$2;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH$2 - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH$2) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH$2);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}, "deflate_rle");
const deflate_huff = /* @__PURE__ */ __name((s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}, "deflate_huff");
function Config$1(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
__name(Config$1, "Config$1");
const configuration_table = [
  /*      good lazy nice chain */
  new Config$1(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config$1(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config$1(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config$1(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config$1(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config$1(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config$1(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config$1(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config$1(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config$1(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
const lm_init = /* @__PURE__ */ __name((s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH$2 - 1;
  s.match_available = 0;
  s.ins_h = 0;
}, "lm_init");
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE$2 * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES$2 + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES$2 + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS$2 + 1);
  this.heap = new Uint16Array(2 * L_CODES$2 + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES$2 + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
__name(DeflateState, "DeflateState");
const deflateStateCheck = /* @__PURE__ */ __name((strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE$1 && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE$1 && s.status !== FINISH_STATE$1) {
    return 1;
  }
  return 0;
}, "deflateStateCheck");
const deflateResetKeep = /* @__PURE__ */ __name((strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE$1 : BUSY_STATE$1
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
}, "deflateResetKeep");
const deflateReset = /* @__PURE__ */ __name((strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
}, "deflateReset");
const deflateSetHeader = /* @__PURE__ */ __name((strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
}, "deflateSetHeader");
const deflateInit2 = /* @__PURE__ */ __name((strm, level2, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap2 = 1;
  if (level2 === Z_DEFAULT_COMPRESSION$1) {
    level2 = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL$1 || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level2 < 0 || level2 > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap2 !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE$1;
  s.wrap = wrap2;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$2 - 1) / MIN_MATCH$2);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level2;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
}, "deflateInit2");
const deflateInit = /* @__PURE__ */ __name((strm, level2) => {
  return deflateInit2(strm, level2, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL$1, Z_DEFAULT_STRATEGY$1);
}, "deflateInit");
const deflate$2 = /* @__PURE__ */ __name((strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE$1 && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1$1);
  }
  if (s.status === FINISH_STATE$1 && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1$1);
  }
  if (s.status === INIT_STATE$1 && s.wrap === 0) {
    s.status = BUSY_STATE$1;
  }
  if (s.status === INIT_STATE$1) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT$2;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE$1;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE$1;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy2 = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy2), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy2;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy2;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE$1;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE$1) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY$1 ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE$1;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH$1) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
}, "deflate$2");
const deflateEnd = /* @__PURE__ */ __name((strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE$1 ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
}, "deflateEnd");
const deflateSetDictionary = /* @__PURE__ */ __name((strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap2 = s.wrap;
  if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE$1 || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap2 === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap2 === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH$2) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH$2 - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$2 - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH$2 - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH$2 - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap2;
  return Z_OK$3;
}, "deflateSetDictionary");
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has = /* @__PURE__ */ __name((obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
}, "_has");
var assign = /* @__PURE__ */ __name(function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source2 = sources.shift();
    if (!source2) {
      continue;
    }
    if (typeof source2 !== "object") {
      throw new TypeError(source2 + "must be non-object");
    }
    for (const p in source2) {
      if (_has(source2, p)) {
        obj[p] = source2[p];
      }
    }
  }
  return obj;
}, "assign");
var flattenChunks = /* @__PURE__ */ __name((chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
}, "flattenChunks");
var common = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = /* @__PURE__ */ __name((str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
}, "string2buf");
const buf2binstring = /* @__PURE__ */ __name((buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}, "buf2binstring");
var buf2string = /* @__PURE__ */ __name((buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
}, "buf2string");
var utf8border = /* @__PURE__ */ __name((buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
}, "utf8border");
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream$2() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
__name(ZStream$2, "ZStream$2");
var zstream = ZStream$2;
const toString$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$2,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$2,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$2,
  Z_DEFLATED: Z_DEFLATED$1$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION$2,
    method: Z_DEFLATED$1$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY$2
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
__name(Deflate$1, "Deflate$1");
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$2) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
__name(deflate$1, "deflate$1");
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
__name(deflateRaw$1, "deflateRaw$1");
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
__name(gzip$1, "gzip$1");
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1
};
const BAD$1 = 16209;
const TYPE$1 = 16191;
var inffast = /* @__PURE__ */ __name(function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output2;
  const state2 = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output2 = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state2.dmax;
  wsize = state2.wsize;
  whave = state2.whave;
  wnext = state2.wnext;
  s_window = state2.window;
  hold = state2.hold;
  bits = state2.bits;
  lcode = state2.lencode;
  dcode = state2.distcode;
  lmask = (1 << state2.lenbits) - 1;
  dmask = (1 << state2.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output2[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state2.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state2.sane) {
                        strm.msg = "invalid distance too far back";
                        state2.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output2[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output2;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    }
                    while (len > 2) {
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output2[_out++] = from_source[from++];
                      if (len > 1) {
                        output2[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output2[_out++] = output2[from++];
                      if (len > 1) {
                        output2[_out++] = output2[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state2.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state2.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state2.hold = hold;
  state2.bits = bits;
  return;
}, "inflate_fast");
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table = /* @__PURE__ */ __name((type, lens, lens_index, codes, table2, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table2[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table2[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table2[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
}, "inflate_table");
var inftrees = inflate_table;
const CODES$2 = 0;
const LENS$2 = 1;
const DISTS = 2;
const {
  Z_FINISH: Z_FINISH$1$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1$1,
  Z_STREAM_END: Z_STREAM_END$1$1,
  Z_NEED_DICT: Z_NEED_DICT$1$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR: Z_BUF_ERROR$2,
  Z_DEFLATED: Z_DEFLATED$3
} = constants$2;
const HEAD = 16180;
const FLAGS = 16181;
const TIME = 16182;
const OS = 16183;
const EXLEN = 16184;
const EXTRA = 16185;
const NAME = 16186;
const COMMENT = 16187;
const HCRC = 16188;
const DICTID = 16189;
const DICT = 16190;
const TYPE$2 = 16191;
const TYPEDO = 16192;
const STORED$2 = 16193;
const COPY_ = 16194;
const COPY$1 = 16195;
const TABLE$1 = 16196;
const LENLENS = 16197;
const CODELENS = 16198;
const LEN_ = 16199;
const LEN$1 = 16200;
const LENEXT$1 = 16201;
const DIST$1 = 16202;
const DISTEXT$1 = 16203;
const MATCH = 16204;
const LIT$1 = 16205;
const CHECK = 16206;
const LENGTH = 16207;
const DONE$1 = 16208;
const BAD$2 = 16209;
const MEM = 16210;
const SYNC = 16211;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = /* @__PURE__ */ __name((q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}, "zswap32");
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
__name(InflateState, "InflateState");
const inflateStateCheck = /* @__PURE__ */ __name((strm) => {
  if (!strm) {
    return 1;
  }
  const state2 = strm.state;
  if (!state2 || state2.strm !== strm || state2.mode < HEAD || state2.mode > SYNC) {
    return 1;
  }
  return 0;
}, "inflateStateCheck");
const inflateResetKeep = /* @__PURE__ */ __name((strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1$1;
  }
  const state2 = strm.state;
  strm.total_in = strm.total_out = state2.total = 0;
  strm.msg = "";
  if (state2.wrap) {
    strm.adler = state2.wrap & 1;
  }
  state2.mode = HEAD;
  state2.last = 0;
  state2.havedict = 0;
  state2.flags = -1;
  state2.dmax = 32768;
  state2.head = null;
  state2.hold = 0;
  state2.bits = 0;
  state2.lencode = state2.lendyn = new Int32Array(ENOUGH_LENS);
  state2.distcode = state2.distdyn = new Int32Array(ENOUGH_DISTS);
  state2.sane = 1;
  state2.back = -1;
  return Z_OK$1$1;
}, "inflateResetKeep");
const inflateReset = /* @__PURE__ */ __name((strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1$1;
  }
  const state2 = strm.state;
  state2.wsize = 0;
  state2.whave = 0;
  state2.wnext = 0;
  return inflateResetKeep(strm);
}, "inflateReset");
const inflateReset2 = /* @__PURE__ */ __name((strm, windowBits) => {
  let wrap2;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1$1;
  }
  const state2 = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1$1;
  }
  if (state2.window !== null && state2.wbits !== windowBits) {
    state2.window = null;
  }
  state2.wrap = wrap2;
  state2.wbits = windowBits;
  return inflateReset(strm);
}, "inflateReset2");
const inflateInit2 = /* @__PURE__ */ __name((strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1$1;
  }
  const state2 = new InflateState();
  strm.state = state2;
  state2.strm = strm;
  state2.window = null;
  state2.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1$1) {
    strm.state = null;
  }
  return ret;
}, "inflateInit2");
const inflateInit = /* @__PURE__ */ __name((strm) => {
  return inflateInit2(strm, DEF_WBITS);
}, "inflateInit");
let virgin = true;
let lenfix, distfix;
const fixedtables = /* @__PURE__ */ __name((state2) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state2.lens[sym++] = 8;
    }
    while (sym < 256) {
      state2.lens[sym++] = 9;
    }
    while (sym < 280) {
      state2.lens[sym++] = 7;
    }
    while (sym < 288) {
      state2.lens[sym++] = 8;
    }
    inftrees(LENS$2, state2.lens, 0, 288, lenfix, 0, state2.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state2.lens[sym++] = 5;
    }
    inftrees(DISTS, state2.lens, 0, 32, distfix, 0, state2.work, { bits: 5 });
    virgin = false;
  }
  state2.lencode = lenfix;
  state2.lenbits = 9;
  state2.distcode = distfix;
  state2.distbits = 5;
}, "fixedtables");
const updatewindow = /* @__PURE__ */ __name((strm, src, end, copy2) => {
  let dist;
  const state2 = strm.state;
  if (state2.window === null) {
    state2.wsize = 1 << state2.wbits;
    state2.wnext = 0;
    state2.whave = 0;
    state2.window = new Uint8Array(state2.wsize);
  }
  if (copy2 >= state2.wsize) {
    state2.window.set(src.subarray(end - state2.wsize, end), 0);
    state2.wnext = 0;
    state2.whave = state2.wsize;
  } else {
    dist = state2.wsize - state2.wnext;
    if (dist > copy2) {
      dist = copy2;
    }
    state2.window.set(src.subarray(end - copy2, end - copy2 + dist), state2.wnext);
    copy2 -= dist;
    if (copy2) {
      state2.window.set(src.subarray(end - copy2, end), 0);
      state2.wnext = copy2;
      state2.whave = state2.wsize;
    } else {
      state2.wnext += dist;
      if (state2.wnext === state2.wsize) {
        state2.wnext = 0;
      }
      if (state2.whave < state2.wsize) {
        state2.whave += dist;
      }
    }
  }
  return 0;
}, "updatewindow");
const inflate$2 = /* @__PURE__ */ __name((strm, flush) => {
  let state2;
  let input, output2;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy2;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1$1;
  }
  state2 = strm.state;
  if (state2.mode === TYPE$2) {
    state2.mode = TYPEDO;
  }
  put = strm.next_out;
  output2 = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state2.hold;
  bits = state2.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1$1;
  inf_leave:
    for (; ; ) {
      switch (state2.mode) {
        case HEAD:
          if (state2.wrap === 0) {
            state2.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.wrap & 2 && hold === 35615) {
            if (state2.wbits === 0) {
              state2.wbits = 15;
            }
            state2.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32_1(state2.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state2.mode = FLAGS;
            break;
          }
          if (state2.head) {
            state2.head.done = false;
          }
          if (!(state2.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state2.mode = BAD$2;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED$3) {
            strm.msg = "unknown compression method";
            state2.mode = BAD$2;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state2.wbits === 0) {
            state2.wbits = len;
          }
          if (len > 15 || len > state2.wbits) {
            strm.msg = "invalid window size";
            state2.mode = BAD$2;
            break;
          }
          state2.dmax = 1 << state2.wbits;
          state2.flags = 0;
          strm.adler = state2.check = 1;
          state2.mode = hold & 512 ? DICTID : TYPE$2;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.flags = hold;
          if ((state2.flags & 255) !== Z_DEFLATED$3) {
            strm.msg = "unknown compression method";
            state2.mode = BAD$2;
            break;
          }
          if (state2.flags & 57344) {
            strm.msg = "unknown header flags set";
            state2.mode = BAD$2;
            break;
          }
          if (state2.head) {
            state2.head.text = hold >> 8 & 1;
          }
          if (state2.flags & 512 && state2.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32_1(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.time = hold;
          }
          if (state2.flags & 512 && state2.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state2.check = crc32_1(state2.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.xflags = hold & 255;
            state2.head.os = hold >> 8;
          }
          if (state2.flags & 512 && state2.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32_1(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state2.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length = hold;
            if (state2.head) {
              state2.head.extra_len = hold;
            }
            if (state2.flags & 512 && state2.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32_1(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state2.head) {
            state2.head.extra = null;
          }
          state2.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state2.flags & 1024) {
            copy2 = state2.length;
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2) {
              if (state2.head) {
                len = state2.head.extra_len - state2.length;
                if (!state2.head.extra) {
                  state2.head.extra = new Uint8Array(state2.head.extra_len);
                }
                state2.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy2
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state2.flags & 512 && state2.wrap & 4) {
                state2.check = crc32_1(state2.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              state2.length -= copy2;
            }
            if (state2.length) {
              break inf_leave;
            }
          }
          state2.length = 0;
          state2.mode = NAME;
        /* falls through */
        case NAME:
          if (state2.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.name += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state2.flags & 512 && state2.wrap & 4) {
              state2.check = crc32_1(state2.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.name = null;
          }
          state2.length = 0;
          state2.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state2.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.comment += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state2.flags & 512 && state2.wrap & 4) {
              state2.check = crc32_1(state2.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.comment = null;
          }
          state2.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state2.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.wrap & 4 && hold !== (state2.check & 65535)) {
              strm.msg = "header crc mismatch";
              state2.mode = BAD$2;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state2.head) {
            state2.head.hcrc = state2.flags >> 9 & 1;
            state2.head.done = true;
          }
          strm.adler = state2.check = 0;
          state2.mode = TYPE$2;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state2.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state2.mode = DICT;
        /* falls through */
        case DICT:
          if (state2.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            return Z_NEED_DICT$1$1;
          }
          strm.adler = state2.check = 1;
          state2.mode = TYPE$2;
        /* falls through */
        case TYPE$2:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state2.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state2.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state2.mode = STORED$2;
              break;
            case 1:
              fixedtables(state2);
              state2.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state2.mode = TABLE$1;
              break;
            case 3:
              strm.msg = "invalid block type";
              state2.mode = BAD$2;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED$2:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state2.mode = BAD$2;
            break;
          }
          state2.length = hold & 65535;
          hold = 0;
          bits = 0;
          state2.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state2.mode = COPY$1;
        /* falls through */
        case COPY$1:
          copy2 = state2.length;
          if (copy2) {
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            if (copy2 === 0) {
              break inf_leave;
            }
            output2.set(input.subarray(next, next + copy2), put);
            have -= copy2;
            next += copy2;
            left -= copy2;
            put += copy2;
            state2.length -= copy2;
            break;
          }
          state2.mode = TYPE$2;
          break;
        case TABLE$1:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state2.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state2.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state2.nlen > 286 || state2.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state2.mode = BAD$2;
            break;
          }
          state2.have = 0;
          state2.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state2.have < state2.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.lens[order[state2.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state2.have < 19) {
            state2.lens[order[state2.have++]] = 0;
          }
          state2.lencode = state2.lendyn;
          state2.lenbits = 7;
          opts = { bits: state2.lenbits };
          ret = inftrees(CODES$2, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts);
          state2.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state2.mode = BAD$2;
            break;
          }
          state2.have = 0;
          state2.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state2.have < state2.nlen + state2.ndist) {
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state2.lens[state2.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state2.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD$2;
                  break;
                }
                len = state2.lens[state2.have - 1];
                copy2 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state2.have + copy2 > state2.nlen + state2.ndist) {
                strm.msg = "invalid bit length repeat";
                state2.mode = BAD$2;
                break;
              }
              while (copy2--) {
                state2.lens[state2.have++] = len;
              }
            }
          }
          if (state2.mode === BAD$2) {
            break;
          }
          if (state2.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state2.mode = BAD$2;
            break;
          }
          state2.lenbits = 9;
          opts = { bits: state2.lenbits };
          ret = inftrees(LENS$2, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts);
          state2.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state2.mode = BAD$2;
            break;
          }
          state2.distbits = 6;
          state2.distcode = state2.distdyn;
          opts = { bits: state2.distbits };
          ret = inftrees(DISTS, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts);
          state2.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state2.mode = BAD$2;
            break;
          }
          state2.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state2.mode = LEN$1;
        /* falls through */
        case LEN$1:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output2 = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state2.hold;
            bits = state2.bits;
            if (state2.mode === TYPE$2) {
              state2.back = -1;
            }
            break;
          }
          state2.back = 0;
          for (; ; ) {
            here = state2.lencode[hold & (1 << state2.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          state2.length = here_val;
          if (here_op === 0) {
            state2.mode = LIT$1;
            break;
          }
          if (here_op & 32) {
            state2.back = -1;
            state2.mode = TYPE$2;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD$2;
            break;
          }
          state2.extra = here_op & 15;
          state2.mode = LENEXT$1;
        /* falls through */
        case LENEXT$1:
          if (state2.extra) {
            n = state2.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          state2.was = state2.length;
          state2.mode = DIST$1;
        /* falls through */
        case DIST$1:
          for (; ; ) {
            here = state2.distcode[hold & (1 << state2.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state2.mode = BAD$2;
            break;
          }
          state2.offset = here_val;
          state2.extra = here_op & 15;
          state2.mode = DISTEXT$1;
        /* falls through */
        case DISTEXT$1:
          if (state2.extra) {
            n = state2.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.offset += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          if (state2.offset > state2.dmax) {
            strm.msg = "invalid distance too far back";
            state2.mode = BAD$2;
            break;
          }
          state2.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy2 = _out - left;
          if (state2.offset > copy2) {
            copy2 = state2.offset - copy2;
            if (copy2 > state2.whave) {
              if (state2.sane) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD$2;
                break;
              }
            }
            if (copy2 > state2.wnext) {
              copy2 -= state2.wnext;
              from = state2.wsize - copy2;
            } else {
              from = state2.wnext - copy2;
            }
            if (copy2 > state2.length) {
              copy2 = state2.length;
            }
            from_source = state2.window;
          } else {
            from_source = output2;
            from = put - state2.offset;
            copy2 = state2.length;
          }
          if (copy2 > left) {
            copy2 = left;
          }
          left -= copy2;
          state2.length -= copy2;
          do {
            output2[put++] = from_source[from++];
          } while (--copy2);
          if (state2.length === 0) {
            state2.mode = LEN$1;
          }
          break;
        case LIT$1:
          if (left === 0) {
            break inf_leave;
          }
          output2[put++] = state2.length;
          left--;
          state2.mode = LEN$1;
          break;
        case CHECK:
          if (state2.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state2.total += _out;
            if (state2.wrap & 4 && _out) {
              strm.adler = state2.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state2.flags ? crc32_1(state2.check, output2, _out, put - _out) : adler32_1(state2.check, output2, _out, put - _out);
            }
            _out = left;
            if (state2.wrap & 4 && (state2.flags ? hold : zswap32(hold)) !== state2.check) {
              strm.msg = "incorrect data check";
              state2.mode = BAD$2;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state2.wrap && state2.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.wrap & 4 && hold !== (state2.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state2.mode = BAD$2;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = DONE$1;
        /* falls through */
        case DONE$1:
          ret = Z_STREAM_END$1$1;
          break inf_leave;
        case BAD$2:
          ret = Z_DATA_ERROR$1$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state2.hold = hold;
  state2.bits = bits;
  if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD$2 && (state2.mode < CHECK || flush !== Z_FINISH$1$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state2.total += _out;
  if (state2.wrap & 4 && _out) {
    strm.adler = state2.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state2.flags ? crc32_1(state2.check, output2, _out, strm.next_out - _out) : adler32_1(state2.check, output2, _out, strm.next_out - _out);
  }
  strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE$2 ? 128 : 0) + (state2.mode === LEN_ || state2.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1$1) && ret === Z_OK$1$1) {
    ret = Z_BUF_ERROR$2;
  }
  return ret;
}, "inflate$2");
const inflateEnd = /* @__PURE__ */ __name((strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1$1;
  }
  let state2 = strm.state;
  if (state2.window) {
    state2.window = null;
  }
  strm.state = null;
  return Z_OK$1$1;
}, "inflateEnd");
const inflateGetHeader = /* @__PURE__ */ __name((strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1$1;
  }
  const state2 = strm.state;
  if ((state2.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1$1;
  }
  state2.head = head;
  head.done = false;
  return Z_OK$1$1;
}, "inflateGetHeader");
const inflateSetDictionary = /* @__PURE__ */ __name((strm, dictionary) => {
  const dictLength = dictionary.length;
  let state2;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1$1;
  }
  state2 = strm.state;
  if (state2.wrap !== 0 && state2.mode !== DICT) {
    return Z_STREAM_ERROR$1$1;
  }
  if (state2.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state2.check) {
      return Z_DATA_ERROR$1$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state2.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state2.havedict = 1;
  return Z_OK$1$1;
}, "inflateSetDictionary");
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
__name(GZheader, "GZheader");
var gzheader = GZheader;
const toString = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$3,
  Z_FINISH: Z_FINISH$4,
  Z_OK: Z_OK$4,
  Z_STREAM_END: Z_STREAM_END$4,
  Z_NEED_DICT: Z_NEED_DICT$2,
  Z_STREAM_ERROR: Z_STREAM_ERROR$3,
  Z_DATA_ERROR: Z_DATA_ERROR$3,
  Z_MEM_ERROR: Z_MEM_ERROR$2
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK$4) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK$4) {
        throw new Error(messages[status]);
      }
    }
  }
}
__name(Inflate$1, "Inflate$1");
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$4 : Z_NO_FLUSH$3;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT$2 && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK$4) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR$3) {
        status = Z_NEED_DICT$2;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END$4 && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR$3:
      case Z_DATA_ERROR$3:
      case Z_NEED_DICT$2:
      case Z_MEM_ERROR$2:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END$4) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK$4 && last_avail_out === 0) continue;
    if (status === Z_STREAM_END$4) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$4) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
__name(inflate$1, "inflate$1");
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
__name(inflateRaw$1, "inflateRaw$1");
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1
};
const { Deflate: Deflate$2, deflate, deflateRaw, gzip } = deflate_1$1;
const { Inflate: Inflate$2, inflate, inflateRaw, ungzip } = inflate_1$1;
var Deflate_1 = Deflate$2;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate$2;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;
var pako = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};
const DefaultFilesystemOptions = {
  uid: 0,
  gid: 0,
  addDevices: true,
  defaultDirectories: true,
  disableAccessChecks: false,
  disableAsyncCache: false,
  onlySyncOnClose: false,
  log: {
    level: "debug",
    enabled: false
  },
  mounts: {
    "/": { backend: IndexedDB, options: { storeName: "root" } },
    "/media": { backend: InMemory, options: { name: "media" } },
    "/mnt": { backend: InMemory, options: { name: "mnt" } },
    "/proc": { backend: InMemory, options: { name: "procfs" } },
    "/tmp": { backend: InMemory, options: { name: "tmpfs" } }
  }
};
const _Filesystem = class _Filesystem {
  constructor(kernel) {
    __publicField(this, "_config", DefaultFilesystemOptions);
    __publicField(this, "_fs", fs);
    __publicField(this, "_kernel");
    // Descriptions for common filesystem entries
    __publicField(this, "descriptions", /* @__PURE__ */ __name((t2) => {
      if (!t2) t2 = /* @__PURE__ */ __name((k) => {
        return k;
      }, "t");
      return /* @__PURE__ */ new Map([
        ["/bin", t2("User Programs")],
        ["/boot", t2("Boot files")],
        ["/dev", t2("Device files")],
        ["/etc", t2("Configuration files")],
        ["/home", t2("User home directories")],
        ["/lib", t2("Library files")],
        ["/mnt", t2("Temporary mount point")],
        ["/opt", t2("Optional applications")],
        ["/proc", t2("Process/system information")],
        ["/root", t2("Root user home directory")],
        ["/run", t2("Runtime data")],
        ["/sbin", t2("System programs")],
        ["/sys", t2("System files")],
        ["/tmp", t2("Temporary files")],
        ["/usr", t2("User data")],
        ["/var", t2("Variable data")],
        ["/proc/connection", t2("Network Connection Data")],
        ["/proc/host", t2("Hostname")],
        ["/proc/language", t2("Language Information")],
        ["/proc/memory", t2("Memory Information")],
        ["/proc/platform", t2("Platform Information")],
        ["/proc/querystring", t2("Query String")],
        ["/proc/userAgent", t2("User Agent")],
        ["/proc/userAgentData", t2("User Agent Data")],
        ["/proc/version", t2("Kernel Version")],
        [".bmp", t2("Bitmap Image")],
        [".gif", t2("GIF Image")],
        [".jpg", t2("JPEG Image")],
        [".jpeg", t2("JPEG Image")],
        [".js", t2("JavaScript File")],
        [".json", t2("JSON Data")],
        [".md", t2("Markdown Document")],
        [".pdf", t2("PDF Document")],
        [".png", t2("PNG Image")],
        [".sixel", t2("Sixel Graphics")],
        [".txt", t2("Text File")],
        [".wasm", t2("WebAssembly Module")],
        [".wat", t2("WebAssembly Text Format")]
      ]);
    }, "descriptions"));
    this._kernel = kernel;
  }
  /**
   * @returns {FilesystemOptions} The filesystem options.
   */
  get config() {
    return this._config;
  }
  /**
   * @returns {ZenFS.constants} Constants related to the filesystem.
   */
  get constants() {
    return this._fs.constants;
  }
  /**
   * @returns The filesystem credentials.
   */
  // get credentials(): Credentials { return credentials }
  /**
   * @returns {DeviceFS} The device filesystem.
   * @remarks Remove or replace this; zenfs.mounts is deprecated.
   */
  // get devfs(): DeviceFS { return this._fs.mounts.get('/dev') as DeviceFS }
  /**
   * @returns {ZenFS.fs.promises} The asynchronous ZenFS filesystem instance.
   */
  get fs() {
    return this._fs.promises;
  }
  /**
   * @returns {ZenFS.fs} The synchronous ZenFS filesystem instance.
   */
  get fsSync() {
    return this._fs;
  }
  /**
   * @returns {Kernel} The kernel instance.
   */
  get kernel() {
    return this._kernel;
  }
  /**
   * @returns {ZenFS.mounts} The mounted filesystems.
   * @remarks Remove or replace this; zenfs.mounts is deprecated.
   */
  // get mounts(): typeof fs.mounts { return this._fs.mounts }
  /**
   * Configures the filesystem with the given options.
   * @param {FilesystemOptions} options - The options for the filesystem.
   * @returns {Promise<void>} A promise that resolves when the filesystem is configured.
   */
  async configure(options) {
    if (!options) return;
    this._config = options;
    await configure$1(options);
    const fsInitialized = await this.kernel.storage.local.getItem("ecmaos:filesystem:initialized");
    if (!fsInitialized) {
      try {
        const response = await fetch("/initfs.tar.gz");
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const arrayBuffer = await response.arrayBuffer();
        await this.fs.writeFile("/tmp/initfs.tar", new Uint8Array(arrayBuffer));
        await this.extractTarball("/tmp/initfs.tar", "/");
        await this.fs.unlink("/tmp/initfs.tar");
        await this.kernel.storage.local.setItem("ecmaos:filesystem:initialized", "true");
      } catch (error) {
        globalThis.kernel?.log.error(`Failed to fetch ${"/initfs.tar.gz"}: ${error}`);
        console.error(error);
      }
    }
  }
  /**
   * Checks if a file or directory exists at the given path.
   * @param {string} path - The path to check.
   * @returns {Promise<boolean>} A promise that resolves to true if the path exists, false otherwise.
   * 
   * @remarks A shortcut for `kernel.filesystem.fs.exists`
   */
  async exists(path2) {
    return await this.fs.exists(path2);
  }
  /**
   * Extracts a tarball to the given path.
   * @param {string} tarballPath - The path to the tarball.
   * @param {string} extractPath - The path to extract the tarball to.
   * @param {number} fileMode - The mode to set for files. Defaults to 0o644.
   * @param {number} directoryMode - The mode to set for directories. Defaults to 0o755.
   * @returns {Promise<void>} A promise that resolves when the tarball is extracted.
   */
  async extractTarball(tarballPath, extractPath, fileMode = 420, directoryMode = 493) {
    const tarball = await this.fs.readFile(tarballPath);
    const isGzipped = tarball.length >= 2 && tarball[0] === 31 && tarball[1] === 139;
    const tarData = isGzipped ? pako.ungzip(tarball) : tarball;
    const tar = await TarReader.load(tarData);
    const hasPackageDir = tar.fileInfos.some((file) => file.name.startsWith("package/"));
    const stripPrefix = hasPackageDir ? "package/" : "";
    for (const file of tar.fileInfos) {
      if (hasPackageDir && !file.name.startsWith(stripPrefix)) continue;
      const relativePath = hasPackageDir ? file.name.slice(stripPrefix.length) : file.name;
      if (!relativePath) continue;
      try {
        if (relativePath.endsWith("/")) {
          await this.fs.mkdir(path$1.join(extractPath, relativePath), { mode: directoryMode, recursive: true });
          continue;
        }
        await this.fs.mkdir(path$1.join(extractPath, path$1.dirname(relativePath)), { mode: directoryMode, recursive: true });
        const blob = tar.getFileBlob(file.name);
        const binaryData = await blob.arrayBuffer().then((buffer2) => new Uint8Array(buffer2));
        const filePath = path$1.join(extractPath, relativePath);
        await this.fs.writeFile(filePath, binaryData, { encoding: "binary", mode: fileMode });
      } catch (error) {
        globalThis.kernel?.terminal.writeln(`Failed to extract file ${file.name}: ${error}`);
      }
    }
  }
  /**
   * Returns the default filesystem options with the given extensions.
   * @param {Partial<FilesystemOptions>} extensions - The extensions to apply to the default options.
   * @returns {FilesystemOptions} The filesystem options with the given extensions.
   *
   */
  static options(extensions) {
    return {
      ...DefaultFilesystemOptions,
      ...extensions || {}
    };
  }
};
__name(_Filesystem, "Filesystem");
let Filesystem = _Filesystem;
const prettyLogStyles = {
  reset: [0, 0],
  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  overline: [53, 55],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
};
function formatTemplate(settings, template2, values, hideUnsetPlaceholder = false) {
  const templateString = String(template2);
  const ansiColorWrap = /* @__PURE__ */ __name((placeholderValue, code2) => `\x1B[${code2[0]}m${placeholderValue}\x1B[${code2[1]}m`, "ansiColorWrap");
  const styleWrap = /* @__PURE__ */ __name((value, style) => {
    if (style != null && typeof style === "string") {
      return ansiColorWrap(value, prettyLogStyles[style]);
    } else if (style != null && Array.isArray(style)) {
      return style.reduce((prevValue, thisStyle) => styleWrap(prevValue, thisStyle), value);
    } else {
      if (style != null && style[value.trim()] != null) {
        return styleWrap(value, style[value.trim()]);
      } else if (style != null && style["*"] != null) {
        return styleWrap(value, style["*"]);
      } else {
        return value;
      }
    }
  }, "styleWrap");
  const defaultStyle = null;
  return templateString.replace(/{{(.+?)}}/g, (_, placeholder) => {
    const value = values[placeholder] != null ? String(values[placeholder]) : hideUnsetPlaceholder ? "" : _;
    return settings.stylePrettyLogs ? styleWrap(value, settings?.prettyLogStyles?.[placeholder] ?? defaultStyle) + ansiColorWrap("", prettyLogStyles.reset) : value;
  });
}
__name(formatTemplate, "formatTemplate");
function formatNumberAddZeros(value, digits = 2, addNumber = 0) {
  if (value != null && isNaN(value)) {
    return "";
  }
  value = value != null ? value + addNumber : value;
  return digits === 2 ? value == null ? "--" : value < 10 ? "0" + value : value.toString() : value == null ? "---" : value < 10 ? "00" + value : value < 100 ? "0" + value : value.toString();
}
__name(formatNumberAddZeros, "formatNumberAddZeros");
function urlToObject(url) {
  return {
    href: url.href,
    protocol: url.protocol,
    username: url.username,
    password: url.password,
    host: url.host,
    hostname: url.hostname,
    port: url.port,
    pathname: url.pathname,
    search: url.search,
    searchParams: [...url.searchParams].map(([key, value]) => ({ key, value })),
    hash: url.hash,
    origin: url.origin
  };
}
__name(urlToObject, "urlToObject");
function jsonStringifyRecursive(obj) {
  const cache = /* @__PURE__ */ new Set();
  return JSON.stringify(obj, (key, value) => {
    if (typeof value === "object" && value !== null) {
      if (cache.has(value)) {
        return "[Circular]";
      }
      cache.add(value);
    }
    if (typeof value === "bigint") {
      return `${value}`;
    }
    return value;
  });
}
__name(jsonStringifyRecursive, "jsonStringifyRecursive");
function inspect(obj, opts) {
  const ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (opts != null) {
    _extend(ctx, opts);
  }
  if (isUndefined$1(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined$1(ctx.depth))
    ctx.depth = 2;
  if (isUndefined$1(ctx.colors))
    ctx.colors = true;
  if (isUndefined$1(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
__name(inspect, "inspect");
inspect.colors = prettyLogStyles;
inspect.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  regexp: "red"
};
function isBoolean(arg) {
  return typeof arg === "boolean";
}
__name(isBoolean, "isBoolean");
function isUndefined$1(arg) {
  return arg === void 0;
}
__name(isUndefined$1, "isUndefined$1");
function stylizeNoColor(str) {
  return str;
}
__name(stylizeNoColor, "stylizeNoColor");
function stylizeWithColor(str, styleType) {
  const style = inspect.styles[styleType];
  if (style != null && inspect?.colors?.[style]?.[0] != null && inspect?.colors?.[style]?.[1] != null) {
    return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
  } else {
    return str;
  }
}
__name(stylizeWithColor, "stylizeWithColor");
function isFunction$1(arg) {
  return typeof arg === "function";
}
__name(isFunction$1, "isFunction$1");
function isString$2(arg) {
  return typeof arg === "string";
}
__name(isString$2, "isString$2");
function isNumber$1(arg) {
  return typeof arg === "number";
}
__name(isNumber$1, "isNumber$1");
function isNull$1(arg) {
  return arg === null;
}
__name(isNull$1, "isNull$1");
function hasOwn(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
__name(hasOwn, "hasOwn");
function isRegExp(re2) {
  return isObject$1(re2) && objectToString(re2) === "[object RegExp]";
}
__name(isRegExp, "isRegExp");
function isObject$1(arg) {
  return typeof arg === "object" && arg !== null;
}
__name(isObject$1, "isObject$1");
function isError$1(e2) {
  return isObject$1(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
}
__name(isError$1, "isError$1");
function isDate(d) {
  return isObject$1(d) && objectToString(d) === "[object Date]";
}
__name(isDate, "isDate");
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
__name(objectToString, "objectToString");
function arrayToHash(array2) {
  const hash2 = {};
  array2.forEach((val) => {
    hash2[val] = true;
  });
  return hash2;
}
__name(arrayToHash, "arrayToHash");
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  const output2 = [];
  for (let i = 0, l = value.length; i < l; ++i) {
    if (hasOwn(value, String(i))) {
      output2.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output2.push("");
    }
  }
  keys.forEach((key) => {
    if (!key.match(/^\d+$/)) {
      output2.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output2;
}
__name(formatArray, "formatArray");
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
__name(formatError, "formatError");
function formatValue(ctx, value, recurseTimes = 0) {
  if (ctx.customInspect && value != null && isFunction$1(value) && value?.inspect !== inspect && !(value?.constructor && value?.constructor.prototype === value)) {
    if (typeof value.inspect !== "function" && value.toString != null) {
      return value.toString();
    }
    let ret = value?.inspect(recurseTimes, ctx);
    if (!isString$2(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  const primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  let keys = Object.keys(value);
  const visibleKeys = arrayToHash(keys);
  try {
    if (ctx.showHidden && Object.getOwnPropertyNames) {
      keys = Object.getOwnPropertyNames(value);
    }
  } catch (e2) {
  }
  if (isError$1(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys.length === 0) {
    if (isFunction$1(ctx.stylize)) {
      if (isFunction$1(value)) {
        const name = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toISOString.call(value), "date");
      }
      if (isError$1(value)) {
        return formatError(value);
      }
    } else {
      return value;
    }
  }
  let base = "";
  let array2 = false;
  let braces = ["{\n", "\n}"];
  if (Array.isArray(value)) {
    array2 = true;
    braces = ["[\n", "\n]"];
  }
  if (isFunction$1(value)) {
    const n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError$1(value)) {
    base = " " + formatError(value);
  }
  if (keys.length === 0 && (!array2 || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  let output2;
  if (array2) {
    output2 = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output2 = keys.map((key) => {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array2);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output2, base, braces);
}
__name(formatValue, "formatValue");
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array2) {
  let name, str;
  let desc = { value: void 0 };
  try {
    desc.value = value[key];
  } catch (e2) {
  }
  try {
    if (Object.getOwnPropertyDescriptor) {
      desc = Object.getOwnPropertyDescriptor(value, key) || desc;
    }
  } catch (e2) {
  }
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwn(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull$1(recurseTimes)) {
        str = formatValue(ctx, desc.value, void 0);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array2) {
          str = str.split("\n").map((line3) => {
            return "  " + line3;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map((line3) => {
            return "   " + line3;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined$1(name)) {
    if (array2 && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, "\\'").replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
__name(formatProperty, "formatProperty");
function formatPrimitive(ctx, value) {
  if (isUndefined$1(value))
    return ctx.stylize("undefined", "undefined");
  if (isString$2(value)) {
    const simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, "\\'") + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber$1(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull$1(value))
    return ctx.stylize("null", "null");
}
__name(formatPrimitive, "formatPrimitive");
function reduceToSingleString(output2, base, braces) {
  return braces[0] + (base === "" ? "" : base + "\n") + "  " + output2.join(",\n  ") + " " + braces[1];
}
__name(reduceToSingleString, "reduceToSingleString");
function _extend(origin, add) {
  const typedOrigin = { ...origin };
  if (!add || !isObject$1(add))
    return origin;
  const clonedAdd = { ...add };
  const keys = Object.keys(add);
  let i = keys.length;
  while (i--) {
    typedOrigin[keys[i]] = clonedAdd[keys[i]];
  }
  return typedOrigin;
}
__name(_extend, "_extend");
function formatWithOptions(inspectOptions, ...args) {
  const ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (inspectOptions != null) {
    _extend(ctx, inspectOptions);
  }
  const first = args[0];
  let a = 0;
  let str = "";
  let join2 = "";
  if (typeof first === "string") {
    if (args.length === 1) {
      return first;
    }
    let tempStr;
    let lastPos = 0;
    for (let i = 0; i < first.length - 1; i++) {
      if (first.charCodeAt(i) === 37) {
        const nextChar = first.charCodeAt(++i);
        if (a + 1 !== args.length) {
          switch (nextChar) {
            case 115: {
              const tempArg = args[++a];
              if (typeof tempArg === "number") {
                tempStr = formatPrimitive(ctx, tempArg);
              } else if (typeof tempArg === "bigint") {
                tempStr = formatPrimitive(ctx, tempArg);
              } else if (typeof tempArg !== "object" || tempArg === null) {
                tempStr = String(tempArg);
              } else {
                tempStr = inspect(tempArg, {
                  ...inspectOptions,
                  compact: 3,
                  colors: false,
                  depth: 0
                });
              }
              break;
            }
            case 106:
              tempStr = jsonStringifyRecursive(args[++a]);
              break;
            case 100: {
              const tempNum = args[++a];
              if (typeof tempNum === "bigint") {
                tempStr = formatPrimitive(ctx, tempNum);
              } else if (typeof tempNum === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatPrimitive(ctx, tempNum);
              }
              break;
            }
            case 79:
              tempStr = inspect(args[++a], inspectOptions);
              break;
            case 111:
              tempStr = inspect(args[++a], {
                ...inspectOptions,
                showHidden: true,
                showProxy: true,
                depth: 4
              });
              break;
            case 105: {
              const tempInteger = args[++a];
              if (typeof tempInteger === "bigint") {
                tempStr = formatPrimitive(ctx, tempInteger);
              } else if (typeof tempInteger === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatPrimitive(ctx, parseInt(tempStr));
              }
              break;
            }
            case 102: {
              const tempFloat = args[++a];
              if (typeof tempFloat === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatPrimitive(ctx, parseInt(tempFloat));
              }
              break;
            }
            case 99:
              a += 1;
              tempStr = "";
              break;
            case 37:
              str += first.slice(lastPos, i);
              lastPos = i + 1;
              continue;
            default:
              continue;
          }
          if (lastPos !== i - 1) {
            str += first.slice(lastPos, i - 1);
          }
          str += tempStr;
          lastPos = i + 1;
        } else if (nextChar === 37) {
          str += first.slice(lastPos, i);
          lastPos = i + 1;
        }
      }
    }
    if (lastPos !== 0) {
      a++;
      join2 = " ";
      if (lastPos < first.length) {
        str += first.slice(lastPos);
      }
    }
  }
  while (a < args.length) {
    const value = args[a];
    str += join2;
    str += typeof value !== "string" ? inspect(value, inspectOptions) : value;
    join2 = " ";
    a++;
  }
  return str;
}
__name(formatWithOptions, "formatWithOptions");
const Runtime = {
  getCallerStackFrame,
  getErrorTrace,
  getMeta,
  transportJSON,
  transportFormatted,
  isBuffer,
  isError,
  prettyFormatLogObj,
  prettyFormatErrorObj
};
const meta = {
  runtime: ![typeof window, typeof document].includes("undefined") ? "Browser" : "Generic",
  browser: globalThis?.["navigator"]?.userAgent
};
const pathRegex = /(?:(?:file|https?|global code|[^@]+)@)?(?:file:)?((?:\/[^:/]+){2,})(?::(\d+))?(?::(\d+))?/;
function getMeta(logLevelId, logLevelName, stackDepthLevel, hideLogPositionForPerformance, name, parentNames) {
  return Object.assign({}, meta, {
    name,
    parentNames,
    date: /* @__PURE__ */ new Date(),
    logLevelId,
    logLevelName,
    path: !hideLogPositionForPerformance ? getCallerStackFrame(stackDepthLevel) : void 0
  });
}
__name(getMeta, "getMeta");
function getCallerStackFrame(stackDepthLevel, error = Error()) {
  return stackLineToStackFrame(error?.stack?.split("\n")?.filter((line3) => !line3.includes("Error: "))?.[stackDepthLevel]);
}
__name(getCallerStackFrame, "getCallerStackFrame");
function getErrorTrace(error) {
  return (error?.stack?.split("\n") ?? [])?.filter((line3) => !line3.includes("Error: "))?.reduce((result, line3) => {
    result.push(stackLineToStackFrame(line3));
    return result;
  }, []);
}
__name(getErrorTrace, "getErrorTrace");
function stackLineToStackFrame(line3) {
  const href = globalThis?.location?.origin;
  const pathResult = {
    fullFilePath: void 0,
    fileName: void 0,
    fileNameWithLine: void 0,
    fileColumn: void 0,
    fileLine: void 0,
    filePath: void 0,
    filePathWithLine: void 0,
    method: void 0
  };
  if (line3 != null) {
    const match = line3.match(pathRegex);
    if (match) {
      pathResult.filePath = match[1].replace(/\?.*$/, "");
      pathResult.fullFilePath = `${href}${pathResult.filePath}`;
      const pathParts = pathResult.filePath.split("/");
      pathResult.fileName = pathParts[pathParts.length - 1];
      pathResult.fileLine = match[2];
      pathResult.fileColumn = match[3];
      pathResult.filePathWithLine = `${pathResult.filePath}:${pathResult.fileLine}`;
      pathResult.fileNameWithLine = `${pathResult.fileName}:${pathResult.fileLine}`;
    }
  }
  return pathResult;
}
__name(stackLineToStackFrame, "stackLineToStackFrame");
function isError(e2) {
  return e2 instanceof Error;
}
__name(isError, "isError");
function prettyFormatLogObj(maskedArgs, settings) {
  return maskedArgs.reduce((result, arg) => {
    isError(arg) ? result.errors.push(prettyFormatErrorObj(arg, settings)) : result.args.push(arg);
    return result;
  }, { args: [], errors: [] });
}
__name(prettyFormatLogObj, "prettyFormatLogObj");
function prettyFormatErrorObj(error, settings) {
  const errorStackStr = getErrorTrace(error).map((stackFrame) => {
    return formatTemplate(settings, settings.prettyErrorStackTemplate, { ...stackFrame }, true);
  });
  const placeholderValuesError = {
    errorName: ` ${error.name} `,
    errorMessage: Object.getOwnPropertyNames(error).reduce((result, key) => {
      if (key !== "stack") {
        result.push(error[key]);
      }
      return result;
    }, []).join(", "),
    errorStack: errorStackStr.join("\n")
  };
  return formatTemplate(settings, settings.prettyErrorTemplate, placeholderValuesError);
}
__name(prettyFormatErrorObj, "prettyFormatErrorObj");
function transportFormatted(logMetaMarkup, logArgs, logErrors, settings) {
  const logErrorsStr = (logErrors.length > 0 && logArgs.length > 0 ? "\n" : "") + logErrors.join("\n");
  settings.prettyInspectOptions.colors = settings.stylePrettyLogs;
  console.log(logMetaMarkup + formatWithOptions(settings.prettyInspectOptions, ...logArgs) + logErrorsStr);
}
__name(transportFormatted, "transportFormatted");
function transportJSON(json) {
  console.log(jsonStringifyRecursive(json));
}
__name(transportJSON, "transportJSON");
function isBuffer(arg) {
  return arg ? false : false;
}
__name(isBuffer, "isBuffer");
const _BaseLogger = class _BaseLogger {
  constructor(settings, logObj, stackDepthLevel = 4) {
    this.logObj = logObj;
    this.stackDepthLevel = stackDepthLevel;
    this.runtime = Runtime;
    this.settings = {
      type: settings?.type ?? "pretty",
      name: settings?.name,
      parentNames: settings?.parentNames,
      minLevel: settings?.minLevel ?? 0,
      argumentsArrayName: settings?.argumentsArrayName,
      hideLogPositionForProduction: settings?.hideLogPositionForProduction ?? false,
      prettyLogTemplate: settings?.prettyLogTemplate ?? "{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}	{{logLevelName}}	{{filePathWithLine}}{{nameWithDelimiterPrefix}}	",
      prettyErrorTemplate: settings?.prettyErrorTemplate ?? "\n{{errorName}} {{errorMessage}}\nerror stack:\n{{errorStack}}",
      prettyErrorStackTemplate: settings?.prettyErrorStackTemplate ?? "  • {{fileName}}	{{method}}\n	{{filePathWithLine}}",
      prettyErrorParentNamesSeparator: settings?.prettyErrorParentNamesSeparator ?? ":",
      prettyErrorLoggerNameDelimiter: settings?.prettyErrorLoggerNameDelimiter ?? "	",
      stylePrettyLogs: settings?.stylePrettyLogs ?? true,
      prettyLogTimeZone: settings?.prettyLogTimeZone ?? "UTC",
      prettyLogStyles: settings?.prettyLogStyles ?? {
        logLevelName: {
          "*": ["bold", "black", "bgWhiteBright", "dim"],
          SILLY: ["bold", "white"],
          TRACE: ["bold", "whiteBright"],
          DEBUG: ["bold", "green"],
          INFO: ["bold", "blue"],
          WARN: ["bold", "yellow"],
          ERROR: ["bold", "red"],
          FATAL: ["bold", "redBright"]
        },
        dateIsoStr: "white",
        filePathWithLine: "white",
        name: ["white", "bold"],
        nameWithDelimiterPrefix: ["white", "bold"],
        nameWithDelimiterSuffix: ["white", "bold"],
        errorName: ["bold", "bgRedBright", "whiteBright"],
        fileName: ["yellow"],
        fileNameWithLine: "white"
      },
      prettyInspectOptions: settings?.prettyInspectOptions ?? {
        colors: true,
        compact: false,
        depth: Infinity
      },
      metaProperty: settings?.metaProperty ?? "_meta",
      maskPlaceholder: settings?.maskPlaceholder ?? "[***]",
      maskValuesOfKeys: settings?.maskValuesOfKeys ?? ["password"],
      maskValuesOfKeysCaseInsensitive: settings?.maskValuesOfKeysCaseInsensitive ?? false,
      maskValuesRegEx: settings?.maskValuesRegEx,
      prefix: [...settings?.prefix ?? []],
      attachedTransports: [...settings?.attachedTransports ?? []],
      overwrite: {
        mask: settings?.overwrite?.mask,
        toLogObj: settings?.overwrite?.toLogObj,
        addMeta: settings?.overwrite?.addMeta,
        addPlaceholders: settings?.overwrite?.addPlaceholders,
        formatMeta: settings?.overwrite?.formatMeta,
        formatLogObj: settings?.overwrite?.formatLogObj,
        transportFormatted: settings?.overwrite?.transportFormatted,
        transportJSON: settings?.overwrite?.transportJSON
      }
    };
  }
  log(logLevelId, logLevelName, ...args) {
    if (logLevelId < this.settings.minLevel) {
      return;
    }
    const logArgs = [...this.settings.prefix, ...args];
    const maskedArgs = this.settings.overwrite?.mask != null ? this.settings.overwrite?.mask(logArgs) : this.settings.maskValuesOfKeys != null && this.settings.maskValuesOfKeys.length > 0 ? this._mask(logArgs) : logArgs;
    const thisLogObj = this.logObj != null ? this._recursiveCloneAndExecuteFunctions(this.logObj) : void 0;
    const logObj = this.settings.overwrite?.toLogObj != null ? this.settings.overwrite?.toLogObj(maskedArgs, thisLogObj) : this._toLogObj(maskedArgs, thisLogObj);
    const logObjWithMeta = this.settings.overwrite?.addMeta != null ? this.settings.overwrite?.addMeta(logObj, logLevelId, logLevelName) : this._addMetaToLogObj(logObj, logLevelId, logLevelName);
    let logMetaMarkup;
    let logArgsAndErrorsMarkup = void 0;
    if (this.settings.overwrite?.formatMeta != null) {
      logMetaMarkup = this.settings.overwrite?.formatMeta(logObjWithMeta?.[this.settings.metaProperty]);
    }
    if (this.settings.overwrite?.formatLogObj != null) {
      logArgsAndErrorsMarkup = this.settings.overwrite?.formatLogObj(maskedArgs, this.settings);
    }
    if (this.settings.type === "pretty") {
      logMetaMarkup = logMetaMarkup ?? this._prettyFormatLogObjMeta(logObjWithMeta?.[this.settings.metaProperty]);
      logArgsAndErrorsMarkup = logArgsAndErrorsMarkup ?? this.runtime.prettyFormatLogObj(maskedArgs, this.settings);
    }
    if (logMetaMarkup != null && logArgsAndErrorsMarkup != null) {
      this.settings.overwrite?.transportFormatted != null ? this.settings.overwrite?.transportFormatted(logMetaMarkup, logArgsAndErrorsMarkup.args, logArgsAndErrorsMarkup.errors, this.settings) : this.runtime.transportFormatted(logMetaMarkup, logArgsAndErrorsMarkup.args, logArgsAndErrorsMarkup.errors, this.settings);
    } else {
      this.settings.overwrite?.transportJSON != null ? this.settings.overwrite?.transportJSON(logObjWithMeta) : this.settings.type !== "hidden" ? this.runtime.transportJSON(logObjWithMeta) : void 0;
    }
    if (this.settings.attachedTransports != null && this.settings.attachedTransports.length > 0) {
      this.settings.attachedTransports.forEach((transportLogger) => {
        transportLogger(logObjWithMeta);
      });
    }
    return logObjWithMeta;
  }
  attachTransport(transportLogger) {
    this.settings.attachedTransports.push(transportLogger);
  }
  getSubLogger(settings, logObj) {
    const subLoggerSettings = {
      ...this.settings,
      ...settings,
      parentNames: this.settings?.parentNames != null && this.settings?.name != null ? [...this.settings.parentNames, this.settings.name] : this.settings?.name != null ? [this.settings.name] : void 0,
      prefix: [...this.settings.prefix, ...settings?.prefix ?? []]
    };
    const subLogger = new this.constructor(subLoggerSettings, logObj ?? this.logObj, this.stackDepthLevel);
    return subLogger;
  }
  _mask(args) {
    const maskValuesOfKeys = this.settings.maskValuesOfKeysCaseInsensitive !== true ? this.settings.maskValuesOfKeys : this.settings.maskValuesOfKeys.map((key) => key.toLowerCase());
    return args?.map((arg) => {
      return this._recursiveCloneAndMaskValuesOfKeys(arg, maskValuesOfKeys);
    });
  }
  _recursiveCloneAndMaskValuesOfKeys(source2, keys, seen = []) {
    if (seen.includes(source2)) {
      return { ...source2 };
    }
    if (typeof source2 === "object" && source2 !== null) {
      seen.push(source2);
    }
    if (this.runtime.isError(source2) || this.runtime.isBuffer(source2)) {
      return source2;
    } else if (source2 instanceof Map) {
      return new Map(source2);
    } else if (source2 instanceof Set) {
      return new Set(source2);
    } else if (Array.isArray(source2)) {
      return source2.map((item) => this._recursiveCloneAndMaskValuesOfKeys(item, keys, seen));
    } else if (source2 instanceof Date) {
      return new Date(source2.getTime());
    } else if (source2 instanceof URL) {
      return urlToObject(source2);
    } else if (source2 !== null && typeof source2 === "object") {
      const baseObject = this.runtime.isError(source2) ? this._cloneError(source2) : Object.create(Object.getPrototypeOf(source2));
      return Object.getOwnPropertyNames(source2).reduce((o, prop) => {
        o[prop] = keys.includes(this.settings?.maskValuesOfKeysCaseInsensitive !== true ? prop : prop.toLowerCase()) ? this.settings.maskPlaceholder : (() => {
          try {
            return this._recursiveCloneAndMaskValuesOfKeys(source2[prop], keys, seen);
          } catch (e2) {
            return null;
          }
        })();
        return o;
      }, baseObject);
    } else {
      if (typeof source2 === "string") {
        let modifiedSource = source2;
        for (const regEx of this.settings?.maskValuesRegEx || []) {
          modifiedSource = modifiedSource.replace(regEx, this.settings?.maskPlaceholder || "");
        }
        return modifiedSource;
      }
      return source2;
    }
  }
  _recursiveCloneAndExecuteFunctions(source2, seen = []) {
    if (this.isObjectOrArray(source2) && seen.includes(source2)) {
      return this.shallowCopy(source2);
    }
    if (this.isObjectOrArray(source2)) {
      seen.push(source2);
    }
    if (Array.isArray(source2)) {
      return source2.map((item) => this._recursiveCloneAndExecuteFunctions(item, seen));
    } else if (source2 instanceof Date) {
      return new Date(source2.getTime());
    } else if (this.isObject(source2)) {
      return Object.getOwnPropertyNames(source2).reduce((o, prop) => {
        const descriptor = Object.getOwnPropertyDescriptor(source2, prop);
        if (descriptor) {
          Object.defineProperty(o, prop, descriptor);
          const value = source2[prop];
          o[prop] = typeof value === "function" ? value() : this._recursiveCloneAndExecuteFunctions(value, seen);
        }
        return o;
      }, Object.create(Object.getPrototypeOf(source2)));
    } else {
      return source2;
    }
  }
  isObjectOrArray(value) {
    return typeof value === "object" && value !== null;
  }
  isObject(value) {
    return typeof value === "object" && !Array.isArray(value) && value !== null;
  }
  shallowCopy(source2) {
    if (Array.isArray(source2)) {
      return [...source2];
    } else {
      return { ...source2 };
    }
  }
  _toLogObj(args, clonedLogObj = {}) {
    args = args?.map((arg) => this.runtime.isError(arg) ? this._toErrorObject(arg) : arg);
    if (this.settings.argumentsArrayName == null) {
      if (args.length === 1 && !Array.isArray(args[0]) && this.runtime.isBuffer(args[0]) !== true && !(args[0] instanceof Date)) {
        clonedLogObj = typeof args[0] === "object" && args[0] != null ? { ...args[0], ...clonedLogObj } : { 0: args[0], ...clonedLogObj };
      } else {
        clonedLogObj = { ...clonedLogObj, ...args };
      }
    } else {
      clonedLogObj = {
        ...clonedLogObj,
        [this.settings.argumentsArrayName]: args
      };
    }
    return clonedLogObj;
  }
  _cloneError(error) {
    const cloned = new error.constructor();
    Object.getOwnPropertyNames(error).forEach((key) => {
      cloned[key] = error[key];
    });
    return cloned;
  }
  _toErrorObject(error) {
    return {
      nativeError: error,
      name: error.name ?? "Error",
      message: error.message,
      stack: this.runtime.getErrorTrace(error)
    };
  }
  _addMetaToLogObj(logObj, logLevelId, logLevelName) {
    return {
      ...logObj,
      [this.settings.metaProperty]: this.runtime.getMeta(logLevelId, logLevelName, this.stackDepthLevel, this.settings.hideLogPositionForProduction, this.settings.name, this.settings.parentNames)
    };
  }
  _prettyFormatLogObjMeta(logObjMeta) {
    if (logObjMeta == null) {
      return "";
    }
    let template2 = this.settings.prettyLogTemplate;
    const placeholderValues = {};
    if (template2.includes("{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}")) {
      template2 = template2.replace("{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}", "{{dateIsoStr}}");
    } else {
      if (this.settings.prettyLogTimeZone === "UTC") {
        placeholderValues["yyyy"] = logObjMeta?.date?.getUTCFullYear() ?? "----";
        placeholderValues["mm"] = formatNumberAddZeros(logObjMeta?.date?.getUTCMonth(), 2, 1);
        placeholderValues["dd"] = formatNumberAddZeros(logObjMeta?.date?.getUTCDate(), 2);
        placeholderValues["hh"] = formatNumberAddZeros(logObjMeta?.date?.getUTCHours(), 2);
        placeholderValues["MM"] = formatNumberAddZeros(logObjMeta?.date?.getUTCMinutes(), 2);
        placeholderValues["ss"] = formatNumberAddZeros(logObjMeta?.date?.getUTCSeconds(), 2);
        placeholderValues["ms"] = formatNumberAddZeros(logObjMeta?.date?.getUTCMilliseconds(), 3);
      } else {
        placeholderValues["yyyy"] = logObjMeta?.date?.getFullYear() ?? "----";
        placeholderValues["mm"] = formatNumberAddZeros(logObjMeta?.date?.getMonth(), 2, 1);
        placeholderValues["dd"] = formatNumberAddZeros(logObjMeta?.date?.getDate(), 2);
        placeholderValues["hh"] = formatNumberAddZeros(logObjMeta?.date?.getHours(), 2);
        placeholderValues["MM"] = formatNumberAddZeros(logObjMeta?.date?.getMinutes(), 2);
        placeholderValues["ss"] = formatNumberAddZeros(logObjMeta?.date?.getSeconds(), 2);
        placeholderValues["ms"] = formatNumberAddZeros(logObjMeta?.date?.getMilliseconds(), 3);
      }
    }
    const dateInSettingsTimeZone = this.settings.prettyLogTimeZone === "UTC" ? logObjMeta?.date : new Date(logObjMeta?.date?.getTime() - logObjMeta?.date?.getTimezoneOffset() * 6e4);
    placeholderValues["rawIsoStr"] = dateInSettingsTimeZone?.toISOString();
    placeholderValues["dateIsoStr"] = dateInSettingsTimeZone?.toISOString().replace("T", " ").replace("Z", "");
    placeholderValues["logLevelName"] = logObjMeta?.logLevelName;
    placeholderValues["fileNameWithLine"] = logObjMeta?.path?.fileNameWithLine ?? "";
    placeholderValues["filePathWithLine"] = logObjMeta?.path?.filePathWithLine ?? "";
    placeholderValues["fullFilePath"] = logObjMeta?.path?.fullFilePath ?? "";
    let parentNamesString = this.settings.parentNames?.join(this.settings.prettyErrorParentNamesSeparator);
    parentNamesString = parentNamesString != null && logObjMeta?.name != null ? parentNamesString + this.settings.prettyErrorParentNamesSeparator : void 0;
    placeholderValues["name"] = logObjMeta?.name != null || parentNamesString != null ? (parentNamesString ?? "") + logObjMeta?.name : "";
    placeholderValues["nameWithDelimiterPrefix"] = placeholderValues["name"].length > 0 ? this.settings.prettyErrorLoggerNameDelimiter + placeholderValues["name"] : "";
    placeholderValues["nameWithDelimiterSuffix"] = placeholderValues["name"].length > 0 ? placeholderValues["name"] + this.settings.prettyErrorLoggerNameDelimiter : "";
    if (this.settings.overwrite?.addPlaceholders != null) {
      this.settings.overwrite?.addPlaceholders(logObjMeta, placeholderValues);
    }
    return formatTemplate(this.settings, template2, placeholderValues);
  }
};
__name(_BaseLogger, "BaseLogger");
let BaseLogger = _BaseLogger;
let Logger$1 = (_f = class extends BaseLogger {
  constructor(settings, logObj) {
    const isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
    const isBrowserBlinkEngine = isBrowser ? window.chrome !== void 0 && window.CSS !== void 0 && window.CSS.supports("color", "green") : false;
    const isSafari = isBrowser ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : false;
    settings = settings || {};
    settings.stylePrettyLogs = settings.stylePrettyLogs && isBrowser && !isBrowserBlinkEngine ? false : settings.stylePrettyLogs;
    super(settings, logObj, isSafari ? 4 : 5);
  }
  log(logLevelId, logLevelName, ...args) {
    return super.log(logLevelId, logLevelName, ...args);
  }
  silly(...args) {
    return super.log(0, "SILLY", ...args);
  }
  trace(...args) {
    return super.log(1, "TRACE", ...args);
  }
  debug(...args) {
    return super.log(2, "DEBUG", ...args);
  }
  info(...args) {
    return super.log(3, "INFO", ...args);
  }
  warn(...args) {
    return super.log(4, "WARN", ...args);
  }
  error(...args) {
    return super.log(5, "ERROR", ...args);
  }
  fatal(...args) {
    return super.log(6, "FATAL", ...args);
  }
  getSubLogger(settings, logObj) {
    return super.getSubLogger(settings, logObj);
  }
}, __name(_f, "Logger"), _f);
const DefaultLogOptions = {
  type: "pretty"
};
const _Log = class _Log extends Logger$1 {
  constructor(_options = DefaultLogOptions) {
    const options = { ...DefaultLogOptions, ..._options };
    super({
      name: options.name || "ecmaos:kernel",
      type: options.type || "pretty",
      maskValuesOfKeysCaseInsensitive: true,
      hideLogPositionForProduction: true,
      prettyLogTemplate: "{{dateIsoStr}} {{name}} {{logLevelName}}	 {{icon}}	 ",
      prettyErrorTemplate: "{{errorName}} {{errorMessage}} {{errorStack}}",
      overwrite: {
        /* v8 ignore start */
        addPlaceholders: /* @__PURE__ */ __name((logObjMeta, placeholderValues) => {
          switch (logObjMeta.logLevelName) {
            case "DEBUG":
              placeholderValues.icon = "🔍";
              break;
            case "INFO":
              placeholderValues.icon = "💡";
              break;
            case "WARN":
              placeholderValues.icon = "⚠️";
              break;
            case "ERROR":
              placeholderValues.icon = "🚨";
              break;
            case "FATAL":
              placeholderValues.icon = "💀";
              break;
            default:
              placeholderValues.icon = "💬";
              break;
          }
        }, "addPlaceholders")
        /* v8 ignore end */
      }
    });
    __publicField(this, "_name");
    this._name = options.name || "ecmaos:kernel";
    if (options.silent) {
      this.silly = () => void 0;
      this.debug = () => void 0;
      this.info = () => void 0;
      this.warn = () => void 0;
      this.error = () => void 0;
      this.fatal = () => void 0;
    }
  }
  get name() {
    return this._name;
  }
};
__name(_Log, "Log");
let Log = _Log;
const dots = { "interval": 80, "frames": ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"] };
const dots2 = { "interval": 80, "frames": ["⣾", "⣽", "⣻", "⢿", "⡿", "⣟", "⣯", "⣷"] };
const dots3 = { "interval": 80, "frames": ["⠋", "⠙", "⠚", "⠞", "⠖", "⠦", "⠴", "⠲", "⠳", "⠓"] };
const dots4 = { "interval": 80, "frames": ["⠄", "⠆", "⠇", "⠋", "⠙", "⠸", "⠰", "⠠", "⠰", "⠸", "⠙", "⠋", "⠇", "⠆"] };
const dots5 = { "interval": 80, "frames": ["⠋", "⠙", "⠚", "⠒", "⠂", "⠂", "⠒", "⠲", "⠴", "⠦", "⠖", "⠒", "⠐", "⠐", "⠒", "⠓", "⠋"] };
const dots6 = { "interval": 80, "frames": ["⠁", "⠉", "⠙", "⠚", "⠒", "⠂", "⠂", "⠒", "⠲", "⠴", "⠤", "⠄", "⠄", "⠤", "⠴", "⠲", "⠒", "⠂", "⠂", "⠒", "⠚", "⠙", "⠉", "⠁"] };
const dots7 = { "interval": 80, "frames": ["⠈", "⠉", "⠋", "⠓", "⠒", "⠐", "⠐", "⠒", "⠖", "⠦", "⠤", "⠠", "⠠", "⠤", "⠦", "⠖", "⠒", "⠐", "⠐", "⠒", "⠓", "⠋", "⠉", "⠈"] };
const dots8 = { "interval": 80, "frames": ["⠁", "⠁", "⠉", "⠙", "⠚", "⠒", "⠂", "⠂", "⠒", "⠲", "⠴", "⠤", "⠄", "⠄", "⠤", "⠠", "⠠", "⠤", "⠦", "⠖", "⠒", "⠐", "⠐", "⠒", "⠓", "⠋", "⠉", "⠈", "⠈"] };
const dots9 = { "interval": 80, "frames": ["⢹", "⢺", "⢼", "⣸", "⣇", "⡧", "⡗", "⡏"] };
const dots10 = { "interval": 80, "frames": ["⢄", "⢂", "⢁", "⡁", "⡈", "⡐", "⡠"] };
const dots11 = { "interval": 100, "frames": ["⠁", "⠂", "⠄", "⡀", "⢀", "⠠", "⠐", "⠈"] };
const dots12 = { "interval": 80, "frames": ["⢀⠀", "⡀⠀", "⠄⠀", "⢂⠀", "⡂⠀", "⠅⠀", "⢃⠀", "⡃⠀", "⠍⠀", "⢋⠀", "⡋⠀", "⠍⠁", "⢋⠁", "⡋⠁", "⠍⠉", "⠋⠉", "⠋⠉", "⠉⠙", "⠉⠙", "⠉⠩", "⠈⢙", "⠈⡙", "⢈⠩", "⡀⢙", "⠄⡙", "⢂⠩", "⡂⢘", "⠅⡘", "⢃⠨", "⡃⢐", "⠍⡐", "⢋⠠", "⡋⢀", "⠍⡁", "⢋⠁", "⡋⠁", "⠍⠉", "⠋⠉", "⠋⠉", "⠉⠙", "⠉⠙", "⠉⠩", "⠈⢙", "⠈⡙", "⠈⠩", "⠀⢙", "⠀⡙", "⠀⠩", "⠀⢘", "⠀⡘", "⠀⠨", "⠀⢐", "⠀⡐", "⠀⠠", "⠀⢀", "⠀⡀"] };
const dots13 = { "interval": 80, "frames": ["⣼", "⣹", "⢻", "⠿", "⡟", "⣏", "⣧", "⣶"] };
const dots14 = { "interval": 80, "frames": ["⠉⠉", "⠈⠙", "⠀⠹", "⠀⢸", "⠀⣰", "⢀⣠", "⣀⣀", "⣄⡀", "⣆⠀", "⡇⠀", "⠏⠀", "⠋⠁"] };
const dots8Bit = { "interval": 80, "frames": ["⠀", "⠁", "⠂", "⠃", "⠄", "⠅", "⠆", "⠇", "⡀", "⡁", "⡂", "⡃", "⡄", "⡅", "⡆", "⡇", "⠈", "⠉", "⠊", "⠋", "⠌", "⠍", "⠎", "⠏", "⡈", "⡉", "⡊", "⡋", "⡌", "⡍", "⡎", "⡏", "⠐", "⠑", "⠒", "⠓", "⠔", "⠕", "⠖", "⠗", "⡐", "⡑", "⡒", "⡓", "⡔", "⡕", "⡖", "⡗", "⠘", "⠙", "⠚", "⠛", "⠜", "⠝", "⠞", "⠟", "⡘", "⡙", "⡚", "⡛", "⡜", "⡝", "⡞", "⡟", "⠠", "⠡", "⠢", "⠣", "⠤", "⠥", "⠦", "⠧", "⡠", "⡡", "⡢", "⡣", "⡤", "⡥", "⡦", "⡧", "⠨", "⠩", "⠪", "⠫", "⠬", "⠭", "⠮", "⠯", "⡨", "⡩", "⡪", "⡫", "⡬", "⡭", "⡮", "⡯", "⠰", "⠱", "⠲", "⠳", "⠴", "⠵", "⠶", "⠷", "⡰", "⡱", "⡲", "⡳", "⡴", "⡵", "⡶", "⡷", "⠸", "⠹", "⠺", "⠻", "⠼", "⠽", "⠾", "⠿", "⡸", "⡹", "⡺", "⡻", "⡼", "⡽", "⡾", "⡿", "⢀", "⢁", "⢂", "⢃", "⢄", "⢅", "⢆", "⢇", "⣀", "⣁", "⣂", "⣃", "⣄", "⣅", "⣆", "⣇", "⢈", "⢉", "⢊", "⢋", "⢌", "⢍", "⢎", "⢏", "⣈", "⣉", "⣊", "⣋", "⣌", "⣍", "⣎", "⣏", "⢐", "⢑", "⢒", "⢓", "⢔", "⢕", "⢖", "⢗", "⣐", "⣑", "⣒", "⣓", "⣔", "⣕", "⣖", "⣗", "⢘", "⢙", "⢚", "⢛", "⢜", "⢝", "⢞", "⢟", "⣘", "⣙", "⣚", "⣛", "⣜", "⣝", "⣞", "⣟", "⢠", "⢡", "⢢", "⢣", "⢤", "⢥", "⢦", "⢧", "⣠", "⣡", "⣢", "⣣", "⣤", "⣥", "⣦", "⣧", "⢨", "⢩", "⢪", "⢫", "⢬", "⢭", "⢮", "⢯", "⣨", "⣩", "⣪", "⣫", "⣬", "⣭", "⣮", "⣯", "⢰", "⢱", "⢲", "⢳", "⢴", "⢵", "⢶", "⢷", "⣰", "⣱", "⣲", "⣳", "⣴", "⣵", "⣶", "⣷", "⢸", "⢹", "⢺", "⢻", "⢼", "⢽", "⢾", "⢿", "⣸", "⣹", "⣺", "⣻", "⣼", "⣽", "⣾", "⣿"] };
const dotsCircle = { "interval": 80, "frames": ["⢎ ", "⠎⠁", "⠊⠑", "⠈⠱", " ⡱", "⢀⡰", "⢄⡠", "⢆⡀"] };
const sand = { "interval": 80, "frames": ["⠁", "⠂", "⠄", "⡀", "⡈", "⡐", "⡠", "⣀", "⣁", "⣂", "⣄", "⣌", "⣔", "⣤", "⣥", "⣦", "⣮", "⣶", "⣷", "⣿", "⡿", "⠿", "⢟", "⠟", "⡛", "⠛", "⠫", "⢋", "⠋", "⠍", "⡉", "⠉", "⠑", "⠡", "⢁"] };
const line = { "interval": 130, "frames": ["-", "\\", "|", "/"] };
const line2 = { "interval": 100, "frames": ["⠂", "-", "–", "—", "–", "-"] };
const pipe = { "interval": 100, "frames": ["┤", "┘", "┴", "└", "├", "┌", "┬", "┐"] };
const simpleDots = { "interval": 400, "frames": [".  ", ".. ", "...", "   "] };
const simpleDotsScrolling = { "interval": 200, "frames": [".  ", ".. ", "...", " ..", "  .", "   "] };
const star = { "interval": 70, "frames": ["✶", "✸", "✹", "✺", "✹", "✷"] };
const star2 = { "interval": 80, "frames": ["+", "x", "*"] };
const flip = { "interval": 70, "frames": ["_", "_", "_", "-", "`", "`", "'", "´", "-", "_", "_", "_"] };
const hamburger = { "interval": 100, "frames": ["☱", "☲", "☴"] };
const growVertical = { "interval": 120, "frames": ["▁", "▃", "▄", "▅", "▆", "▇", "▆", "▅", "▄", "▃"] };
const growHorizontal = { "interval": 120, "frames": ["▏", "▎", "▍", "▌", "▋", "▊", "▉", "▊", "▋", "▌", "▍", "▎"] };
const balloon = { "interval": 140, "frames": [" ", ".", "o", "O", "@", "*", " "] };
const balloon2 = { "interval": 120, "frames": [".", "o", "O", "°", "O", "o", "."] };
const noise = { "interval": 100, "frames": ["▓", "▒", "░"] };
const bounce = { "interval": 120, "frames": ["⠁", "⠂", "⠄", "⠂"] };
const boxBounce = { "interval": 120, "frames": ["▖", "▘", "▝", "▗"] };
const boxBounce2 = { "interval": 100, "frames": ["▌", "▀", "▐", "▄"] };
const triangle = { "interval": 50, "frames": ["◢", "◣", "◤", "◥"] };
const binary = { "interval": 80, "frames": ["010010", "001100", "100101", "111010", "111101", "010111", "101011", "111000", "110011", "110101"] };
const arc = { "interval": 100, "frames": ["◜", "◠", "◝", "◞", "◡", "◟"] };
const circle = { "interval": 120, "frames": ["◡", "⊙", "◠"] };
const squareCorners = { "interval": 180, "frames": ["◰", "◳", "◲", "◱"] };
const circleQuarters = { "interval": 120, "frames": ["◴", "◷", "◶", "◵"] };
const circleHalves = { "interval": 50, "frames": ["◐", "◓", "◑", "◒"] };
const squish = { "interval": 100, "frames": ["╫", "╪"] };
const toggle = { "interval": 250, "frames": ["⊶", "⊷"] };
const toggle2 = { "interval": 80, "frames": ["▫", "▪"] };
const toggle3 = { "interval": 120, "frames": ["□", "■"] };
const toggle4 = { "interval": 100, "frames": ["■", "□", "▪", "▫"] };
const toggle5 = { "interval": 100, "frames": ["▮", "▯"] };
const toggle6 = { "interval": 300, "frames": ["ဝ", "၀"] };
const toggle7 = { "interval": 80, "frames": ["⦾", "⦿"] };
const toggle8 = { "interval": 100, "frames": ["◍", "◌"] };
const toggle9 = { "interval": 100, "frames": ["◉", "◎"] };
const toggle10 = { "interval": 100, "frames": ["㊂", "㊀", "㊁"] };
const toggle11 = { "interval": 50, "frames": ["⧇", "⧆"] };
const toggle12 = { "interval": 120, "frames": ["☗", "☖"] };
const toggle13 = { "interval": 80, "frames": ["=", "*", "-"] };
const arrow = { "interval": 100, "frames": ["←", "↖", "↑", "↗", "→", "↘", "↓", "↙"] };
const arrow2 = { "interval": 80, "frames": ["⬆️ ", "↗️ ", "➡️ ", "↘️ ", "⬇️ ", "↙️ ", "⬅️ ", "↖️ "] };
const arrow3 = { "interval": 120, "frames": ["▹▹▹▹▹", "▸▹▹▹▹", "▹▸▹▹▹", "▹▹▸▹▹", "▹▹▹▸▹", "▹▹▹▹▸"] };
const bouncingBar = { "interval": 80, "frames": ["[    ]", "[=   ]", "[==  ]", "[=== ]", "[====]", "[ ===]", "[  ==]", "[   =]", "[    ]", "[   =]", "[  ==]", "[ ===]", "[====]", "[=== ]", "[==  ]", "[=   ]"] };
const bouncingBall = { "interval": 80, "frames": ["( ●    )", "(  ●   )", "(   ●  )", "(    ● )", "(     ●)", "(    ● )", "(   ●  )", "(  ●   )", "( ●    )", "(●     )"] };
const smiley = { "interval": 200, "frames": ["😄 ", "😝 "] };
const monkey = { "interval": 300, "frames": ["🙈 ", "🙈 ", "🙉 ", "🙊 "] };
const hearts = { "interval": 100, "frames": ["💛 ", "💙 ", "💜 ", "💚 ", "❤️ "] };
const clock = { "interval": 100, "frames": ["🕛 ", "🕐 ", "🕑 ", "🕒 ", "🕓 ", "🕔 ", "🕕 ", "🕖 ", "🕗 ", "🕘 ", "🕙 ", "🕚 "] };
const earth = { "interval": 180, "frames": ["🌍 ", "🌎 ", "🌏 "] };
const material = { "interval": 17, "frames": ["█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "███▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "████▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "██████▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "██████▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "███████▁▁▁▁▁▁▁▁▁▁▁▁▁", "████████▁▁▁▁▁▁▁▁▁▁▁▁", "█████████▁▁▁▁▁▁▁▁▁▁▁", "█████████▁▁▁▁▁▁▁▁▁▁▁", "██████████▁▁▁▁▁▁▁▁▁▁", "███████████▁▁▁▁▁▁▁▁▁", "█████████████▁▁▁▁▁▁▁", "██████████████▁▁▁▁▁▁", "██████████████▁▁▁▁▁▁", "▁██████████████▁▁▁▁▁", "▁██████████████▁▁▁▁▁", "▁██████████████▁▁▁▁▁", "▁▁██████████████▁▁▁▁", "▁▁▁██████████████▁▁▁", "▁▁▁▁█████████████▁▁▁", "▁▁▁▁██████████████▁▁", "▁▁▁▁██████████████▁▁", "▁▁▁▁▁██████████████▁", "▁▁▁▁▁██████████████▁", "▁▁▁▁▁██████████████▁", "▁▁▁▁▁▁██████████████", "▁▁▁▁▁▁██████████████", "▁▁▁▁▁▁▁█████████████", "▁▁▁▁▁▁▁█████████████", "▁▁▁▁▁▁▁▁████████████", "▁▁▁▁▁▁▁▁████████████", "▁▁▁▁▁▁▁▁▁███████████", "▁▁▁▁▁▁▁▁▁███████████", "▁▁▁▁▁▁▁▁▁▁██████████", "▁▁▁▁▁▁▁▁▁▁██████████", "▁▁▁▁▁▁▁▁▁▁▁▁████████", "▁▁▁▁▁▁▁▁▁▁▁▁▁███████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁██████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████", "█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████", "██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███", "██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███", "███▁▁▁▁▁▁▁▁▁▁▁▁▁▁███", "████▁▁▁▁▁▁▁▁▁▁▁▁▁▁██", "█████▁▁▁▁▁▁▁▁▁▁▁▁▁▁█", "█████▁▁▁▁▁▁▁▁▁▁▁▁▁▁█", "██████▁▁▁▁▁▁▁▁▁▁▁▁▁█", "████████▁▁▁▁▁▁▁▁▁▁▁▁", "█████████▁▁▁▁▁▁▁▁▁▁▁", "█████████▁▁▁▁▁▁▁▁▁▁▁", "█████████▁▁▁▁▁▁▁▁▁▁▁", "█████████▁▁▁▁▁▁▁▁▁▁▁", "███████████▁▁▁▁▁▁▁▁▁", "████████████▁▁▁▁▁▁▁▁", "████████████▁▁▁▁▁▁▁▁", "██████████████▁▁▁▁▁▁", "██████████████▁▁▁▁▁▁", "▁██████████████▁▁▁▁▁", "▁██████████████▁▁▁▁▁", "▁▁▁█████████████▁▁▁▁", "▁▁▁▁▁████████████▁▁▁", "▁▁▁▁▁████████████▁▁▁", "▁▁▁▁▁▁███████████▁▁▁", "▁▁▁▁▁▁▁▁█████████▁▁▁", "▁▁▁▁▁▁▁▁█████████▁▁▁", "▁▁▁▁▁▁▁▁▁█████████▁▁", "▁▁▁▁▁▁▁▁▁█████████▁▁", "▁▁▁▁▁▁▁▁▁▁█████████▁", "▁▁▁▁▁▁▁▁▁▁▁████████▁", "▁▁▁▁▁▁▁▁▁▁▁████████▁", "▁▁▁▁▁▁▁▁▁▁▁▁███████▁", "▁▁▁▁▁▁▁▁▁▁▁▁███████▁", "▁▁▁▁▁▁▁▁▁▁▁▁▁███████", "▁▁▁▁▁▁▁▁▁▁▁▁▁███████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁"] };
const moon = { "interval": 80, "frames": ["🌑 ", "🌒 ", "🌓 ", "🌔 ", "🌕 ", "🌖 ", "🌗 ", "🌘 "] };
const runner = { "interval": 140, "frames": ["🚶 ", "🏃 "] };
const pong = { "interval": 80, "frames": ["▐⠂       ▌", "▐⠈       ▌", "▐ ⠂      ▌", "▐ ⠠      ▌", "▐  ⡀     ▌", "▐  ⠠     ▌", "▐   ⠂    ▌", "▐   ⠈    ▌", "▐    ⠂   ▌", "▐    ⠠   ▌", "▐     ⡀  ▌", "▐     ⠠  ▌", "▐      ⠂ ▌", "▐      ⠈ ▌", "▐       ⠂▌", "▐       ⠠▌", "▐       ⡀▌", "▐      ⠠ ▌", "▐      ⠂ ▌", "▐     ⠈  ▌", "▐     ⠂  ▌", "▐    ⠠   ▌", "▐    ⡀   ▌", "▐   ⠠    ▌", "▐   ⠂    ▌", "▐  ⠈     ▌", "▐  ⠂     ▌", "▐ ⠠      ▌", "▐ ⡀      ▌", "▐⠠       ▌"] };
const shark = { "interval": 120, "frames": ["▐|\\____________▌", "▐_|\\___________▌", "▐__|\\__________▌", "▐___|\\_________▌", "▐____|\\________▌", "▐_____|\\_______▌", "▐______|\\______▌", "▐_______|\\_____▌", "▐________|\\____▌", "▐_________|\\___▌", "▐__________|\\__▌", "▐___________|\\_▌", "▐____________|\\▌", "▐____________/|▌", "▐___________/|_▌", "▐__________/|__▌", "▐_________/|___▌", "▐________/|____▌", "▐_______/|_____▌", "▐______/|______▌", "▐_____/|_______▌", "▐____/|________▌", "▐___/|_________▌", "▐__/|__________▌", "▐_/|___________▌", "▐/|____________▌"] };
const dqpb = { "interval": 100, "frames": ["d", "q", "p", "b"] };
const weather = { "interval": 100, "frames": ["☀️ ", "☀️ ", "☀️ ", "🌤 ", "⛅️ ", "🌥 ", "☁️ ", "🌧 ", "🌨 ", "🌧 ", "🌨 ", "🌧 ", "🌨 ", "⛈ ", "🌨 ", "🌧 ", "🌨 ", "☁️ ", "🌥 ", "⛅️ ", "🌤 ", "☀️ ", "☀️ "] };
const christmas = { "interval": 400, "frames": ["🌲", "🎄"] };
const grenade = { "interval": 80, "frames": ["،  ", "′  ", " ´ ", " ‾ ", "  ⸌", "  ⸊", "  |", "  ⁎", "  ⁕", " ෴ ", "  ⁓", "   ", "   ", "   "] };
const point = { "interval": 125, "frames": ["∙∙∙", "●∙∙", "∙●∙", "∙∙●", "∙∙∙"] };
const layer = { "interval": 150, "frames": ["-", "=", "≡"] };
const betaWave = { "interval": 80, "frames": ["ρββββββ", "βρβββββ", "ββρββββ", "βββρβββ", "ββββρββ", "βββββρβ", "ββββββρ"] };
const fingerDance = { "interval": 160, "frames": ["🤘 ", "🤟 ", "🖖 ", "✋ ", "🤚 ", "👆 "] };
const fistBump = { "interval": 80, "frames": ["🤜　　　　🤛 ", "🤜　　　　🤛 ", "🤜　　　　🤛 ", "　🤜　　🤛　 ", "　　🤜🤛　　 ", "　🤜✨🤛　　 ", "🤜　✨　🤛　 "] };
const soccerHeader = { "interval": 80, "frames": [" 🧑⚽️       🧑 ", "🧑  ⚽️      🧑 ", "🧑   ⚽️     🧑 ", "🧑    ⚽️    🧑 ", "🧑     ⚽️   🧑 ", "🧑      ⚽️  🧑 ", "🧑       ⚽️🧑  ", "🧑      ⚽️  🧑 ", "🧑     ⚽️   🧑 ", "🧑    ⚽️    🧑 ", "🧑   ⚽️     🧑 ", "🧑  ⚽️      🧑 "] };
const mindblown = { "interval": 160, "frames": ["😐 ", "😐 ", "😮 ", "😮 ", "😦 ", "😦 ", "😧 ", "😧 ", "🤯 ", "💥 ", "✨ ", "　 ", "　 ", "　 "] };
const speaker = { "interval": 160, "frames": ["🔈 ", "🔉 ", "🔊 ", "🔉 "] };
const orangePulse = { "interval": 100, "frames": ["🔸 ", "🔶 ", "🟠 ", "🟠 ", "🔶 "] };
const bluePulse = { "interval": 100, "frames": ["🔹 ", "🔷 ", "🔵 ", "🔵 ", "🔷 "] };
const orangeBluePulse = { "interval": 100, "frames": ["🔸 ", "🔶 ", "🟠 ", "🟠 ", "🔶 ", "🔹 ", "🔷 ", "🔵 ", "🔵 ", "🔷 "] };
const timeTravel = { "interval": 100, "frames": ["🕛 ", "🕚 ", "🕙 ", "🕘 ", "🕗 ", "🕖 ", "🕕 ", "🕔 ", "🕓 ", "🕒 ", "🕑 ", "🕐 "] };
const aesthetic = { "interval": 80, "frames": ["▰▱▱▱▱▱▱", "▰▰▱▱▱▱▱", "▰▰▰▱▱▱▱", "▰▰▰▰▱▱▱", "▰▰▰▰▰▱▱", "▰▰▰▰▰▰▱", "▰▰▰▰▰▰▰", "▰▱▱▱▱▱▱"] };
const dwarfFortress = { "interval": 80, "frames": [" ██████£££  ", "☺██████£££  ", "☺██████£££  ", "☺▓█████£££  ", "☺▓█████£££  ", "☺▒█████£££  ", "☺▒█████£££  ", "☺░█████£££  ", "☺░█████£££  ", "☺ █████£££  ", " ☺█████£££  ", " ☺█████£££  ", " ☺▓████£££  ", " ☺▓████£££  ", " ☺▒████£££  ", " ☺▒████£££  ", " ☺░████£££  ", " ☺░████£££  ", " ☺ ████£££  ", "  ☺████£££  ", "  ☺████£££  ", "  ☺▓███£££  ", "  ☺▓███£££  ", "  ☺▒███£££  ", "  ☺▒███£££  ", "  ☺░███£££  ", "  ☺░███£££  ", "  ☺ ███£££  ", "   ☺███£££  ", "   ☺███£££  ", "   ☺▓██£££  ", "   ☺▓██£££  ", "   ☺▒██£££  ", "   ☺▒██£££  ", "   ☺░██£££  ", "   ☺░██£££  ", "   ☺ ██£££  ", "    ☺██£££  ", "    ☺██£££  ", "    ☺▓█£££  ", "    ☺▓█£££  ", "    ☺▒█£££  ", "    ☺▒█£££  ", "    ☺░█£££  ", "    ☺░█£££  ", "    ☺ █£££  ", "     ☺█£££  ", "     ☺█£££  ", "     ☺▓£££  ", "     ☺▓£££  ", "     ☺▒£££  ", "     ☺▒£££  ", "     ☺░£££  ", "     ☺░£££  ", "     ☺ £££  ", "      ☺£££  ", "      ☺£££  ", "      ☺▓££  ", "      ☺▓££  ", "      ☺▒££  ", "      ☺▒££  ", "      ☺░££  ", "      ☺░££  ", "      ☺ ££  ", "       ☺££  ", "       ☺££  ", "       ☺▓£  ", "       ☺▓£  ", "       ☺▒£  ", "       ☺▒£  ", "       ☺░£  ", "       ☺░£  ", "       ☺ £  ", "        ☺£  ", "        ☺£  ", "        ☺▓  ", "        ☺▓  ", "        ☺▒  ", "        ☺▒  ", "        ☺░  ", "        ☺░  ", "        ☺   ", "        ☺  &", "        ☺ ☼&", "       ☺ ☼ &", "       ☺☼  &", "      ☺☼  & ", "      ‼   & ", "     ☺   &  ", "    ‼    &  ", "   ☺    &   ", "  ‼     &   ", " ☺     &    ", "‼      &    ", "      &     ", "      &     ", "     &   ░  ", "     &   ▒  ", "    &    ▓  ", "    &    £  ", "   &    ░£  ", "   &    ▒£  ", "  &     ▓£  ", "  &     ££  ", " &     ░££  ", " &     ▒££  ", "&      ▓££  ", "&      £££  ", "      ░£££  ", "      ▒£££  ", "      ▓£££  ", "      █£££  ", "     ░█£££  ", "     ▒█£££  ", "     ▓█£££  ", "     ██£££  ", "    ░██£££  ", "    ▒██£££  ", "    ▓██£££  ", "    ███£££  ", "   ░███£££  ", "   ▒███£££  ", "   ▓███£££  ", "   ████£££  ", "  ░████£££  ", "  ▒████£££  ", "  ▓████£££  ", "  █████£££  ", " ░█████£££  ", " ▒█████£££  ", " ▓█████£££  ", " ██████£££  ", " ██████£££  "] };
const spinners = {
  dots,
  dots2,
  dots3,
  dots4,
  dots5,
  dots6,
  dots7,
  dots8,
  dots9,
  dots10,
  dots11,
  dots12,
  dots13,
  dots14,
  dots8Bit,
  dotsCircle,
  sand,
  line,
  line2,
  pipe,
  simpleDots,
  simpleDotsScrolling,
  star,
  star2,
  flip,
  hamburger,
  growVertical,
  growHorizontal,
  balloon,
  balloon2,
  noise,
  bounce,
  boxBounce,
  boxBounce2,
  triangle,
  binary,
  arc,
  circle,
  squareCorners,
  circleQuarters,
  circleHalves,
  squish,
  toggle,
  toggle2,
  toggle3,
  toggle4,
  toggle5,
  toggle6,
  toggle7,
  toggle8,
  toggle9,
  toggle10,
  toggle11,
  toggle12,
  toggle13,
  arrow,
  arrow2,
  arrow3,
  bouncingBar,
  bouncingBall,
  smiley,
  monkey,
  hearts,
  clock,
  earth,
  material,
  moon,
  runner,
  pong,
  shark,
  dqpb,
  weather,
  christmas,
  grenade,
  point,
  layer,
  betaWave,
  fingerDance,
  fistBump,
  soccerHeader,
  mindblown,
  speaker,
  orangePulse,
  bluePulse,
  orangeBluePulse,
  timeTravel,
  aesthetic,
  dwarfFortress
};
const EMOJI = {
  "-1": "👎",
  "+1": "👍",
  "100": "💯",
  "1234": "🔢",
  "8ball": "🎱",
  a: "🅰️",
  ab: "🆎",
  abacus: "🧮",
  abc: "🔤",
  abcd: "🔡",
  accept: "🉑",
  accordion: "🪗",
  adhesive_bandage: "🩹",
  admission_tickets: "🎟️",
  adult: "🧑",
  aerial_tramway: "🚡",
  airplane_arriving: "🛬",
  airplane_departure: "🛫",
  airplane: "✈️",
  alarm_clock: "⏰",
  alembic: "⚗️",
  alien: "👽",
  ambulance: "🚑",
  amphora: "🏺",
  anatomical_heart: "🫀",
  anchor: "⚓",
  angel: "👼",
  anger: "💢",
  angry: "😠",
  anguished: "😧",
  ant: "🐜",
  apple: "🍎",
  aquarius: "♒",
  aries: "♈",
  arrow_backward: "◀️",
  arrow_double_down: "⏬",
  arrow_double_up: "⏫",
  arrow_down_small: "🔽",
  arrow_down: "⬇️",
  arrow_forward: "▶️",
  arrow_heading_down: "⤵️",
  arrow_heading_up: "⤴️",
  arrow_left: "⬅️",
  arrow_lower_left: "↙️",
  arrow_lower_right: "↘️",
  arrow_right_hook: "↪️",
  arrow_right: "➡️",
  arrow_up_down: "↕️",
  arrow_up_small: "🔼",
  arrow_up: "⬆️",
  arrow_upper_left: "↖️",
  arrow_upper_right: "↗️",
  arrows_clockwise: "🔃",
  arrows_counterclockwise: "🔄",
  art: "🎨",
  articulated_lorry: "🚛",
  artist: "🧑‍🎨",
  astonished: "😲",
  astronaut: "🧑‍🚀",
  athletic_shoe: "👟",
  atm: "🏧",
  atom_symbol: "⚛️",
  auto_rickshaw: "🛺",
  avocado: "🥑",
  axe: "🪓",
  b: "🅱️",
  baby_bottle: "🍼",
  baby_chick: "🐤",
  baby_symbol: "🚼",
  baby: "👶",
  back: "🔙",
  bacon: "🥓",
  badger: "🦡",
  badminton_racquet_and_shuttlecock: "🏸",
  bagel: "🥯",
  baggage_claim: "🛄",
  baguette_bread: "🥖",
  bald_man: "👨‍🦲",
  bald_person: "🧑‍🦲",
  bald_woman: "👩‍🦲",
  ballet_shoes: "🩰",
  balloon: "🎈",
  ballot_box_with_ballot: "🗳️",
  ballot_box_with_check: "☑️",
  bamboo: "🎍",
  banana: "🍌",
  bangbang: "‼️",
  banjo: "🪕",
  bank: "🏦",
  bar_chart: "📊",
  barber: "💈",
  barely_sunny: "🌥️",
  baseball: "⚾",
  basket: "🧺",
  basketball: "🏀",
  bat: "🦇",
  bath: "🛀",
  bathtub: "🛁",
  battery: "🔋",
  beach_with_umbrella: "🏖️",
  bear: "🐻",
  bearded_person: "🧔",
  beaver: "🦫",
  bed: "🛏️",
  bee: "🐝",
  beer: "🍺",
  beers: "🍻",
  beetle: "🪲",
  beginner: "🔰",
  bell_pepper: "🫑",
  bell: "🔔",
  bellhop_bell: "🛎️",
  bento: "🍱",
  beverage_box: "🧃",
  bicyclist: "🚴‍♂️",
  bike: "🚲",
  bikini: "👙",
  billed_cap: "🧢",
  biohazard_sign: "☣️",
  bird: "🐦",
  birthday: "🎂",
  bison: "🦬",
  black_cat: "🐈‍⬛",
  black_circle_for_record: "⏺️",
  black_circle: "⚫",
  black_heart: "🖤",
  black_joker: "🃏",
  black_large_square: "⬛",
  black_left_pointing_double_triangle_with_vertical_bar: "⏮️",
  black_medium_small_square: "◾",
  black_medium_square: "◼️",
  black_nib: "✒️",
  black_right_pointing_double_triangle_with_vertical_bar: "⏭️",
  black_right_pointing_triangle_with_double_vertical_bar: "⏯️",
  black_small_square: "▪️",
  black_square_button: "🔲",
  black_square_for_stop: "⏹️",
  blond_haired_man: "👱‍♂️",
  blond_haired_woman: "👱‍♀️",
  blossom: "🌼",
  blowfish: "🐡",
  blue_book: "📘",
  blue_car: "🚙",
  blue_heart: "💙",
  blueberries: "🫐",
  blush: "😊",
  boar: "🐗",
  boat: "⛵",
  bomb: "💣",
  bone: "🦴",
  book: "📖",
  bookmark_tabs: "📑",
  bookmark: "🔖",
  books: "📚",
  boom: "💥",
  boomerang: "🪃",
  boot: "👢",
  bouquet: "💐",
  bow_and_arrow: "🏹",
  bow: "🙇‍♂️",
  bowl_with_spoon: "🥣",
  bowling: "🎳",
  boxing_glove: "🥊",
  boy: "👦",
  brain: "🧠",
  bread: "🍞",
  breast_feeding: "🤱",
  bricks: "🧱",
  bride_with_veil: "👰",
  bridge_at_night: "🌉",
  briefcase: "💼",
  briefs: "🩲",
  broccoli: "🥦",
  broken_heart: "💔",
  broom: "🧹",
  brown_heart: "🤎",
  bubble_tea: "🧋",
  bucket: "🪣",
  bug: "🐛",
  building_construction: "🏗️",
  bulb: "💡",
  bullettrain_front: "🚅",
  bullettrain_side: "🚄",
  burrito: "🌯",
  bus: "🚌",
  busstop: "🚏",
  bust_in_silhouette: "👤",
  busts_in_silhouette: "👥",
  butter: "🧈",
  butterfly: "🦋",
  cactus: "🌵",
  cake: "🍰",
  calendar: "📆",
  call_me_hand: "🤙",
  calling: "📲",
  camel: "🐫",
  camera_with_flash: "📸",
  camera: "📷",
  camping: "🏕️",
  cancer: "♋",
  candle: "🕯️",
  candy: "🍬",
  canned_food: "🥫",
  canoe: "🛶",
  capital_abcd: "🔠",
  capricorn: "♑",
  car: "🚗",
  card_file_box: "🗃️",
  card_index_dividers: "🗂️",
  card_index: "📇",
  carousel_horse: "🎠",
  carpentry_saw: "🪚",
  carrot: "🥕",
  cat: "🐱",
  cat2: "🐈",
  cd: "💿",
  chains: "⛓️",
  chair: "🪑",
  champagne: "🍾",
  chart_with_downwards_trend: "📉",
  chart_with_upwards_trend: "📈",
  chart: "💹",
  checkered_flag: "🏁",
  cheese_wedge: "🧀",
  cherries: "🍒",
  cherry_blossom: "🌸",
  chess_pawn: "♟️",
  chestnut: "🌰",
  chicken: "🐔",
  child: "🧒",
  children_crossing: "🚸",
  chipmunk: "🐿️",
  chocolate_bar: "🍫",
  chopsticks: "🥢",
  christmas_tree: "🎄",
  church: "⛪",
  cinema: "🎦",
  circus_tent: "🎪",
  city_sunrise: "🌇",
  city_sunset: "🌆",
  cityscape: "🏙️",
  cl: "🆑",
  clap: "👏",
  clapper: "🎬",
  classical_building: "🏛️",
  clinking_glasses: "🥂",
  clipboard: "📋",
  clock1: "🕐",
  clock10: "🕙",
  clock1030: "🕥",
  clock11: "🕚",
  clock1130: "🕦",
  clock12: "🕛",
  clock1230: "🕧",
  clock130: "🕜",
  clock2: "🕑",
  clock230: "🕝",
  clock3: "🕒",
  clock330: "🕞",
  clock4: "🕓",
  clock430: "🕟",
  clock5: "🕔",
  clock530: "🕠",
  clock6: "🕕",
  clock630: "🕡",
  clock7: "🕖",
  clock730: "🕢",
  clock8: "🕗",
  clock830: "🕣",
  clock9: "🕘",
  clock930: "🕤",
  closed_book: "📕",
  closed_lock_with_key: "🔐",
  closed_umbrella: "🌂",
  cloud: "☁️",
  clown_face: "🤡",
  clubs: "♣️",
  cn: "🇨🇳",
  coat: "🧥",
  cockroach: "🪳",
  cocktail: "🍸",
  coconut: "🥥",
  coffee: "☕",
  coffin: "⚰️",
  coin: "🪙",
  cold_face: "🥶",
  cold_sweat: "😰",
  collision: "💥",
  comet: "☄️",
  compass: "🧭",
  compression: "🗜️",
  computer: "💻",
  confetti_ball: "🎊",
  confounded: "😖",
  confused: "😕",
  congratulations: "㊗️",
  construction_worker: "👷‍♂️",
  construction: "🚧",
  control_knobs: "🎛️",
  convenience_store: "🏪",
  cook: "🧑‍🍳",
  cookie: "🍪",
  cooking: "🍳",
  cool: "🆒",
  cop: "👮‍♂️",
  copyright: "©️",
  corn: "🌽",
  couch_and_lamp: "🛋️",
  couple_with_heart: "💑",
  couple: "👫",
  couplekiss: "💏",
  cow: "🐮",
  cow2: "🐄",
  crab: "🦀",
  credit_card: "💳",
  crescent_moon: "🌙",
  cricket_bat_and_ball: "🏏",
  cricket: "🦗",
  crocodile: "🐊",
  croissant: "🥐",
  crossed_fingers: "🤞",
  crossed_flags: "🎌",
  crossed_swords: "⚔️",
  crown: "👑",
  cry: "😢",
  crying_cat_face: "😿",
  crystal_ball: "🔮",
  cucumber: "🥒",
  cup_with_straw: "🥤",
  cupcake: "🧁",
  cupid: "💘",
  curling_stone: "🥌",
  curly_haired_man: "👨‍🦱",
  curly_haired_person: "🧑‍🦱",
  curly_haired_woman: "👩‍🦱",
  curly_loop: "➰",
  currency_exchange: "💱",
  curry: "🍛",
  custard: "🍮",
  customs: "🛃",
  cut_of_meat: "🥩",
  cyclone: "🌀",
  dagger_knife: "🗡️",
  dancer: "💃",
  dancers: "👯‍♀️",
  dango: "🍡",
  dark_sunglasses: "🕶️",
  dart: "🎯",
  dash: "💨",
  date: "📅",
  de: "🇩🇪",
  deaf_man: "🧏‍♂️",
  deaf_person: "🧏",
  deaf_woman: "🧏‍♀️",
  deciduous_tree: "🌳",
  deer: "🦌",
  department_store: "🏬",
  derelict_house_building: "🏚️",
  desert_island: "🏝️",
  desert: "🏜️",
  desktop_computer: "🖥️",
  diamond_shape_with_a_dot_inside: "💠",
  diamonds: "♦️",
  disappointed_relieved: "😥",
  disappointed: "😞",
  disguised_face: "🥸",
  diving_mask: "🤿",
  diya_lamp: "🪔",
  dizzy_face: "😵",
  dizzy: "💫",
  dna: "🧬",
  do_not_litter: "🚯",
  dodo: "🦤",
  dog: "🐶",
  dog2: "🐕",
  dollar: "💵",
  dolls: "🎎",
  dolphin: "🐬",
  door: "🚪",
  double_vertical_bar: "⏸️",
  doughnut: "🍩",
  dove_of_peace: "🕊️",
  dragon_face: "🐲",
  dragon: "🐉",
  dress: "👗",
  dromedary_camel: "🐪",
  drooling_face: "🤤",
  drop_of_blood: "🩸",
  droplet: "💧",
  drum_with_drumsticks: "🥁",
  duck: "🦆",
  dumpling: "🥟",
  dvd: "📀",
  e_mail: "📧",
  eagle: "🦅",
  ear_of_rice: "🌾",
  ear_with_hearing_aid: "🦻",
  ear: "👂",
  earth_africa: "🌍",
  earth_americas: "🌎",
  earth_asia: "🌏",
  egg: "🥚",
  eggplant: "🍆",
  eight_pointed_black_star: "✴️",
  eight_spoked_asterisk: "✳️",
  eight: "8️⃣",
  eject: "⏏️",
  electric_plug: "🔌",
  elephant: "🐘",
  elevator: "🛗",
  elf: "🧝‍♂️",
  email: "✉️",
  end: "🔚",
  envelope_with_arrow: "📩",
  envelope: "✉️",
  es: "🇪🇸",
  euro: "💶",
  european_castle: "🏰",
  european_post_office: "🏤",
  evergreen_tree: "🌲",
  exclamation: "❗",
  exploding_head: "🤯",
  expressionless: "😑",
  eye_in_speech_bubble: "👁️‍🗨️",
  eye: "👁️",
  eyeglasses: "👓",
  eyes: "👀",
  face_exhaling: "😮‍💨",
  face_in_clouds: "😶‍🌫️",
  face_palm: "🤦",
  face_vomiting: "🤮",
  face_with_cowboy_hat: "🤠",
  face_with_finger_covering_closed_lips: "🤫",
  face_with_hand_over_mouth: "🤭",
  face_with_head_bandage: "🤕",
  face_with_monocle: "🧐",
  face_with_one_eyebrow_raised: "🤨",
  face_with_open_mouth_vomiting: "🤮",
  face_with_raised_eyebrow: "🤨",
  face_with_rolling_eyes: "🙄",
  face_with_spiral_eyes: "😵‍💫",
  face_with_symbols_on_mouth: "🤬",
  face_with_thermometer: "🤒",
  facepunch: "👊",
  factory_worker: "🧑‍🏭",
  factory: "🏭",
  fairy: "🧚‍♀️",
  falafel: "🧆",
  fallen_leaf: "🍂",
  family: "👨‍👩‍👦",
  farmer: "🧑‍🌾",
  fast_forward: "⏩",
  fax: "📠",
  fearful: "😨",
  feather: "🪶",
  feet: "🐾",
  female_artist: "👩‍🎨",
  female_astronaut: "👩‍🚀",
  female_construction_worker: "👷‍♀️",
  female_cook: "👩‍🍳",
  female_detective: "🕵️‍♀️",
  female_doctor: "👩‍⚕️",
  female_elf: "🧝‍♀️",
  female_factory_worker: "👩‍🏭",
  female_fairy: "🧚‍♀️",
  female_farmer: "👩‍🌾",
  female_firefighter: "👩‍🚒",
  female_genie: "🧞‍♀️",
  female_guard: "💂‍♀️",
  female_judge: "👩‍⚖️",
  female_mage: "🧙‍♀️",
  female_mechanic: "👩‍🔧",
  female_office_worker: "👩‍💼",
  female_pilot: "👩‍✈️",
  female_police_officer: "👮‍♀️",
  female_scientist: "👩‍🔬",
  female_sign: "♀️",
  female_singer: "👩‍🎤",
  female_student: "👩‍🎓",
  female_superhero: "🦸‍♀️",
  female_supervillain: "🦹‍♀️",
  female_teacher: "👩‍🏫",
  female_technologist: "👩‍💻",
  female_vampire: "🧛‍♀️",
  female_zombie: "🧟‍♀️",
  fencer: "🤺",
  ferris_wheel: "🎡",
  ferry: "⛴️",
  field_hockey_stick_and_ball: "🏑",
  file_cabinet: "🗄️",
  file_folder: "📁",
  film_frames: "🎞️",
  film_projector: "📽️",
  fire_engine: "🚒",
  fire_extinguisher: "🧯",
  fire: "🔥",
  firecracker: "🧨",
  firefighter: "🧑‍🚒",
  fireworks: "🎆",
  first_place_medal: "🥇",
  first_quarter_moon_with_face: "🌛",
  first_quarter_moon: "🌓",
  fish_cake: "🍥",
  fish: "🐟",
  fishing_pole_and_fish: "🎣",
  fist: "✊",
  five: "5️⃣",
  flag_ac: "🇦🇨",
  flag_ad: "🇦🇩",
  flag_ae: "🇦🇪",
  flag_af: "🇦🇫",
  flag_ag: "🇦🇬",
  flag_ai: "🇦🇮",
  flag_al: "🇦🇱",
  flag_am: "🇦🇲",
  flag_ao: "🇦🇴",
  flag_aq: "🇦🇶",
  flag_ar: "🇦🇷",
  flag_as: "🇦🇸",
  flag_at: "🇦🇹",
  flag_au: "🇦🇺",
  flag_aw: "🇦🇼",
  flag_ax: "🇦🇽",
  flag_az: "🇦🇿",
  flag_ba: "🇧🇦",
  flag_bb: "🇧🇧",
  flag_bd: "🇧🇩",
  flag_be: "🇧🇪",
  flag_bf: "🇧🇫",
  flag_bg: "🇧🇬",
  flag_bh: "🇧🇭",
  flag_bi: "🇧🇮",
  flag_bj: "🇧🇯",
  flag_bl: "🇧🇱",
  flag_bm: "🇧🇲",
  flag_bn: "🇧🇳",
  flag_bo: "🇧🇴",
  flag_bq: "🇧🇶",
  flag_br: "🇧🇷",
  flag_bs: "🇧🇸",
  flag_bt: "🇧🇹",
  flag_bv: "🇧🇻",
  flag_bw: "🇧🇼",
  flag_by: "🇧🇾",
  flag_bz: "🇧🇿",
  flag_ca: "🇨🇦",
  flag_cc: "🇨🇨",
  flag_cd: "🇨🇩",
  flag_cf: "🇨🇫",
  flag_cg: "🇨🇬",
  flag_ch: "🇨🇭",
  flag_ci: "🇨🇮",
  flag_ck: "🇨🇰",
  flag_cl: "🇨🇱",
  flag_cm: "🇨🇲",
  flag_cn: "🇨🇳",
  flag_co: "🇨🇴",
  flag_cp: "🇨🇵",
  flag_cr: "🇨🇷",
  flag_cu: "🇨🇺",
  flag_cv: "🇨🇻",
  flag_cw: "🇨🇼",
  flag_cx: "🇨🇽",
  flag_cy: "🇨🇾",
  flag_cz: "🇨🇿",
  flag_de: "🇩🇪",
  flag_dg: "🇩🇬",
  flag_dj: "🇩🇯",
  flag_dk: "🇩🇰",
  flag_dm: "🇩🇲",
  flag_do: "🇩🇴",
  flag_dz: "🇩🇿",
  flag_ea: "🇪🇦",
  flag_ec: "🇪🇨",
  flag_ee: "🇪🇪",
  flag_eg: "🇪🇬",
  flag_eh: "🇪🇭",
  flag_england: "🏴󠁧󠁢󠁥󠁮󠁧󠁿",
  flag_er: "🇪🇷",
  flag_es: "🇪🇸",
  flag_et: "🇪🇹",
  flag_eu: "🇪🇺",
  flag_fi: "🇫🇮",
  flag_fj: "🇫🇯",
  flag_fk: "🇫🇰",
  flag_fm: "🇫🇲",
  flag_fo: "🇫🇴",
  flag_fr: "🇫🇷",
  flag_ga: "🇬🇦",
  flag_gb: "🇬🇧",
  flag_gd: "🇬🇩",
  flag_ge: "🇬🇪",
  flag_gf: "🇬🇫",
  flag_gg: "🇬🇬",
  flag_gh: "🇬🇭",
  flag_gi: "🇬🇮",
  flag_gl: "🇬🇱",
  flag_gm: "🇬🇲",
  flag_gn: "🇬🇳",
  flag_gp: "🇬🇵",
  flag_gq: "🇬🇶",
  flag_gr: "🇬🇷",
  flag_gs: "🇬🇸",
  flag_gt: "🇬🇹",
  flag_gu: "🇬🇺",
  flag_gw: "🇬🇼",
  flag_gy: "🇬🇾",
  flag_hk: "🇭🇰",
  flag_hm: "🇭🇲",
  flag_hn: "🇭🇳",
  flag_hr: "🇭🇷",
  flag_ht: "🇭🇹",
  flag_hu: "🇭🇺",
  flag_ic: "🇮🇨",
  flag_id: "🇮🇩",
  flag_ie: "🇮🇪",
  flag_il: "🇮🇱",
  flag_im: "🇮🇲",
  flag_in: "🇮🇳",
  flag_io: "🇮🇴",
  flag_iq: "🇮🇶",
  flag_ir: "🇮🇷",
  flag_is: "🇮🇸",
  flag_it: "🇮🇹",
  flag_je: "🇯🇪",
  flag_jm: "🇯🇲",
  flag_jo: "🇯🇴",
  flag_jp: "🇯🇵",
  flag_ke: "🇰🇪",
  flag_kg: "🇰🇬",
  flag_kh: "🇰🇭",
  flag_ki: "🇰🇮",
  flag_km: "🇰🇲",
  flag_kn: "🇰🇳",
  flag_kp: "🇰🇵",
  flag_kr: "🇰🇷",
  flag_kw: "🇰🇼",
  flag_ky: "🇰🇾",
  flag_kz: "🇰🇿",
  flag_la: "🇱🇦",
  flag_lb: "🇱🇧",
  flag_lc: "🇱🇨",
  flag_li: "🇱🇮",
  flag_lk: "🇱🇰",
  flag_lr: "🇱🇷",
  flag_ls: "🇱🇸",
  flag_lt: "🇱🇹",
  flag_lu: "🇱🇺",
  flag_lv: "🇱🇻",
  flag_ly: "🇱🇾",
  flag_ma: "🇲🇦",
  flag_mc: "🇲🇨",
  flag_md: "🇲🇩",
  flag_me: "🇲🇪",
  flag_mf: "🇲🇫",
  flag_mg: "🇲🇬",
  flag_mh: "🇲🇭",
  flag_mk: "🇲🇰",
  flag_ml: "🇲🇱",
  flag_mm: "🇲🇲",
  flag_mn: "🇲🇳",
  flag_mo: "🇲🇴",
  flag_mp: "🇲🇵",
  flag_mq: "🇲🇶",
  flag_mr: "🇲🇷",
  flag_ms: "🇲🇸",
  flag_mt: "🇲🇹",
  flag_mu: "🇲🇺",
  flag_mv: "🇲🇻",
  flag_mw: "🇲🇼",
  flag_mx: "🇲🇽",
  flag_my: "🇲🇾",
  flag_mz: "🇲🇿",
  flag_na: "🇳🇦",
  flag_nc: "🇳🇨",
  flag_ne: "🇳🇪",
  flag_nf: "🇳🇫",
  flag_ng: "🇳🇬",
  flag_ni: "🇳🇮",
  flag_nl: "🇳🇱",
  flag_no: "🇳🇴",
  flag_np: "🇳🇵",
  flag_nr: "🇳🇷",
  flag_nu: "🇳🇺",
  flag_nz: "🇳🇿",
  flag_om: "🇴🇲",
  flag_pa: "🇵🇦",
  flag_pe: "🇵🇪",
  flag_pf: "🇵🇫",
  flag_pg: "🇵🇬",
  flag_ph: "🇵🇭",
  flag_pk: "🇵🇰",
  flag_pl: "🇵🇱",
  flag_pm: "🇵🇲",
  flag_pn: "🇵🇳",
  flag_pr: "🇵🇷",
  flag_ps: "🇵🇸",
  flag_pt: "🇵🇹",
  flag_pw: "🇵🇼",
  flag_py: "🇵🇾",
  flag_qa: "🇶🇦",
  flag_re: "🇷🇪",
  flag_ro: "🇷🇴",
  flag_rs: "🇷🇸",
  flag_ru: "🇷🇺",
  flag_rw: "🇷🇼",
  flag_sa: "🇸🇦",
  flag_sb: "🇸🇧",
  flag_sc: "🇸🇨",
  flag_scotland: "🏴󠁧󠁢󠁳󠁣󠁴󠁿",
  flag_sd: "🇸🇩",
  flag_se: "🇸🇪",
  flag_sg: "🇸🇬",
  flag_sh: "🇸🇭",
  flag_si: "🇸🇮",
  flag_sj: "🇸🇯",
  flag_sk: "🇸🇰",
  flag_sl: "🇸🇱",
  flag_sm: "🇸🇲",
  flag_sn: "🇸🇳",
  flag_so: "🇸🇴",
  flag_sr: "🇸🇷",
  flag_ss: "🇸🇸",
  flag_st: "🇸🇹",
  flag_sv: "🇸🇻",
  flag_sx: "🇸🇽",
  flag_sy: "🇸🇾",
  flag_sz: "🇸🇿",
  flag_ta: "🇹🇦",
  flag_tc: "🇹🇨",
  flag_td: "🇹🇩",
  flag_tf: "🇹🇫",
  flag_tg: "🇹🇬",
  flag_th: "🇹🇭",
  flag_tj: "🇹🇯",
  flag_tk: "🇹🇰",
  flag_tl: "🇹🇱",
  flag_tm: "🇹🇲",
  flag_tn: "🇹🇳",
  flag_to: "🇹🇴",
  flag_tr: "🇹🇷",
  flag_tt: "🇹🇹",
  flag_tv: "🇹🇻",
  flag_tw: "🇹🇼",
  flag_tz: "🇹🇿",
  flag_ua: "🇺🇦",
  flag_ug: "🇺🇬",
  flag_um: "🇺🇲",
  flag_un: "🇺🇳",
  flag_us: "🇺🇸",
  flag_uy: "🇺🇾",
  flag_uz: "🇺🇿",
  flag_va: "🇻🇦",
  flag_vc: "🇻🇨",
  flag_ve: "🇻🇪",
  flag_vg: "🇻🇬",
  flag_vi: "🇻🇮",
  flag_vn: "🇻🇳",
  flag_vu: "🇻🇺",
  flag_wales: "🏴󠁧󠁢󠁷󠁬󠁳󠁿",
  flag_wf: "🇼🇫",
  flag_ws: "🇼🇸",
  flag_xk: "🇽🇰",
  flag_ye: "🇾🇪",
  flag_yt: "🇾🇹",
  flag_za: "🇿🇦",
  flag_zm: "🇿🇲",
  flag_zw: "🇿🇼",
  flags: "🎏",
  flamingo: "🦩",
  flashlight: "🔦",
  flatbread: "🫓",
  fleur_de_lis: "⚜️",
  flipper: "🐬",
  floppy_disk: "💾",
  flower_playing_cards: "🎴",
  flushed: "😳",
  fly: "🪰",
  flying_disc: "🥏",
  flying_saucer: "🛸",
  fog: "🌫️",
  foggy: "🌁",
  fondue: "🫕",
  foot: "🦶",
  football: "🏈",
  footprints: "👣",
  fork_and_knife: "🍴",
  fortune_cookie: "🥠",
  fountain: "⛲",
  four_leaf_clover: "🍀",
  four: "4️⃣",
  fox_face: "🦊",
  fr: "🇫🇷",
  frame_with_picture: "🖼️",
  free: "🆓",
  fried_egg: "🍳",
  fried_shrimp: "🍤",
  fries: "🍟",
  frog: "🐸",
  frowning: "😦",
  fuelpump: "⛽",
  full_moon_with_face: "🌝",
  full_moon: "🌕",
  funeral_urn: "⚱️",
  game_die: "🎲",
  garlic: "🧄",
  gb: "🇬🇧",
  gear: "⚙️",
  gem: "💎",
  gemini: "♊",
  genie: "🧞‍♂️",
  ghost: "👻",
  gift_heart: "💝",
  gift: "🎁",
  giraffe_face: "🦒",
  girl: "👧",
  glass_of_milk: "🥛",
  globe_with_meridians: "🌐",
  gloves: "🧤",
  goal_net: "🥅",
  goat: "🐐",
  goggles: "🥽",
  golf: "⛳",
  golfer: "🏌️‍♂️",
  gorilla: "🦍",
  grapes: "🍇",
  green_apple: "🍏",
  green_book: "📗",
  green_heart: "💚",
  green_salad: "🥗",
  grey_exclamation: "❕",
  grey_question: "❔",
  grimacing: "😬",
  grin: "😁",
  grinning_face_with_one_large_and_one_small_eye: "🤪",
  grinning_face_with_star_eyes: "🤩",
  grinning: "😀",
  guardsman: "💂‍♂️",
  guide_dog: "🦮",
  guitar: "🎸",
  gun: "🔫",
  haircut: "💇‍♀️",
  hamburger: "🍔",
  hammer_and_pick: "⚒️",
  hammer_and_wrench: "🛠️",
  hammer: "🔨",
  hamster: "🐹",
  hand_with_index_and_middle_fingers_crossed: "🤞",
  hand: "✋",
  handbag: "👜",
  handball: "🤾",
  handshake: "🤝",
  hankey: "💩",
  hash: "#️⃣",
  hatched_chick: "🐥",
  hatching_chick: "🐣",
  headphones: "🎧",
  headstone: "🪦",
  health_worker: "🧑‍⚕️",
  hear_no_evil: "🙉",
  heart_decoration: "💟",
  heart_eyes_cat: "😻",
  heart_eyes: "😍",
  heart_on_fire: "❤️‍🔥",
  heart: "❤️",
  heartbeat: "💓",
  heartpulse: "💗",
  hearts: "♥️",
  heavy_check_mark: "✔️",
  heavy_division_sign: "➗",
  heavy_dollar_sign: "💲",
  heavy_exclamation_mark: "❗",
  heavy_heart_exclamation_mark_ornament: "❣️",
  heavy_minus_sign: "➖",
  heavy_multiplication_x: "✖️",
  heavy_plus_sign: "➕",
  hedgehog: "🦔",
  helicopter: "🚁",
  helmet_with_white_cross: "⛑️",
  herb: "🌿",
  hibiscus: "🌺",
  high_brightness: "🔆",
  high_heel: "👠",
  hiking_boot: "🥾",
  hindu_temple: "🛕",
  hippopotamus: "🦛",
  hocho: "🔪",
  hole: "🕳️",
  honey_pot: "🍯",
  honeybee: "🐝",
  hook: "🪝",
  horse_racing: "🏇",
  horse: "🐴",
  hospital: "🏥",
  hot_face: "🥵",
  hot_pepper: "🌶️",
  hotdog: "🌭",
  hotel: "🏨",
  hotsprings: "♨️",
  hourglass_flowing_sand: "⏳",
  hourglass: "⌛",
  house_buildings: "🏘️",
  house_with_garden: "🏡",
  house: "🏠",
  hugging_face: "🤗",
  hushed: "😯",
  hut: "🛖",
  i_love_you_hand_sign: "🤟",
  ice_cream: "🍨",
  ice_cube: "🧊",
  ice_hockey_stick_and_puck: "🏒",
  ice_skate: "⛸️",
  icecream: "🍦",
  id: "🆔",
  ideograph_advantage: "🉐",
  imp: "👿",
  inbox_tray: "📥",
  incoming_envelope: "📨",
  infinity: "♾️",
  information_desk_person: "💁‍♀️",
  information_source: "ℹ️",
  innocent: "😇",
  interrobang: "⁉️",
  iphone: "📱",
  it: "🇮🇹",
  izakaya_lantern: "🏮",
  jack_o_lantern: "🎃",
  japan: "🗾",
  japanese_castle: "🏯",
  japanese_goblin: "👺",
  japanese_ogre: "👹",
  jeans: "👖",
  jigsaw: "🧩",
  joy_cat: "😹",
  joy: "😂",
  joystick: "🕹️",
  jp: "🇯🇵",
  judge: "🧑‍⚖️",
  juggling: "🤹",
  kaaba: "🕋",
  kangaroo: "🦘",
  key: "🔑",
  keyboard: "⌨️",
  keycap_star: "*️⃣",
  keycap_ten: "🔟",
  kimono: "👘",
  kiss: "💋",
  kissing_cat: "😽",
  kissing_closed_eyes: "😚",
  kissing_heart: "😘",
  kissing_smiling_eyes: "😙",
  kissing: "😗",
  kite: "🪁",
  kiwifruit: "🥝",
  kneeling_person: "🧎",
  knife_fork_plate: "🍽️",
  knife: "🔪",
  knot: "🪢",
  koala: "🐨",
  koko: "🈁",
  kr: "🇰🇷",
  lab_coat: "🥼",
  label: "🏷️",
  lacrosse: "🥍",
  ladder: "🪜",
  lady_beetle: "🐞",
  ladybug: "🐞",
  lantern: "🏮",
  large_blue_circle: "🔵",
  large_blue_diamond: "🔷",
  large_blue_square: "🟦",
  large_brown_circle: "🟤",
  large_brown_square: "🟫",
  large_green_circle: "🟢",
  large_green_square: "🟩",
  large_orange_circle: "🟠",
  large_orange_diamond: "🔶",
  large_orange_square: "🟧",
  large_purple_circle: "🟣",
  large_purple_square: "🟪",
  large_red_square: "🟥",
  large_yellow_circle: "🟡",
  large_yellow_square: "🟨",
  last_quarter_moon_with_face: "🌜",
  last_quarter_moon: "🌗",
  latin_cross: "✝️",
  laughing: "😆",
  leafy_green: "🥬",
  leaves: "🍃",
  ledger: "📒",
  left_facing_fist: "🤛",
  left_luggage: "🛅",
  left_right_arrow: "↔️",
  left_speech_bubble: "🗨️",
  leftwards_arrow_with_hook: "↩️",
  leg: "🦵",
  lemon: "🍋",
  leo: "♌",
  leopard: "🐆",
  level_slider: "🎚️",
  libra: "♎",
  light_rail: "🚈",
  lightning_cloud: "🌩️",
  lightning: "🌩️",
  link: "🔗",
  linked_paperclips: "🖇️",
  lion_face: "🦁",
  lips: "👄",
  lipstick: "💄",
  lizard: "🦎",
  llama: "🦙",
  lobster: "🦞",
  lock_with_ink_pen: "🔏",
  lock: "🔒",
  lollipop: "🍭",
  long_drum: "🪘",
  loop: "➿",
  lotion_bottle: "🧴",
  loud_sound: "🔊",
  loudspeaker: "📢",
  love_hotel: "🏩",
  love_letter: "💌",
  low_brightness: "🔅",
  lower_left_ballpoint_pen: "🖊️",
  lower_left_crayon: "🖍️",
  lower_left_fountain_pen: "🖋️",
  lower_left_paintbrush: "🖌️",
  luggage: "🧳",
  lungs: "🫁",
  lying_face: "🤥",
  m: "Ⓜ️",
  mag_right: "🔎",
  mag: "🔍",
  mage: "🧙‍♀️",
  magic_wand: "🪄",
  magnet: "🧲",
  mahjong: "🀄",
  mailbox_closed: "📪",
  mailbox_with_mail: "📬",
  mailbox_with_no_mail: "📭",
  mailbox: "📫",
  male_artist: "👨‍🎨",
  male_astronaut: "👨‍🚀",
  male_construction_worker: "👷‍♂️",
  male_cook: "👨‍🍳",
  male_detective: "🕵️‍♂️",
  male_doctor: "👨‍⚕️",
  male_elf: "🧝‍♂️",
  male_factory_worker: "👨‍🏭",
  male_fairy: "🧚‍♂️",
  male_farmer: "👨‍🌾",
  male_firefighter: "👨‍🚒",
  male_genie: "🧞‍♂️",
  male_guard: "💂‍♂️",
  male_judge: "👨‍⚖️",
  male_mage: "🧙‍♂️",
  male_mechanic: "👨‍🔧",
  male_office_worker: "👨‍💼",
  male_pilot: "👨‍✈️",
  male_police_officer: "👮‍♂️",
  male_scientist: "👨‍🔬",
  male_sign: "♂️",
  male_singer: "👨‍🎤",
  male_student: "👨‍🎓",
  male_superhero: "🦸‍♂️",
  male_supervillain: "🦹‍♂️",
  male_teacher: "👨‍🏫",
  male_technologist: "👨‍💻",
  male_vampire: "🧛‍♂️",
  male_zombie: "🧟‍♂️",
  mammoth: "🦣",
  man_and_woman_holding_hands: "👫",
  man_biking: "🚴‍♂️",
  man_bouncing_ball: "⛹️‍♂️",
  man_bowing: "🙇‍♂️",
  man_boy_boy: "👨‍👦‍👦",
  man_boy: "👨‍👦",
  man_cartwheeling: "🤸‍♂️",
  man_climbing: "🧗‍♂️",
  man_dancing: "🕺",
  man_facepalming: "🤦‍♂️",
  man_feeding_baby: "👨‍🍼",
  man_frowning: "🙍‍♂️",
  man_gesturing_no: "🙅‍♂️",
  man_gesturing_ok: "🙆‍♂️",
  man_getting_haircut: "💇‍♂️",
  man_getting_massage: "💆‍♂️",
  man_girl_boy: "👨‍👧‍👦",
  man_girl_girl: "👨‍👧‍👧",
  man_girl: "👨‍👧",
  man_golfing: "🏌️‍♂️",
  man_heart_man: "👨‍❤️‍👨",
  man_in_business_suit_levitating: "🕴️",
  man_in_lotus_position: "🧘‍♂️",
  man_in_manual_wheelchair: "👨‍🦽",
  man_in_motorized_wheelchair: "👨‍🦼",
  man_in_steamy_room: "🧖‍♂️",
  man_in_tuxedo: "🤵‍♂️",
  man_juggling: "🤹‍♂️",
  man_kiss_man: "👨‍❤️‍💋‍👨",
  man_kneeling: "🧎‍♂️",
  man_lifting_weights: "🏋️‍♂️",
  man_man_boy_boy: "👨‍👨‍👦‍👦",
  man_man_boy: "👨‍👨‍👦",
  man_man_girl_boy: "👨‍👨‍👧‍👦",
  man_man_girl_girl: "👨‍👨‍👧‍👧",
  man_man_girl: "👨‍👨‍👧",
  man_mountain_biking: "🚵‍♂️",
  man_playing_handball: "🤾‍♂️",
  man_playing_water_polo: "🤽‍♂️",
  man_pouting: "🙎‍♂️",
  man_raising_hand: "🙋‍♂️",
  man_rowing_boat: "🚣‍♂️",
  man_running: "🏃‍♂️",
  man_shrugging: "🤷‍♂️",
  man_standing: "🧍‍♂️",
  man_surfing: "🏄‍♂️",
  man_swimming: "🏊‍♂️",
  man_tipping_hand: "💁‍♂️",
  man_walking: "🚶‍♂️",
  man_wearing_turban: "👳‍♂️",
  man_with_beard: "🧔‍♂️",
  man_with_bunny_ears_partying: "👯‍♂️",
  man_with_gua_pi_mao: "👲",
  man_with_probing_cane: "👨‍🦯",
  man_with_turban: "👳‍♂️",
  man_with_veil: "👰‍♂️",
  man_woman_boy_boy: "👨‍👩‍👦‍👦",
  man_woman_boy: "👨‍👩‍👦",
  man_woman_girl_boy: "👨‍👩‍👧‍👦",
  man_woman_girl_girl: "👨‍👩‍👧‍👧",
  man_woman_girl: "👨‍👩‍👧",
  man_wrestling: "🤼‍♂️",
  man: "👨",
  mango: "🥭",
  mans_shoe: "👞",
  mantelpiece_clock: "🕰️",
  manual_wheelchair: "🦽",
  maple_leaf: "🍁",
  martial_arts_uniform: "🥋",
  mask: "😷",
  massage: "💆‍♀️",
  mate_drink: "🧉",
  meat_on_bone: "🍖",
  mechanic: "🧑‍🔧",
  mechanical_arm: "🦾",
  mechanical_leg: "🦿",
  medal: "🎖️",
  medical_symbol: "⚕️",
  mega: "📣",
  melon: "🍈",
  memo: "📝",
  men_holding_hands: "👬",
  men_with_bunny_ears_partying: "👯‍♂️",
  mending_heart: "❤️‍🩹",
  menorah_with_nine_branches: "🕎",
  mens: "🚹",
  mermaid: "🧜‍♀️",
  merman: "🧜‍♂️",
  merperson: "🧜‍♂️",
  metro: "🚇",
  microbe: "🦠",
  microphone: "🎤",
  microscope: "🔬",
  middle_finger: "🖕",
  military_helmet: "🪖",
  milky_way: "🌌",
  minibus: "🚐",
  minidisc: "💽",
  mirror: "🪞",
  mobile_phone_off: "📴",
  money_mouth_face: "🤑",
  money_with_wings: "💸",
  moneybag: "💰",
  monkey_face: "🐵",
  monkey: "🐒",
  monorail: "🚝",
  moon_cake: "🥮",
  moon: "🌔",
  mortar_board: "🎓",
  mosque: "🕌",
  mosquito: "🦟",
  mostly_sunny: "🌤️",
  mother_christmas: "🤶",
  motor_boat: "🛥️",
  motor_scooter: "🛵",
  motorized_wheelchair: "🦼",
  motorway: "🛣️",
  mount_fuji: "🗻",
  mountain_bicyclist: "🚵‍♂️",
  mountain_cableway: "🚠",
  mountain_railway: "🚞",
  mountain: "⛰️",
  mouse_trap: "🪤",
  mouse: "🐭",
  mouse2: "🐁",
  movie_camera: "🎥",
  moyai: "🗿",
  mrs_claus: "🤶",
  muscle: "💪",
  mushroom: "🍄",
  musical_keyboard: "🎹",
  musical_note: "🎵",
  musical_score: "🎼",
  mute: "🔇",
  mx_claus: "🧑‍🎄",
  nail_care: "💅",
  name_badge: "📛",
  national_park: "🏞️",
  nauseated_face: "🤢",
  nazar_amulet: "🧿",
  necktie: "👔",
  negative_squared_cross_mark: "❎",
  nerd_face: "🤓",
  nesting_dolls: "🪆",
  neutral_face: "😐",
  new_moon_with_face: "🌚",
  new_moon: "🌑",
  new: "🆕",
  newspaper: "📰",
  ng: "🆖",
  night_with_stars: "🌃",
  nine: "9️⃣",
  ninja: "🥷",
  no_bell: "🔕",
  no_bicycles: "🚳",
  no_entry_sign: "🚫",
  no_entry: "⛔",
  no_good: "🙅‍♀️",
  no_mobile_phones: "📵",
  no_mouth: "😶",
  no_pedestrians: "🚷",
  no_smoking: "🚭",
  non_potable_water: "🚱",
  nose: "👃",
  notebook_with_decorative_cover: "📔",
  notebook: "📓",
  notes: "🎶",
  nut_and_bolt: "🔩",
  o: "⭕",
  o2: "🅾️",
  ocean: "🌊",
  octagonal_sign: "🛑",
  octopus: "🐙",
  oden: "🍢",
  office_worker: "🧑‍💼",
  office: "🏢",
  oil_drum: "🛢️",
  ok_hand: "👌",
  ok_woman: "🙆‍♀️",
  ok: "🆗",
  old_key: "🗝️",
  older_adult: "🧓",
  older_man: "👴",
  older_woman: "👵",
  olive: "🫒",
  om_symbol: "🕉️",
  on: "🔛",
  oncoming_automobile: "🚘",
  oncoming_bus: "🚍",
  oncoming_police_car: "🚔",
  oncoming_taxi: "🚖",
  one_piece_swimsuit: "🩱",
  one: "1️⃣",
  onion: "🧅",
  open_book: "📖",
  open_file_folder: "📂",
  open_hands: "👐",
  open_mouth: "😮",
  ophiuchus: "⛎",
  orange_book: "📙",
  orange_heart: "🧡",
  orangutan: "🦧",
  orthodox_cross: "☦️",
  otter: "🦦",
  outbox_tray: "📤",
  owl: "🦉",
  ox: "🐂",
  oyster: "🦪",
  package: "📦",
  page_facing_up: "📄",
  page_with_curl: "📃",
  pager: "📟",
  palm_tree: "🌴",
  palms_up_together: "🤲",
  pancakes: "🥞",
  panda_face: "🐼",
  paperclip: "📎",
  parachute: "🪂",
  parking: "🅿️",
  parrot: "🦜",
  part_alternation_mark: "〽️",
  partly_sunny_rain: "🌦️",
  partly_sunny: "⛅",
  partying_face: "🥳",
  passenger_ship: "🛳️",
  passport_control: "🛂",
  paw_prints: "🐾",
  peace_symbol: "☮️",
  peach: "🍑",
  peacock: "🦚",
  peanuts: "🥜",
  pear: "🍐",
  pencil: "📝",
  pencil2: "✏️",
  penguin: "🐧",
  pensive: "😔",
  people_holding_hands: "🧑‍🤝‍🧑",
  people_hugging: "🫂",
  performing_arts: "🎭",
  persevere: "😣",
  person_climbing: "🧗‍♀️",
  person_doing_cartwheel: "🤸",
  person_feeding_baby: "🧑‍🍼",
  person_frowning: "🙍‍♀️",
  person_in_lotus_position: "🧘‍♀️",
  person_in_manual_wheelchair: "🧑‍🦽",
  person_in_motorized_wheelchair: "🧑‍🦼",
  person_in_steamy_room: "🧖‍♂️",
  person_in_tuxedo: "🤵",
  person_with_ball: "⛹️‍♂️",
  person_with_blond_hair: "👱‍♂️",
  person_with_headscarf: "🧕",
  person_with_pouting_face: "🙎‍♀️",
  person_with_probing_cane: "🧑‍🦯",
  petri_dish: "🧫",
  phone: "☎️",
  pick: "⛏️",
  pickup_truck: "🛻",
  pie: "🥧",
  pig_nose: "🐽",
  pig: "🐷",
  pig2: "🐖",
  pill: "💊",
  pilot: "🧑‍✈️",
  pinata: "🪅",
  pinched_fingers: "🤌",
  pinching_hand: "🤏",
  pineapple: "🍍",
  pirate_flag: "🏴‍☠️",
  pisces: "♓",
  pizza: "🍕",
  placard: "🪧",
  place_of_worship: "🛐",
  pleading_face: "🥺",
  plunger: "🪠",
  point_down: "👇",
  point_left: "👈",
  point_right: "👉",
  point_up_2: "👆",
  point_up: "☝️",
  polar_bear: "🐻‍❄️",
  police_car: "🚓",
  poodle: "🐩",
  poop: "💩",
  popcorn: "🍿",
  post_office: "🏣",
  postal_horn: "📯",
  postbox: "📮",
  potable_water: "🚰",
  potato: "🥔",
  potted_plant: "🪴",
  pouch: "👝",
  poultry_leg: "🍗",
  pound: "💷",
  pouting_cat: "😾",
  pray: "🙏",
  prayer_beads: "📿",
  pregnant_woman: "🤰",
  pretzel: "🥨",
  prince: "🤴",
  princess: "👸",
  printer: "🖨️",
  probing_cane: "🦯",
  punch: "👊",
  purple_heart: "💜",
  purse: "👛",
  pushpin: "📌",
  put_litter_in_its_place: "🚮",
  question: "❓",
  rabbit: "🐰",
  rabbit2: "🐇",
  raccoon: "🦝",
  racehorse: "🐎",
  racing_car: "🏎️",
  racing_motorcycle: "🏍️",
  radio_button: "🔘",
  radio: "📻",
  radioactive_sign: "☢️",
  rage: "😡",
  railway_car: "🚃",
  railway_track: "🛤️",
  rain_cloud: "🌧️",
  rainbow_flag: "🏳️‍🌈",
  rainbow: "🌈",
  raised_back_of_hand: "🤚",
  raised_hand_with_fingers_splayed: "🖐️",
  raised_hand: "✋",
  raised_hands: "🙌",
  raising_hand: "🙋‍♀️",
  ram: "🐏",
  ramen: "🍜",
  rat: "🐀",
  razor: "🪒",
  receipt: "🧾",
  recycle: "♻️",
  red_car: "🚗",
  red_circle: "🔴",
  red_envelope: "🧧",
  red_haired_man: "👨‍🦰",
  red_haired_person: "🧑‍🦰",
  red_haired_woman: "👩‍🦰",
  regional_indicator_a: "�",
  regional_indicator_b: "�",
  regional_indicator_c: "�",
  regional_indicator_d: "�",
  regional_indicator_e: "🇪",
  regional_indicator_f: "�",
  regional_indicator_g: "�",
  regional_indicator_h: "�",
  regional_indicator_i: "�",
  regional_indicator_j: "�",
  regional_indicator_k: "�",
  regional_indicator_l: "�",
  regional_indicator_m: "�",
  regional_indicator_n: "🇳",
  regional_indicator_o: "�",
  regional_indicator_p: "🇵",
  regional_indicator_q: "�",
  regional_indicator_r: "�",
  regional_indicator_s: "�",
  regional_indicator_t: "�",
  regional_indicator_u: "�",
  regional_indicator_v: "�",
  regional_indicator_w: "�",
  regional_indicator_x: "�",
  regional_indicator_y: "�",
  regional_indicator_z: "�",
  registered: "®️",
  relaxed: "☺️",
  relieved: "😌",
  reminder_ribbon: "🎗️",
  repeat_one: "🔂",
  repeat: "🔁",
  restroom: "🚻",
  reversed_hand_with_middle_finger_extended: "🖕",
  revolving_hearts: "💞",
  rewind: "⏪",
  rhinoceros: "🦏",
  ribbon: "🎀",
  rice_ball: "🍙",
  rice_cracker: "🍘",
  rice_scene: "🎑",
  rice: "🍚",
  right_anger_bubble: "🗯️",
  right_facing_fist: "🤜",
  ring: "💍",
  ringed_planet: "🪐",
  robot_face: "🤖",
  rock: "🪨",
  rocket: "🚀",
  roll_of_paper: "🧻",
  rolled_up_newspaper: "🗞️",
  roller_coaster: "🎢",
  roller_skate: "🛼",
  rolling_on_the_floor_laughing: "🤣",
  rooster: "🐓",
  rose: "🌹",
  rosette: "🏵️",
  rotating_light: "🚨",
  round_pushpin: "📍",
  rowboat: "🚣‍♂️",
  ru: "🇷🇺",
  rugby_football: "🏉",
  runner: "🏃‍♂️",
  running_shirt_with_sash: "🎽",
  running: "🏃‍♂️",
  sa: "🈂️",
  safety_pin: "🧷",
  safety_vest: "🦺",
  sagittarius: "♐",
  sailboat: "⛵",
  sake: "🍶",
  salt: "🧂",
  sandal: "👡",
  sandwich: "🥪",
  santa: "🎅",
  sari: "🥻",
  satellite_antenna: "📡",
  satellite: "🛰️",
  satisfied: "😆",
  sauropod: "🦕",
  saxophone: "🎷",
  scales: "⚖️",
  scarf: "🧣",
  school_satchel: "🎒",
  school: "🏫",
  scientist: "🧑‍🔬",
  scissors: "✂️",
  scooter: "🛴",
  scorpion: "🦂",
  scorpius: "♏",
  scream_cat: "🙀",
  scream: "😱",
  screwdriver: "🪛",
  scroll: "📜",
  seal: "🦭",
  seat: "💺",
  second_place_medal: "🥈",
  secret: "㊙️",
  see_no_evil: "🙈",
  seedling: "🌱",
  selfie: "🤳",
  serious_face_with_symbols_covering_mouth: "🤬",
  service_dog: "🐕‍🦺",
  seven: "7️⃣",
  sewing_needle: "🪡",
  shallow_pan_of_food: "🥘",
  shamrock: "☘️",
  shark: "🦈",
  shaved_ice: "🍧",
  sheep: "🐑",
  shell: "🐚",
  shield: "🛡️",
  shinto_shrine: "⛩️",
  ship: "🚢",
  shirt: "👕",
  shit: "💩",
  shocked_face_with_exploding_head: "🤯",
  shoe: "👞",
  shopping_bags: "🛍️",
  shopping_trolley: "🛒",
  shorts: "🩳",
  shower: "🚿",
  shrimp: "🦐",
  shrug: "🤷",
  shushing_face: "🤫",
  sign_of_the_horns: "🤘",
  signal_strength: "📶",
  singer: "🧑‍🎤",
  six_pointed_star: "🔯",
  six: "6️⃣",
  skateboard: "🛹",
  ski: "🎿",
  skier: "⛷️",
  skin_tone_2: "🏻",
  skin_tone_3: "🏼",
  skin_tone_4: "🏽",
  skin_tone_5: "🏾",
  skin_tone_6: "🏿",
  skull_and_crossbones: "☠️",
  skull: "💀",
  skunk: "🦨",
  sled: "🛷",
  sleeping_accommodation: "🛌",
  sleeping: "😴",
  sleepy: "😪",
  sleuth_or_spy: "🕵️‍♂️",
  slightly_frowning_face: "🙁",
  slightly_smiling_face: "🙂",
  slot_machine: "🎰",
  sloth: "🦥",
  small_airplane: "🛩️",
  small_blue_diamond: "🔹",
  small_orange_diamond: "🔸",
  small_red_triangle_down: "🔻",
  small_red_triangle: "🔺",
  smile_cat: "😸",
  smile: "😄",
  smiley_cat: "😺",
  smiley: "😃",
  smiling_face_with_3_hearts: "🥰",
  smiling_face_with_smiling_eyes_and_hand_covering_mouth: "🤭",
  smiling_face_with_tear: "🥲",
  smiling_imp: "😈",
  smirk_cat: "😼",
  smirk: "😏",
  smoking: "🚬",
  snail: "🐌",
  snake: "🐍",
  sneezing_face: "🤧",
  snow_capped_mountain: "🏔️",
  snow_cloud: "🌨️",
  snowboarder: "🏂",
  snowflake: "❄️",
  snowman_without_snow: "⛄",
  snowman: "☃️",
  soap: "🧼",
  sob: "😭",
  soccer: "⚽",
  socks: "🧦",
  softball: "🥎",
  soon: "🔜",
  sos: "🆘",
  sound: "🔉",
  space_invader: "👾",
  spades: "♠️",
  spaghetti: "🍝",
  sparkle: "❇️",
  sparkler: "🎇",
  sparkles: "✨",
  sparkling_heart: "💖",
  speak_no_evil: "🙊",
  speaker: "🔈",
  speaking_head_in_silhouette: "🗣️",
  speech_balloon: "💬",
  speedboat: "🚤",
  spider_web: "🕸️",
  spider: "🕷️",
  spiral_calendar_pad: "🗓️",
  spiral_note_pad: "🗒️",
  spock_hand: "🖖",
  sponge: "🧽",
  spoon: "🥄",
  sports_medal: "🏅",
  squid: "🦑",
  stadium: "🏟️",
  staff_of_aesculapius: "⚕️",
  standing_person: "🧍",
  star_and_crescent: "☪️",
  star_of_david: "✡️",
  star_struck: "🤩",
  star: "⭐",
  star2: "🌟",
  stars: "🌠",
  station: "🚉",
  statue_of_liberty: "🗽",
  steam_locomotive: "🚂",
  stethoscope: "🩺",
  stew: "🍲",
  stopwatch: "⏱️",
  straight_ruler: "📏",
  strawberry: "🍓",
  stuck_out_tongue_closed_eyes: "😝",
  stuck_out_tongue_winking_eye: "😜",
  stuck_out_tongue: "😛",
  student: "🧑‍🎓",
  studio_microphone: "🎙️",
  stuffed_flatbread: "🥙",
  sun_behind_cloud: "🌥️",
  sun_behind_rain_cloud: "🌦️",
  sun_small_cloud: "🌤️",
  sun_with_face: "🌞",
  sunflower: "🌻",
  sunglasses: "😎",
  sunny: "☀️",
  sunrise_over_mountains: "🌄",
  sunrise: "🌅",
  superhero: "🦸",
  supervillain: "🦹",
  surfer: "🏄‍♂️",
  sushi: "🍣",
  suspension_railway: "🚟",
  swan: "🦢",
  sweat_drops: "💦",
  sweat_smile: "😅",
  sweat: "😓",
  sweet_potato: "🍠",
  swimmer: "🏊‍♂️",
  symbols: "🔣",
  synagogue: "🕍",
  syringe: "💉",
  t_rex: "🦖",
  table_tennis_paddle_and_ball: "🏓",
  taco: "🌮",
  tada: "🎉",
  takeout_box: "🥡",
  tamale: "🫔",
  tanabata_tree: "🎋",
  tangerine: "🍊",
  taurus: "♉",
  taxi: "🚕",
  tea: "🍵",
  teacher: "🧑‍🏫",
  teapot: "🫖",
  technologist: "🧑‍💻",
  teddy_bear: "🧸",
  telephone_receiver: "📞",
  telephone: "☎️",
  telescope: "🔭",
  tennis: "🎾",
  tent: "⛺",
  test_tube: "🧪",
  the_horns: "🤘",
  thermometer: "🌡️",
  thinking_face: "🤔",
  third_place_medal: "🥉",
  thong_sandal: "🩴",
  thought_balloon: "💭",
  thread: "🧵",
  three_button_mouse: "🖱️",
  three: "3️⃣",
  thumbsdown: "👎",
  thumbsup: "👍",
  thunder_cloud_and_rain: "⛈️",
  ticket: "🎫",
  tiger: "🐯",
  tiger2: "🐅",
  timer_clock: "⏲️",
  tired_face: "😫",
  tm: "™️",
  toilet: "🚽",
  tokyo_tower: "🗼",
  tomato: "🍅",
  tongue: "👅",
  toolbox: "🧰",
  tooth: "🦷",
  toothbrush: "🪥",
  top: "🔝",
  tophat: "🎩",
  tornado_cloud: "🌪️",
  tornado: "🌪️",
  trackball: "🖲️",
  tractor: "🚜",
  traffic_light: "🚥",
  train: "🚋",
  train2: "🚆",
  tram: "🚊",
  transgender_flag: "🏳️‍⚧️",
  transgender_symbol: "⚧️",
  triangular_flag_on_post: "🚩",
  triangular_ruler: "📐",
  trident: "🔱",
  triumph: "😤",
  trolleybus: "🚎",
  trophy: "🏆",
  tropical_drink: "🍹",
  tropical_fish: "🐠",
  truck: "🚚",
  trumpet: "🎺",
  tshirt: "👕",
  tulip: "🌷",
  tumbler_glass: "🥃",
  turkey: "🦃",
  turtle: "🐢",
  tv: "📺",
  twisted_rightwards_arrows: "🔀",
  two_hearts: "💕",
  two_men_holding_hands: "👬",
  two_women_holding_hands: "👭",
  two: "2️⃣",
  u5272: "🈹",
  u5408: "🈴",
  u55b6: "🈺",
  u6307: "🈯",
  u6708: "🈷️",
  u6709: "🈶",
  u6e80: "🈵",
  u7121: "🈚",
  u7533: "🈸",
  u7981: "🈲",
  u7a7a: "🈳",
  uk: "🇬🇧",
  umbrella_on_ground: "⛱️",
  umbrella_with_rain_drops: "☔",
  umbrella: "☂️",
  unamused: "😒",
  underage: "🔞",
  unicorn_face: "🦄",
  unlock: "🔓",
  up: "🆙",
  upside_down_face: "🙃",
  us: "🇺🇸",
  v: "✌️",
  vampire: "🧛‍♀️",
  vertical_traffic_light: "🚦",
  vhs: "📼",
  vibration_mode: "📳",
  video_camera: "📹",
  video_game: "🎮",
  violin: "🎻",
  virgo: "♍",
  volcano: "🌋",
  volleyball: "🏐",
  vs: "🆚",
  waffle: "🧇",
  walking: "🚶‍♂️",
  waning_crescent_moon: "🌘",
  waning_gibbous_moon: "🌖",
  warning: "⚠️",
  wastebasket: "🗑️",
  watch: "⌚",
  water_buffalo: "🐃",
  water_polo: "🤽",
  watermelon: "🍉",
  wave: "👋",
  waving_black_flag: "🏴",
  waving_white_flag: "🏳️",
  wavy_dash: "〰️",
  waxing_crescent_moon: "🌒",
  waxing_gibbous_moon: "🌔",
  wc: "🚾",
  weary: "😩",
  wedding: "💒",
  weight_lifter: "🏋️‍♂️",
  whale: "🐳",
  whale2: "🐋",
  wheel_of_dharma: "☸️",
  wheelchair: "♿",
  white_check_mark: "✅",
  white_circle: "⚪",
  white_flower: "💮",
  white_frowning_face: "☹️",
  white_haired_man: "👨‍🦳",
  white_haired_person: "🧑‍🦳",
  white_haired_woman: "👩‍🦳",
  white_heart: "🤍",
  white_large_square: "⬜",
  white_medium_small_square: "◽",
  white_medium_square: "◻️",
  white_small_square: "▫️",
  white_square_button: "🔳",
  wilted_flower: "🥀",
  wind_blowing_face: "🌬️",
  wind_chime: "🎐",
  window: "🪟",
  wine_glass: "🍷",
  wink: "😉",
  wolf: "🐺",
  woman_and_man_holding_hands: "👫",
  woman_biking: "🚴‍♀️",
  woman_bouncing_ball: "⛹️‍♀️",
  woman_bowing: "🙇‍♀️",
  woman_boy_boy: "👩‍👦‍👦",
  woman_boy: "👩‍👦",
  woman_cartwheeling: "🤸‍♀️",
  woman_climbing: "🧗‍♀️",
  woman_facepalming: "🤦‍♀️",
  woman_feeding_baby: "👩‍🍼",
  woman_frowning: "🙍‍♀️",
  woman_gesturing_no: "🙅‍♀️",
  woman_gesturing_ok: "🙆‍♀️",
  woman_getting_haircut: "💇‍♀️",
  woman_getting_massage: "💆‍♀️",
  woman_girl_boy: "👩‍👧‍👦",
  woman_girl_girl: "👩‍👧‍👧",
  woman_girl: "👩‍👧",
  woman_golfing: "🏌️‍♀️",
  woman_heart_man: "👩‍❤️‍👨",
  woman_heart_woman: "👩‍❤️‍👩",
  woman_in_lotus_position: "🧘‍♀️",
  woman_in_manual_wheelchair: "👩‍🦽",
  woman_in_motorized_wheelchair: "👩‍🦼",
  woman_in_steamy_room: "🧖‍♀️",
  woman_in_tuxedo: "🤵‍♀️",
  woman_juggling: "🤹‍♀️",
  woman_kiss_man: "👩‍❤️‍💋‍👨",
  woman_kiss_woman: "👩‍❤️‍💋‍👩",
  woman_kneeling: "🧎‍♀️",
  woman_lifting_weights: "🏋️‍♀️",
  woman_mountain_biking: "🚵‍♀️",
  woman_playing_handball: "🤾‍♀️",
  woman_playing_water_polo: "🤽‍♀️",
  woman_pouting: "🙎‍♀️",
  woman_raising_hand: "🙋‍♀️",
  woman_rowing_boat: "🚣‍♀️",
  woman_running: "🏃‍♀️",
  woman_shrugging: "🤷‍♀️",
  woman_standing: "🧍‍♀️",
  woman_surfing: "🏄‍♀️",
  woman_swimming: "🏊‍♀️",
  woman_tipping_hand: "💁‍♀️",
  woman_walking: "🚶‍♀️",
  woman_wearing_turban: "👳‍♀️",
  woman_with_beard: "🧔‍♀️",
  woman_with_bunny_ears_partying: "👯‍♀️",
  woman_with_probing_cane: "👩‍🦯",
  woman_with_veil: "👰‍♀️",
  woman_woman_boy_boy: "👩‍👩‍👦‍👦",
  woman_woman_boy: "👩‍👩‍👦",
  woman_woman_girl_boy: "👩‍👩‍👧‍👦",
  woman_woman_girl_girl: "👩‍👩‍👧‍👧",
  woman_woman_girl: "👩‍👩‍👧",
  woman_wrestling: "🤼‍♀️",
  woman: "👩",
  womans_clothes: "👚",
  womans_flat_shoe: "🥿",
  womans_hat: "👒",
  women_holding_hands: "👭",
  women_with_bunny_ears_partying: "👯‍♀️",
  womens: "🚺",
  wood: "🪵",
  woozy_face: "🥴",
  world_map: "🗺️",
  worm: "🪱",
  worried: "😟",
  wrench: "🔧",
  wrestlers: "🤼",
  writing_hand: "✍️",
  x: "❌",
  yarn: "🧶",
  yawning_face: "🥱",
  yellow_heart: "💛",
  yen: "💴",
  yin_yang: "☯️",
  yo_yo: "🪀",
  yum: "😋",
  zany_face: "🤪",
  zap: "⚡",
  zebra_face: "🦓",
  zero: "0️⃣",
  zipper_mouth_face: "🤐",
  zombie: "🧟‍♂️",
  zzz: "💤"
};
const NAMES = Object.entries(EMOJI).reduce(
  (acc, [k, v]) => (acc[v] = k, acc),
  {}
);
const replaceNames = /* @__PURE__ */ __name((src) => src.replace(/:([a-z0-9_+-]+):/g, (orig, id) => EMOJI[id] || orig), "replaceNames");
const emoji = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EMOJI,
  NAMES,
  replaceNames
}, Symbol.toStringTag, { value: "Module" }));
var xterm = { exports: {} };
var hasRequiredXterm;
function requireXterm() {
  if (hasRequiredXterm) return xterm.exports;
  hasRequiredXterm = 1;
  (function(module, exports) {
    !(function(e2, t2) {
      module.exports = t2();
    })(globalThis, (() => (() => {
      var e2 = { 4567: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.AccessibilityManager = void 0;
        const n = i2(9042), o = i2(9924), a = i2(844), h = i2(4725), c = i2(2585), l = i2(3656);
        let d = t3.AccessibilityManager = class extends a.Disposable {
          constructor(e4, t4, i3, s3) {
            super(), this._terminal = e4, this._coreBrowserService = i3, this._renderService = s3, this._rowColumns = /* @__PURE__ */ new WeakMap(), this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = this._coreBrowserService.mainDocument.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = this._coreBrowserService.mainDocument.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
            for (let e5 = 0; e5 < this._terminal.rows; e5++) this._rowElements[e5] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e5]);
            if (this._topBoundaryFocusListener = (e5) => this._handleBoundaryFocus(e5, 0), this._bottomBoundaryFocusListener = (e5) => this._handleBoundaryFocus(e5, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = this._coreBrowserService.mainDocument.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new o.TimeBasedDebouncer(this._renderRows.bind(this))), !this._terminal.element) throw new Error("Cannot enable accessibility before Terminal.open");
            this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._terminal.onResize(((e5) => this._handleResize(e5.rows)))), this.register(this._terminal.onRender(((e5) => this._refreshRows(e5.start, e5.end)))), this.register(this._terminal.onScroll((() => this._refreshRows()))), this.register(this._terminal.onA11yChar(((e5) => this._handleChar(e5)))), this.register(this._terminal.onLineFeed((() => this._handleChar("\n")))), this.register(this._terminal.onA11yTab(((e5) => this._handleTab(e5)))), this.register(this._terminal.onKey(((e5) => this._handleKey(e5.key)))), this.register(this._terminal.onBlur((() => this._clearLiveRegion()))), this.register(this._renderService.onDimensionsChange((() => this._refreshRowsDimensions()))), this.register((0, l.addDisposableDomListener)(document, "selectionchange", (() => this._handleSelectionChange()))), this.register(this._coreBrowserService.onDprChange((() => this._refreshRowsDimensions()))), this._refreshRows(), this.register((0, a.toDisposable)((() => {
              this._accessibilityContainer.remove(), this._rowElements.length = 0;
            })));
          }
          _handleTab(e4) {
            for (let t4 = 0; t4 < e4; t4++) this._handleChar(" ");
          }
          _handleChar(e4) {
            this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== e4 && (this._charsToAnnounce += e4) : this._charsToAnnounce += e4, "\n" === e4 && (this._liveRegionLineCount++, 21 === this._liveRegionLineCount && (this._liveRegion.textContent += n.tooMuchOutput)));
          }
          _clearLiveRegion() {
            this._liveRegion.textContent = "", this._liveRegionLineCount = 0;
          }
          _handleKey(e4) {
            this._clearLiveRegion(), /\p{Control}/u.test(e4) || this._charsToConsume.push(e4);
          }
          _refreshRows(e4, t4) {
            this._liveRegionDebouncer.refresh(e4, t4, this._terminal.rows);
          }
          _renderRows(e4, t4) {
            const i3 = this._terminal.buffer, s3 = i3.lines.length.toString();
            for (let r2 = e4; r2 <= t4; r2++) {
              const e5 = i3.lines.get(i3.ydisp + r2), t5 = [], n2 = e5?.translateToString(true, void 0, void 0, t5) || "", o2 = (i3.ydisp + r2 + 1).toString(), a2 = this._rowElements[r2];
              a2 && (0 === n2.length ? (a2.innerText = " ", this._rowColumns.set(a2, [0, 1])) : (a2.textContent = n2, this._rowColumns.set(a2, t5)), a2.setAttribute("aria-posinset", o2), a2.setAttribute("aria-setsize", s3));
            }
            this._announceCharacters();
          }
          _announceCharacters() {
            0 !== this._charsToAnnounce.length && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
          }
          _handleBoundaryFocus(e4, t4) {
            const i3 = e4.target, s3 = this._rowElements[0 === t4 ? 1 : this._rowElements.length - 2];
            if (i3.getAttribute("aria-posinset") === (0 === t4 ? "1" : `${this._terminal.buffer.lines.length}`)) return;
            if (e4.relatedTarget !== s3) return;
            let r2, n2;
            if (0 === t4 ? (r2 = i3, n2 = this._rowElements.pop(), this._rowContainer.removeChild(n2)) : (r2 = this._rowElements.shift(), n2 = i3, this._rowContainer.removeChild(r2)), r2.removeEventListener("focus", this._topBoundaryFocusListener), n2.removeEventListener("focus", this._bottomBoundaryFocusListener), 0 === t4) {
              const e5 = this._createAccessibilityTreeNode();
              this._rowElements.unshift(e5), this._rowContainer.insertAdjacentElement("afterbegin", e5);
            } else {
              const e5 = this._createAccessibilityTreeNode();
              this._rowElements.push(e5), this._rowContainer.appendChild(e5);
            }
            this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(0 === t4 ? -1 : 1), this._rowElements[0 === t4 ? 1 : this._rowElements.length - 2].focus(), e4.preventDefault(), e4.stopImmediatePropagation();
          }
          _handleSelectionChange() {
            if (0 === this._rowElements.length) return;
            const e4 = document.getSelection();
            if (!e4) return;
            if (e4.isCollapsed) return void (this._rowContainer.contains(e4.anchorNode) && this._terminal.clearSelection());
            if (!e4.anchorNode || !e4.focusNode) return void console.error("anchorNode and/or focusNode are null");
            let t4 = { node: e4.anchorNode, offset: e4.anchorOffset }, i3 = { node: e4.focusNode, offset: e4.focusOffset };
            if ((t4.node.compareDocumentPosition(i3.node) & Node.DOCUMENT_POSITION_PRECEDING || t4.node === i3.node && t4.offset > i3.offset) && ([t4, i3] = [i3, t4]), t4.node.compareDocumentPosition(this._rowElements[0]) & (Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING) && (t4 = { node: this._rowElements[0].childNodes[0], offset: 0 }), !this._rowContainer.contains(t4.node)) return;
            const s3 = this._rowElements.slice(-1)[0];
            if (i3.node.compareDocumentPosition(s3) & (Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_PRECEDING) && (i3 = { node: s3, offset: s3.textContent?.length ?? 0 }), !this._rowContainer.contains(i3.node)) return;
            const r2 = /* @__PURE__ */ __name(({ node: e5, offset: t5 }) => {
              const i4 = e5 instanceof Text ? e5.parentNode : e5;
              let s4 = parseInt(i4?.getAttribute("aria-posinset"), 10) - 1;
              if (isNaN(s4)) return console.warn("row is invalid. Race condition?"), null;
              const r3 = this._rowColumns.get(i4);
              if (!r3) return console.warn("columns is null. Race condition?"), null;
              let n3 = t5 < r3.length ? r3[t5] : r3.slice(-1)[0] + 1;
              return n3 >= this._terminal.cols && (++s4, n3 = 0), { row: s4, column: n3 };
            }, "r"), n2 = r2(t4), o2 = r2(i3);
            if (n2 && o2) {
              if (n2.row > o2.row || n2.row === o2.row && n2.column >= o2.column) throw new Error("invalid range");
              this._terminal.select(n2.column, n2.row, (o2.row - n2.row) * this._terminal.cols - n2.column + o2.column);
            }
          }
          _handleResize(e4) {
            this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
            for (let e5 = this._rowContainer.children.length; e5 < this._terminal.rows; e5++) this._rowElements[e5] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e5]);
            for (; this._rowElements.length > e4; ) this._rowContainer.removeChild(this._rowElements.pop());
            this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
          }
          _createAccessibilityTreeNode() {
            const e4 = this._coreBrowserService.mainDocument.createElement("div");
            return e4.setAttribute("role", "listitem"), e4.tabIndex = -1, this._refreshRowDimensions(e4), e4;
          }
          _refreshRowsDimensions() {
            if (this._renderService.dimensions.css.cell.height) {
              this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
              for (let e4 = 0; e4 < this._terminal.rows; e4++) this._refreshRowDimensions(this._rowElements[e4]);
            }
          }
          _refreshRowDimensions(e4) {
            e4.style.height = `${this._renderService.dimensions.css.cell.height}px`;
          }
        };
        t3.AccessibilityManager = d = s2([r(1, c.IInstantiationService), r(2, h.ICoreBrowserService), r(3, h.IRenderService)], d);
      }, 3614: (e3, t3) => {
        function i2(e4) {
          return e4.replace(/\r?\n/g, "\r");
        }
        __name(i2, "i");
        function s2(e4, t4) {
          return t4 ? "\x1B[200~" + e4 + "\x1B[201~" : e4;
        }
        __name(s2, "s");
        function r(e4, t4, r2, n2) {
          e4 = s2(e4 = i2(e4), r2.decPrivateModes.bracketedPasteMode && true !== n2.rawOptions.ignoreBracketedPasteMode), r2.triggerDataEvent(e4, true), t4.value = "";
        }
        __name(r, "r");
        function n(e4, t4, i3) {
          const s3 = i3.getBoundingClientRect(), r2 = e4.clientX - s3.left - 10, n2 = e4.clientY - s3.top - 10;
          t4.style.width = "20px", t4.style.height = "20px", t4.style.left = `${r2}px`, t4.style.top = `${n2}px`, t4.style.zIndex = "1000", t4.focus();
        }
        __name(n, "n");
        Object.defineProperty(t3, "__esModule", { value: true }), t3.rightClickHandler = t3.moveTextAreaUnderMouseCursor = t3.paste = t3.handlePasteEvent = t3.copyHandler = t3.bracketTextForPaste = t3.prepareTextForTerminal = void 0, t3.prepareTextForTerminal = i2, t3.bracketTextForPaste = s2, t3.copyHandler = function(e4, t4) {
          e4.clipboardData && e4.clipboardData.setData("text/plain", t4.selectionText), e4.preventDefault();
        }, t3.handlePasteEvent = function(e4, t4, i3, s3) {
          e4.stopPropagation(), e4.clipboardData && r(e4.clipboardData.getData("text/plain"), t4, i3, s3);
        }, t3.paste = r, t3.moveTextAreaUnderMouseCursor = n, t3.rightClickHandler = function(e4, t4, i3, s3, r2) {
          n(e4, t4, i3), r2 && s3.rightClickSelect(e4), t4.value = s3.selectionText, t4.select();
        };
      }, 7239: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.ColorContrastCache = void 0;
        const s2 = i2(1505);
        t3.ColorContrastCache = class {
          constructor() {
            this._color = new s2.TwoKeyMap(), this._css = new s2.TwoKeyMap();
          }
          setCss(e4, t4, i3) {
            this._css.set(e4, t4, i3);
          }
          getCss(e4, t4) {
            return this._css.get(e4, t4);
          }
          setColor(e4, t4, i3) {
            this._color.set(e4, t4, i3);
          }
          getColor(e4, t4) {
            return this._color.get(e4, t4);
          }
          clear() {
            this._color.clear(), this._css.clear();
          }
        };
      }, 3656: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.addDisposableDomListener = void 0, t3.addDisposableDomListener = function(e4, t4, i2, s2) {
          e4.addEventListener(t4, i2, s2);
          let r = false;
          return { dispose: /* @__PURE__ */ __name(() => {
            r || (r = true, e4.removeEventListener(t4, i2, s2));
          }, "dispose") };
        };
      }, 3551: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.Linkifier = void 0;
        const n = i2(3656), o = i2(8460), a = i2(844), h = i2(2585), c = i2(4725);
        let l = t3.Linkifier = class extends a.Disposable {
          get currentLink() {
            return this._currentLink;
          }
          constructor(e4, t4, i3, s3, r2) {
            super(), this._element = e4, this._mouseService = t4, this._renderService = i3, this._bufferService = s3, this._linkProviderService = r2, this._linkCacheDisposables = [], this._isMouseOut = true, this._wasResized = false, this._activeLine = -1, this._onShowLinkUnderline = this.register(new o.EventEmitter()), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new o.EventEmitter()), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, a.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, a.toDisposable)((() => {
              this._lastMouseEvent = void 0, this._activeProviderReplies?.clear();
            }))), this.register(this._bufferService.onResize((() => {
              this._clearCurrentLink(), this._wasResized = true;
            }))), this.register((0, n.addDisposableDomListener)(this._element, "mouseleave", (() => {
              this._isMouseOut = true, this._clearCurrentLink();
            }))), this.register((0, n.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
          }
          _handleMouseMove(e4) {
            this._lastMouseEvent = e4;
            const t4 = this._positionFromMouseEvent(e4, this._element, this._mouseService);
            if (!t4) return;
            this._isMouseOut = false;
            const i3 = e4.composedPath();
            for (let e5 = 0; e5 < i3.length; e5++) {
              const t5 = i3[e5];
              if (t5.classList.contains("xterm")) break;
              if (t5.classList.contains("xterm-hover")) return;
            }
            this._lastBufferCell && t4.x === this._lastBufferCell.x && t4.y === this._lastBufferCell.y || (this._handleHover(t4), this._lastBufferCell = t4);
          }
          _handleHover(e4) {
            if (this._activeLine !== e4.y || this._wasResized) return this._clearCurrentLink(), this._askForLink(e4, false), void (this._wasResized = false);
            this._currentLink && this._linkAtPosition(this._currentLink.link, e4) || (this._clearCurrentLink(), this._askForLink(e4, true));
          }
          _askForLink(e4, t4) {
            this._activeProviderReplies && t4 || (this._activeProviderReplies?.forEach(((e5) => {
              e5?.forEach(((e6) => {
                e6.link.dispose && e6.link.dispose();
              }));
            })), this._activeProviderReplies = /* @__PURE__ */ new Map(), this._activeLine = e4.y);
            let i3 = false;
            for (const [s3, r2] of this._linkProviderService.linkProviders.entries()) if (t4) {
              const t5 = this._activeProviderReplies?.get(s3);
              t5 && (i3 = this._checkLinkProviderResult(s3, e4, i3));
            } else r2.provideLinks(e4.y, ((t5) => {
              if (this._isMouseOut) return;
              const r3 = t5?.map(((e5) => ({ link: e5 })));
              this._activeProviderReplies?.set(s3, r3), i3 = this._checkLinkProviderResult(s3, e4, i3), this._activeProviderReplies?.size === this._linkProviderService.linkProviders.length && this._removeIntersectingLinks(e4.y, this._activeProviderReplies);
            }));
          }
          _removeIntersectingLinks(e4, t4) {
            const i3 = /* @__PURE__ */ new Set();
            for (let s3 = 0; s3 < t4.size; s3++) {
              const r2 = t4.get(s3);
              if (r2) for (let t5 = 0; t5 < r2.length; t5++) {
                const s4 = r2[t5], n2 = s4.link.range.start.y < e4 ? 0 : s4.link.range.start.x, o2 = s4.link.range.end.y > e4 ? this._bufferService.cols : s4.link.range.end.x;
                for (let e5 = n2; e5 <= o2; e5++) {
                  if (i3.has(e5)) {
                    r2.splice(t5--, 1);
                    break;
                  }
                  i3.add(e5);
                }
              }
            }
          }
          _checkLinkProviderResult(e4, t4, i3) {
            if (!this._activeProviderReplies) return i3;
            const s3 = this._activeProviderReplies.get(e4);
            let r2 = false;
            for (let t5 = 0; t5 < e4; t5++) this._activeProviderReplies.has(t5) && !this._activeProviderReplies.get(t5) || (r2 = true);
            if (!r2 && s3) {
              const e5 = s3.find(((e6) => this._linkAtPosition(e6.link, t4)));
              e5 && (i3 = true, this._handleNewLink(e5));
            }
            if (this._activeProviderReplies.size === this._linkProviderService.linkProviders.length && !i3) for (let e5 = 0; e5 < this._activeProviderReplies.size; e5++) {
              const s4 = this._activeProviderReplies.get(e5)?.find(((e6) => this._linkAtPosition(e6.link, t4)));
              if (s4) {
                i3 = true, this._handleNewLink(s4);
                break;
              }
            }
            return i3;
          }
          _handleMouseDown() {
            this._mouseDownLink = this._currentLink;
          }
          _handleMouseUp(e4) {
            if (!this._currentLink) return;
            const t4 = this._positionFromMouseEvent(e4, this._element, this._mouseService);
            t4 && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, t4) && this._currentLink.link.activate(e4, this._currentLink.link.text);
          }
          _clearCurrentLink(e4, t4) {
            this._currentLink && this._lastMouseEvent && (!e4 || !t4 || this._currentLink.link.range.start.y >= e4 && this._currentLink.link.range.end.y <= t4) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, a.disposeArray)(this._linkCacheDisposables));
          }
          _handleNewLink(e4) {
            if (!this._lastMouseEvent) return;
            const t4 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
            t4 && this._linkAtPosition(e4.link, t4) && (this._currentLink = e4, this._currentLink.state = { decorations: { underline: void 0 === e4.link.decorations || e4.link.decorations.underline, pointerCursor: void 0 === e4.link.decorations || e4.link.decorations.pointerCursor }, isHovered: true }, this._linkHover(this._element, e4.link, this._lastMouseEvent), e4.link.decorations = {}, Object.defineProperties(e4.link.decorations, { pointerCursor: { get: /* @__PURE__ */ __name(() => this._currentLink?.state?.decorations.pointerCursor, "get"), set: /* @__PURE__ */ __name((e5) => {
              this._currentLink?.state && this._currentLink.state.decorations.pointerCursor !== e5 && (this._currentLink.state.decorations.pointerCursor = e5, this._currentLink.state.isHovered && this._element.classList.toggle("xterm-cursor-pointer", e5));
            }, "set") }, underline: { get: /* @__PURE__ */ __name(() => this._currentLink?.state?.decorations.underline, "get"), set: /* @__PURE__ */ __name((t5) => {
              this._currentLink?.state && this._currentLink?.state?.decorations.underline !== t5 && (this._currentLink.state.decorations.underline = t5, this._currentLink.state.isHovered && this._fireUnderlineEvent(e4.link, t5));
            }, "set") } }), this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange(((e5) => {
              if (!this._currentLink) return;
              const t5 = 0 === e5.start ? 0 : e5.start + 1 + this._bufferService.buffer.ydisp, i3 = this._bufferService.buffer.ydisp + 1 + e5.end;
              if (this._currentLink.link.range.start.y >= t5 && this._currentLink.link.range.end.y <= i3 && (this._clearCurrentLink(t5, i3), this._lastMouseEvent)) {
                const e6 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
                e6 && this._askForLink(e6, false);
              }
            }))));
          }
          _linkHover(e4, t4, i3) {
            this._currentLink?.state && (this._currentLink.state.isHovered = true, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t4, true), this._currentLink.state.decorations.pointerCursor && e4.classList.add("xterm-cursor-pointer")), t4.hover && t4.hover(i3, t4.text);
          }
          _fireUnderlineEvent(e4, t4) {
            const i3 = e4.range, s3 = this._bufferService.buffer.ydisp, r2 = this._createLinkUnderlineEvent(i3.start.x - 1, i3.start.y - s3 - 1, i3.end.x, i3.end.y - s3 - 1, void 0);
            (t4 ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(r2);
          }
          _linkLeave(e4, t4, i3) {
            this._currentLink?.state && (this._currentLink.state.isHovered = false, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t4, false), this._currentLink.state.decorations.pointerCursor && e4.classList.remove("xterm-cursor-pointer")), t4.leave && t4.leave(i3, t4.text);
          }
          _linkAtPosition(e4, t4) {
            const i3 = e4.range.start.y * this._bufferService.cols + e4.range.start.x, s3 = e4.range.end.y * this._bufferService.cols + e4.range.end.x, r2 = t4.y * this._bufferService.cols + t4.x;
            return i3 <= r2 && r2 <= s3;
          }
          _positionFromMouseEvent(e4, t4, i3) {
            const s3 = i3.getCoords(e4, t4, this._bufferService.cols, this._bufferService.rows);
            if (s3) return { x: s3[0], y: s3[1] + this._bufferService.buffer.ydisp };
          }
          _createLinkUnderlineEvent(e4, t4, i3, s3, r2) {
            return { x1: e4, y1: t4, x2: i3, y2: s3, cols: this._bufferService.cols, fg: r2 };
          }
        };
        t3.Linkifier = l = s2([r(1, c.IMouseService), r(2, c.IRenderService), r(3, h.IBufferService), r(4, c.ILinkProviderService)], l);
      }, 9042: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.tooMuchOutput = t3.promptLabel = void 0, t3.promptLabel = "Terminal input", t3.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
      }, 3730: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.OscLinkProvider = void 0;
        const n = i2(511), o = i2(2585);
        let a = t3.OscLinkProvider = class {
          constructor(e4, t4, i3) {
            this._bufferService = e4, this._optionsService = t4, this._oscLinkService = i3;
          }
          provideLinks(e4, t4) {
            const i3 = this._bufferService.buffer.lines.get(e4 - 1);
            if (!i3) return void t4(void 0);
            const s3 = [], r2 = this._optionsService.rawOptions.linkHandler, o2 = new n.CellData(), a2 = i3.getTrimmedLength();
            let c = -1, l = -1, d = false;
            for (let t5 = 0; t5 < a2; t5++) if (-1 !== l || i3.hasContent(t5)) {
              if (i3.loadCell(t5, o2), o2.hasExtendedAttrs() && o2.extended.urlId) {
                if (-1 === l) {
                  l = t5, c = o2.extended.urlId;
                  continue;
                }
                d = o2.extended.urlId !== c;
              } else -1 !== l && (d = true);
              if (d || -1 !== l && t5 === a2 - 1) {
                const i4 = this._oscLinkService.getLinkData(c)?.uri;
                if (i4) {
                  const n2 = { start: { x: l + 1, y: e4 }, end: { x: t5 + (d || t5 !== a2 - 1 ? 0 : 1), y: e4 } };
                  let o3 = false;
                  if (!r2?.allowNonHttpProtocols) try {
                    const e5 = new URL(i4);
                    ["http:", "https:"].includes(e5.protocol) || (o3 = true);
                  } catch (e5) {
                    o3 = true;
                  }
                  o3 || s3.push({ text: i4, range: n2, activate: /* @__PURE__ */ __name((e5, t6) => r2 ? r2.activate(e5, t6, n2) : h(0, t6), "activate"), hover: /* @__PURE__ */ __name((e5, t6) => r2?.hover?.(e5, t6, n2), "hover"), leave: /* @__PURE__ */ __name((e5, t6) => r2?.leave?.(e5, t6, n2), "leave") });
                }
                d = false, o2.hasExtendedAttrs() && o2.extended.urlId ? (l = t5, c = o2.extended.urlId) : (l = -1, c = -1);
              }
            }
            t4(s3);
          }
        };
        function h(e4, t4) {
          if (confirm(`Do you want to navigate to ${t4}?

WARNING: This link could potentially be dangerous`)) {
            const e5 = window.open();
            if (e5) {
              try {
                e5.opener = null;
              } catch {
              }
              e5.location.href = t4;
            } else console.warn("Opening link blocked as opener could not be cleared");
          }
        }
        __name(h, "h");
        t3.OscLinkProvider = a = s2([r(0, o.IBufferService), r(1, o.IOptionsService), r(2, o.IOscLinkService)], a);
      }, 6193: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.RenderDebouncer = void 0, t3.RenderDebouncer = class {
          constructor(e4, t4) {
            this._renderCallback = e4, this._coreBrowserService = t4, this._refreshCallbacks = [];
          }
          dispose() {
            this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
          }
          addRefreshCallback(e4) {
            return this._refreshCallbacks.push(e4), this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame((() => this._innerRefresh()))), this._animationFrame;
          }
          refresh(e4, t4, i2) {
            this._rowCount = i2, e4 = void 0 !== e4 ? e4 : 0, t4 = void 0 !== t4 ? t4 : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e4) : e4, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t4) : t4, this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame((() => this._innerRefresh())));
          }
          _innerRefresh() {
            if (this._animationFrame = void 0, void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount) return void this._runRefreshCallbacks();
            const e4 = Math.max(this._rowStart, 0), t4 = Math.min(this._rowEnd, this._rowCount - 1);
            this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e4, t4), this._runRefreshCallbacks();
          }
          _runRefreshCallbacks() {
            for (const e4 of this._refreshCallbacks) e4(0);
            this._refreshCallbacks = [];
          }
        };
      }, 3236: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.Terminal = void 0;
        const s2 = i2(3614), r = i2(3656), n = i2(3551), o = i2(9042), a = i2(3730), h = i2(1680), c = i2(3107), l = i2(5744), d = i2(2950), _ = i2(1296), u = i2(428), f = i2(4269), v = i2(5114), p = i2(8934), g = i2(3230), m = i2(9312), S = i2(4725), C = i2(6731), b = i2(8055), w = i2(8969), y = i2(8460), E = i2(844), k = i2(6114), L = i2(8437), D = i2(2584), R = i2(7399), x = i2(5941), A = i2(9074), B = i2(2585), T = i2(5435), M = i2(4567), O = i2(779);
        const _P = class _P extends w.CoreTerminal {
          get onFocus() {
            return this._onFocus.event;
          }
          get onBlur() {
            return this._onBlur.event;
          }
          get onA11yChar() {
            return this._onA11yCharEmitter.event;
          }
          get onA11yTab() {
            return this._onA11yTabEmitter.event;
          }
          get onWillOpen() {
            return this._onWillOpen.event;
          }
          constructor(e4 = {}) {
            super(e4), this.browser = k, this._keyDownHandled = false, this._keyDownSeen = false, this._keyPressHandled = false, this._unprocessedDeadKey = false, this._accessibilityManager = this.register(new E.MutableDisposable()), this._onCursorMove = this.register(new y.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new y.EventEmitter()), this.onKey = this._onKey.event, this._onRender = this.register(new y.EventEmitter()), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new y.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new y.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new y.EventEmitter()), this.onBell = this._onBell.event, this._onFocus = this.register(new y.EventEmitter()), this._onBlur = this.register(new y.EventEmitter()), this._onA11yCharEmitter = this.register(new y.EventEmitter()), this._onA11yTabEmitter = this.register(new y.EventEmitter()), this._onWillOpen = this.register(new y.EventEmitter()), this._setup(), this._decorationService = this._instantiationService.createInstance(A.DecorationService), this._instantiationService.setService(B.IDecorationService, this._decorationService), this._linkProviderService = this._instantiationService.createInstance(O.LinkProviderService), this._instantiationService.setService(S.ILinkProviderService, this._linkProviderService), this._linkProviderService.registerLinkProvider(this._instantiationService.createInstance(a.OscLinkProvider)), this.register(this._inputHandler.onRequestBell((() => this._onBell.fire()))), this.register(this._inputHandler.onRequestRefreshRows(((e5, t4) => this.refresh(e5, t4)))), this.register(this._inputHandler.onRequestSendFocus((() => this._reportFocus()))), this.register(this._inputHandler.onRequestReset((() => this.reset()))), this.register(this._inputHandler.onRequestWindowsOptionsReport(((e5) => this._reportWindowsOptions(e5)))), this.register(this._inputHandler.onColor(((e5) => this._handleColorEvent(e5)))), this.register((0, y.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, y.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, y.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, y.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize(((e5) => this._afterResize(e5.cols, e5.rows)))), this.register((0, E.toDisposable)((() => {
              this._customKeyEventHandler = void 0, this.element?.parentNode?.removeChild(this.element);
            })));
          }
          _handleColorEvent(e4) {
            if (this._themeService) for (const t4 of e4) {
              let e5, i3 = "";
              switch (t4.index) {
                case 256:
                  e5 = "foreground", i3 = "10";
                  break;
                case 257:
                  e5 = "background", i3 = "11";
                  break;
                case 258:
                  e5 = "cursor", i3 = "12";
                  break;
                default:
                  e5 = "ansi", i3 = "4;" + t4.index;
              }
              switch (t4.type) {
                case 0:
                  const s3 = b.color.toColorRGB("ansi" === e5 ? this._themeService.colors.ansi[t4.index] : this._themeService.colors[e5]);
                  this.coreService.triggerDataEvent(`${D.C0.ESC}]${i3};${(0, x.toRgbString)(s3)}${D.C1_ESCAPED.ST}`);
                  break;
                case 1:
                  if ("ansi" === e5) this._themeService.modifyColors(((e6) => e6.ansi[t4.index] = b.channels.toColor(...t4.color)));
                  else {
                    const i4 = e5;
                    this._themeService.modifyColors(((e6) => e6[i4] = b.channels.toColor(...t4.color)));
                  }
                  break;
                case 2:
                  this._themeService.restoreColor(t4.index);
              }
            }
          }
          _setup() {
            super._setup(), this._customKeyEventHandler = void 0;
          }
          get buffer() {
            return this.buffers.active;
          }
          focus() {
            this.textarea && this.textarea.focus({ preventScroll: true });
          }
          _handleScreenReaderModeOptionChange(e4) {
            e4 ? !this._accessibilityManager.value && this._renderService && (this._accessibilityManager.value = this._instantiationService.createInstance(M.AccessibilityManager, this)) : this._accessibilityManager.clear();
          }
          _handleTextAreaFocus(e4) {
            this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(D.C0.ESC + "[I"), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
          }
          blur() {
            return this.textarea?.blur();
          }
          _handleTextAreaBlur() {
            this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(D.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
          }
          _syncTextArea() {
            if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService) return;
            const e4 = this.buffer.ybase + this.buffer.y, t4 = this.buffer.lines.get(e4);
            if (!t4) return;
            const i3 = Math.min(this.buffer.x, this.cols - 1), s3 = this._renderService.dimensions.css.cell.height, r2 = t4.getWidth(i3), n2 = this._renderService.dimensions.css.cell.width * r2, o2 = this.buffer.y * this._renderService.dimensions.css.cell.height, a2 = i3 * this._renderService.dimensions.css.cell.width;
            this.textarea.style.left = a2 + "px", this.textarea.style.top = o2 + "px", this.textarea.style.width = n2 + "px", this.textarea.style.height = s3 + "px", this.textarea.style.lineHeight = s3 + "px", this.textarea.style.zIndex = "-5";
          }
          _initGlobal() {
            this._bindKeys(), this.register((0, r.addDisposableDomListener)(this.element, "copy", ((e5) => {
              this.hasSelection() && (0, s2.copyHandler)(e5, this._selectionService);
            })));
            const e4 = /* @__PURE__ */ __name((e5) => (0, s2.handlePasteEvent)(e5, this.textarea, this.coreService, this.optionsService), "e");
            this.register((0, r.addDisposableDomListener)(this.textarea, "paste", e4)), this.register((0, r.addDisposableDomListener)(this.element, "paste", e4)), k.isFirefox ? this.register((0, r.addDisposableDomListener)(this.element, "mousedown", ((e5) => {
              2 === e5.button && (0, s2.rightClickHandler)(e5, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
            }))) : this.register((0, r.addDisposableDomListener)(this.element, "contextmenu", ((e5) => {
              (0, s2.rightClickHandler)(e5, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
            }))), k.isLinux && this.register((0, r.addDisposableDomListener)(this.element, "auxclick", ((e5) => {
              1 === e5.button && (0, s2.moveTextAreaUnderMouseCursor)(e5, this.textarea, this.screenElement);
            })));
          }
          _bindKeys() {
            this.register((0, r.addDisposableDomListener)(this.textarea, "keyup", ((e4) => this._keyUp(e4)), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "keydown", ((e4) => this._keyDown(e4)), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "keypress", ((e4) => this._keyPress(e4)), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionstart", (() => this._compositionHelper.compositionstart()))), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionupdate", ((e4) => this._compositionHelper.compositionupdate(e4)))), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionend", (() => this._compositionHelper.compositionend()))), this.register((0, r.addDisposableDomListener)(this.textarea, "input", ((e4) => this._inputEvent(e4)), true)), this.register(this.onRender((() => this._compositionHelper.updateCompositionElements())));
          }
          open(e4) {
            if (!e4) throw new Error("Terminal requires a parent element.");
            if (e4.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this.element?.ownerDocument.defaultView && this._coreBrowserService) return void (this.element.ownerDocument.defaultView !== this._coreBrowserService.window && (this._coreBrowserService.window = this.element.ownerDocument.defaultView));
            this._document = e4.ownerDocument, this.options.documentOverride && this.options.documentOverride instanceof Document && (this._document = this.optionsService.rawOptions.documentOverride), this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), e4.appendChild(this.element);
            const t4 = this._document.createDocumentFragment();
            this._viewportElement = this._document.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), t4.appendChild(this._viewportElement), this._viewportScrollArea = this._document.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = this._document.createElement("div"), this.screenElement.classList.add("xterm-screen"), this.register((0, r.addDisposableDomListener)(this.screenElement, "mousemove", ((e5) => this.updateCursorStyle(e5)))), this._helperContainer = this._document.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), t4.appendChild(this.screenElement), this.textarea = this._document.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", o.promptLabel), k.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this.register(this._instantiationService.createInstance(v.CoreBrowserService, this.textarea, e4.ownerDocument.defaultView ?? window, this._document ?? "undefined" != typeof window ? window.document : null)), this._instantiationService.setService(S.ICoreBrowserService, this._coreBrowserService), this.register((0, r.addDisposableDomListener)(this.textarea, "focus", ((e5) => this._handleTextAreaFocus(e5)))), this.register((0, r.addDisposableDomListener)(this.textarea, "blur", (() => this._handleTextAreaBlur()))), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(u.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(S.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(C.ThemeService), this._instantiationService.setService(S.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(f.CharacterJoinerService), this._instantiationService.setService(S.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(g.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(S.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange(((e5) => this._onRender.fire(e5)))), this.onResize(((e5) => this._renderService.resize(e5.cols, e5.rows))), this._compositionView = this._document.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(d.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this._mouseService = this._instantiationService.createInstance(p.MouseService), this._instantiationService.setService(S.IMouseService, this._mouseService), this.linkifier = this.register(this._instantiationService.createInstance(n.Linkifier, this.screenElement)), this.element.appendChild(t4);
            try {
              this._onWillOpen.fire(this.element);
            } catch {
            }
            this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this.viewport = this._instantiationService.createInstance(h.Viewport, this._viewportElement, this._viewportScrollArea), this.viewport.onRequestScrollLines(((e5) => this.scrollLines(e5.amount, e5.suppressScrollEvent, 1))), this.register(this._inputHandler.onRequestSyncScrollBar((() => this.viewport.syncScrollArea()))), this.register(this.viewport), this.register(this.onCursorMove((() => {
              this._renderService.handleCursorMove(), this._syncTextArea();
            }))), this.register(this.onResize((() => this._renderService.handleResize(this.cols, this.rows)))), this.register(this.onBlur((() => this._renderService.handleBlur()))), this.register(this.onFocus((() => this._renderService.handleFocus()))), this.register(this._renderService.onDimensionsChange((() => this.viewport.syncScrollArea()))), this._selectionService = this.register(this._instantiationService.createInstance(m.SelectionService, this.element, this.screenElement, this.linkifier)), this._instantiationService.setService(S.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines(((e5) => this.scrollLines(e5.amount, e5.suppressScrollEvent)))), this.register(this._selectionService.onSelectionChange((() => this._onSelectionChange.fire()))), this.register(this._selectionService.onRequestRedraw(((e5) => this._renderService.handleSelectionChanged(e5.start, e5.end, e5.columnSelectMode)))), this.register(this._selectionService.onLinuxMouseSelection(((e5) => {
              this.textarea.value = e5, this.textarea.focus(), this.textarea.select();
            }))), this.register(this._onScroll.event(((e5) => {
              this.viewport.syncScrollArea(), this._selectionService.refresh();
            }))), this.register((0, r.addDisposableDomListener)(this._viewportElement, "scroll", (() => this._selectionService.refresh()))), this.register(this._instantiationService.createInstance(c.BufferDecorationRenderer, this.screenElement)), this.register((0, r.addDisposableDomListener)(this.element, "mousedown", ((e5) => this._selectionService.handleMouseDown(e5)))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager.value = this._instantiationService.createInstance(M.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", ((e5) => this._handleScreenReaderModeOptionChange(e5)))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(l.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", ((e5) => {
              !this._overviewRulerRenderer && e5 && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(l.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
            })), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
          }
          _createRenderer() {
            return this._instantiationService.createInstance(_.DomRenderer, this, this._document, this.element, this.screenElement, this._viewportElement, this._helperContainer, this.linkifier);
          }
          bindMouse() {
            const e4 = this, t4 = this.element;
            function i3(t5) {
              const i4 = e4._mouseService.getMouseReportCoords(t5, e4.screenElement);
              if (!i4) return false;
              let s4, r2;
              switch (t5.overrideType || t5.type) {
                case "mousemove":
                  r2 = 32, void 0 === t5.buttons ? (s4 = 3, void 0 !== t5.button && (s4 = t5.button < 3 ? t5.button : 3)) : s4 = 1 & t5.buttons ? 0 : 4 & t5.buttons ? 1 : 2 & t5.buttons ? 2 : 3;
                  break;
                case "mouseup":
                  r2 = 0, s4 = t5.button < 3 ? t5.button : 3;
                  break;
                case "mousedown":
                  r2 = 1, s4 = t5.button < 3 ? t5.button : 3;
                  break;
                case "wheel":
                  if (e4._customWheelEventHandler && false === e4._customWheelEventHandler(t5)) return false;
                  if (0 === e4.viewport.getLinesScrolled(t5)) return false;
                  r2 = t5.deltaY < 0 ? 0 : 1, s4 = 4;
                  break;
                default:
                  return false;
              }
              return !(void 0 === r2 || void 0 === s4 || s4 > 4) && e4.coreMouseService.triggerMouseEvent({ col: i4.col, row: i4.row, x: i4.x, y: i4.y, button: s4, action: r2, ctrl: t5.ctrlKey, alt: t5.altKey, shift: t5.shiftKey });
            }
            __name(i3, "i");
            const s3 = { mouseup: null, wheel: null, mousedrag: null, mousemove: null }, n2 = { mouseup: /* @__PURE__ */ __name((e5) => (i3(e5), e5.buttons || (this._document.removeEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.removeEventListener("mousemove", s3.mousedrag)), this.cancel(e5)), "mouseup"), wheel: /* @__PURE__ */ __name((e5) => (i3(e5), this.cancel(e5, true)), "wheel"), mousedrag: /* @__PURE__ */ __name((e5) => {
              e5.buttons && i3(e5);
            }, "mousedrag"), mousemove: /* @__PURE__ */ __name((e5) => {
              e5.buttons || i3(e5);
            }, "mousemove") };
            this.register(this.coreMouseService.onProtocolChange(((e5) => {
              e5 ? ("debug" === this.optionsService.rawOptions.logLevel && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(e5)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & e5 ? s3.mousemove || (t4.addEventListener("mousemove", n2.mousemove), s3.mousemove = n2.mousemove) : (t4.removeEventListener("mousemove", s3.mousemove), s3.mousemove = null), 16 & e5 ? s3.wheel || (t4.addEventListener("wheel", n2.wheel, { passive: false }), s3.wheel = n2.wheel) : (t4.removeEventListener("wheel", s3.wheel), s3.wheel = null), 2 & e5 ? s3.mouseup || (s3.mouseup = n2.mouseup) : (this._document.removeEventListener("mouseup", s3.mouseup), s3.mouseup = null), 4 & e5 ? s3.mousedrag || (s3.mousedrag = n2.mousedrag) : (this._document.removeEventListener("mousemove", s3.mousedrag), s3.mousedrag = null);
            }))), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, r.addDisposableDomListener)(t4, "mousedown", ((e5) => {
              if (e5.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(e5)) return i3(e5), s3.mouseup && this._document.addEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.addEventListener("mousemove", s3.mousedrag), this.cancel(e5);
            }))), this.register((0, r.addDisposableDomListener)(t4, "wheel", ((e5) => {
              if (!s3.wheel) {
                if (this._customWheelEventHandler && false === this._customWheelEventHandler(e5)) return false;
                if (!this.buffer.hasScrollback) {
                  const t5 = this.viewport.getLinesScrolled(e5);
                  if (0 === t5) return;
                  const i4 = D.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (e5.deltaY < 0 ? "A" : "B");
                  let s4 = "";
                  for (let e6 = 0; e6 < Math.abs(t5); e6++) s4 += i4;
                  return this.coreService.triggerDataEvent(s4, true), this.cancel(e5, true);
                }
                return this.viewport.handleWheel(e5) ? this.cancel(e5) : void 0;
              }
            }), { passive: false })), this.register((0, r.addDisposableDomListener)(t4, "touchstart", ((e5) => {
              if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchStart(e5), this.cancel(e5);
            }), { passive: true })), this.register((0, r.addDisposableDomListener)(t4, "touchmove", ((e5) => {
              if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchMove(e5) ? void 0 : this.cancel(e5);
            }), { passive: false }));
          }
          refresh(e4, t4) {
            this._renderService?.refreshRows(e4, t4);
          }
          updateCursorStyle(e4) {
            this._selectionService?.shouldColumnSelect(e4) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
          }
          _showCursor() {
            this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = true, this.refresh(this.buffer.y, this.buffer.y));
          }
          scrollLines(e4, t4, i3 = 0) {
            1 === i3 ? (super.scrollLines(e4, t4, i3), this.refresh(0, this.rows - 1)) : this.viewport?.scrollLines(e4);
          }
          paste(e4) {
            (0, s2.paste)(e4, this.textarea, this.coreService, this.optionsService);
          }
          attachCustomKeyEventHandler(e4) {
            this._customKeyEventHandler = e4;
          }
          attachCustomWheelEventHandler(e4) {
            this._customWheelEventHandler = e4;
          }
          registerLinkProvider(e4) {
            return this._linkProviderService.registerLinkProvider(e4);
          }
          registerCharacterJoiner(e4) {
            if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
            const t4 = this._characterJoinerService.register(e4);
            return this.refresh(0, this.rows - 1), t4;
          }
          deregisterCharacterJoiner(e4) {
            if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
            this._characterJoinerService.deregister(e4) && this.refresh(0, this.rows - 1);
          }
          get markers() {
            return this.buffer.markers;
          }
          registerMarker(e4) {
            return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + e4);
          }
          registerDecoration(e4) {
            return this._decorationService.registerDecoration(e4);
          }
          hasSelection() {
            return !!this._selectionService && this._selectionService.hasSelection;
          }
          select(e4, t4, i3) {
            this._selectionService.setSelection(e4, t4, i3);
          }
          getSelection() {
            return this._selectionService ? this._selectionService.selectionText : "";
          }
          getSelectionPosition() {
            if (this._selectionService && this._selectionService.hasSelection) return { start: { x: this._selectionService.selectionStart[0], y: this._selectionService.selectionStart[1] }, end: { x: this._selectionService.selectionEnd[0], y: this._selectionService.selectionEnd[1] } };
          }
          clearSelection() {
            this._selectionService?.clearSelection();
          }
          selectAll() {
            this._selectionService?.selectAll();
          }
          selectLines(e4, t4) {
            this._selectionService?.selectLines(e4, t4);
          }
          _keyDown(e4) {
            if (this._keyDownHandled = false, this._keyDownSeen = true, this._customKeyEventHandler && false === this._customKeyEventHandler(e4)) return false;
            const t4 = this.browser.isMac && this.options.macOptionIsMeta && e4.altKey;
            if (!t4 && !this._compositionHelper.keydown(e4)) return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this.scrollToBottom(), false;
            t4 || "Dead" !== e4.key && "AltGraph" !== e4.key || (this._unprocessedDeadKey = true);
            const i3 = (0, R.evaluateKeyboardEvent)(e4, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
            if (this.updateCursorStyle(e4), 3 === i3.type || 2 === i3.type) {
              const t5 = this.rows - 1;
              return this.scrollLines(2 === i3.type ? -t5 : t5), this.cancel(e4, true);
            }
            return 1 === i3.type && this.selectAll(), !!this._isThirdLevelShift(this.browser, e4) || (i3.cancel && this.cancel(e4, true), !i3.key || !!(e4.key && !e4.ctrlKey && !e4.altKey && !e4.metaKey && 1 === e4.key.length && e4.key.charCodeAt(0) >= 65 && e4.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = false, true) : (i3.key !== D.C0.ETX && i3.key !== D.C0.CR || (this.textarea.value = ""), this._onKey.fire({ key: i3.key, domEvent: e4 }), this._showCursor(), this.coreService.triggerDataEvent(i3.key, true), !this.optionsService.rawOptions.screenReaderMode || e4.altKey || e4.ctrlKey ? this.cancel(e4, true) : void (this._keyDownHandled = true))));
          }
          _isThirdLevelShift(e4, t4) {
            const i3 = e4.isMac && !this.options.macOptionIsMeta && t4.altKey && !t4.ctrlKey && !t4.metaKey || e4.isWindows && t4.altKey && t4.ctrlKey && !t4.metaKey || e4.isWindows && t4.getModifierState("AltGraph");
            return "keypress" === t4.type ? i3 : i3 && (!t4.keyCode || t4.keyCode > 47);
          }
          _keyUp(e4) {
            this._keyDownSeen = false, this._customKeyEventHandler && false === this._customKeyEventHandler(e4) || ((function(e5) {
              return 16 === e5.keyCode || 17 === e5.keyCode || 18 === e5.keyCode;
            })(e4) || this.focus(), this.updateCursorStyle(e4), this._keyPressHandled = false);
          }
          _keyPress(e4) {
            let t4;
            if (this._keyPressHandled = false, this._keyDownHandled) return false;
            if (this._customKeyEventHandler && false === this._customKeyEventHandler(e4)) return false;
            if (this.cancel(e4), e4.charCode) t4 = e4.charCode;
            else if (null === e4.which || void 0 === e4.which) t4 = e4.keyCode;
            else {
              if (0 === e4.which || 0 === e4.charCode) return false;
              t4 = e4.which;
            }
            return !(!t4 || (e4.altKey || e4.ctrlKey || e4.metaKey) && !this._isThirdLevelShift(this.browser, e4) || (t4 = String.fromCharCode(t4), this._onKey.fire({ key: t4, domEvent: e4 }), this._showCursor(), this.coreService.triggerDataEvent(t4, true), this._keyPressHandled = true, this._unprocessedDeadKey = false, 0));
          }
          _inputEvent(e4) {
            if (e4.data && "insertText" === e4.inputType && (!e4.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
              if (this._keyPressHandled) return false;
              this._unprocessedDeadKey = false;
              const t4 = e4.data;
              return this.coreService.triggerDataEvent(t4, true), this.cancel(e4), true;
            }
            return false;
          }
          resize(e4, t4) {
            e4 !== this.cols || t4 !== this.rows ? super.resize(e4, t4) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
          }
          _afterResize(e4, t4) {
            this._charSizeService?.measure(), this.viewport?.syncScrollArea(true);
          }
          clear() {
            if (0 !== this.buffer.ybase || 0 !== this.buffer.y) {
              this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
              for (let e4 = 1; e4 < this.rows; e4++) this.buffer.lines.push(this.buffer.getBlankLine(L.DEFAULT_ATTR_DATA));
              this._onScroll.fire({ position: this.buffer.ydisp, source: 0 }), this.viewport?.reset(), this.refresh(0, this.rows - 1);
            }
          }
          reset() {
            this.options.rows = this.rows, this.options.cols = this.cols;
            const e4 = this._customKeyEventHandler;
            this._setup(), super.reset(), this._selectionService?.reset(), this._decorationService.reset(), this.viewport?.reset(), this._customKeyEventHandler = e4, this.refresh(0, this.rows - 1);
          }
          clearTextureAtlas() {
            this._renderService?.clearTextureAtlas();
          }
          _reportFocus() {
            this.element?.classList.contains("focus") ? this.coreService.triggerDataEvent(D.C0.ESC + "[I") : this.coreService.triggerDataEvent(D.C0.ESC + "[O");
          }
          _reportWindowsOptions(e4) {
            if (this._renderService) switch (e4) {
              case T.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
                const e5 = this._renderService.dimensions.css.canvas.width.toFixed(0), t4 = this._renderService.dimensions.css.canvas.height.toFixed(0);
                this.coreService.triggerDataEvent(`${D.C0.ESC}[4;${t4};${e5}t`);
                break;
              case T.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
                const i3 = this._renderService.dimensions.css.cell.width.toFixed(0), s3 = this._renderService.dimensions.css.cell.height.toFixed(0);
                this.coreService.triggerDataEvent(`${D.C0.ESC}[6;${s3};${i3}t`);
            }
          }
          cancel(e4, t4) {
            if (this.options.cancelEvents || t4) return e4.preventDefault(), e4.stopPropagation(), false;
          }
        };
        __name(_P, "P");
        let P = _P;
        t3.Terminal = P;
      }, 9924: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.TimeBasedDebouncer = void 0, t3.TimeBasedDebouncer = class {
          constructor(e4, t4 = 1e3) {
            this._renderCallback = e4, this._debounceThresholdMS = t4, this._lastRefreshMs = 0, this._additionalRefreshRequested = false;
          }
          dispose() {
            this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
          }
          refresh(e4, t4, i2) {
            this._rowCount = i2, e4 = void 0 !== e4 ? e4 : 0, t4 = void 0 !== t4 ? t4 : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e4) : e4, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t4) : t4;
            const s2 = Date.now();
            if (s2 - this._lastRefreshMs >= this._debounceThresholdMS) this._lastRefreshMs = s2, this._innerRefresh();
            else if (!this._additionalRefreshRequested) {
              const e5 = s2 - this._lastRefreshMs, t5 = this._debounceThresholdMS - e5;
              this._additionalRefreshRequested = true, this._refreshTimeoutID = window.setTimeout((() => {
                this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = false, this._refreshTimeoutID = void 0;
              }), t5);
            }
          }
          _innerRefresh() {
            if (void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount) return;
            const e4 = Math.max(this._rowStart, 0), t4 = Math.min(this._rowEnd, this._rowCount - 1);
            this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e4, t4);
          }
        };
      }, 1680: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.Viewport = void 0;
        const n = i2(3656), o = i2(4725), a = i2(8460), h = i2(844), c = i2(2585);
        let l = t3.Viewport = class extends h.Disposable {
          constructor(e4, t4, i3, s3, r2, o2, h2, c2) {
            super(), this._viewportElement = e4, this._scrollArea = t4, this._bufferService = i3, this._optionsService = s3, this._charSizeService = r2, this._renderService = o2, this._coreBrowserService = h2, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = false, this._smoothScrollState = { startTime: 0, origin: -1, target: -1 }, this._onRequestScrollLines = this.register(new a.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, n.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate(((e5) => this._activeBuffer = e5.activeBuffer))), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange(((e5) => this._renderDimensions = e5))), this._handleThemeChange(c2.colors), this.register(c2.onChangeColors(((e5) => this._handleThemeChange(e5)))), this.register(this._optionsService.onSpecificOptionChange("scrollback", (() => this.syncScrollArea()))), setTimeout((() => this.syncScrollArea()));
          }
          _handleThemeChange(e4) {
            this._viewportElement.style.backgroundColor = e4.background.css;
          }
          reset() {
            this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._coreBrowserService.window.requestAnimationFrame((() => this.syncScrollArea()));
          }
          _refresh(e4) {
            if (e4) return this._innerRefresh(), void (null !== this._refreshAnimationFrame && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
            null === this._refreshAnimationFrame && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame((() => this._innerRefresh())));
          }
          _innerRefresh() {
            if (this._charSizeService.height > 0) {
              this._currentRowHeight = this._renderDimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderDimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
              const e5 = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderDimensions.css.canvas.height);
              this._lastRecordedBufferHeight !== e5 && (this._lastRecordedBufferHeight = e5, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
            }
            const e4 = this._bufferService.buffer.ydisp * this._currentRowHeight;
            this._viewportElement.scrollTop !== e4 && (this._ignoreNextScrollEvent = true, this._viewportElement.scrollTop = e4), this._refreshAnimationFrame = null;
          }
          syncScrollArea(e4 = false) {
            if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length) return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(e4);
            this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(e4);
          }
          _handleScroll(e4) {
            if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent) return;
            if (this._ignoreNextScrollEvent) return this._ignoreNextScrollEvent = false, void this._onRequestScrollLines.fire({ amount: 0, suppressScrollEvent: true });
            const t4 = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
            this._onRequestScrollLines.fire({ amount: t4, suppressScrollEvent: true });
          }
          _smoothScroll() {
            if (this._isDisposed || -1 === this._smoothScrollState.origin || -1 === this._smoothScrollState.target) return;
            const e4 = this._smoothScrollPercent();
            this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(e4 * (this._smoothScrollState.target - this._smoothScrollState.origin)), e4 < 1 ? this._coreBrowserService.window.requestAnimationFrame((() => this._smoothScroll())) : this._clearSmoothScrollState();
          }
          _smoothScrollPercent() {
            return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
          }
          _clearSmoothScrollState() {
            this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
          }
          _bubbleScroll(e4, t4) {
            const i3 = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
            return !(t4 < 0 && 0 !== this._viewportElement.scrollTop || t4 > 0 && i3 < this._lastRecordedBufferHeight) || (e4.cancelable && e4.preventDefault(), false);
          }
          handleWheel(e4) {
            const t4 = this._getPixelsScrolled(e4);
            return 0 !== t4 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, -1 === this._smoothScrollState.target ? this._smoothScrollState.target = this._viewportElement.scrollTop + t4 : this._smoothScrollState.target += t4, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += t4, this._bubbleScroll(e4, t4));
          }
          scrollLines(e4) {
            if (0 !== e4) if (this._optionsService.rawOptions.smoothScrollDuration) {
              const t4 = e4 * this._currentRowHeight;
              this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target = this._smoothScrollState.origin + t4, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState();
            } else this._onRequestScrollLines.fire({ amount: e4, suppressScrollEvent: false });
          }
          _getPixelsScrolled(e4) {
            if (0 === e4.deltaY || e4.shiftKey) return 0;
            let t4 = this._applyScrollModifier(e4.deltaY, e4);
            return e4.deltaMode === WheelEvent.DOM_DELTA_LINE ? t4 *= this._currentRowHeight : e4.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t4 *= this._currentRowHeight * this._bufferService.rows), t4;
          }
          getBufferElements(e4, t4) {
            let i3, s3 = "";
            const r2 = [], n2 = t4 ?? this._bufferService.buffer.lines.length, o2 = this._bufferService.buffer.lines;
            for (let t5 = e4; t5 < n2; t5++) {
              const e5 = o2.get(t5);
              if (!e5) continue;
              const n3 = o2.get(t5 + 1)?.isWrapped;
              if (s3 += e5.translateToString(!n3), !n3 || t5 === o2.length - 1) {
                const e6 = document.createElement("div");
                e6.textContent = s3, r2.push(e6), s3.length > 0 && (i3 = e6), s3 = "";
              }
            }
            return { bufferElements: r2, cursorElement: i3 };
          }
          getLinesScrolled(e4) {
            if (0 === e4.deltaY || e4.shiftKey) return 0;
            let t4 = this._applyScrollModifier(e4.deltaY, e4);
            return e4.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (t4 /= this._currentRowHeight + 0, this._wheelPartialScroll += t4, t4 = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : e4.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t4 *= this._bufferService.rows), t4;
          }
          _applyScrollModifier(e4, t4) {
            const i3 = this._optionsService.rawOptions.fastScrollModifier;
            return "alt" === i3 && t4.altKey || "ctrl" === i3 && t4.ctrlKey || "shift" === i3 && t4.shiftKey ? e4 * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : e4 * this._optionsService.rawOptions.scrollSensitivity;
          }
          handleTouchStart(e4) {
            this._lastTouchY = e4.touches[0].pageY;
          }
          handleTouchMove(e4) {
            const t4 = this._lastTouchY - e4.touches[0].pageY;
            return this._lastTouchY = e4.touches[0].pageY, 0 !== t4 && (this._viewportElement.scrollTop += t4, this._bubbleScroll(e4, t4));
          }
        };
        t3.Viewport = l = s2([r(2, c.IBufferService), r(3, c.IOptionsService), r(4, o.ICharSizeService), r(5, o.IRenderService), r(6, o.ICoreBrowserService), r(7, o.IThemeService)], l);
      }, 3107: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.BufferDecorationRenderer = void 0;
        const n = i2(4725), o = i2(844), a = i2(2585);
        let h = t3.BufferDecorationRenderer = class extends o.Disposable {
          constructor(e4, t4, i3, s3, r2) {
            super(), this._screenElement = e4, this._bufferService = t4, this._coreBrowserService = i3, this._decorationService = s3, this._renderService = r2, this._decorationElements = /* @__PURE__ */ new Map(), this._altBufferIsActive = false, this._dimensionsChanged = false, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange((() => this._doRefreshDecorations()))), this.register(this._renderService.onDimensionsChange((() => {
              this._dimensionsChanged = true, this._queueRefresh();
            }))), this.register(this._coreBrowserService.onDprChange((() => this._queueRefresh()))), this.register(this._bufferService.buffers.onBufferActivate((() => {
              this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
            }))), this.register(this._decorationService.onDecorationRegistered((() => this._queueRefresh()))), this.register(this._decorationService.onDecorationRemoved(((e5) => this._removeDecoration(e5)))), this.register((0, o.toDisposable)((() => {
              this._container.remove(), this._decorationElements.clear();
            })));
          }
          _queueRefresh() {
            void 0 === this._animationFrame && (this._animationFrame = this._renderService.addRefreshCallback((() => {
              this._doRefreshDecorations(), this._animationFrame = void 0;
            })));
          }
          _doRefreshDecorations() {
            for (const e4 of this._decorationService.decorations) this._renderDecoration(e4);
            this._dimensionsChanged = false;
          }
          _renderDecoration(e4) {
            this._refreshStyle(e4), this._dimensionsChanged && this._refreshXPosition(e4);
          }
          _createElement(e4) {
            const t4 = this._coreBrowserService.mainDocument.createElement("div");
            t4.classList.add("xterm-decoration"), t4.classList.toggle("xterm-decoration-top-layer", "top" === e4?.options?.layer), t4.style.width = `${Math.round((e4.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, t4.style.height = (e4.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", t4.style.top = (e4.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", t4.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
            const i3 = e4.options.x ?? 0;
            return i3 && i3 > this._bufferService.cols && (t4.style.display = "none"), this._refreshXPosition(e4, t4), t4;
          }
          _refreshStyle(e4) {
            const t4 = e4.marker.line - this._bufferService.buffers.active.ydisp;
            if (t4 < 0 || t4 >= this._bufferService.rows) e4.element && (e4.element.style.display = "none", e4.onRenderEmitter.fire(e4.element));
            else {
              let i3 = this._decorationElements.get(e4);
              i3 || (i3 = this._createElement(e4), e4.element = i3, this._decorationElements.set(e4, i3), this._container.appendChild(i3), e4.onDispose((() => {
                this._decorationElements.delete(e4), i3.remove();
              }))), i3.style.top = t4 * this._renderService.dimensions.css.cell.height + "px", i3.style.display = this._altBufferIsActive ? "none" : "block", e4.onRenderEmitter.fire(i3);
            }
          }
          _refreshXPosition(e4, t4 = e4.element) {
            if (!t4) return;
            const i3 = e4.options.x ?? 0;
            "right" === (e4.options.anchor || "left") ? t4.style.right = i3 ? i3 * this._renderService.dimensions.css.cell.width + "px" : "" : t4.style.left = i3 ? i3 * this._renderService.dimensions.css.cell.width + "px" : "";
          }
          _removeDecoration(e4) {
            this._decorationElements.get(e4)?.remove(), this._decorationElements.delete(e4), e4.dispose();
          }
        };
        t3.BufferDecorationRenderer = h = s2([r(1, a.IBufferService), r(2, n.ICoreBrowserService), r(3, a.IDecorationService), r(4, n.IRenderService)], h);
      }, 5871: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.ColorZoneStore = void 0, t3.ColorZoneStore = class {
          constructor() {
            this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = { full: 0, left: 0, center: 0, right: 0 };
          }
          get zones() {
            return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
          }
          clear() {
            this._zones.length = 0, this._zonePoolIndex = 0;
          }
          addDecoration(e4) {
            if (e4.options.overviewRulerOptions) {
              for (const t4 of this._zones) if (t4.color === e4.options.overviewRulerOptions.color && t4.position === e4.options.overviewRulerOptions.position) {
                if (this._lineIntersectsZone(t4, e4.marker.line)) return;
                if (this._lineAdjacentToZone(t4, e4.marker.line, e4.options.overviewRulerOptions.position)) return void this._addLineToZone(t4, e4.marker.line);
              }
              if (this._zonePoolIndex < this._zonePool.length) return this._zonePool[this._zonePoolIndex].color = e4.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = e4.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = e4.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = e4.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
              this._zones.push({ color: e4.options.overviewRulerOptions.color, position: e4.options.overviewRulerOptions.position, startBufferLine: e4.marker.line, endBufferLine: e4.marker.line }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
            }
          }
          setPadding(e4) {
            this._linePadding = e4;
          }
          _lineIntersectsZone(e4, t4) {
            return t4 >= e4.startBufferLine && t4 <= e4.endBufferLine;
          }
          _lineAdjacentToZone(e4, t4, i2) {
            return t4 >= e4.startBufferLine - this._linePadding[i2 || "full"] && t4 <= e4.endBufferLine + this._linePadding[i2 || "full"];
          }
          _addLineToZone(e4, t4) {
            e4.startBufferLine = Math.min(e4.startBufferLine, t4), e4.endBufferLine = Math.max(e4.endBufferLine, t4);
          }
        };
      }, 5744: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.OverviewRulerRenderer = void 0;
        const n = i2(5871), o = i2(4725), a = i2(844), h = i2(2585), c = { full: 0, left: 0, center: 0, right: 0 }, l = { full: 0, left: 0, center: 0, right: 0 }, d = { full: 0, left: 0, center: 0, right: 0 };
        let _ = t3.OverviewRulerRenderer = class extends a.Disposable {
          get _width() {
            return this._optionsService.options.overviewRulerWidth || 0;
          }
          constructor(e4, t4, i3, s3, r2, o2, h2) {
            super(), this._viewportElement = e4, this._screenElement = t4, this._bufferService = i3, this._decorationService = s3, this._renderService = r2, this._optionsService = o2, this._coreBrowserService = h2, this._colorZoneStore = new n.ColorZoneStore(), this._shouldUpdateDimensions = true, this._shouldUpdateAnchor = true, this._lastKnownBufferLength = 0, this._canvas = this._coreBrowserService.mainDocument.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), this._viewportElement.parentElement?.insertBefore(this._canvas, this._viewportElement);
            const c2 = this._canvas.getContext("2d");
            if (!c2) throw new Error("Ctx cannot be null");
            this._ctx = c2, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, a.toDisposable)((() => {
              this._canvas?.remove();
            })));
          }
          _registerDecorationListeners() {
            this.register(this._decorationService.onDecorationRegistered((() => this._queueRefresh(void 0, true)))), this.register(this._decorationService.onDecorationRemoved((() => this._queueRefresh(void 0, true))));
          }
          _registerBufferChangeListeners() {
            this.register(this._renderService.onRenderedViewportChange((() => this._queueRefresh()))), this.register(this._bufferService.buffers.onBufferActivate((() => {
              this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
            }))), this.register(this._bufferService.onScroll((() => {
              this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
            })));
          }
          _registerDimensionChangeListeners() {
            this.register(this._renderService.onRender((() => {
              this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(true), this._containerHeight = this._screenElement.clientHeight);
            }))), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", (() => this._queueRefresh(true)))), this.register(this._coreBrowserService.onDprChange((() => this._queueRefresh(true)))), this._queueRefresh(true);
          }
          _refreshDrawConstants() {
            const e4 = Math.floor(this._canvas.width / 3), t4 = Math.ceil(this._canvas.width / 3);
            l.full = this._canvas.width, l.left = e4, l.center = t4, l.right = e4, this._refreshDrawHeightConstants(), d.full = 0, d.left = 0, d.center = l.left, d.right = l.left + l.center;
          }
          _refreshDrawHeightConstants() {
            c.full = Math.round(2 * this._coreBrowserService.dpr);
            const e4 = this._canvas.height / this._bufferService.buffer.lines.length, t4 = Math.round(Math.max(Math.min(e4, 12), 6) * this._coreBrowserService.dpr);
            c.left = t4, c.center = t4, c.right = t4;
          }
          _refreshColorZonePadding() {
            this._colorZoneStore.setPadding({ full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.full), left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.left), center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.center), right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.right) }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
          }
          _refreshCanvasDimensions() {
            this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowserService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowserService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
          }
          _refreshDecorations() {
            this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
            for (const e5 of this._decorationService.decorations) this._colorZoneStore.addDecoration(e5);
            this._ctx.lineWidth = 1;
            const e4 = this._colorZoneStore.zones;
            for (const t4 of e4) "full" !== t4.position && this._renderColorZone(t4);
            for (const t4 of e4) "full" === t4.position && this._renderColorZone(t4);
            this._shouldUpdateDimensions = false, this._shouldUpdateAnchor = false;
          }
          _renderColorZone(e4) {
            this._ctx.fillStyle = e4.color, this._ctx.fillRect(d[e4.position || "full"], Math.round((this._canvas.height - 1) * (e4.startBufferLine / this._bufferService.buffers.active.lines.length) - c[e4.position || "full"] / 2), l[e4.position || "full"], Math.round((this._canvas.height - 1) * ((e4.endBufferLine - e4.startBufferLine) / this._bufferService.buffers.active.lines.length) + c[e4.position || "full"]));
          }
          _queueRefresh(e4, t4) {
            this._shouldUpdateDimensions = e4 || this._shouldUpdateDimensions, this._shouldUpdateAnchor = t4 || this._shouldUpdateAnchor, void 0 === this._animationFrame && (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame((() => {
              this._refreshDecorations(), this._animationFrame = void 0;
            })));
          }
        };
        t3.OverviewRulerRenderer = _ = s2([r(2, h.IBufferService), r(3, h.IDecorationService), r(4, o.IRenderService), r(5, h.IOptionsService), r(6, o.ICoreBrowserService)], _);
      }, 2950: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.CompositionHelper = void 0;
        const n = i2(4725), o = i2(2585), a = i2(2584);
        let h = t3.CompositionHelper = class {
          get isComposing() {
            return this._isComposing;
          }
          constructor(e4, t4, i3, s3, r2, n2) {
            this._textarea = e4, this._compositionView = t4, this._bufferService = i3, this._optionsService = s3, this._coreService = r2, this._renderService = n2, this._isComposing = false, this._isSendingComposition = false, this._compositionPosition = { start: 0, end: 0 }, this._dataAlreadySent = "";
          }
          compositionstart() {
            this._isComposing = true, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
          }
          compositionupdate(e4) {
            this._compositionView.textContent = e4.data, this.updateCompositionElements(), setTimeout((() => {
              this._compositionPosition.end = this._textarea.value.length;
            }), 0);
          }
          compositionend() {
            this._finalizeComposition(true);
          }
          keydown(e4) {
            if (this._isComposing || this._isSendingComposition) {
              if (229 === e4.keyCode) return false;
              if (16 === e4.keyCode || 17 === e4.keyCode || 18 === e4.keyCode) return false;
              this._finalizeComposition(false);
            }
            return 229 !== e4.keyCode || (this._handleAnyTextareaChanges(), false);
          }
          _finalizeComposition(e4) {
            if (this._compositionView.classList.remove("active"), this._isComposing = false, e4) {
              const e5 = { start: this._compositionPosition.start, end: this._compositionPosition.end };
              this._isSendingComposition = true, setTimeout((() => {
                if (this._isSendingComposition) {
                  let t4;
                  this._isSendingComposition = false, e5.start += this._dataAlreadySent.length, t4 = this._isComposing ? this._textarea.value.substring(e5.start, e5.end) : this._textarea.value.substring(e5.start), t4.length > 0 && this._coreService.triggerDataEvent(t4, true);
                }
              }), 0);
            } else {
              this._isSendingComposition = false;
              const e5 = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
              this._coreService.triggerDataEvent(e5, true);
            }
          }
          _handleAnyTextareaChanges() {
            const e4 = this._textarea.value;
            setTimeout((() => {
              if (!this._isComposing) {
                const t4 = this._textarea.value, i3 = t4.replace(e4, "");
                this._dataAlreadySent = i3, t4.length > e4.length ? this._coreService.triggerDataEvent(i3, true) : t4.length < e4.length ? this._coreService.triggerDataEvent(`${a.C0.DEL}`, true) : t4.length === e4.length && t4 !== e4 && this._coreService.triggerDataEvent(t4, true);
              }
            }), 0);
          }
          updateCompositionElements(e4) {
            if (this._isComposing) {
              if (this._bufferService.buffer.isCursorInViewport) {
                const e5 = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), t4 = this._renderService.dimensions.css.cell.height, i3 = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, s3 = e5 * this._renderService.dimensions.css.cell.width;
                this._compositionView.style.left = s3 + "px", this._compositionView.style.top = i3 + "px", this._compositionView.style.height = t4 + "px", this._compositionView.style.lineHeight = t4 + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
                const r2 = this._compositionView.getBoundingClientRect();
                this._textarea.style.left = s3 + "px", this._textarea.style.top = i3 + "px", this._textarea.style.width = Math.max(r2.width, 1) + "px", this._textarea.style.height = Math.max(r2.height, 1) + "px", this._textarea.style.lineHeight = r2.height + "px";
              }
              e4 || setTimeout((() => this.updateCompositionElements(true)), 0);
            }
          }
        };
        t3.CompositionHelper = h = s2([r(2, o.IBufferService), r(3, o.IOptionsService), r(4, o.ICoreService), r(5, n.IRenderService)], h);
      }, 9806: (e3, t3) => {
        function i2(e4, t4, i3) {
          const s2 = i3.getBoundingClientRect(), r = e4.getComputedStyle(i3), n = parseInt(r.getPropertyValue("padding-left")), o = parseInt(r.getPropertyValue("padding-top"));
          return [t4.clientX - s2.left - n, t4.clientY - s2.top - o];
        }
        __name(i2, "i");
        Object.defineProperty(t3, "__esModule", { value: true }), t3.getCoords = t3.getCoordsRelativeToElement = void 0, t3.getCoordsRelativeToElement = i2, t3.getCoords = function(e4, t4, s2, r, n, o, a, h, c) {
          if (!o) return;
          const l = i2(e4, t4, s2);
          return l ? (l[0] = Math.ceil((l[0] + (c ? a / 2 : 0)) / a), l[1] = Math.ceil(l[1] / h), l[0] = Math.min(Math.max(l[0], 1), r + (c ? 1 : 0)), l[1] = Math.min(Math.max(l[1], 1), n), l) : void 0;
        };
      }, 9504: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.moveToCellSequence = void 0;
        const s2 = i2(2584);
        function r(e4, t4, i3, s3) {
          const r2 = e4 - n(e4, i3), a2 = t4 - n(t4, i3), l = Math.abs(r2 - a2) - (function(e5, t5, i4) {
            let s4 = 0;
            const r3 = e5 - n(e5, i4), a3 = t5 - n(t5, i4);
            for (let n2 = 0; n2 < Math.abs(r3 - a3); n2++) {
              const a4 = "A" === o(e5, t5) ? -1 : 1, h2 = i4.buffer.lines.get(r3 + a4 * n2);
              h2?.isWrapped && s4++;
            }
            return s4;
          })(e4, t4, i3);
          return c(l, h(o(e4, t4), s3));
        }
        __name(r, "r");
        function n(e4, t4) {
          let i3 = 0, s3 = t4.buffer.lines.get(e4), r2 = s3?.isWrapped;
          for (; r2 && e4 >= 0 && e4 < t4.rows; ) i3++, s3 = t4.buffer.lines.get(--e4), r2 = s3?.isWrapped;
          return i3;
        }
        __name(n, "n");
        function o(e4, t4) {
          return e4 > t4 ? "A" : "B";
        }
        __name(o, "o");
        function a(e4, t4, i3, s3, r2, n2) {
          let o2 = e4, a2 = t4, h2 = "";
          for (; o2 !== i3 || a2 !== s3; ) o2 += r2 ? 1 : -1, r2 && o2 > n2.cols - 1 ? (h2 += n2.buffer.translateBufferLineToString(a2, false, e4, o2), o2 = 0, e4 = 0, a2++) : !r2 && o2 < 0 && (h2 += n2.buffer.translateBufferLineToString(a2, false, 0, e4 + 1), o2 = n2.cols - 1, e4 = o2, a2--);
          return h2 + n2.buffer.translateBufferLineToString(a2, false, e4, o2);
        }
        __name(a, "a");
        function h(e4, t4) {
          const i3 = t4 ? "O" : "[";
          return s2.C0.ESC + i3 + e4;
        }
        __name(h, "h");
        function c(e4, t4) {
          e4 = Math.floor(e4);
          let i3 = "";
          for (let s3 = 0; s3 < e4; s3++) i3 += t4;
          return i3;
        }
        __name(c, "c");
        t3.moveToCellSequence = function(e4, t4, i3, s3) {
          const o2 = i3.buffer.x, l = i3.buffer.y;
          if (!i3.buffer.hasScrollback) return (function(e5, t5, i4, s4, o3, l2) {
            return 0 === r(t5, s4, o3, l2).length ? "" : c(a(e5, t5, e5, t5 - n(t5, o3), false, o3).length, h("D", l2));
          })(o2, l, 0, t4, i3, s3) + r(l, t4, i3, s3) + (function(e5, t5, i4, s4, o3, l2) {
            let d2;
            d2 = r(t5, s4, o3, l2).length > 0 ? s4 - n(s4, o3) : t5;
            const _2 = s4, u = (function(e6, t6, i5, s5, o4, a2) {
              let h2;
              return h2 = r(i5, s5, o4, a2).length > 0 ? s5 - n(s5, o4) : t6, e6 < i5 && h2 <= s5 || e6 >= i5 && h2 < s5 ? "C" : "D";
            })(e5, t5, i4, s4, o3, l2);
            return c(a(e5, d2, i4, _2, "C" === u, o3).length, h(u, l2));
          })(o2, l, e4, t4, i3, s3);
          let d;
          if (l === t4) return d = o2 > e4 ? "D" : "C", c(Math.abs(o2 - e4), h(d, s3));
          d = l > t4 ? "D" : "C";
          const _ = Math.abs(l - t4);
          return c((function(e5, t5) {
            return t5.cols - e5;
          })(l > t4 ? e4 : o2, i3) + (_ - 1) * i3.cols + 1 + ((l > t4 ? o2 : e4) - 1), h(d, s3));
        };
      }, 1296: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.DomRenderer = void 0;
        const n = i2(3787), o = i2(2550), a = i2(2223), h = i2(6171), c = i2(6052), l = i2(4725), d = i2(8055), _ = i2(8460), u = i2(844), f = i2(2585), v = "xterm-dom-renderer-owner-", p = "xterm-rows", g = "xterm-fg-", m = "xterm-bg-", S = "xterm-focus", C = "xterm-selection";
        let b = 1, w = t3.DomRenderer = class extends u.Disposable {
          constructor(e4, t4, i3, s3, r2, a2, l2, d2, f2, g2, m2, S2, w2) {
            super(), this._terminal = e4, this._document = t4, this._element = i3, this._screenElement = s3, this._viewportElement = r2, this._helperContainer = a2, this._linkifier2 = l2, this._charSizeService = f2, this._optionsService = g2, this._bufferService = m2, this._coreBrowserService = S2, this._themeService = w2, this._terminalClass = b++, this._rowElements = [], this._selectionRenderModel = (0, c.createSelectionRenderModel)(), this.onRequestRedraw = this.register(new _.EventEmitter()).event, this._rowContainer = this._document.createElement("div"), this._rowContainer.classList.add(p), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = this._document.createElement("div"), this._selectionContainer.classList.add(C), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, h.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange((() => this._handleOptionsChanged()))), this.register(this._themeService.onChangeColors(((e5) => this._injectCss(e5)))), this._injectCss(this._themeService.colors), this._rowFactory = d2.createInstance(n.DomRendererRowFactory, document), this._element.classList.add(v + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline(((e5) => this._handleLinkHover(e5)))), this.register(this._linkifier2.onHideLinkUnderline(((e5) => this._handleLinkLeave(e5)))), this.register((0, u.toDisposable)((() => {
              this._element.classList.remove(v + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._widthCache.dispose(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
            }))), this._widthCache = new o.WidthCache(this._document, this._helperContainer), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
          }
          _updateDimensions() {
            const e4 = this._coreBrowserService.dpr;
            this.dimensions.device.char.width = this._charSizeService.width * e4, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * e4), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / e4), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / e4), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
            for (const e5 of this._rowElements) e5.style.width = `${this.dimensions.css.canvas.width}px`, e5.style.height = `${this.dimensions.css.cell.height}px`, e5.style.lineHeight = `${this.dimensions.css.cell.height}px`, e5.style.overflow = "hidden";
            this._dimensionsStyleElement || (this._dimensionsStyleElement = this._document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
            const t4 = `${this._terminalSelector} .${p} span { display: inline-block; height: 100%; vertical-align: top;}`;
            this._dimensionsStyleElement.textContent = t4, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
          }
          _injectCss(e4) {
            this._themeStyleElement || (this._themeStyleElement = this._document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
            let t4 = `${this._terminalSelector} .${p} { color: ${e4.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`;
            t4 += `${this._terminalSelector} .${p} .xterm-dim { color: ${d.color.multiplyOpacity(e4.foreground, 0.5).css};}`, t4 += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`;
            const i3 = `blink_underline_${this._terminalClass}`, s3 = `blink_bar_${this._terminalClass}`, r2 = `blink_block_${this._terminalClass}`;
            t4 += `@keyframes ${i3} { 50% {  border-bottom-style: hidden; }}`, t4 += `@keyframes ${s3} { 50% {  box-shadow: none; }}`, t4 += `@keyframes ${r2} { 0% {  background-color: ${e4.cursor.css};  color: ${e4.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${e4.cursor.css}; }}`, t4 += `${this._terminalSelector} .${p}.${S} .xterm-cursor.xterm-cursor-blink.xterm-cursor-underline { animation: ${i3} 1s step-end infinite;}${this._terminalSelector} .${p}.${S} .xterm-cursor.xterm-cursor-blink.xterm-cursor-bar { animation: ${s3} 1s step-end infinite;}${this._terminalSelector} .${p}.${S} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: ${r2} 1s step-end infinite;}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-block { background-color: ${e4.cursor.css}; color: ${e4.cursorAccent.css};}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-block:not(.xterm-cursor-blink) { background-color: ${e4.cursor.css} !important; color: ${e4.cursorAccent.css} !important;}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${e4.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${e4.cursor.css} inset;}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${e4.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`, t4 += `${this._terminalSelector} .${C} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${C} div { position: absolute; background-color: ${e4.selectionBackgroundOpaque.css};}${this._terminalSelector} .${C} div { position: absolute; background-color: ${e4.selectionInactiveBackgroundOpaque.css};}`;
            for (const [i4, s4] of e4.ansi.entries()) t4 += `${this._terminalSelector} .${g}${i4} { color: ${s4.css}; }${this._terminalSelector} .${g}${i4}.xterm-dim { color: ${d.color.multiplyOpacity(s4, 0.5).css}; }${this._terminalSelector} .${m}${i4} { background-color: ${s4.css}; }`;
            t4 += `${this._terminalSelector} .${g}${a.INVERTED_DEFAULT_COLOR} { color: ${d.color.opaque(e4.background).css}; }${this._terminalSelector} .${g}${a.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${d.color.multiplyOpacity(d.color.opaque(e4.background), 0.5).css}; }${this._terminalSelector} .${m}${a.INVERTED_DEFAULT_COLOR} { background-color: ${e4.foreground.css}; }`, this._themeStyleElement.textContent = t4;
          }
          _setDefaultSpacing() {
            const e4 = this.dimensions.css.cell.width - this._widthCache.get("W", false, false);
            this._rowContainer.style.letterSpacing = `${e4}px`, this._rowFactory.defaultSpacing = e4;
          }
          handleDevicePixelRatioChange() {
            this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
          }
          _refreshRowElements(e4, t4) {
            for (let e5 = this._rowElements.length; e5 <= t4; e5++) {
              const e6 = this._document.createElement("div");
              this._rowContainer.appendChild(e6), this._rowElements.push(e6);
            }
            for (; this._rowElements.length > t4; ) this._rowContainer.removeChild(this._rowElements.pop());
          }
          handleResize(e4, t4) {
            this._refreshRowElements(e4, t4), this._updateDimensions(), this.handleSelectionChanged(this._selectionRenderModel.selectionStart, this._selectionRenderModel.selectionEnd, this._selectionRenderModel.columnSelectMode);
          }
          handleCharSizeChanged() {
            this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
          }
          handleBlur() {
            this._rowContainer.classList.remove(S), this.renderRows(0, this._bufferService.rows - 1);
          }
          handleFocus() {
            this._rowContainer.classList.add(S), this.renderRows(this._bufferService.buffer.y, this._bufferService.buffer.y);
          }
          handleSelectionChanged(e4, t4, i3) {
            if (this._selectionContainer.replaceChildren(), this._rowFactory.handleSelectionChanged(e4, t4, i3), this.renderRows(0, this._bufferService.rows - 1), !e4 || !t4) return;
            this._selectionRenderModel.update(this._terminal, e4, t4, i3);
            const s3 = this._selectionRenderModel.viewportStartRow, r2 = this._selectionRenderModel.viewportEndRow, n2 = this._selectionRenderModel.viewportCappedStartRow, o2 = this._selectionRenderModel.viewportCappedEndRow;
            if (n2 >= this._bufferService.rows || o2 < 0) return;
            const a2 = this._document.createDocumentFragment();
            if (i3) {
              const i4 = e4[0] > t4[0];
              a2.appendChild(this._createSelectionElement(n2, i4 ? t4[0] : e4[0], i4 ? e4[0] : t4[0], o2 - n2 + 1));
            } else {
              const i4 = s3 === n2 ? e4[0] : 0, h2 = n2 === r2 ? t4[0] : this._bufferService.cols;
              a2.appendChild(this._createSelectionElement(n2, i4, h2));
              const c2 = o2 - n2 - 1;
              if (a2.appendChild(this._createSelectionElement(n2 + 1, 0, this._bufferService.cols, c2)), n2 !== o2) {
                const e5 = r2 === o2 ? t4[0] : this._bufferService.cols;
                a2.appendChild(this._createSelectionElement(o2, 0, e5));
              }
            }
            this._selectionContainer.appendChild(a2);
          }
          _createSelectionElement(e4, t4, i3, s3 = 1) {
            const r2 = this._document.createElement("div"), n2 = t4 * this.dimensions.css.cell.width;
            let o2 = this.dimensions.css.cell.width * (i3 - t4);
            return n2 + o2 > this.dimensions.css.canvas.width && (o2 = this.dimensions.css.canvas.width - n2), r2.style.height = s3 * this.dimensions.css.cell.height + "px", r2.style.top = e4 * this.dimensions.css.cell.height + "px", r2.style.left = `${n2}px`, r2.style.width = `${o2}px`, r2;
          }
          handleCursorMove() {
          }
          _handleOptionsChanged() {
            this._updateDimensions(), this._injectCss(this._themeService.colors), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
          }
          clear() {
            for (const e4 of this._rowElements) e4.replaceChildren();
          }
          renderRows(e4, t4) {
            const i3 = this._bufferService.buffer, s3 = i3.ybase + i3.y, r2 = Math.min(i3.x, this._bufferService.cols - 1), n2 = this._optionsService.rawOptions.cursorBlink, o2 = this._optionsService.rawOptions.cursorStyle, a2 = this._optionsService.rawOptions.cursorInactiveStyle;
            for (let h2 = e4; h2 <= t4; h2++) {
              const e5 = h2 + i3.ydisp, t5 = this._rowElements[h2], c2 = i3.lines.get(e5);
              if (!t5 || !c2) break;
              t5.replaceChildren(...this._rowFactory.createRow(c2, e5, e5 === s3, o2, a2, r2, n2, this.dimensions.css.cell.width, this._widthCache, -1, -1));
            }
          }
          get _terminalSelector() {
            return `.${v}${this._terminalClass}`;
          }
          _handleLinkHover(e4) {
            this._setCellUnderline(e4.x1, e4.x2, e4.y1, e4.y2, e4.cols, true);
          }
          _handleLinkLeave(e4) {
            this._setCellUnderline(e4.x1, e4.x2, e4.y1, e4.y2, e4.cols, false);
          }
          _setCellUnderline(e4, t4, i3, s3, r2, n2) {
            i3 < 0 && (e4 = 0), s3 < 0 && (t4 = 0);
            const o2 = this._bufferService.rows - 1;
            i3 = Math.max(Math.min(i3, o2), 0), s3 = Math.max(Math.min(s3, o2), 0), r2 = Math.min(r2, this._bufferService.cols);
            const a2 = this._bufferService.buffer, h2 = a2.ybase + a2.y, c2 = Math.min(a2.x, r2 - 1), l2 = this._optionsService.rawOptions.cursorBlink, d2 = this._optionsService.rawOptions.cursorStyle, _2 = this._optionsService.rawOptions.cursorInactiveStyle;
            for (let o3 = i3; o3 <= s3; ++o3) {
              const u2 = o3 + a2.ydisp, f2 = this._rowElements[o3], v2 = a2.lines.get(u2);
              if (!f2 || !v2) break;
              f2.replaceChildren(...this._rowFactory.createRow(v2, u2, u2 === h2, d2, _2, c2, l2, this.dimensions.css.cell.width, this._widthCache, n2 ? o3 === i3 ? e4 : 0 : -1, n2 ? (o3 === s3 ? t4 : r2) - 1 : -1));
            }
          }
        };
        t3.DomRenderer = w = s2([r(7, f.IInstantiationService), r(8, l.ICharSizeService), r(9, f.IOptionsService), r(10, f.IBufferService), r(11, l.ICoreBrowserService), r(12, l.IThemeService)], w);
      }, 3787: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.DomRendererRowFactory = void 0;
        const n = i2(2223), o = i2(643), a = i2(511), h = i2(2585), c = i2(8055), l = i2(4725), d = i2(4269), _ = i2(6171), u = i2(3734);
        let f = t3.DomRendererRowFactory = class {
          constructor(e4, t4, i3, s3, r2, n2, o2) {
            this._document = e4, this._characterJoinerService = t4, this._optionsService = i3, this._coreBrowserService = s3, this._coreService = r2, this._decorationService = n2, this._themeService = o2, this._workCell = new a.CellData(), this._columnSelectMode = false, this.defaultSpacing = 0;
          }
          handleSelectionChanged(e4, t4, i3) {
            this._selectionStart = e4, this._selectionEnd = t4, this._columnSelectMode = i3;
          }
          createRow(e4, t4, i3, s3, r2, a2, h2, l2, _2, f2, p) {
            const g = [], m = this._characterJoinerService.getJoinedCharacters(t4), S = this._themeService.colors;
            let C, b = e4.getNoBgTrimmedLength();
            i3 && b < a2 + 1 && (b = a2 + 1);
            let w = 0, y = "", E = 0, k = 0, L = 0, D = false, R = 0, x = false, A = 0;
            const B = [], T = -1 !== f2 && -1 !== p;
            for (let M = 0; M < b; M++) {
              e4.loadCell(M, this._workCell);
              let b2 = this._workCell.getWidth();
              if (0 === b2) continue;
              let O = false, P = M, I = this._workCell;
              if (m.length > 0 && M === m[0][0]) {
                O = true;
                const t5 = m.shift();
                I = new d.JoinedCellData(this._workCell, e4.translateToString(true, t5[0], t5[1]), t5[1] - t5[0]), P = t5[1] - 1, b2 = I.getWidth();
              }
              const H = this._isCellInSelection(M, t4), F = i3 && M === a2, W = T && M >= f2 && M <= p;
              let U = false;
              this._decorationService.forEachDecorationAtCell(M, t4, void 0, ((e5) => {
                U = true;
              }));
              let N = I.getChars() || o.WHITESPACE_CELL_CHAR;
              if (" " === N && (I.isUnderline() || I.isOverline()) && (N = " "), A = b2 * l2 - _2.get(N, I.isBold(), I.isItalic()), C) {
                if (w && (H && x || !H && !x && I.bg === E) && (H && x && S.selectionForeground || I.fg === k) && I.extended.ext === L && W === D && A === R && !F && !O && !U) {
                  I.isInvisible() ? y += o.WHITESPACE_CELL_CHAR : y += N, w++;
                  continue;
                }
                w && (C.textContent = y), C = this._document.createElement("span"), w = 0, y = "";
              } else C = this._document.createElement("span");
              if (E = I.bg, k = I.fg, L = I.extended.ext, D = W, R = A, x = H, O && a2 >= M && a2 <= P && (a2 = M), !this._coreService.isCursorHidden && F && this._coreService.isCursorInitialized) {
                if (B.push("xterm-cursor"), this._coreBrowserService.isFocused) h2 && B.push("xterm-cursor-blink"), B.push("bar" === s3 ? "xterm-cursor-bar" : "underline" === s3 ? "xterm-cursor-underline" : "xterm-cursor-block");
                else if (r2) switch (r2) {
                  case "outline":
                    B.push("xterm-cursor-outline");
                    break;
                  case "block":
                    B.push("xterm-cursor-block");
                    break;
                  case "bar":
                    B.push("xterm-cursor-bar");
                    break;
                  case "underline":
                    B.push("xterm-cursor-underline");
                }
              }
              if (I.isBold() && B.push("xterm-bold"), I.isItalic() && B.push("xterm-italic"), I.isDim() && B.push("xterm-dim"), y = I.isInvisible() ? o.WHITESPACE_CELL_CHAR : I.getChars() || o.WHITESPACE_CELL_CHAR, I.isUnderline() && (B.push(`xterm-underline-${I.extended.underlineStyle}`), " " === y && (y = " "), !I.isUnderlineColorDefault())) if (I.isUnderlineColorRGB()) C.style.textDecorationColor = `rgb(${u.AttributeData.toColorRGB(I.getUnderlineColor()).join(",")})`;
              else {
                let e5 = I.getUnderlineColor();
                this._optionsService.rawOptions.drawBoldTextInBrightColors && I.isBold() && e5 < 8 && (e5 += 8), C.style.textDecorationColor = S.ansi[e5].css;
              }
              I.isOverline() && (B.push("xterm-overline"), " " === y && (y = " ")), I.isStrikethrough() && B.push("xterm-strikethrough"), W && (C.style.textDecoration = "underline");
              let $ = I.getFgColor(), j = I.getFgColorMode(), z = I.getBgColor(), K = I.getBgColorMode();
              const q = !!I.isInverse();
              if (q) {
                const e5 = $;
                $ = z, z = e5;
                const t5 = j;
                j = K, K = t5;
              }
              let V, G, X, J = false;
              switch (this._decorationService.forEachDecorationAtCell(M, t4, void 0, ((e5) => {
                "top" !== e5.options.layer && J || (e5.backgroundColorRGB && (K = 50331648, z = e5.backgroundColorRGB.rgba >> 8 & 16777215, V = e5.backgroundColorRGB), e5.foregroundColorRGB && (j = 50331648, $ = e5.foregroundColorRGB.rgba >> 8 & 16777215, G = e5.foregroundColorRGB), J = "top" === e5.options.layer);
              })), !J && H && (V = this._coreBrowserService.isFocused ? S.selectionBackgroundOpaque : S.selectionInactiveBackgroundOpaque, z = V.rgba >> 8 & 16777215, K = 50331648, J = true, S.selectionForeground && (j = 50331648, $ = S.selectionForeground.rgba >> 8 & 16777215, G = S.selectionForeground)), J && B.push("xterm-decoration-top"), K) {
                case 16777216:
                case 33554432:
                  X = S.ansi[z], B.push(`xterm-bg-${z}`);
                  break;
                case 50331648:
                  X = c.channels.toColor(z >> 16, z >> 8 & 255, 255 & z), this._addStyle(C, `background-color:#${v((z >>> 0).toString(16), "0", 6)}`);
                  break;
                default:
                  q ? (X = S.foreground, B.push(`xterm-bg-${n.INVERTED_DEFAULT_COLOR}`)) : X = S.background;
              }
              switch (V || I.isDim() && (V = c.color.multiplyOpacity(X, 0.5)), j) {
                case 16777216:
                case 33554432:
                  I.isBold() && $ < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && ($ += 8), this._applyMinimumContrast(C, X, S.ansi[$], I, V, void 0) || B.push(`xterm-fg-${$}`);
                  break;
                case 50331648:
                  const e5 = c.channels.toColor($ >> 16 & 255, $ >> 8 & 255, 255 & $);
                  this._applyMinimumContrast(C, X, e5, I, V, G) || this._addStyle(C, `color:#${v($.toString(16), "0", 6)}`);
                  break;
                default:
                  this._applyMinimumContrast(C, X, S.foreground, I, V, G) || q && B.push(`xterm-fg-${n.INVERTED_DEFAULT_COLOR}`);
              }
              B.length && (C.className = B.join(" "), B.length = 0), F || O || U ? C.textContent = y : w++, A !== this.defaultSpacing && (C.style.letterSpacing = `${A}px`), g.push(C), M = P;
            }
            return C && w && (C.textContent = y), g;
          }
          _applyMinimumContrast(e4, t4, i3, s3, r2, n2) {
            if (1 === this._optionsService.rawOptions.minimumContrastRatio || (0, _.treatGlyphAsBackgroundColor)(s3.getCode())) return false;
            const o2 = this._getContrastCache(s3);
            let a2;
            if (r2 || n2 || (a2 = o2.getColor(t4.rgba, i3.rgba)), void 0 === a2) {
              const e5 = this._optionsService.rawOptions.minimumContrastRatio / (s3.isDim() ? 2 : 1);
              a2 = c.color.ensureContrastRatio(r2 || t4, n2 || i3, e5), o2.setColor((r2 || t4).rgba, (n2 || i3).rgba, a2 ?? null);
            }
            return !!a2 && (this._addStyle(e4, `color:${a2.css}`), true);
          }
          _getContrastCache(e4) {
            return e4.isDim() ? this._themeService.colors.halfContrastCache : this._themeService.colors.contrastCache;
          }
          _addStyle(e4, t4) {
            e4.setAttribute("style", `${e4.getAttribute("style") || ""}${t4};`);
          }
          _isCellInSelection(e4, t4) {
            const i3 = this._selectionStart, s3 = this._selectionEnd;
            return !(!i3 || !s3) && (this._columnSelectMode ? i3[0] <= s3[0] ? e4 >= i3[0] && t4 >= i3[1] && e4 < s3[0] && t4 <= s3[1] : e4 < i3[0] && t4 >= i3[1] && e4 >= s3[0] && t4 <= s3[1] : t4 > i3[1] && t4 < s3[1] || i3[1] === s3[1] && t4 === i3[1] && e4 >= i3[0] && e4 < s3[0] || i3[1] < s3[1] && t4 === s3[1] && e4 < s3[0] || i3[1] < s3[1] && t4 === i3[1] && e4 >= i3[0]);
          }
        };
        function v(e4, t4, i3) {
          for (; e4.length < i3; ) e4 = t4 + e4;
          return e4;
        }
        __name(v, "v");
        t3.DomRendererRowFactory = f = s2([r(1, l.ICharacterJoinerService), r(2, h.IOptionsService), r(3, l.ICoreBrowserService), r(4, h.ICoreService), r(5, h.IDecorationService), r(6, l.IThemeService)], f);
      }, 2550: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.WidthCache = void 0, t3.WidthCache = class {
          constructor(e4, t4) {
            this._flat = new Float32Array(256), this._font = "", this._fontSize = 0, this._weight = "normal", this._weightBold = "bold", this._measureElements = [], this._container = e4.createElement("div"), this._container.classList.add("xterm-width-cache-measure-container"), this._container.setAttribute("aria-hidden", "true"), this._container.style.whiteSpace = "pre", this._container.style.fontKerning = "none";
            const i2 = e4.createElement("span");
            i2.classList.add("xterm-char-measure-element");
            const s2 = e4.createElement("span");
            s2.classList.add("xterm-char-measure-element"), s2.style.fontWeight = "bold";
            const r = e4.createElement("span");
            r.classList.add("xterm-char-measure-element"), r.style.fontStyle = "italic";
            const n = e4.createElement("span");
            n.classList.add("xterm-char-measure-element"), n.style.fontWeight = "bold", n.style.fontStyle = "italic", this._measureElements = [i2, s2, r, n], this._container.appendChild(i2), this._container.appendChild(s2), this._container.appendChild(r), this._container.appendChild(n), t4.appendChild(this._container), this.clear();
          }
          dispose() {
            this._container.remove(), this._measureElements.length = 0, this._holey = void 0;
          }
          clear() {
            this._flat.fill(-9999), this._holey = /* @__PURE__ */ new Map();
          }
          setFont(e4, t4, i2, s2) {
            e4 === this._font && t4 === this._fontSize && i2 === this._weight && s2 === this._weightBold || (this._font = e4, this._fontSize = t4, this._weight = i2, this._weightBold = s2, this._container.style.fontFamily = this._font, this._container.style.fontSize = `${this._fontSize}px`, this._measureElements[0].style.fontWeight = `${i2}`, this._measureElements[1].style.fontWeight = `${s2}`, this._measureElements[2].style.fontWeight = `${i2}`, this._measureElements[3].style.fontWeight = `${s2}`, this.clear());
          }
          get(e4, t4, i2) {
            let s2 = 0;
            if (!t4 && !i2 && 1 === e4.length && (s2 = e4.charCodeAt(0)) < 256) {
              if (-9999 !== this._flat[s2]) return this._flat[s2];
              const t5 = this._measure(e4, 0);
              return t5 > 0 && (this._flat[s2] = t5), t5;
            }
            let r = e4;
            t4 && (r += "B"), i2 && (r += "I");
            let n = this._holey.get(r);
            if (void 0 === n) {
              let s3 = 0;
              t4 && (s3 |= 1), i2 && (s3 |= 2), n = this._measure(e4, s3), n > 0 && this._holey.set(r, n);
            }
            return n;
          }
          _measure(e4, t4) {
            const i2 = this._measureElements[t4];
            return i2.textContent = e4.repeat(32), i2.offsetWidth / 32;
          }
        };
      }, 2223: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.TEXT_BASELINE = t3.DIM_OPACITY = t3.INVERTED_DEFAULT_COLOR = void 0;
        const s2 = i2(6114);
        t3.INVERTED_DEFAULT_COLOR = 257, t3.DIM_OPACITY = 0.5, t3.TEXT_BASELINE = s2.isFirefox || s2.isLegacyEdge ? "bottom" : "ideographic";
      }, 6171: (e3, t3) => {
        function i2(e4) {
          return 57508 <= e4 && e4 <= 57558;
        }
        __name(i2, "i");
        function s2(e4) {
          return e4 >= 128512 && e4 <= 128591 || e4 >= 127744 && e4 <= 128511 || e4 >= 128640 && e4 <= 128767 || e4 >= 9728 && e4 <= 9983 || e4 >= 9984 && e4 <= 10175 || e4 >= 65024 && e4 <= 65039 || e4 >= 129280 && e4 <= 129535 || e4 >= 127462 && e4 <= 127487;
        }
        __name(s2, "s");
        Object.defineProperty(t3, "__esModule", { value: true }), t3.computeNextVariantOffset = t3.createRenderDimensions = t3.treatGlyphAsBackgroundColor = t3.allowRescaling = t3.isEmoji = t3.isRestrictedPowerlineGlyph = t3.isPowerlineGlyph = t3.throwIfFalsy = void 0, t3.throwIfFalsy = function(e4) {
          if (!e4) throw new Error("value must not be falsy");
          return e4;
        }, t3.isPowerlineGlyph = i2, t3.isRestrictedPowerlineGlyph = function(e4) {
          return 57520 <= e4 && e4 <= 57527;
        }, t3.isEmoji = s2, t3.allowRescaling = function(e4, t4, r, n) {
          return 1 === t4 && r > Math.ceil(1.5 * n) && void 0 !== e4 && e4 > 255 && !s2(e4) && !i2(e4) && !(function(e5) {
            return 57344 <= e5 && e5 <= 63743;
          })(e4);
        }, t3.treatGlyphAsBackgroundColor = function(e4) {
          return i2(e4) || (function(e5) {
            return 9472 <= e5 && e5 <= 9631;
          })(e4);
        }, t3.createRenderDimensions = function() {
          return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
        }, t3.computeNextVariantOffset = function(e4, t4, i3 = 0) {
          return (e4 - (2 * Math.round(t4) - i3)) % (2 * Math.round(t4));
        };
      }, 6052: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.createSelectionRenderModel = void 0;
        const _i = class _i {
          constructor() {
            this.clear();
          }
          clear() {
            this.hasSelection = false, this.columnSelectMode = false, this.viewportStartRow = 0, this.viewportEndRow = 0, this.viewportCappedStartRow = 0, this.viewportCappedEndRow = 0, this.startCol = 0, this.endCol = 0, this.selectionStart = void 0, this.selectionEnd = void 0;
          }
          update(e4, t4, i3, s2 = false) {
            if (this.selectionStart = t4, this.selectionEnd = i3, !t4 || !i3 || t4[0] === i3[0] && t4[1] === i3[1]) return void this.clear();
            const r = e4.buffers.active.ydisp, n = t4[1] - r, o = i3[1] - r, a = Math.max(n, 0), h = Math.min(o, e4.rows - 1);
            a >= e4.rows || h < 0 ? this.clear() : (this.hasSelection = true, this.columnSelectMode = s2, this.viewportStartRow = n, this.viewportEndRow = o, this.viewportCappedStartRow = a, this.viewportCappedEndRow = h, this.startCol = t4[0], this.endCol = i3[0]);
          }
          isCellSelected(e4, t4, i3) {
            return !!this.hasSelection && (i3 -= e4.buffer.active.viewportY, this.columnSelectMode ? this.startCol <= this.endCol ? t4 >= this.startCol && i3 >= this.viewportCappedStartRow && t4 < this.endCol && i3 <= this.viewportCappedEndRow : t4 < this.startCol && i3 >= this.viewportCappedStartRow && t4 >= this.endCol && i3 <= this.viewportCappedEndRow : i3 > this.viewportStartRow && i3 < this.viewportEndRow || this.viewportStartRow === this.viewportEndRow && i3 === this.viewportStartRow && t4 >= this.startCol && t4 < this.endCol || this.viewportStartRow < this.viewportEndRow && i3 === this.viewportEndRow && t4 < this.endCol || this.viewportStartRow < this.viewportEndRow && i3 === this.viewportStartRow && t4 >= this.startCol);
          }
        };
        __name(_i, "i");
        let i2 = _i;
        t3.createSelectionRenderModel = function() {
          return new i2();
        };
      }, 456: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.SelectionModel = void 0, t3.SelectionModel = class {
          constructor(e4) {
            this._bufferService = e4, this.isSelectAllActive = false, this.selectionStartLength = 0;
          }
          clearSelection() {
            this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = false, this.selectionStartLength = 0;
          }
          get finalSelectionStart() {
            return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
          }
          get finalSelectionEnd() {
            if (this.isSelectAllActive) return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];
            if (this.selectionStart) {
              if (!this.selectionEnd || this.areSelectionValuesReversed()) {
                const e4 = this.selectionStart[0] + this.selectionStartLength;
                return e4 > this._bufferService.cols ? e4 % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(e4 / this._bufferService.cols) - 1] : [e4 % this._bufferService.cols, this.selectionStart[1] + Math.floor(e4 / this._bufferService.cols)] : [e4, this.selectionStart[1]];
              }
              if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
                const e4 = this.selectionStart[0] + this.selectionStartLength;
                return e4 > this._bufferService.cols ? [e4 % this._bufferService.cols, this.selectionStart[1] + Math.floor(e4 / this._bufferService.cols)] : [Math.max(e4, this.selectionEnd[0]), this.selectionEnd[1]];
              }
              return this.selectionEnd;
            }
          }
          areSelectionValuesReversed() {
            const e4 = this.selectionStart, t4 = this.selectionEnd;
            return !(!e4 || !t4) && (e4[1] > t4[1] || e4[1] === t4[1] && e4[0] > t4[0]);
          }
          handleTrim(e4) {
            return this.selectionStart && (this.selectionStart[1] -= e4), this.selectionEnd && (this.selectionEnd[1] -= e4), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), true) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), false);
          }
        };
      }, 428: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.CharSizeService = void 0;
        const n = i2(2585), o = i2(8460), a = i2(844);
        let h = t3.CharSizeService = class extends a.Disposable {
          get hasValidSize() {
            return this.width > 0 && this.height > 0;
          }
          constructor(e4, t4, i3) {
            super(), this._optionsService = i3, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new o.EventEmitter()), this.onCharSizeChange = this._onCharSizeChange.event;
            try {
              this._measureStrategy = this.register(new d(this._optionsService));
            } catch {
              this._measureStrategy = this.register(new l(e4, t4, this._optionsService));
            }
            this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], (() => this.measure())));
          }
          measure() {
            const e4 = this._measureStrategy.measure();
            e4.width === this.width && e4.height === this.height || (this.width = e4.width, this.height = e4.height, this._onCharSizeChange.fire());
          }
        };
        t3.CharSizeService = h = s2([r(2, n.IOptionsService)], h);
        const _c2 = class _c2 extends a.Disposable {
          constructor() {
            super(...arguments), this._result = { width: 0, height: 0 };
          }
          _validateAndSet(e4, t4) {
            void 0 !== e4 && e4 > 0 && void 0 !== t4 && t4 > 0 && (this._result.width = e4, this._result.height = t4);
          }
        };
        __name(_c2, "c");
        let c = _c2;
        const _l = class _l extends c {
          constructor(e4, t4, i3) {
            super(), this._document = e4, this._parentElement = t4, this._optionsService = i3, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W".repeat(32), this._measureElement.setAttribute("aria-hidden", "true"), this._measureElement.style.whiteSpace = "pre", this._measureElement.style.fontKerning = "none", this._parentElement.appendChild(this._measureElement);
          }
          measure() {
            return this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`, this._validateAndSet(Number(this._measureElement.offsetWidth) / 32, Number(this._measureElement.offsetHeight)), this._result;
          }
        };
        __name(_l, "l");
        let l = _l;
        const _d2 = class _d2 extends c {
          constructor(e4) {
            super(), this._optionsService = e4, this._canvas = new OffscreenCanvas(100, 100), this._ctx = this._canvas.getContext("2d");
            const t4 = this._ctx.measureText("W");
            if (!("width" in t4 && "fontBoundingBoxAscent" in t4 && "fontBoundingBoxDescent" in t4)) throw new Error("Required font metrics not supported");
          }
          measure() {
            this._ctx.font = `${this._optionsService.rawOptions.fontSize}px ${this._optionsService.rawOptions.fontFamily}`;
            const e4 = this._ctx.measureText("W");
            return this._validateAndSet(e4.width, e4.fontBoundingBoxAscent + e4.fontBoundingBoxDescent), this._result;
          }
        };
        __name(_d2, "d");
        let d = _d2;
      }, 4269: function(e3, t3, i2) {
        var _a2;
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.CharacterJoinerService = t3.JoinedCellData = void 0;
        const n = i2(3734), o = i2(643), a = i2(511), h = i2(2585);
        const _c2 = class _c2 extends n.AttributeData {
          constructor(e4, t4, i3) {
            super(), this.content = 0, this.combinedData = "", this.fg = e4.fg, this.bg = e4.bg, this.combinedData = t4, this._width = i3;
          }
          isCombined() {
            return 2097152;
          }
          getWidth() {
            return this._width;
          }
          getChars() {
            return this.combinedData;
          }
          getCode() {
            return 2097151;
          }
          setFromCharData(e4) {
            throw new Error("not implemented");
          }
          getAsCharData() {
            return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
          }
        };
        __name(_c2, "c");
        let c = _c2;
        t3.JoinedCellData = c;
        let l = t3.CharacterJoinerService = (_a2 = class {
          constructor(e4) {
            this._bufferService = e4, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new a.CellData();
          }
          register(e4) {
            const t4 = { id: this._nextCharacterJoinerId++, handler: e4 };
            return this._characterJoiners.push(t4), t4.id;
          }
          deregister(e4) {
            for (let t4 = 0; t4 < this._characterJoiners.length; t4++) if (this._characterJoiners[t4].id === e4) return this._characterJoiners.splice(t4, 1), true;
            return false;
          }
          getJoinedCharacters(e4) {
            if (0 === this._characterJoiners.length) return [];
            const t4 = this._bufferService.buffer.lines.get(e4);
            if (!t4 || 0 === t4.length) return [];
            const i3 = [], s3 = t4.translateToString(true);
            let r2 = 0, n2 = 0, a2 = 0, h2 = t4.getFg(0), c2 = t4.getBg(0);
            for (let e5 = 0; e5 < t4.getTrimmedLength(); e5++) if (t4.loadCell(e5, this._workCell), 0 !== this._workCell.getWidth()) {
              if (this._workCell.fg !== h2 || this._workCell.bg !== c2) {
                if (e5 - r2 > 1) {
                  const e6 = this._getJoinedRanges(s3, a2, n2, t4, r2);
                  for (let t5 = 0; t5 < e6.length; t5++) i3.push(e6[t5]);
                }
                r2 = e5, a2 = n2, h2 = this._workCell.fg, c2 = this._workCell.bg;
              }
              n2 += this._workCell.getChars().length || o.WHITESPACE_CELL_CHAR.length;
            }
            if (this._bufferService.cols - r2 > 1) {
              const e5 = this._getJoinedRanges(s3, a2, n2, t4, r2);
              for (let t5 = 0; t5 < e5.length; t5++) i3.push(e5[t5]);
            }
            return i3;
          }
          _getJoinedRanges(t4, i3, s3, r2, n2) {
            const o2 = t4.substring(i3, s3);
            let a2 = [];
            try {
              a2 = this._characterJoiners[0].handler(o2);
            } catch (e4) {
              console.error(e4);
            }
            for (let t5 = 1; t5 < this._characterJoiners.length; t5++) try {
              const i4 = this._characterJoiners[t5].handler(o2);
              for (let t6 = 0; t6 < i4.length; t6++) _a2._mergeRanges(a2, i4[t6]);
            } catch (e4) {
              console.error(e4);
            }
            return this._stringRangesToCellRanges(a2, r2, n2), a2;
          }
          _stringRangesToCellRanges(e4, t4, i3) {
            let s3 = 0, r2 = false, n2 = 0, a2 = e4[s3];
            if (a2) {
              for (let h2 = i3; h2 < this._bufferService.cols; h2++) {
                const i4 = t4.getWidth(h2), c2 = t4.getString(h2).length || o.WHITESPACE_CELL_CHAR.length;
                if (0 !== i4) {
                  if (!r2 && a2[0] <= n2 && (a2[0] = h2, r2 = true), a2[1] <= n2) {
                    if (a2[1] = h2, a2 = e4[++s3], !a2) break;
                    a2[0] <= n2 ? (a2[0] = h2, r2 = true) : r2 = false;
                  }
                  n2 += c2;
                }
              }
              a2 && (a2[1] = this._bufferService.cols);
            }
          }
          static _mergeRanges(e4, t4) {
            let i3 = false;
            for (let s3 = 0; s3 < e4.length; s3++) {
              const r2 = e4[s3];
              if (i3) {
                if (t4[1] <= r2[0]) return e4[s3 - 1][1] = t4[1], e4;
                if (t4[1] <= r2[1]) return e4[s3 - 1][1] = Math.max(t4[1], r2[1]), e4.splice(s3, 1), e4;
                e4.splice(s3, 1), s3--;
              } else {
                if (t4[1] <= r2[0]) return e4.splice(s3, 0, t4), e4;
                if (t4[1] <= r2[1]) return r2[0] = Math.min(t4[0], r2[0]), e4;
                t4[0] < r2[1] && (r2[0] = Math.min(t4[0], r2[0]), i3 = true);
              }
            }
            return i3 ? e4[e4.length - 1][1] = t4[1] : e4.push(t4), e4;
          }
        }, __name(_a2, "e"), _a2);
        t3.CharacterJoinerService = l = s2([r(0, h.IBufferService)], l);
      }, 5114: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.CoreBrowserService = void 0;
        const s2 = i2(844), r = i2(8460), n = i2(3656);
        const _o = class _o extends s2.Disposable {
          constructor(e4, t4, i3) {
            super(), this._textarea = e4, this._window = t4, this.mainDocument = i3, this._isFocused = false, this._cachedIsFocused = void 0, this._screenDprMonitor = new a(this._window), this._onDprChange = this.register(new r.EventEmitter()), this.onDprChange = this._onDprChange.event, this._onWindowChange = this.register(new r.EventEmitter()), this.onWindowChange = this._onWindowChange.event, this.register(this.onWindowChange(((e5) => this._screenDprMonitor.setWindow(e5)))), this.register((0, r.forwardEvent)(this._screenDprMonitor.onDprChange, this._onDprChange)), this._textarea.addEventListener("focus", (() => this._isFocused = true)), this._textarea.addEventListener("blur", (() => this._isFocused = false));
          }
          get window() {
            return this._window;
          }
          set window(e4) {
            this._window !== e4 && (this._window = e4, this._onWindowChange.fire(this._window));
          }
          get dpr() {
            return this.window.devicePixelRatio;
          }
          get isFocused() {
            return void 0 === this._cachedIsFocused && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask((() => this._cachedIsFocused = void 0))), this._cachedIsFocused;
          }
        };
        __name(_o, "o");
        let o = _o;
        t3.CoreBrowserService = o;
        const _a2 = class _a2 extends s2.Disposable {
          constructor(e4) {
            super(), this._parentWindow = e4, this._windowResizeListener = this.register(new s2.MutableDisposable()), this._onDprChange = this.register(new r.EventEmitter()), this.onDprChange = this._onDprChange.event, this._outerListener = () => this._setDprAndFireIfDiffers(), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._updateDpr(), this._setWindowResizeListener(), this.register((0, s2.toDisposable)((() => this.clearListener())));
          }
          setWindow(e4) {
            this._parentWindow = e4, this._setWindowResizeListener(), this._setDprAndFireIfDiffers();
          }
          _setWindowResizeListener() {
            this._windowResizeListener.value = (0, n.addDisposableDomListener)(this._parentWindow, "resize", (() => this._setDprAndFireIfDiffers()));
          }
          _setDprAndFireIfDiffers() {
            this._parentWindow.devicePixelRatio !== this._currentDevicePixelRatio && this._onDprChange.fire(this._parentWindow.devicePixelRatio), this._updateDpr();
          }
          _updateDpr() {
            this._outerListener && (this._resolutionMediaMatchList?.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
          }
          clearListener() {
            this._resolutionMediaMatchList && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._outerListener = void 0);
          }
        };
        __name(_a2, "a");
        let a = _a2;
      }, 779: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.LinkProviderService = void 0;
        const s2 = i2(844);
        const _r = class _r extends s2.Disposable {
          constructor() {
            super(), this.linkProviders = [], this.register((0, s2.toDisposable)((() => this.linkProviders.length = 0)));
          }
          registerLinkProvider(e4) {
            return this.linkProviders.push(e4), { dispose: /* @__PURE__ */ __name(() => {
              const t4 = this.linkProviders.indexOf(e4);
              -1 !== t4 && this.linkProviders.splice(t4, 1);
            }, "dispose") };
          }
        };
        __name(_r, "r");
        let r = _r;
        t3.LinkProviderService = r;
      }, 8934: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.MouseService = void 0;
        const n = i2(4725), o = i2(9806);
        let a = t3.MouseService = class {
          constructor(e4, t4) {
            this._renderService = e4, this._charSizeService = t4;
          }
          getCoords(e4, t4, i3, s3, r2) {
            return (0, o.getCoords)(window, e4, t4, i3, s3, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, r2);
          }
          getMouseReportCoords(e4, t4) {
            const i3 = (0, o.getCoordsRelativeToElement)(window, e4, t4);
            if (this._charSizeService.hasValidSize) return i3[0] = Math.min(Math.max(i3[0], 0), this._renderService.dimensions.css.canvas.width - 1), i3[1] = Math.min(Math.max(i3[1], 0), this._renderService.dimensions.css.canvas.height - 1), { col: Math.floor(i3[0] / this._renderService.dimensions.css.cell.width), row: Math.floor(i3[1] / this._renderService.dimensions.css.cell.height), x: Math.floor(i3[0]), y: Math.floor(i3[1]) };
          }
        };
        t3.MouseService = a = s2([r(0, n.IRenderService), r(1, n.ICharSizeService)], a);
      }, 3230: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.RenderService = void 0;
        const n = i2(6193), o = i2(4725), a = i2(8460), h = i2(844), c = i2(7226), l = i2(2585);
        let d = t3.RenderService = class extends h.Disposable {
          get dimensions() {
            return this._renderer.value.dimensions;
          }
          constructor(e4, t4, i3, s3, r2, o2, l2, d2) {
            super(), this._rowCount = e4, this._charSizeService = s3, this._renderer = this.register(new h.MutableDisposable()), this._pausedResizeTask = new c.DebouncedIdleTask(), this._observerDisposable = this.register(new h.MutableDisposable()), this._isPaused = false, this._needsFullRefresh = false, this._isNextRenderRedrawOnly = true, this._needsSelectionRefresh = false, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = { start: void 0, end: void 0, columnSelectMode: false }, this._onDimensionsChange = this.register(new a.EventEmitter()), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new a.EventEmitter()), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new a.EventEmitter()), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new a.EventEmitter()), this.onRefreshRequest = this._onRefreshRequest.event, this._renderDebouncer = new n.RenderDebouncer(((e5, t5) => this._renderRows(e5, t5)), l2), this.register(this._renderDebouncer), this.register(l2.onDprChange((() => this.handleDevicePixelRatioChange()))), this.register(o2.onResize((() => this._fullRefresh()))), this.register(o2.buffers.onBufferActivate((() => this._renderer.value?.clear()))), this.register(i3.onOptionChange((() => this._handleOptionsChanged()))), this.register(this._charSizeService.onCharSizeChange((() => this.handleCharSizeChanged()))), this.register(r2.onDecorationRegistered((() => this._fullRefresh()))), this.register(r2.onDecorationRemoved((() => this._fullRefresh()))), this.register(i3.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio", "rescaleOverlappingGlyphs"], (() => {
              this.clear(), this.handleResize(o2.cols, o2.rows), this._fullRefresh();
            }))), this.register(i3.onMultipleOptionChange(["cursorBlink", "cursorStyle"], (() => this.refreshRows(o2.buffer.y, o2.buffer.y, true)))), this.register(d2.onChangeColors((() => this._fullRefresh()))), this._registerIntersectionObserver(l2.window, t4), this.register(l2.onWindowChange(((e5) => this._registerIntersectionObserver(e5, t4))));
          }
          _registerIntersectionObserver(e4, t4) {
            if ("IntersectionObserver" in e4) {
              const i3 = new e4.IntersectionObserver(((e5) => this._handleIntersectionChange(e5[e5.length - 1])), { threshold: 0 });
              i3.observe(t4), this._observerDisposable.value = (0, h.toDisposable)((() => i3.disconnect()));
            }
          }
          _handleIntersectionChange(e4) {
            this._isPaused = void 0 === e4.isIntersecting ? 0 === e4.intersectionRatio : !e4.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = false);
          }
          refreshRows(e4, t4, i3 = false) {
            this._isPaused ? this._needsFullRefresh = true : (i3 || (this._isNextRenderRedrawOnly = false), this._renderDebouncer.refresh(e4, t4, this._rowCount));
          }
          _renderRows(e4, t4) {
            this._renderer.value && (e4 = Math.min(e4, this._rowCount - 1), t4 = Math.min(t4, this._rowCount - 1), this._renderer.value.renderRows(e4, t4), this._needsSelectionRefresh && (this._renderer.value.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = false), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({ start: e4, end: t4 }), this._onRender.fire({ start: e4, end: t4 }), this._isNextRenderRedrawOnly = true);
          }
          resize(e4, t4) {
            this._rowCount = t4, this._fireOnCanvasResize();
          }
          _handleOptionsChanged() {
            this._renderer.value && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
          }
          _fireOnCanvasResize() {
            this._renderer.value && (this._renderer.value.dimensions.css.canvas.width === this._canvasWidth && this._renderer.value.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.value.dimensions));
          }
          hasRenderer() {
            return !!this._renderer.value;
          }
          setRenderer(e4) {
            this._renderer.value = e4, this._renderer.value && (this._renderer.value.onRequestRedraw(((e5) => this.refreshRows(e5.start, e5.end, true))), this._needsSelectionRefresh = true, this._fullRefresh());
          }
          addRefreshCallback(e4) {
            return this._renderDebouncer.addRefreshCallback(e4);
          }
          _fullRefresh() {
            this._isPaused ? this._needsFullRefresh = true : this.refreshRows(0, this._rowCount - 1);
          }
          clearTextureAtlas() {
            this._renderer.value && (this._renderer.value.clearTextureAtlas?.(), this._fullRefresh());
          }
          handleDevicePixelRatioChange() {
            this._charSizeService.measure(), this._renderer.value && (this._renderer.value.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
          }
          handleResize(e4, t4) {
            this._renderer.value && (this._isPaused ? this._pausedResizeTask.set((() => this._renderer.value?.handleResize(e4, t4))) : this._renderer.value.handleResize(e4, t4), this._fullRefresh());
          }
          handleCharSizeChanged() {
            this._renderer.value?.handleCharSizeChanged();
          }
          handleBlur() {
            this._renderer.value?.handleBlur();
          }
          handleFocus() {
            this._renderer.value?.handleFocus();
          }
          handleSelectionChanged(e4, t4, i3) {
            this._selectionState.start = e4, this._selectionState.end = t4, this._selectionState.columnSelectMode = i3, this._renderer.value?.handleSelectionChanged(e4, t4, i3);
          }
          handleCursorMove() {
            this._renderer.value?.handleCursorMove();
          }
          clear() {
            this._renderer.value?.clear();
          }
        };
        t3.RenderService = d = s2([r(2, l.IOptionsService), r(3, o.ICharSizeService), r(4, l.IDecorationService), r(5, l.IBufferService), r(6, o.ICoreBrowserService), r(7, o.IThemeService)], d);
      }, 9312: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.SelectionService = void 0;
        const n = i2(9806), o = i2(9504), a = i2(456), h = i2(4725), c = i2(8460), l = i2(844), d = i2(6114), _ = i2(4841), u = i2(511), f = i2(2585), v = String.fromCharCode(160), p = new RegExp(v, "g");
        let g = t3.SelectionService = class extends l.Disposable {
          constructor(e4, t4, i3, s3, r2, n2, o2, h2, d2) {
            super(), this._element = e4, this._screenElement = t4, this._linkifier = i3, this._bufferService = s3, this._coreService = r2, this._mouseService = n2, this._optionsService = o2, this._renderService = h2, this._coreBrowserService = d2, this._dragScrollAmount = 0, this._enabled = true, this._workCell = new u.CellData(), this._mouseDownTimeStamp = 0, this._oldHasSelection = false, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new c.EventEmitter()), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new c.EventEmitter()), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new c.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new c.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (e5) => this._handleMouseMove(e5), this._mouseUpListener = (e5) => this._handleMouseUp(e5), this._coreService.onUserInput((() => {
              this.hasSelection && this.clearSelection();
            })), this._trimListener = this._bufferService.buffer.lines.onTrim(((e5) => this._handleTrim(e5))), this.register(this._bufferService.buffers.onBufferActivate(((e5) => this._handleBufferActivate(e5)))), this.enable(), this._model = new a.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, l.toDisposable)((() => {
              this._removeMouseDownListeners();
            })));
          }
          reset() {
            this.clearSelection();
          }
          disable() {
            this.clearSelection(), this._enabled = false;
          }
          enable() {
            this._enabled = true;
          }
          get selectionStart() {
            return this._model.finalSelectionStart;
          }
          get selectionEnd() {
            return this._model.finalSelectionEnd;
          }
          get hasSelection() {
            const e4 = this._model.finalSelectionStart, t4 = this._model.finalSelectionEnd;
            return !(!e4 || !t4 || e4[0] === t4[0] && e4[1] === t4[1]);
          }
          get selectionText() {
            const e4 = this._model.finalSelectionStart, t4 = this._model.finalSelectionEnd;
            if (!e4 || !t4) return "";
            const i3 = this._bufferService.buffer, s3 = [];
            if (3 === this._activeSelectionMode) {
              if (e4[0] === t4[0]) return "";
              const r2 = e4[0] < t4[0] ? e4[0] : t4[0], n2 = e4[0] < t4[0] ? t4[0] : e4[0];
              for (let o2 = e4[1]; o2 <= t4[1]; o2++) {
                const e5 = i3.translateBufferLineToString(o2, true, r2, n2);
                s3.push(e5);
              }
            } else {
              const r2 = e4[1] === t4[1] ? t4[0] : void 0;
              s3.push(i3.translateBufferLineToString(e4[1], true, e4[0], r2));
              for (let r3 = e4[1] + 1; r3 <= t4[1] - 1; r3++) {
                const e5 = i3.lines.get(r3), t5 = i3.translateBufferLineToString(r3, true);
                e5?.isWrapped ? s3[s3.length - 1] += t5 : s3.push(t5);
              }
              if (e4[1] !== t4[1]) {
                const e5 = i3.lines.get(t4[1]), r3 = i3.translateBufferLineToString(t4[1], true, 0, t4[0]);
                e5 && e5.isWrapped ? s3[s3.length - 1] += r3 : s3.push(r3);
              }
            }
            return s3.map(((e5) => e5.replace(p, " "))).join(d.isWindows ? "\r\n" : "\n");
          }
          clearSelection() {
            this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
          }
          refresh(e4) {
            this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame((() => this._refresh()))), d.isLinux && e4 && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
          }
          _refresh() {
            this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({ start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd, columnSelectMode: 3 === this._activeSelectionMode });
          }
          _isClickInSelection(e4) {
            const t4 = this._getMouseBufferCoords(e4), i3 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
            return !!(i3 && s3 && t4) && this._areCoordsInSelection(t4, i3, s3);
          }
          isCellInSelection(e4, t4) {
            const i3 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
            return !(!i3 || !s3) && this._areCoordsInSelection([e4, t4], i3, s3);
          }
          _areCoordsInSelection(e4, t4, i3) {
            return e4[1] > t4[1] && e4[1] < i3[1] || t4[1] === i3[1] && e4[1] === t4[1] && e4[0] >= t4[0] && e4[0] < i3[0] || t4[1] < i3[1] && e4[1] === i3[1] && e4[0] < i3[0] || t4[1] < i3[1] && e4[1] === t4[1] && e4[0] >= t4[0];
          }
          _selectWordAtCursor(e4, t4) {
            const i3 = this._linkifier.currentLink?.link?.range;
            if (i3) return this._model.selectionStart = [i3.start.x - 1, i3.start.y - 1], this._model.selectionStartLength = (0, _.getRangeLength)(i3, this._bufferService.cols), this._model.selectionEnd = void 0, true;
            const s3 = this._getMouseBufferCoords(e4);
            return !!s3 && (this._selectWordAt(s3, t4), this._model.selectionEnd = void 0, true);
          }
          selectAll() {
            this._model.isSelectAllActive = true, this.refresh(), this._onSelectionChange.fire();
          }
          selectLines(e4, t4) {
            this._model.clearSelection(), e4 = Math.max(e4, 0), t4 = Math.min(t4, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, e4], this._model.selectionEnd = [this._bufferService.cols, t4], this.refresh(), this._onSelectionChange.fire();
          }
          _handleTrim(e4) {
            this._model.handleTrim(e4) && this.refresh();
          }
          _getMouseBufferCoords(e4) {
            const t4 = this._mouseService.getCoords(e4, this._screenElement, this._bufferService.cols, this._bufferService.rows, true);
            if (t4) return t4[0]--, t4[1]--, t4[1] += this._bufferService.buffer.ydisp, t4;
          }
          _getMouseEventScrollAmount(e4) {
            let t4 = (0, n.getCoordsRelativeToElement)(this._coreBrowserService.window, e4, this._screenElement)[1];
            const i3 = this._renderService.dimensions.css.canvas.height;
            return t4 >= 0 && t4 <= i3 ? 0 : (t4 > i3 && (t4 -= i3), t4 = Math.min(Math.max(t4, -50), 50), t4 /= 50, t4 / Math.abs(t4) + Math.round(14 * t4));
          }
          shouldForceSelection(e4) {
            return d.isMac ? e4.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : e4.shiftKey;
          }
          handleMouseDown(e4) {
            if (this._mouseDownTimeStamp = e4.timeStamp, (2 !== e4.button || !this.hasSelection) && 0 === e4.button) {
              if (!this._enabled) {
                if (!this.shouldForceSelection(e4)) return;
                e4.stopPropagation();
              }
              e4.preventDefault(), this._dragScrollAmount = 0, this._enabled && e4.shiftKey ? this._handleIncrementalClick(e4) : 1 === e4.detail ? this._handleSingleClick(e4) : 2 === e4.detail ? this._handleDoubleClick(e4) : 3 === e4.detail && this._handleTripleClick(e4), this._addMouseDownListeners(), this.refresh(true);
            }
          }
          _addMouseDownListeners() {
            this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval((() => this._dragScroll()), 50);
          }
          _removeMouseDownListeners() {
            this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;
          }
          _handleIncrementalClick(e4) {
            this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(e4));
          }
          _handleSingleClick(e4) {
            if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = false, this._activeSelectionMode = this.shouldColumnSelect(e4) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(e4), !this._model.selectionStart) return;
            this._model.selectionEnd = void 0;
            const t4 = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
            t4 && t4.length !== this._model.selectionStart[0] && 0 === t4.hasWidth(this._model.selectionStart[0]) && this._model.selectionStart[0]++;
          }
          _handleDoubleClick(e4) {
            this._selectWordAtCursor(e4, true) && (this._activeSelectionMode = 1);
          }
          _handleTripleClick(e4) {
            const t4 = this._getMouseBufferCoords(e4);
            t4 && (this._activeSelectionMode = 2, this._selectLineAt(t4[1]));
          }
          shouldColumnSelect(e4) {
            return e4.altKey && !(d.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
          }
          _handleMouseMove(e4) {
            if (e4.stopImmediatePropagation(), !this._model.selectionStart) return;
            const t4 = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
            if (this._model.selectionEnd = this._getMouseBufferCoords(e4), !this._model.selectionEnd) return void this.refresh(true);
            2 === this._activeSelectionMode ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : 1 === this._activeSelectionMode && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(e4), 3 !== this._activeSelectionMode && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
            const i3 = this._bufferService.buffer;
            if (this._model.selectionEnd[1] < i3.lines.length) {
              const e5 = i3.lines.get(this._model.selectionEnd[1]);
              e5 && 0 === e5.hasWidth(this._model.selectionEnd[0]) && this._model.selectionEnd[0] < this._bufferService.cols && this._model.selectionEnd[0]++;
            }
            t4 && t4[0] === this._model.selectionEnd[0] && t4[1] === this._model.selectionEnd[1] || this.refresh(true);
          }
          _dragScroll() {
            if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
              this._onRequestScrollLines.fire({ amount: this._dragScrollAmount, suppressScrollEvent: false });
              const e4 = this._bufferService.buffer;
              this._dragScrollAmount > 0 ? (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(e4.ydisp + this._bufferService.rows, e4.lines.length - 1)) : (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = e4.ydisp), this.refresh();
            }
          }
          _handleMouseUp(e4) {
            const t4 = e4.timeStamp - this._mouseDownTimeStamp;
            if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && t4 < 500 && e4.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
              if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
                const t5 = this._mouseService.getCoords(e4, this._element, this._bufferService.cols, this._bufferService.rows, false);
                if (t5 && void 0 !== t5[0] && void 0 !== t5[1]) {
                  const e5 = (0, o.moveToCellSequence)(t5[0] - 1, t5[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                  this._coreService.triggerDataEvent(e5, true);
                }
              }
            } else this._fireEventIfSelectionChanged();
          }
          _fireEventIfSelectionChanged() {
            const e4 = this._model.finalSelectionStart, t4 = this._model.finalSelectionEnd, i3 = !(!e4 || !t4 || e4[0] === t4[0] && e4[1] === t4[1]);
            i3 ? e4 && t4 && (this._oldSelectionStart && this._oldSelectionEnd && e4[0] === this._oldSelectionStart[0] && e4[1] === this._oldSelectionStart[1] && t4[0] === this._oldSelectionEnd[0] && t4[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(e4, t4, i3)) : this._oldHasSelection && this._fireOnSelectionChange(e4, t4, i3);
          }
          _fireOnSelectionChange(e4, t4, i3) {
            this._oldSelectionStart = e4, this._oldSelectionEnd = t4, this._oldHasSelection = i3, this._onSelectionChange.fire();
          }
          _handleBufferActivate(e4) {
            this.clearSelection(), this._trimListener.dispose(), this._trimListener = e4.activeBuffer.lines.onTrim(((e5) => this._handleTrim(e5)));
          }
          _convertViewportColToCharacterIndex(e4, t4) {
            let i3 = t4;
            for (let s3 = 0; t4 >= s3; s3++) {
              const r2 = e4.loadCell(s3, this._workCell).getChars().length;
              0 === this._workCell.getWidth() ? i3-- : r2 > 1 && t4 !== s3 && (i3 += r2 - 1);
            }
            return i3;
          }
          setSelection(e4, t4, i3) {
            this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [e4, t4], this._model.selectionStartLength = i3, this.refresh(), this._fireEventIfSelectionChanged();
          }
          rightClickSelect(e4) {
            this._isClickInSelection(e4) || (this._selectWordAtCursor(e4, false) && this.refresh(true), this._fireEventIfSelectionChanged());
          }
          _getWordAt(e4, t4, i3 = true, s3 = true) {
            if (e4[0] >= this._bufferService.cols) return;
            const r2 = this._bufferService.buffer, n2 = r2.lines.get(e4[1]);
            if (!n2) return;
            const o2 = r2.translateBufferLineToString(e4[1], false);
            let a2 = this._convertViewportColToCharacterIndex(n2, e4[0]), h2 = a2;
            const c2 = e4[0] - a2;
            let l2 = 0, d2 = 0, _2 = 0, u2 = 0;
            if (" " === o2.charAt(a2)) {
              for (; a2 > 0 && " " === o2.charAt(a2 - 1); ) a2--;
              for (; h2 < o2.length && " " === o2.charAt(h2 + 1); ) h2++;
            } else {
              let t5 = e4[0], i4 = e4[0];
              0 === n2.getWidth(t5) && (l2++, t5--), 2 === n2.getWidth(i4) && (d2++, i4++);
              const s4 = n2.getString(i4).length;
              for (s4 > 1 && (u2 += s4 - 1, h2 += s4 - 1); t5 > 0 && a2 > 0 && !this._isCharWordSeparator(n2.loadCell(t5 - 1, this._workCell)); ) {
                n2.loadCell(t5 - 1, this._workCell);
                const e5 = this._workCell.getChars().length;
                0 === this._workCell.getWidth() ? (l2++, t5--) : e5 > 1 && (_2 += e5 - 1, a2 -= e5 - 1), a2--, t5--;
              }
              for (; i4 < n2.length && h2 + 1 < o2.length && !this._isCharWordSeparator(n2.loadCell(i4 + 1, this._workCell)); ) {
                n2.loadCell(i4 + 1, this._workCell);
                const e5 = this._workCell.getChars().length;
                2 === this._workCell.getWidth() ? (d2++, i4++) : e5 > 1 && (u2 += e5 - 1, h2 += e5 - 1), h2++, i4++;
              }
            }
            h2++;
            let f2 = a2 + c2 - l2 + _2, v2 = Math.min(this._bufferService.cols, h2 - a2 + l2 + d2 - _2 - u2);
            if (t4 || "" !== o2.slice(a2, h2).trim()) {
              if (i3 && 0 === f2 && 32 !== n2.getCodePoint(0)) {
                const t5 = r2.lines.get(e4[1] - 1);
                if (t5 && n2.isWrapped && 32 !== t5.getCodePoint(this._bufferService.cols - 1)) {
                  const t6 = this._getWordAt([this._bufferService.cols - 1, e4[1] - 1], false, true, false);
                  if (t6) {
                    const e5 = this._bufferService.cols - t6.start;
                    f2 -= e5, v2 += e5;
                  }
                }
              }
              if (s3 && f2 + v2 === this._bufferService.cols && 32 !== n2.getCodePoint(this._bufferService.cols - 1)) {
                const t5 = r2.lines.get(e4[1] + 1);
                if (t5?.isWrapped && 32 !== t5.getCodePoint(0)) {
                  const t6 = this._getWordAt([0, e4[1] + 1], false, false, true);
                  t6 && (v2 += t6.length);
                }
              }
              return { start: f2, length: v2 };
            }
          }
          _selectWordAt(e4, t4) {
            const i3 = this._getWordAt(e4, t4);
            if (i3) {
              for (; i3.start < 0; ) i3.start += this._bufferService.cols, e4[1]--;
              this._model.selectionStart = [i3.start, e4[1]], this._model.selectionStartLength = i3.length;
            }
          }
          _selectToWordAt(e4) {
            const t4 = this._getWordAt(e4, true);
            if (t4) {
              let i3 = e4[1];
              for (; t4.start < 0; ) t4.start += this._bufferService.cols, i3--;
              if (!this._model.areSelectionValuesReversed()) for (; t4.start + t4.length > this._bufferService.cols; ) t4.length -= this._bufferService.cols, i3++;
              this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? t4.start : t4.start + t4.length, i3];
            }
          }
          _isCharWordSeparator(e4) {
            return 0 !== e4.getWidth() && this._optionsService.rawOptions.wordSeparator.indexOf(e4.getChars()) >= 0;
          }
          _selectLineAt(e4) {
            const t4 = this._bufferService.buffer.getWrappedRangeForLine(e4), i3 = { start: { x: 0, y: t4.first }, end: { x: this._bufferService.cols - 1, y: t4.last } };
            this._model.selectionStart = [0, t4.first], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, _.getRangeLength)(i3, this._bufferService.cols);
          }
        };
        t3.SelectionService = g = s2([r(3, f.IBufferService), r(4, f.ICoreService), r(5, h.IMouseService), r(6, f.IOptionsService), r(7, h.IRenderService), r(8, h.ICoreBrowserService)], g);
      }, 4725: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.ILinkProviderService = t3.IThemeService = t3.ICharacterJoinerService = t3.ISelectionService = t3.IRenderService = t3.IMouseService = t3.ICoreBrowserService = t3.ICharSizeService = void 0;
        const s2 = i2(8343);
        t3.ICharSizeService = (0, s2.createDecorator)("CharSizeService"), t3.ICoreBrowserService = (0, s2.createDecorator)("CoreBrowserService"), t3.IMouseService = (0, s2.createDecorator)("MouseService"), t3.IRenderService = (0, s2.createDecorator)("RenderService"), t3.ISelectionService = (0, s2.createDecorator)("SelectionService"), t3.ICharacterJoinerService = (0, s2.createDecorator)("CharacterJoinerService"), t3.IThemeService = (0, s2.createDecorator)("ThemeService"), t3.ILinkProviderService = (0, s2.createDecorator)("LinkProviderService");
      }, 6731: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.ThemeService = t3.DEFAULT_ANSI_COLORS = void 0;
        const n = i2(7239), o = i2(8055), a = i2(8460), h = i2(844), c = i2(2585), l = o.css.toColor("#ffffff"), d = o.css.toColor("#000000"), _ = o.css.toColor("#ffffff"), u = o.css.toColor("#000000"), f = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 };
        t3.DEFAULT_ANSI_COLORS = Object.freeze((() => {
          const e4 = [o.css.toColor("#2e3436"), o.css.toColor("#cc0000"), o.css.toColor("#4e9a06"), o.css.toColor("#c4a000"), o.css.toColor("#3465a4"), o.css.toColor("#75507b"), o.css.toColor("#06989a"), o.css.toColor("#d3d7cf"), o.css.toColor("#555753"), o.css.toColor("#ef2929"), o.css.toColor("#8ae234"), o.css.toColor("#fce94f"), o.css.toColor("#729fcf"), o.css.toColor("#ad7fa8"), o.css.toColor("#34e2e2"), o.css.toColor("#eeeeec")], t4 = [0, 95, 135, 175, 215, 255];
          for (let i3 = 0; i3 < 216; i3++) {
            const s3 = t4[i3 / 36 % 6 | 0], r2 = t4[i3 / 6 % 6 | 0], n2 = t4[i3 % 6];
            e4.push({ css: o.channels.toCss(s3, r2, n2), rgba: o.channels.toRgba(s3, r2, n2) });
          }
          for (let t5 = 0; t5 < 24; t5++) {
            const i3 = 8 + 10 * t5;
            e4.push({ css: o.channels.toCss(i3, i3, i3), rgba: o.channels.toRgba(i3, i3, i3) });
          }
          return e4;
        })());
        let v = t3.ThemeService = class extends h.Disposable {
          get colors() {
            return this._colors;
          }
          constructor(e4) {
            super(), this._optionsService = e4, this._contrastCache = new n.ColorContrastCache(), this._halfContrastCache = new n.ColorContrastCache(), this._onChangeColors = this.register(new a.EventEmitter()), this.onChangeColors = this._onChangeColors.event, this._colors = { foreground: l, background: d, cursor: _, cursorAccent: u, selectionForeground: void 0, selectionBackgroundTransparent: f, selectionBackgroundOpaque: o.color.blend(d, f), selectionInactiveBackgroundTransparent: f, selectionInactiveBackgroundOpaque: o.color.blend(d, f), ansi: t3.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache, halfContrastCache: this._halfContrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", (() => this._contrastCache.clear()))), this.register(this._optionsService.onSpecificOptionChange("theme", (() => this._setTheme(this._optionsService.rawOptions.theme))));
          }
          _setTheme(e4 = {}) {
            const i3 = this._colors;
            if (i3.foreground = p(e4.foreground, l), i3.background = p(e4.background, d), i3.cursor = p(e4.cursor, _), i3.cursorAccent = p(e4.cursorAccent, u), i3.selectionBackgroundTransparent = p(e4.selectionBackground, f), i3.selectionBackgroundOpaque = o.color.blend(i3.background, i3.selectionBackgroundTransparent), i3.selectionInactiveBackgroundTransparent = p(e4.selectionInactiveBackground, i3.selectionBackgroundTransparent), i3.selectionInactiveBackgroundOpaque = o.color.blend(i3.background, i3.selectionInactiveBackgroundTransparent), i3.selectionForeground = e4.selectionForeground ? p(e4.selectionForeground, o.NULL_COLOR) : void 0, i3.selectionForeground === o.NULL_COLOR && (i3.selectionForeground = void 0), o.color.isOpaque(i3.selectionBackgroundTransparent)) {
              const e5 = 0.3;
              i3.selectionBackgroundTransparent = o.color.opacity(i3.selectionBackgroundTransparent, e5);
            }
            if (o.color.isOpaque(i3.selectionInactiveBackgroundTransparent)) {
              const e5 = 0.3;
              i3.selectionInactiveBackgroundTransparent = o.color.opacity(i3.selectionInactiveBackgroundTransparent, e5);
            }
            if (i3.ansi = t3.DEFAULT_ANSI_COLORS.slice(), i3.ansi[0] = p(e4.black, t3.DEFAULT_ANSI_COLORS[0]), i3.ansi[1] = p(e4.red, t3.DEFAULT_ANSI_COLORS[1]), i3.ansi[2] = p(e4.green, t3.DEFAULT_ANSI_COLORS[2]), i3.ansi[3] = p(e4.yellow, t3.DEFAULT_ANSI_COLORS[3]), i3.ansi[4] = p(e4.blue, t3.DEFAULT_ANSI_COLORS[4]), i3.ansi[5] = p(e4.magenta, t3.DEFAULT_ANSI_COLORS[5]), i3.ansi[6] = p(e4.cyan, t3.DEFAULT_ANSI_COLORS[6]), i3.ansi[7] = p(e4.white, t3.DEFAULT_ANSI_COLORS[7]), i3.ansi[8] = p(e4.brightBlack, t3.DEFAULT_ANSI_COLORS[8]), i3.ansi[9] = p(e4.brightRed, t3.DEFAULT_ANSI_COLORS[9]), i3.ansi[10] = p(e4.brightGreen, t3.DEFAULT_ANSI_COLORS[10]), i3.ansi[11] = p(e4.brightYellow, t3.DEFAULT_ANSI_COLORS[11]), i3.ansi[12] = p(e4.brightBlue, t3.DEFAULT_ANSI_COLORS[12]), i3.ansi[13] = p(e4.brightMagenta, t3.DEFAULT_ANSI_COLORS[13]), i3.ansi[14] = p(e4.brightCyan, t3.DEFAULT_ANSI_COLORS[14]), i3.ansi[15] = p(e4.brightWhite, t3.DEFAULT_ANSI_COLORS[15]), e4.extendedAnsi) {
              const s3 = Math.min(i3.ansi.length - 16, e4.extendedAnsi.length);
              for (let r2 = 0; r2 < s3; r2++) i3.ansi[r2 + 16] = p(e4.extendedAnsi[r2], t3.DEFAULT_ANSI_COLORS[r2 + 16]);
            }
            this._contrastCache.clear(), this._halfContrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
          }
          restoreColor(e4) {
            this._restoreColor(e4), this._onChangeColors.fire(this.colors);
          }
          _restoreColor(e4) {
            if (void 0 !== e4) switch (e4) {
              case 256:
                this._colors.foreground = this._restoreColors.foreground;
                break;
              case 257:
                this._colors.background = this._restoreColors.background;
                break;
              case 258:
                this._colors.cursor = this._restoreColors.cursor;
                break;
              default:
                this._colors.ansi[e4] = this._restoreColors.ansi[e4];
            }
            else for (let e5 = 0; e5 < this._restoreColors.ansi.length; ++e5) this._colors.ansi[e5] = this._restoreColors.ansi[e5];
          }
          modifyColors(e4) {
            e4(this._colors), this._onChangeColors.fire(this.colors);
          }
          _updateRestoreColors() {
            this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() };
          }
        };
        function p(e4, t4) {
          if (void 0 !== e4) try {
            return o.css.toColor(e4);
          } catch {
          }
          return t4;
        }
        __name(p, "p");
        t3.ThemeService = v = s2([r(0, c.IOptionsService)], v);
      }, 6349: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.CircularList = void 0;
        const s2 = i2(8460), r = i2(844);
        const _n = class _n extends r.Disposable {
          constructor(e4) {
            super(), this._maxLength = e4, this.onDeleteEmitter = this.register(new s2.EventEmitter()), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new s2.EventEmitter()), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new s2.EventEmitter()), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
          }
          get maxLength() {
            return this._maxLength;
          }
          set maxLength(e4) {
            if (this._maxLength === e4) return;
            const t4 = new Array(e4);
            for (let i3 = 0; i3 < Math.min(e4, this.length); i3++) t4[i3] = this._array[this._getCyclicIndex(i3)];
            this._array = t4, this._maxLength = e4, this._startIndex = 0;
          }
          get length() {
            return this._length;
          }
          set length(e4) {
            if (e4 > this._length) for (let t4 = this._length; t4 < e4; t4++) this._array[t4] = void 0;
            this._length = e4;
          }
          get(e4) {
            return this._array[this._getCyclicIndex(e4)];
          }
          set(e4, t4) {
            this._array[this._getCyclicIndex(e4)] = t4;
          }
          push(e4) {
            this._array[this._getCyclicIndex(this._length)] = e4, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
          }
          recycle() {
            if (this._length !== this._maxLength) throw new Error("Can only recycle when the buffer is full");
            return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
          }
          get isFull() {
            return this._length === this._maxLength;
          }
          pop() {
            return this._array[this._getCyclicIndex(this._length-- - 1)];
          }
          splice(e4, t4, ...i3) {
            if (t4) {
              for (let i4 = e4; i4 < this._length - t4; i4++) this._array[this._getCyclicIndex(i4)] = this._array[this._getCyclicIndex(i4 + t4)];
              this._length -= t4, this.onDeleteEmitter.fire({ index: e4, amount: t4 });
            }
            for (let t5 = this._length - 1; t5 >= e4; t5--) this._array[this._getCyclicIndex(t5 + i3.length)] = this._array[this._getCyclicIndex(t5)];
            for (let t5 = 0; t5 < i3.length; t5++) this._array[this._getCyclicIndex(e4 + t5)] = i3[t5];
            if (i3.length && this.onInsertEmitter.fire({ index: e4, amount: i3.length }), this._length + i3.length > this._maxLength) {
              const e5 = this._length + i3.length - this._maxLength;
              this._startIndex += e5, this._length = this._maxLength, this.onTrimEmitter.fire(e5);
            } else this._length += i3.length;
          }
          trimStart(e4) {
            e4 > this._length && (e4 = this._length), this._startIndex += e4, this._length -= e4, this.onTrimEmitter.fire(e4);
          }
          shiftElements(e4, t4, i3) {
            if (!(t4 <= 0)) {
              if (e4 < 0 || e4 >= this._length) throw new Error("start argument out of range");
              if (e4 + i3 < 0) throw new Error("Cannot shift elements in list beyond index 0");
              if (i3 > 0) {
                for (let s4 = t4 - 1; s4 >= 0; s4--) this.set(e4 + s4 + i3, this.get(e4 + s4));
                const s3 = e4 + t4 + i3 - this._length;
                if (s3 > 0) for (this._length += s3; this._length > this._maxLength; ) this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
              } else for (let s3 = 0; s3 < t4; s3++) this.set(e4 + s3 + i3, this.get(e4 + s3));
            }
          }
          _getCyclicIndex(e4) {
            return (this._startIndex + e4) % this._maxLength;
          }
        };
        __name(_n, "n");
        let n = _n;
        t3.CircularList = n;
      }, 1439: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.clone = void 0, t3.clone = /* @__PURE__ */ __name(function e4(t4, i2 = 5) {
          if ("object" != typeof t4) return t4;
          const s2 = Array.isArray(t4) ? [] : {};
          for (const r in t4) s2[r] = i2 <= 1 ? t4[r] : t4[r] && e4(t4[r], i2 - 1);
          return s2;
        }, "e");
      }, 8055: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.contrastRatio = t3.toPaddedHex = t3.rgba = t3.rgb = t3.css = t3.color = t3.channels = t3.NULL_COLOR = void 0;
        let i2 = 0, s2 = 0, r = 0, n = 0;
        var o, a, h, c, l;
        function d(e4) {
          const t4 = e4.toString(16);
          return t4.length < 2 ? "0" + t4 : t4;
        }
        __name(d, "d");
        function _(e4, t4) {
          return e4 < t4 ? (t4 + 0.05) / (e4 + 0.05) : (e4 + 0.05) / (t4 + 0.05);
        }
        __name(_, "_");
        t3.NULL_COLOR = { css: "#00000000", rgba: 0 }, (function(e4) {
          e4.toCss = function(e5, t4, i3, s3) {
            return void 0 !== s3 ? `#${d(e5)}${d(t4)}${d(i3)}${d(s3)}` : `#${d(e5)}${d(t4)}${d(i3)}`;
          }, e4.toRgba = function(e5, t4, i3, s3 = 255) {
            return (e5 << 24 | t4 << 16 | i3 << 8 | s3) >>> 0;
          }, e4.toColor = function(t4, i3, s3, r2) {
            return { css: e4.toCss(t4, i3, s3, r2), rgba: e4.toRgba(t4, i3, s3, r2) };
          };
        })(o || (t3.channels = o = {})), (function(e4) {
          function t4(e5, t5) {
            return n = Math.round(255 * t5), [i2, s2, r] = l.toChannels(e5.rgba), { css: o.toCss(i2, s2, r, n), rgba: o.toRgba(i2, s2, r, n) };
          }
          __name(t4, "t");
          e4.blend = function(e5, t5) {
            if (n = (255 & t5.rgba) / 255, 1 === n) return { css: t5.css, rgba: t5.rgba };
            const a2 = t5.rgba >> 24 & 255, h2 = t5.rgba >> 16 & 255, c2 = t5.rgba >> 8 & 255, l2 = e5.rgba >> 24 & 255, d2 = e5.rgba >> 16 & 255, _2 = e5.rgba >> 8 & 255;
            return i2 = l2 + Math.round((a2 - l2) * n), s2 = d2 + Math.round((h2 - d2) * n), r = _2 + Math.round((c2 - _2) * n), { css: o.toCss(i2, s2, r), rgba: o.toRgba(i2, s2, r) };
          }, e4.isOpaque = function(e5) {
            return 255 == (255 & e5.rgba);
          }, e4.ensureContrastRatio = function(e5, t5, i3) {
            const s3 = l.ensureContrastRatio(e5.rgba, t5.rgba, i3);
            if (s3) return o.toColor(s3 >> 24 & 255, s3 >> 16 & 255, s3 >> 8 & 255);
          }, e4.opaque = function(e5) {
            const t5 = (255 | e5.rgba) >>> 0;
            return [i2, s2, r] = l.toChannels(t5), { css: o.toCss(i2, s2, r), rgba: t5 };
          }, e4.opacity = t4, e4.multiplyOpacity = function(e5, i3) {
            return n = 255 & e5.rgba, t4(e5, n * i3 / 255);
          }, e4.toColorRGB = function(e5) {
            return [e5.rgba >> 24 & 255, e5.rgba >> 16 & 255, e5.rgba >> 8 & 255];
          };
        })(a || (t3.color = a = {})), (function(e4) {
          let t4, a2;
          try {
            const e5 = document.createElement("canvas");
            e5.width = 1, e5.height = 1;
            const i3 = e5.getContext("2d", { willReadFrequently: true });
            i3 && (t4 = i3, t4.globalCompositeOperation = "copy", a2 = t4.createLinearGradient(0, 0, 1, 1));
          } catch {
          }
          e4.toColor = function(e5) {
            if (e5.match(/#[\da-f]{3,8}/i)) switch (e5.length) {
              case 4:
                return i2 = parseInt(e5.slice(1, 2).repeat(2), 16), s2 = parseInt(e5.slice(2, 3).repeat(2), 16), r = parseInt(e5.slice(3, 4).repeat(2), 16), o.toColor(i2, s2, r);
              case 5:
                return i2 = parseInt(e5.slice(1, 2).repeat(2), 16), s2 = parseInt(e5.slice(2, 3).repeat(2), 16), r = parseInt(e5.slice(3, 4).repeat(2), 16), n = parseInt(e5.slice(4, 5).repeat(2), 16), o.toColor(i2, s2, r, n);
              case 7:
                return { css: e5, rgba: (parseInt(e5.slice(1), 16) << 8 | 255) >>> 0 };
              case 9:
                return { css: e5, rgba: parseInt(e5.slice(1), 16) >>> 0 };
            }
            const h2 = e5.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
            if (h2) return i2 = parseInt(h2[1]), s2 = parseInt(h2[2]), r = parseInt(h2[3]), n = Math.round(255 * (void 0 === h2[5] ? 1 : parseFloat(h2[5]))), o.toColor(i2, s2, r, n);
            if (!t4 || !a2) throw new Error("css.toColor: Unsupported css format");
            if (t4.fillStyle = a2, t4.fillStyle = e5, "string" != typeof t4.fillStyle) throw new Error("css.toColor: Unsupported css format");
            if (t4.fillRect(0, 0, 1, 1), [i2, s2, r, n] = t4.getImageData(0, 0, 1, 1).data, 255 !== n) throw new Error("css.toColor: Unsupported css format");
            return { rgba: o.toRgba(i2, s2, r, n), css: e5 };
          };
        })(h || (t3.css = h = {})), (function(e4) {
          function t4(e5, t5, i3) {
            const s3 = e5 / 255, r2 = t5 / 255, n2 = i3 / 255;
            return 0.2126 * (s3 <= 0.03928 ? s3 / 12.92 : Math.pow((s3 + 0.055) / 1.055, 2.4)) + 0.7152 * (r2 <= 0.03928 ? r2 / 12.92 : Math.pow((r2 + 0.055) / 1.055, 2.4)) + 0.0722 * (n2 <= 0.03928 ? n2 / 12.92 : Math.pow((n2 + 0.055) / 1.055, 2.4));
          }
          __name(t4, "t");
          e4.relativeLuminance = function(e5) {
            return t4(e5 >> 16 & 255, e5 >> 8 & 255, 255 & e5);
          }, e4.relativeLuminance2 = t4;
        })(c || (t3.rgb = c = {})), (function(e4) {
          function t4(e5, t5, i3) {
            const s3 = e5 >> 24 & 255, r2 = e5 >> 16 & 255, n2 = e5 >> 8 & 255;
            let o2 = t5 >> 24 & 255, a3 = t5 >> 16 & 255, h2 = t5 >> 8 & 255, l2 = _(c.relativeLuminance2(o2, a3, h2), c.relativeLuminance2(s3, r2, n2));
            for (; l2 < i3 && (o2 > 0 || a3 > 0 || h2 > 0); ) o2 -= Math.max(0, Math.ceil(0.1 * o2)), a3 -= Math.max(0, Math.ceil(0.1 * a3)), h2 -= Math.max(0, Math.ceil(0.1 * h2)), l2 = _(c.relativeLuminance2(o2, a3, h2), c.relativeLuminance2(s3, r2, n2));
            return (o2 << 24 | a3 << 16 | h2 << 8 | 255) >>> 0;
          }
          __name(t4, "t");
          function a2(e5, t5, i3) {
            const s3 = e5 >> 24 & 255, r2 = e5 >> 16 & 255, n2 = e5 >> 8 & 255;
            let o2 = t5 >> 24 & 255, a3 = t5 >> 16 & 255, h2 = t5 >> 8 & 255, l2 = _(c.relativeLuminance2(o2, a3, h2), c.relativeLuminance2(s3, r2, n2));
            for (; l2 < i3 && (o2 < 255 || a3 < 255 || h2 < 255); ) o2 = Math.min(255, o2 + Math.ceil(0.1 * (255 - o2))), a3 = Math.min(255, a3 + Math.ceil(0.1 * (255 - a3))), h2 = Math.min(255, h2 + Math.ceil(0.1 * (255 - h2))), l2 = _(c.relativeLuminance2(o2, a3, h2), c.relativeLuminance2(s3, r2, n2));
            return (o2 << 24 | a3 << 16 | h2 << 8 | 255) >>> 0;
          }
          __name(a2, "a");
          e4.blend = function(e5, t5) {
            if (n = (255 & t5) / 255, 1 === n) return t5;
            const a3 = t5 >> 24 & 255, h2 = t5 >> 16 & 255, c2 = t5 >> 8 & 255, l2 = e5 >> 24 & 255, d2 = e5 >> 16 & 255, _2 = e5 >> 8 & 255;
            return i2 = l2 + Math.round((a3 - l2) * n), s2 = d2 + Math.round((h2 - d2) * n), r = _2 + Math.round((c2 - _2) * n), o.toRgba(i2, s2, r);
          }, e4.ensureContrastRatio = function(e5, i3, s3) {
            const r2 = c.relativeLuminance(e5 >> 8), n2 = c.relativeLuminance(i3 >> 8);
            if (_(r2, n2) < s3) {
              if (n2 < r2) {
                const n3 = t4(e5, i3, s3), o3 = _(r2, c.relativeLuminance(n3 >> 8));
                if (o3 < s3) {
                  const t5 = a2(e5, i3, s3);
                  return o3 > _(r2, c.relativeLuminance(t5 >> 8)) ? n3 : t5;
                }
                return n3;
              }
              const o2 = a2(e5, i3, s3), h2 = _(r2, c.relativeLuminance(o2 >> 8));
              if (h2 < s3) {
                const n3 = t4(e5, i3, s3);
                return h2 > _(r2, c.relativeLuminance(n3 >> 8)) ? o2 : n3;
              }
              return o2;
            }
          }, e4.reduceLuminance = t4, e4.increaseLuminance = a2, e4.toChannels = function(e5) {
            return [e5 >> 24 & 255, e5 >> 16 & 255, e5 >> 8 & 255, 255 & e5];
          };
        })(l || (t3.rgba = l = {})), t3.toPaddedHex = d, t3.contrastRatio = _;
      }, 8969: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.CoreTerminal = void 0;
        const s2 = i2(844), r = i2(2585), n = i2(4348), o = i2(7866), a = i2(744), h = i2(7302), c = i2(6975), l = i2(8460), d = i2(1753), _ = i2(1480), u = i2(7994), f = i2(9282), v = i2(5435), p = i2(5981), g = i2(2660);
        let m = false;
        const _S = class _S extends s2.Disposable {
          get onScroll() {
            return this._onScrollApi || (this._onScrollApi = this.register(new l.EventEmitter()), this._onScroll.event(((e4) => {
              this._onScrollApi?.fire(e4.position);
            }))), this._onScrollApi.event;
          }
          get cols() {
            return this._bufferService.cols;
          }
          get rows() {
            return this._bufferService.rows;
          }
          get buffers() {
            return this._bufferService.buffers;
          }
          get options() {
            return this.optionsService.options;
          }
          set options(e4) {
            for (const t4 in e4) this.optionsService.options[t4] = e4[t4];
          }
          constructor(e4) {
            super(), this._windowsWrappingHeuristics = this.register(new s2.MutableDisposable()), this._onBinary = this.register(new l.EventEmitter()), this.onBinary = this._onBinary.event, this._onData = this.register(new l.EventEmitter()), this.onData = this._onData.event, this._onLineFeed = this.register(new l.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new l.EventEmitter()), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new l.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new l.EventEmitter()), this._instantiationService = new n.InstantiationService(), this.optionsService = this.register(new h.OptionsService(e4)), this._instantiationService.setService(r.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(a.BufferService)), this._instantiationService.setService(r.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(o.LogService)), this._instantiationService.setService(r.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(c.CoreService)), this._instantiationService.setService(r.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(d.CoreMouseService)), this._instantiationService.setService(r.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(_.UnicodeService)), this._instantiationService.setService(r.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(u.CharsetService), this._instantiationService.setService(r.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(g.OscLinkService), this._instantiationService.setService(r.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new v.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, l.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, l.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, l.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, l.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom((() => this.scrollToBottom()))), this.register(this.coreService.onUserInput((() => this._writeBuffer.handleUserInput()))), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], (() => this._handleWindowsPtyOptionChange()))), this.register(this._bufferService.onScroll(((e5) => {
              this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
            }))), this.register(this._inputHandler.onScroll(((e5) => {
              this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
            }))), this._writeBuffer = this.register(new p.WriteBuffer(((e5, t4) => this._inputHandler.parse(e5, t4)))), this.register((0, l.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed));
          }
          write(e4, t4) {
            this._writeBuffer.write(e4, t4);
          }
          writeSync(e4, t4) {
            this._logService.logLevel <= r.LogLevelEnum.WARN && !m && (this._logService.warn("writeSync is unreliable and will be removed soon."), m = true), this._writeBuffer.writeSync(e4, t4);
          }
          input(e4, t4 = true) {
            this.coreService.triggerDataEvent(e4, t4);
          }
          resize(e4, t4) {
            isNaN(e4) || isNaN(t4) || (e4 = Math.max(e4, a.MINIMUM_COLS), t4 = Math.max(t4, a.MINIMUM_ROWS), this._bufferService.resize(e4, t4));
          }
          scroll(e4, t4 = false) {
            this._bufferService.scroll(e4, t4);
          }
          scrollLines(e4, t4, i3) {
            this._bufferService.scrollLines(e4, t4, i3);
          }
          scrollPages(e4) {
            this.scrollLines(e4 * (this.rows - 1));
          }
          scrollToTop() {
            this.scrollLines(-this._bufferService.buffer.ydisp);
          }
          scrollToBottom() {
            this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
          }
          scrollToLine(e4) {
            const t4 = e4 - this._bufferService.buffer.ydisp;
            0 !== t4 && this.scrollLines(t4);
          }
          registerEscHandler(e4, t4) {
            return this._inputHandler.registerEscHandler(e4, t4);
          }
          registerDcsHandler(e4, t4) {
            return this._inputHandler.registerDcsHandler(e4, t4);
          }
          registerCsiHandler(e4, t4) {
            return this._inputHandler.registerCsiHandler(e4, t4);
          }
          registerOscHandler(e4, t4) {
            return this._inputHandler.registerOscHandler(e4, t4);
          }
          _setup() {
            this._handleWindowsPtyOptionChange();
          }
          reset() {
            this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
          }
          _handleWindowsPtyOptionChange() {
            let e4 = false;
            const t4 = this.optionsService.rawOptions.windowsPty;
            t4 && void 0 !== t4.buildNumber && void 0 !== t4.buildNumber ? e4 = !!("conpty" === t4.backend && t4.buildNumber < 21376) : this.optionsService.rawOptions.windowsMode && (e4 = true), e4 ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear();
          }
          _enableWindowsWrappingHeuristics() {
            if (!this._windowsWrappingHeuristics.value) {
              const e4 = [];
              e4.push(this.onLineFeed(f.updateWindowsModeWrappedState.bind(null, this._bufferService))), e4.push(this.registerCsiHandler({ final: "H" }, (() => ((0, f.updateWindowsModeWrappedState)(this._bufferService), false)))), this._windowsWrappingHeuristics.value = (0, s2.toDisposable)((() => {
                for (const t4 of e4) t4.dispose();
              }));
            }
          }
        };
        __name(_S, "S");
        let S = _S;
        t3.CoreTerminal = S;
      }, 8460: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.runAndSubscribe = t3.forwardEvent = t3.EventEmitter = void 0, t3.EventEmitter = class {
          constructor() {
            this._listeners = [], this._disposed = false;
          }
          get event() {
            return this._event || (this._event = (e4) => (this._listeners.push(e4), { dispose: /* @__PURE__ */ __name(() => {
              if (!this._disposed) {
                for (let t4 = 0; t4 < this._listeners.length; t4++) if (this._listeners[t4] === e4) return void this._listeners.splice(t4, 1);
              }
            }, "dispose") })), this._event;
          }
          fire(e4, t4) {
            const i2 = [];
            for (let e5 = 0; e5 < this._listeners.length; e5++) i2.push(this._listeners[e5]);
            for (let s2 = 0; s2 < i2.length; s2++) i2[s2].call(void 0, e4, t4);
          }
          dispose() {
            this.clearListeners(), this._disposed = true;
          }
          clearListeners() {
            this._listeners && (this._listeners.length = 0);
          }
        }, t3.forwardEvent = function(e4, t4) {
          return e4(((e5) => t4.fire(e5)));
        }, t3.runAndSubscribe = function(e4, t4) {
          return t4(void 0), e4(((e5) => t4(e5)));
        };
      }, 5435: function(e3, t3, i2) {
        var _a2;
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.InputHandler = t3.WindowsOptionsReportType = void 0;
        const n = i2(2584), o = i2(7116), a = i2(2015), h = i2(844), c = i2(482), l = i2(8437), d = i2(8460), _ = i2(643), u = i2(511), f = i2(3734), v = i2(2585), p = i2(1480), g = i2(6242), m = i2(6351), S = i2(5941), C = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, b = 131072;
        function w(e4, t4) {
          if (e4 > 24) return t4.setWinLines || false;
          switch (e4) {
            case 1:
              return !!t4.restoreWin;
            case 2:
              return !!t4.minimizeWin;
            case 3:
              return !!t4.setWinPosition;
            case 4:
              return !!t4.setWinSizePixels;
            case 5:
              return !!t4.raiseWin;
            case 6:
              return !!t4.lowerWin;
            case 7:
              return !!t4.refreshWin;
            case 8:
              return !!t4.setWinSizeChars;
            case 9:
              return !!t4.maximizeWin;
            case 10:
              return !!t4.fullscreenWin;
            case 11:
              return !!t4.getWinState;
            case 13:
              return !!t4.getWinPosition;
            case 14:
              return !!t4.getWinSizePixels;
            case 15:
              return !!t4.getScreenSizePixels;
            case 16:
              return !!t4.getCellSizePixels;
            case 18:
              return !!t4.getWinSizeChars;
            case 19:
              return !!t4.getScreenSizeChars;
            case 20:
              return !!t4.getIconTitle;
            case 21:
              return !!t4.getWinTitle;
            case 22:
              return !!t4.pushTitle;
            case 23:
              return !!t4.popTitle;
            case 24:
              return !!t4.setWinLines;
          }
          return false;
        }
        __name(w, "w");
        var y;
        !(function(e4) {
          e4[e4.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", e4[e4.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
        })(y || (t3.WindowsOptionsReportType = y = {}));
        let E = 0;
        const _k = class _k extends h.Disposable {
          getAttrData() {
            return this._curAttrData;
          }
          constructor(e4, t4, i3, s3, r2, h2, _2, f2, v2 = new a.EscapeSequenceParser()) {
            super(), this._bufferService = e4, this._charsetService = t4, this._coreService = i3, this._logService = s3, this._optionsService = r2, this._oscLinkService = h2, this._coreMouseService = _2, this._unicodeService = f2, this._parser = v2, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new c.StringToUtf32(), this._utf8Decoder = new c.Utf8ToUtf32(), this._workCell = new u.CellData(), this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new d.EventEmitter()), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new d.EventEmitter()), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new d.EventEmitter()), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new d.EventEmitter()), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new d.EventEmitter()), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new d.EventEmitter()), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new d.EventEmitter()), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new d.EventEmitter()), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new d.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new d.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new d.EventEmitter()), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new d.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new d.EventEmitter()), this.onColor = this._onColor.event, this._parseStack = { paused: false, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new L(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate(((e5) => this._activeBuffer = e5.activeBuffer))), this._parser.setCsiHandlerFallback(((e5, t5) => {
              this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(e5), params: t5.toArray() });
            })), this._parser.setEscHandlerFallback(((e5) => {
              this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(e5) });
            })), this._parser.setExecuteHandlerFallback(((e5) => {
              this._logService.debug("Unknown EXECUTE code: ", { code: e5 });
            })), this._parser.setOscHandlerFallback(((e5, t5, i4) => {
              this._logService.debug("Unknown OSC code: ", { identifier: e5, action: t5, data: i4 });
            })), this._parser.setDcsHandlerFallback(((e5, t5, i4) => {
              "HOOK" === t5 && (i4 = i4.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(e5), action: t5, payload: i4 });
            })), this._parser.setPrintHandler(((e5, t5, i4) => this.print(e5, t5, i4))), this._parser.registerCsiHandler({ final: "@" }, ((e5) => this.insertChars(e5))), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, ((e5) => this.scrollLeft(e5))), this._parser.registerCsiHandler({ final: "A" }, ((e5) => this.cursorUp(e5))), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, ((e5) => this.scrollRight(e5))), this._parser.registerCsiHandler({ final: "B" }, ((e5) => this.cursorDown(e5))), this._parser.registerCsiHandler({ final: "C" }, ((e5) => this.cursorForward(e5))), this._parser.registerCsiHandler({ final: "D" }, ((e5) => this.cursorBackward(e5))), this._parser.registerCsiHandler({ final: "E" }, ((e5) => this.cursorNextLine(e5))), this._parser.registerCsiHandler({ final: "F" }, ((e5) => this.cursorPrecedingLine(e5))), this._parser.registerCsiHandler({ final: "G" }, ((e5) => this.cursorCharAbsolute(e5))), this._parser.registerCsiHandler({ final: "H" }, ((e5) => this.cursorPosition(e5))), this._parser.registerCsiHandler({ final: "I" }, ((e5) => this.cursorForwardTab(e5))), this._parser.registerCsiHandler({ final: "J" }, ((e5) => this.eraseInDisplay(e5, false))), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, ((e5) => this.eraseInDisplay(e5, true))), this._parser.registerCsiHandler({ final: "K" }, ((e5) => this.eraseInLine(e5, false))), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, ((e5) => this.eraseInLine(e5, true))), this._parser.registerCsiHandler({ final: "L" }, ((e5) => this.insertLines(e5))), this._parser.registerCsiHandler({ final: "M" }, ((e5) => this.deleteLines(e5))), this._parser.registerCsiHandler({ final: "P" }, ((e5) => this.deleteChars(e5))), this._parser.registerCsiHandler({ final: "S" }, ((e5) => this.scrollUp(e5))), this._parser.registerCsiHandler({ final: "T" }, ((e5) => this.scrollDown(e5))), this._parser.registerCsiHandler({ final: "X" }, ((e5) => this.eraseChars(e5))), this._parser.registerCsiHandler({ final: "Z" }, ((e5) => this.cursorBackwardTab(e5))), this._parser.registerCsiHandler({ final: "`" }, ((e5) => this.charPosAbsolute(e5))), this._parser.registerCsiHandler({ final: "a" }, ((e5) => this.hPositionRelative(e5))), this._parser.registerCsiHandler({ final: "b" }, ((e5) => this.repeatPrecedingCharacter(e5))), this._parser.registerCsiHandler({ final: "c" }, ((e5) => this.sendDeviceAttributesPrimary(e5))), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, ((e5) => this.sendDeviceAttributesSecondary(e5))), this._parser.registerCsiHandler({ final: "d" }, ((e5) => this.linePosAbsolute(e5))), this._parser.registerCsiHandler({ final: "e" }, ((e5) => this.vPositionRelative(e5))), this._parser.registerCsiHandler({ final: "f" }, ((e5) => this.hVPosition(e5))), this._parser.registerCsiHandler({ final: "g" }, ((e5) => this.tabClear(e5))), this._parser.registerCsiHandler({ final: "h" }, ((e5) => this.setMode(e5))), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, ((e5) => this.setModePrivate(e5))), this._parser.registerCsiHandler({ final: "l" }, ((e5) => this.resetMode(e5))), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, ((e5) => this.resetModePrivate(e5))), this._parser.registerCsiHandler({ final: "m" }, ((e5) => this.charAttributes(e5))), this._parser.registerCsiHandler({ final: "n" }, ((e5) => this.deviceStatus(e5))), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, ((e5) => this.deviceStatusPrivate(e5))), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, ((e5) => this.softReset(e5))), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, ((e5) => this.setCursorStyle(e5))), this._parser.registerCsiHandler({ final: "r" }, ((e5) => this.setScrollRegion(e5))), this._parser.registerCsiHandler({ final: "s" }, ((e5) => this.saveCursor(e5))), this._parser.registerCsiHandler({ final: "t" }, ((e5) => this.windowOptions(e5))), this._parser.registerCsiHandler({ final: "u" }, ((e5) => this.restoreCursor(e5))), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, ((e5) => this.insertColumns(e5))), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, ((e5) => this.deleteColumns(e5))), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, ((e5) => this.selectProtected(e5))), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, ((e5) => this.requestMode(e5, true))), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, ((e5) => this.requestMode(e5, false))), this._parser.setExecuteHandler(n.C0.BEL, (() => this.bell())), this._parser.setExecuteHandler(n.C0.LF, (() => this.lineFeed())), this._parser.setExecuteHandler(n.C0.VT, (() => this.lineFeed())), this._parser.setExecuteHandler(n.C0.FF, (() => this.lineFeed())), this._parser.setExecuteHandler(n.C0.CR, (() => this.carriageReturn())), this._parser.setExecuteHandler(n.C0.BS, (() => this.backspace())), this._parser.setExecuteHandler(n.C0.HT, (() => this.tab())), this._parser.setExecuteHandler(n.C0.SO, (() => this.shiftOut())), this._parser.setExecuteHandler(n.C0.SI, (() => this.shiftIn())), this._parser.setExecuteHandler(n.C1.IND, (() => this.index())), this._parser.setExecuteHandler(n.C1.NEL, (() => this.nextLine())), this._parser.setExecuteHandler(n.C1.HTS, (() => this.tabSet())), this._parser.registerOscHandler(0, new g.OscHandler(((e5) => (this.setTitle(e5), this.setIconName(e5), true)))), this._parser.registerOscHandler(1, new g.OscHandler(((e5) => this.setIconName(e5)))), this._parser.registerOscHandler(2, new g.OscHandler(((e5) => this.setTitle(e5)))), this._parser.registerOscHandler(4, new g.OscHandler(((e5) => this.setOrReportIndexedColor(e5)))), this._parser.registerOscHandler(8, new g.OscHandler(((e5) => this.setHyperlink(e5)))), this._parser.registerOscHandler(10, new g.OscHandler(((e5) => this.setOrReportFgColor(e5)))), this._parser.registerOscHandler(11, new g.OscHandler(((e5) => this.setOrReportBgColor(e5)))), this._parser.registerOscHandler(12, new g.OscHandler(((e5) => this.setOrReportCursorColor(e5)))), this._parser.registerOscHandler(104, new g.OscHandler(((e5) => this.restoreIndexedColor(e5)))), this._parser.registerOscHandler(110, new g.OscHandler(((e5) => this.restoreFgColor(e5)))), this._parser.registerOscHandler(111, new g.OscHandler(((e5) => this.restoreBgColor(e5)))), this._parser.registerOscHandler(112, new g.OscHandler(((e5) => this.restoreCursorColor(e5)))), this._parser.registerEscHandler({ final: "7" }, (() => this.saveCursor())), this._parser.registerEscHandler({ final: "8" }, (() => this.restoreCursor())), this._parser.registerEscHandler({ final: "D" }, (() => this.index())), this._parser.registerEscHandler({ final: "E" }, (() => this.nextLine())), this._parser.registerEscHandler({ final: "H" }, (() => this.tabSet())), this._parser.registerEscHandler({ final: "M" }, (() => this.reverseIndex())), this._parser.registerEscHandler({ final: "=" }, (() => this.keypadApplicationMode())), this._parser.registerEscHandler({ final: ">" }, (() => this.keypadNumericMode())), this._parser.registerEscHandler({ final: "c" }, (() => this.fullReset())), this._parser.registerEscHandler({ final: "n" }, (() => this.setgLevel(2))), this._parser.registerEscHandler({ final: "o" }, (() => this.setgLevel(3))), this._parser.registerEscHandler({ final: "|" }, (() => this.setgLevel(3))), this._parser.registerEscHandler({ final: "}" }, (() => this.setgLevel(2))), this._parser.registerEscHandler({ final: "~" }, (() => this.setgLevel(1))), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, (() => this.selectDefaultCharset())), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, (() => this.selectDefaultCharset()));
            for (const e5 in o.CHARSETS) this._parser.registerEscHandler({ intermediates: "(", final: e5 }, (() => this.selectCharset("(" + e5))), this._parser.registerEscHandler({ intermediates: ")", final: e5 }, (() => this.selectCharset(")" + e5))), this._parser.registerEscHandler({ intermediates: "*", final: e5 }, (() => this.selectCharset("*" + e5))), this._parser.registerEscHandler({ intermediates: "+", final: e5 }, (() => this.selectCharset("+" + e5))), this._parser.registerEscHandler({ intermediates: "-", final: e5 }, (() => this.selectCharset("-" + e5))), this._parser.registerEscHandler({ intermediates: ".", final: e5 }, (() => this.selectCharset("." + e5))), this._parser.registerEscHandler({ intermediates: "/", final: e5 }, (() => this.selectCharset("/" + e5)));
            this._parser.registerEscHandler({ intermediates: "#", final: "8" }, (() => this.screenAlignmentPattern())), this._parser.setErrorHandler(((e5) => (this._logService.error("Parsing error: ", e5), e5))), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new m.DcsHandler(((e5, t5) => this.requestStatusString(e5, t5))));
          }
          _preserveStack(e4, t4, i3, s3) {
            this._parseStack.paused = true, this._parseStack.cursorStartX = e4, this._parseStack.cursorStartY = t4, this._parseStack.decodedLength = i3, this._parseStack.position = s3;
          }
          _logSlowResolvingAsync(e4) {
            this._logService.logLevel <= v.LogLevelEnum.WARN && Promise.race([e4, new Promise(((e5, t4) => setTimeout((() => t4("#SLOW_TIMEOUT")), 5e3)))]).catch(((e5) => {
              if ("#SLOW_TIMEOUT" !== e5) throw e5;
              console.warn("async parser handler taking longer than 5000 ms");
            }));
          }
          _getCurrentLinkId() {
            return this._curAttrData.extended.urlId;
          }
          parse(e4, t4) {
            let i3, s3 = this._activeBuffer.x, r2 = this._activeBuffer.y, n2 = 0;
            const o2 = this._parseStack.paused;
            if (o2) {
              if (i3 = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, t4)) return this._logSlowResolvingAsync(i3), i3;
              s3 = this._parseStack.cursorStartX, r2 = this._parseStack.cursorStartY, this._parseStack.paused = false, e4.length > b && (n2 = this._parseStack.position + b);
            }
            if (this._logService.logLevel <= v.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + ("string" == typeof e4 ? ` "${e4}"` : ` "${Array.prototype.map.call(e4, ((e5) => String.fromCharCode(e5))).join("")}"`), "string" == typeof e4 ? e4.split("").map(((e5) => e5.charCodeAt(0))) : e4), this._parseBuffer.length < e4.length && this._parseBuffer.length < b && (this._parseBuffer = new Uint32Array(Math.min(e4.length, b))), o2 || this._dirtyRowTracker.clearRange(), e4.length > b) for (let t5 = n2; t5 < e4.length; t5 += b) {
              const n3 = t5 + b < e4.length ? t5 + b : e4.length, o3 = "string" == typeof e4 ? this._stringDecoder.decode(e4.substring(t5, n3), this._parseBuffer) : this._utf8Decoder.decode(e4.subarray(t5, n3), this._parseBuffer);
              if (i3 = this._parser.parse(this._parseBuffer, o3)) return this._preserveStack(s3, r2, o3, t5), this._logSlowResolvingAsync(i3), i3;
            }
            else if (!o2) {
              const t5 = "string" == typeof e4 ? this._stringDecoder.decode(e4, this._parseBuffer) : this._utf8Decoder.decode(e4, this._parseBuffer);
              if (i3 = this._parser.parse(this._parseBuffer, t5)) return this._preserveStack(s3, r2, t5, 0), this._logSlowResolvingAsync(i3), i3;
            }
            this._activeBuffer.x === s3 && this._activeBuffer.y === r2 || this._onCursorMove.fire();
            const a2 = this._dirtyRowTracker.end + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp), h2 = this._dirtyRowTracker.start + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
            h2 < this._bufferService.rows && this._onRequestRefreshRows.fire(Math.min(h2, this._bufferService.rows - 1), Math.min(a2, this._bufferService.rows - 1));
          }
          print(e4, t4, i3) {
            let s3, r2;
            const n2 = this._charsetService.charset, o2 = this._optionsService.rawOptions.screenReaderMode, a2 = this._bufferService.cols, h2 = this._coreService.decPrivateModes.wraparound, d2 = this._coreService.modes.insertMode, u2 = this._curAttrData;
            let f2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && i3 - t4 > 0 && 2 === f2.getWidth(this._activeBuffer.x - 1) && f2.setCellFromCodepoint(this._activeBuffer.x - 1, 0, 1, u2);
            let v2 = this._parser.precedingJoinState;
            for (let g2 = t4; g2 < i3; ++g2) {
              if (s3 = e4[g2], s3 < 127 && n2) {
                const e5 = n2[String.fromCharCode(s3)];
                e5 && (s3 = e5.charCodeAt(0));
              }
              const t5 = this._unicodeService.charProperties(s3, v2);
              r2 = p.UnicodeService.extractWidth(t5);
              const i4 = p.UnicodeService.extractShouldJoin(t5), m2 = i4 ? p.UnicodeService.extractWidth(v2) : 0;
              if (v2 = t5, o2 && this._onA11yChar.fire((0, c.stringFromCodePoint)(s3)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), this._activeBuffer.x + r2 - m2 > a2) {
                if (h2) {
                  const e5 = f2;
                  let t6 = this._activeBuffer.x - m2;
                  for (this._activeBuffer.x = m2, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), true)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = true), f2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y), m2 > 0 && f2 instanceof l.BufferLine && f2.copyCellsFrom(e5, t6, 0, m2, false); t6 < a2; ) e5.setCellFromCodepoint(t6++, 0, 1, u2);
                } else if (this._activeBuffer.x = a2 - 1, 2 === r2) continue;
              }
              if (i4 && this._activeBuffer.x) {
                const e5 = f2.getWidth(this._activeBuffer.x - 1) ? 1 : 2;
                f2.addCodepointToCell(this._activeBuffer.x - e5, s3, r2);
                for (let e6 = r2 - m2; --e6 >= 0; ) f2.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, u2);
              } else if (d2 && (f2.insertCells(this._activeBuffer.x, r2 - m2, this._activeBuffer.getNullCell(u2)), 2 === f2.getWidth(a2 - 1) && f2.setCellFromCodepoint(a2 - 1, _.NULL_CELL_CODE, _.NULL_CELL_WIDTH, u2)), f2.setCellFromCodepoint(this._activeBuffer.x++, s3, r2, u2), r2 > 0) for (; --r2; ) f2.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, u2);
            }
            this._parser.precedingJoinState = v2, this._activeBuffer.x < a2 && i3 - t4 > 0 && 0 === f2.getWidth(this._activeBuffer.x) && !f2.hasContent(this._activeBuffer.x) && f2.setCellFromCodepoint(this._activeBuffer.x, 0, 1, u2), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          registerCsiHandler(e4, t4) {
            return "t" !== e4.final || e4.prefix || e4.intermediates ? this._parser.registerCsiHandler(e4, t4) : this._parser.registerCsiHandler(e4, ((e5) => !w(e5.params[0], this._optionsService.rawOptions.windowOptions) || t4(e5)));
          }
          registerDcsHandler(e4, t4) {
            return this._parser.registerDcsHandler(e4, new m.DcsHandler(t4));
          }
          registerEscHandler(e4, t4) {
            return this._parser.registerEscHandler(e4, t4);
          }
          registerOscHandler(e4, t4) {
            return this._parser.registerOscHandler(e4, new g.OscHandler(t4));
          }
          bell() {
            return this._onRequestBell.fire(), true;
          }
          lineFeed() {
            return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), true;
          }
          carriageReturn() {
            return this._activeBuffer.x = 0, true;
          }
          backspace() {
            if (!this._coreService.decPrivateModes.reverseWraparound) return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, true;
            if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0) this._activeBuffer.x--;
            else if (0 === this._activeBuffer.x && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)?.isWrapped) {
              this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
              const e4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              e4.hasWidth(this._activeBuffer.x) && !e4.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
            }
            return this._restrictCursor(), true;
          }
          tab() {
            if (this._activeBuffer.x >= this._bufferService.cols) return true;
            const e4 = this._activeBuffer.x;
            return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - e4), true;
          }
          shiftOut() {
            return this._charsetService.setgLevel(1), true;
          }
          shiftIn() {
            return this._charsetService.setgLevel(0), true;
          }
          _restrictCursor(e4 = this._bufferService.cols - 1) {
            this._activeBuffer.x = Math.min(e4, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          _setCursor(e4, t4) {
            this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = e4, this._activeBuffer.y = this._activeBuffer.scrollTop + t4) : (this._activeBuffer.x = e4, this._activeBuffer.y = t4), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          _moveCursor(e4, t4) {
            this._restrictCursor(), this._setCursor(this._activeBuffer.x + e4, this._activeBuffer.y + t4);
          }
          cursorUp(e4) {
            const t4 = this._activeBuffer.y - this._activeBuffer.scrollTop;
            return t4 >= 0 ? this._moveCursor(0, -Math.min(t4, e4.params[0] || 1)) : this._moveCursor(0, -(e4.params[0] || 1)), true;
          }
          cursorDown(e4) {
            const t4 = this._activeBuffer.scrollBottom - this._activeBuffer.y;
            return t4 >= 0 ? this._moveCursor(0, Math.min(t4, e4.params[0] || 1)) : this._moveCursor(0, e4.params[0] || 1), true;
          }
          cursorForward(e4) {
            return this._moveCursor(e4.params[0] || 1, 0), true;
          }
          cursorBackward(e4) {
            return this._moveCursor(-(e4.params[0] || 1), 0), true;
          }
          cursorNextLine(e4) {
            return this.cursorDown(e4), this._activeBuffer.x = 0, true;
          }
          cursorPrecedingLine(e4) {
            return this.cursorUp(e4), this._activeBuffer.x = 0, true;
          }
          cursorCharAbsolute(e4) {
            return this._setCursor((e4.params[0] || 1) - 1, this._activeBuffer.y), true;
          }
          cursorPosition(e4) {
            return this._setCursor(e4.length >= 2 ? (e4.params[1] || 1) - 1 : 0, (e4.params[0] || 1) - 1), true;
          }
          charPosAbsolute(e4) {
            return this._setCursor((e4.params[0] || 1) - 1, this._activeBuffer.y), true;
          }
          hPositionRelative(e4) {
            return this._moveCursor(e4.params[0] || 1, 0), true;
          }
          linePosAbsolute(e4) {
            return this._setCursor(this._activeBuffer.x, (e4.params[0] || 1) - 1), true;
          }
          vPositionRelative(e4) {
            return this._moveCursor(0, e4.params[0] || 1), true;
          }
          hVPosition(e4) {
            return this.cursorPosition(e4), true;
          }
          tabClear(e4) {
            const t4 = e4.params[0];
            return 0 === t4 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : 3 === t4 && (this._activeBuffer.tabs = {}), true;
          }
          cursorForwardTab(e4) {
            if (this._activeBuffer.x >= this._bufferService.cols) return true;
            let t4 = e4.params[0] || 1;
            for (; t4--; ) this._activeBuffer.x = this._activeBuffer.nextStop();
            return true;
          }
          cursorBackwardTab(e4) {
            if (this._activeBuffer.x >= this._bufferService.cols) return true;
            let t4 = e4.params[0] || 1;
            for (; t4--; ) this._activeBuffer.x = this._activeBuffer.prevStop();
            return true;
          }
          selectProtected(e4) {
            const t4 = e4.params[0];
            return 1 === t4 && (this._curAttrData.bg |= 536870912), 2 !== t4 && 0 !== t4 || (this._curAttrData.bg &= -536870913), true;
          }
          _eraseInBufferLine(e4, t4, i3, s3 = false, r2 = false) {
            const n2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
            n2.replaceCells(t4, i3, this._activeBuffer.getNullCell(this._eraseAttrData()), r2), s3 && (n2.isWrapped = false);
          }
          _resetBufferLine(e4, t4 = false) {
            const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
            i3 && (i3.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), t4), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + e4), i3.isWrapped = false);
          }
          eraseInDisplay(e4, t4 = false) {
            let i3;
            switch (this._restrictCursor(this._bufferService.cols), e4.params[0]) {
              case 0:
                for (i3 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i3), this._eraseInBufferLine(i3++, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t4); i3 < this._bufferService.rows; i3++) this._resetBufferLine(i3, t4);
                this._dirtyRowTracker.markDirty(i3);
                break;
              case 1:
                for (i3 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i3), this._eraseInBufferLine(i3, 0, this._activeBuffer.x + 1, true, t4), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(i3 + 1).isWrapped = false); i3--; ) this._resetBufferLine(i3, t4);
                this._dirtyRowTracker.markDirty(0);
                break;
              case 2:
                for (i3 = this._bufferService.rows, this._dirtyRowTracker.markDirty(i3 - 1); i3--; ) this._resetBufferLine(i3, t4);
                this._dirtyRowTracker.markDirty(0);
                break;
              case 3:
                const e5 = this._activeBuffer.lines.length - this._bufferService.rows;
                e5 > 0 && (this._activeBuffer.lines.trimStart(e5), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - e5, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - e5, 0), this._onScroll.fire(0));
            }
            return true;
          }
          eraseInLine(e4, t4 = false) {
            switch (this._restrictCursor(this._bufferService.cols), e4.params[0]) {
              case 0:
                this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t4);
                break;
              case 1:
                this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, false, t4);
                break;
              case 2:
                this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, true, t4);
            }
            return this._dirtyRowTracker.markDirty(this._activeBuffer.y), true;
          }
          insertLines(e4) {
            this._restrictCursor();
            let t4 = e4.params[0] || 1;
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
            const i3 = this._activeBuffer.ybase + this._activeBuffer.y, s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, r2 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3 + 1;
            for (; t4--; ) this._activeBuffer.lines.splice(r2 - 1, 1), this._activeBuffer.lines.splice(i3, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
          }
          deleteLines(e4) {
            this._restrictCursor();
            let t4 = e4.params[0] || 1;
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
            const i3 = this._activeBuffer.ybase + this._activeBuffer.y;
            let s3;
            for (s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, s3 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3; t4--; ) this._activeBuffer.lines.splice(i3, 1), this._activeBuffer.lines.splice(s3, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
          }
          insertChars(e4) {
            this._restrictCursor();
            const t4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return t4 && (t4.insertCells(this._activeBuffer.x, e4.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
          }
          deleteChars(e4) {
            this._restrictCursor();
            const t4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return t4 && (t4.deleteCells(this._activeBuffer.x, e4.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
          }
          scrollUp(e4) {
            let t4 = e4.params[0] || 1;
            for (; t4--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          scrollDown(e4) {
            let t4 = e4.params[0] || 1;
            for (; t4--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(l.DEFAULT_ATTR_DATA));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          scrollLeft(e4) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
            const t4 = e4.params[0] || 1;
            for (let e5 = this._activeBuffer.scrollTop; e5 <= this._activeBuffer.scrollBottom; ++e5) {
              const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e5);
              i3.deleteCells(0, t4, this._activeBuffer.getNullCell(this._eraseAttrData())), i3.isWrapped = false;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          scrollRight(e4) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
            const t4 = e4.params[0] || 1;
            for (let e5 = this._activeBuffer.scrollTop; e5 <= this._activeBuffer.scrollBottom; ++e5) {
              const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e5);
              i3.insertCells(0, t4, this._activeBuffer.getNullCell(this._eraseAttrData())), i3.isWrapped = false;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          insertColumns(e4) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
            const t4 = e4.params[0] || 1;
            for (let e5 = this._activeBuffer.scrollTop; e5 <= this._activeBuffer.scrollBottom; ++e5) {
              const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e5);
              i3.insertCells(this._activeBuffer.x, t4, this._activeBuffer.getNullCell(this._eraseAttrData())), i3.isWrapped = false;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          deleteColumns(e4) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
            const t4 = e4.params[0] || 1;
            for (let e5 = this._activeBuffer.scrollTop; e5 <= this._activeBuffer.scrollBottom; ++e5) {
              const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e5);
              i3.deleteCells(this._activeBuffer.x, t4, this._activeBuffer.getNullCell(this._eraseAttrData())), i3.isWrapped = false;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          eraseChars(e4) {
            this._restrictCursor();
            const t4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return t4 && (t4.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (e4.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
          }
          repeatPrecedingCharacter(e4) {
            const t4 = this._parser.precedingJoinState;
            if (!t4) return true;
            const i3 = e4.params[0] || 1, s3 = p.UnicodeService.extractWidth(t4), r2 = this._activeBuffer.x - s3, n2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).getString(r2), o2 = new Uint32Array(n2.length * i3);
            let a2 = 0;
            for (let e5 = 0; e5 < n2.length; ) {
              const t5 = n2.codePointAt(e5) || 0;
              o2[a2++] = t5, e5 += t5 > 65535 ? 2 : 1;
            }
            let h2 = a2;
            for (let e5 = 1; e5 < i3; ++e5) o2.copyWithin(h2, 0, a2), h2 += a2;
            return this.print(o2, 0, h2), true;
          }
          sendDeviceAttributesPrimary(e4) {
            return e4.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(n.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(n.C0.ESC + "[?6c")), true;
          }
          sendDeviceAttributesSecondary(e4) {
            return e4.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(e4.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(n.C0.ESC + "[>83;40003;0c")), true;
          }
          _is(e4) {
            return 0 === (this._optionsService.rawOptions.termName + "").indexOf(e4);
          }
          setMode(e4) {
            for (let t4 = 0; t4 < e4.length; t4++) switch (e4.params[t4]) {
              case 4:
                this._coreService.modes.insertMode = true;
                break;
              case 20:
                this._optionsService.options.convertEol = true;
            }
            return true;
          }
          setModePrivate(e4) {
            for (let t4 = 0; t4 < e4.length; t4++) switch (e4.params[t4]) {
              case 1:
                this._coreService.decPrivateModes.applicationCursorKeys = true;
                break;
              case 2:
                this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), this._charsetService.setgCharset(1, o.DEFAULT_CHARSET), this._charsetService.setgCharset(2, o.DEFAULT_CHARSET), this._charsetService.setgCharset(3, o.DEFAULT_CHARSET);
                break;
              case 3:
                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
                break;
              case 6:
                this._coreService.decPrivateModes.origin = true, this._setCursor(0, 0);
                break;
              case 7:
                this._coreService.decPrivateModes.wraparound = true;
                break;
              case 12:
                this._optionsService.options.cursorBlink = true;
                break;
              case 45:
                this._coreService.decPrivateModes.reverseWraparound = true;
                break;
              case 66:
                this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire();
                break;
              case 9:
                this._coreMouseService.activeProtocol = "X10";
                break;
              case 1e3:
                this._coreMouseService.activeProtocol = "VT200";
                break;
              case 1002:
                this._coreMouseService.activeProtocol = "DRAG";
                break;
              case 1003:
                this._coreMouseService.activeProtocol = "ANY";
                break;
              case 1004:
                this._coreService.decPrivateModes.sendFocus = true, this._onRequestSendFocus.fire();
                break;
              case 1005:
                this._logService.debug("DECSET 1005 not supported (see #2507)");
                break;
              case 1006:
                this._coreMouseService.activeEncoding = "SGR";
                break;
              case 1015:
                this._logService.debug("DECSET 1015 not supported (see #2507)");
                break;
              case 1016:
                this._coreMouseService.activeEncoding = "SGR_PIXELS";
                break;
              case 25:
                this._coreService.isCursorHidden = false;
                break;
              case 1048:
                this.saveCursor();
                break;
              case 1049:
                this.saveCursor();
              case 47:
              case 1047:
                this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                break;
              case 2004:
                this._coreService.decPrivateModes.bracketedPasteMode = true;
            }
            return true;
          }
          resetMode(e4) {
            for (let t4 = 0; t4 < e4.length; t4++) switch (e4.params[t4]) {
              case 4:
                this._coreService.modes.insertMode = false;
                break;
              case 20:
                this._optionsService.options.convertEol = false;
            }
            return true;
          }
          resetModePrivate(e4) {
            for (let t4 = 0; t4 < e4.length; t4++) switch (e4.params[t4]) {
              case 1:
                this._coreService.decPrivateModes.applicationCursorKeys = false;
                break;
              case 3:
                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
                break;
              case 6:
                this._coreService.decPrivateModes.origin = false, this._setCursor(0, 0);
                break;
              case 7:
                this._coreService.decPrivateModes.wraparound = false;
                break;
              case 12:
                this._optionsService.options.cursorBlink = false;
                break;
              case 45:
                this._coreService.decPrivateModes.reverseWraparound = false;
                break;
              case 66:
                this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire();
                break;
              case 9:
              case 1e3:
              case 1002:
              case 1003:
                this._coreMouseService.activeProtocol = "NONE";
                break;
              case 1004:
                this._coreService.decPrivateModes.sendFocus = false;
                break;
              case 1005:
                this._logService.debug("DECRST 1005 not supported (see #2507)");
                break;
              case 1006:
              case 1016:
                this._coreMouseService.activeEncoding = "DEFAULT";
                break;
              case 1015:
                this._logService.debug("DECRST 1015 not supported (see #2507)");
                break;
              case 25:
                this._coreService.isCursorHidden = true;
                break;
              case 1048:
                this.restoreCursor();
                break;
              case 1049:
              case 47:
              case 1047:
                this._bufferService.buffers.activateNormalBuffer(), 1049 === e4.params[t4] && this.restoreCursor(), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                break;
              case 2004:
                this._coreService.decPrivateModes.bracketedPasteMode = false;
            }
            return true;
          }
          requestMode(e4, t4) {
            const i3 = this._coreService.decPrivateModes, { activeProtocol: s3, activeEncoding: r2 } = this._coreMouseService, o2 = this._coreService, { buffers: a2, cols: h2 } = this._bufferService, { active: c2, alt: l2 } = a2, d2 = this._optionsService.rawOptions, _2 = /* @__PURE__ */ __name((e5) => e5 ? 1 : 2, "_"), u2 = e4.params[0];
            return f2 = u2, v2 = t4 ? 2 === u2 ? 4 : 4 === u2 ? _2(o2.modes.insertMode) : 12 === u2 ? 3 : 20 === u2 ? _2(d2.convertEol) : 0 : 1 === u2 ? _2(i3.applicationCursorKeys) : 3 === u2 ? d2.windowOptions.setWinLines ? 80 === h2 ? 2 : 132 === h2 ? 1 : 0 : 0 : 6 === u2 ? _2(i3.origin) : 7 === u2 ? _2(i3.wraparound) : 8 === u2 ? 3 : 9 === u2 ? _2("X10" === s3) : 12 === u2 ? _2(d2.cursorBlink) : 25 === u2 ? _2(!o2.isCursorHidden) : 45 === u2 ? _2(i3.reverseWraparound) : 66 === u2 ? _2(i3.applicationKeypad) : 67 === u2 ? 4 : 1e3 === u2 ? _2("VT200" === s3) : 1002 === u2 ? _2("DRAG" === s3) : 1003 === u2 ? _2("ANY" === s3) : 1004 === u2 ? _2(i3.sendFocus) : 1005 === u2 ? 4 : 1006 === u2 ? _2("SGR" === r2) : 1015 === u2 ? 4 : 1016 === u2 ? _2("SGR_PIXELS" === r2) : 1048 === u2 ? 1 : 47 === u2 || 1047 === u2 || 1049 === u2 ? _2(c2 === l2) : 2004 === u2 ? _2(i3.bracketedPasteMode) : 0, o2.triggerDataEvent(`${n.C0.ESC}[${t4 ? "" : "?"}${f2};${v2}$y`), true;
            var f2, v2;
          }
          _updateAttrColor(e4, t4, i3, s3, r2) {
            return 2 === t4 ? (e4 |= 50331648, e4 &= -16777216, e4 |= f.AttributeData.fromColorRGB([i3, s3, r2])) : 5 === t4 && (e4 &= -50331904, e4 |= 33554432 | 255 & i3), e4;
          }
          _extractColor(e4, t4, i3) {
            const s3 = [0, 0, -1, 0, 0, 0];
            let r2 = 0, n2 = 0;
            do {
              if (s3[n2 + r2] = e4.params[t4 + n2], e4.hasSubParams(t4 + n2)) {
                const i4 = e4.getSubParams(t4 + n2);
                let o2 = 0;
                do {
                  5 === s3[1] && (r2 = 1), s3[n2 + o2 + 1 + r2] = i4[o2];
                } while (++o2 < i4.length && o2 + n2 + 1 + r2 < s3.length);
                break;
              }
              if (5 === s3[1] && n2 + r2 >= 2 || 2 === s3[1] && n2 + r2 >= 5) break;
              s3[1] && (r2 = 1);
            } while (++n2 + t4 < e4.length && n2 + r2 < s3.length);
            for (let e5 = 2; e5 < s3.length; ++e5) -1 === s3[e5] && (s3[e5] = 0);
            switch (s3[0]) {
              case 38:
                i3.fg = this._updateAttrColor(i3.fg, s3[1], s3[3], s3[4], s3[5]);
                break;
              case 48:
                i3.bg = this._updateAttrColor(i3.bg, s3[1], s3[3], s3[4], s3[5]);
                break;
              case 58:
                i3.extended = i3.extended.clone(), i3.extended.underlineColor = this._updateAttrColor(i3.extended.underlineColor, s3[1], s3[3], s3[4], s3[5]);
            }
            return n2;
          }
          _processUnderline(e4, t4) {
            t4.extended = t4.extended.clone(), (!~e4 || e4 > 5) && (e4 = 1), t4.extended.underlineStyle = e4, t4.fg |= 268435456, 0 === e4 && (t4.fg &= -268435457), t4.updateExtended();
          }
          _processSGR0(e4) {
            e4.fg = l.DEFAULT_ATTR_DATA.fg, e4.bg = l.DEFAULT_ATTR_DATA.bg, e4.extended = e4.extended.clone(), e4.extended.underlineStyle = 0, e4.extended.underlineColor &= -67108864, e4.updateExtended();
          }
          charAttributes(e4) {
            if (1 === e4.length && 0 === e4.params[0]) return this._processSGR0(this._curAttrData), true;
            const t4 = e4.length;
            let i3;
            const s3 = this._curAttrData;
            for (let r2 = 0; r2 < t4; r2++) i3 = e4.params[r2], i3 >= 30 && i3 <= 37 ? (s3.fg &= -50331904, s3.fg |= 16777216 | i3 - 30) : i3 >= 40 && i3 <= 47 ? (s3.bg &= -50331904, s3.bg |= 16777216 | i3 - 40) : i3 >= 90 && i3 <= 97 ? (s3.fg &= -50331904, s3.fg |= 16777224 | i3 - 90) : i3 >= 100 && i3 <= 107 ? (s3.bg &= -50331904, s3.bg |= 16777224 | i3 - 100) : 0 === i3 ? this._processSGR0(s3) : 1 === i3 ? s3.fg |= 134217728 : 3 === i3 ? s3.bg |= 67108864 : 4 === i3 ? (s3.fg |= 268435456, this._processUnderline(e4.hasSubParams(r2) ? e4.getSubParams(r2)[0] : 1, s3)) : 5 === i3 ? s3.fg |= 536870912 : 7 === i3 ? s3.fg |= 67108864 : 8 === i3 ? s3.fg |= 1073741824 : 9 === i3 ? s3.fg |= 2147483648 : 2 === i3 ? s3.bg |= 134217728 : 21 === i3 ? this._processUnderline(2, s3) : 22 === i3 ? (s3.fg &= -134217729, s3.bg &= -134217729) : 23 === i3 ? s3.bg &= -67108865 : 24 === i3 ? (s3.fg &= -268435457, this._processUnderline(0, s3)) : 25 === i3 ? s3.fg &= -536870913 : 27 === i3 ? s3.fg &= -67108865 : 28 === i3 ? s3.fg &= -1073741825 : 29 === i3 ? s3.fg &= 2147483647 : 39 === i3 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg) : 49 === i3 ? (s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : 38 === i3 || 48 === i3 || 58 === i3 ? r2 += this._extractColor(e4, r2, s3) : 53 === i3 ? s3.bg |= 1073741824 : 55 === i3 ? s3.bg &= -1073741825 : 59 === i3 ? (s3.extended = s3.extended.clone(), s3.extended.underlineColor = -1, s3.updateExtended()) : 100 === i3 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg, s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", i3);
            return true;
          }
          deviceStatus(e4) {
            switch (e4.params[0]) {
              case 5:
                this._coreService.triggerDataEvent(`${n.C0.ESC}[0n`);
                break;
              case 6:
                const e5 = this._activeBuffer.y + 1, t4 = this._activeBuffer.x + 1;
                this._coreService.triggerDataEvent(`${n.C0.ESC}[${e5};${t4}R`);
            }
            return true;
          }
          deviceStatusPrivate(e4) {
            if (6 === e4.params[0]) {
              const e5 = this._activeBuffer.y + 1, t4 = this._activeBuffer.x + 1;
              this._coreService.triggerDataEvent(`${n.C0.ESC}[?${e5};${t4}R`);
            }
            return true;
          }
          softReset(e4) {
            return this._coreService.isCursorHidden = false, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = false, true;
          }
          setCursorStyle(e4) {
            const t4 = e4.params[0] || 1;
            switch (t4) {
              case 1:
              case 2:
                this._optionsService.options.cursorStyle = "block";
                break;
              case 3:
              case 4:
                this._optionsService.options.cursorStyle = "underline";
                break;
              case 5:
              case 6:
                this._optionsService.options.cursorStyle = "bar";
            }
            const i3 = t4 % 2 == 1;
            return this._optionsService.options.cursorBlink = i3, true;
          }
          setScrollRegion(e4) {
            const t4 = e4.params[0] || 1;
            let i3;
            return (e4.length < 2 || (i3 = e4.params[1]) > this._bufferService.rows || 0 === i3) && (i3 = this._bufferService.rows), i3 > t4 && (this._activeBuffer.scrollTop = t4 - 1, this._activeBuffer.scrollBottom = i3 - 1, this._setCursor(0, 0)), true;
          }
          windowOptions(e4) {
            if (!w(e4.params[0], this._optionsService.rawOptions.windowOptions)) return true;
            const t4 = e4.length > 1 ? e4.params[1] : 0;
            switch (e4.params[0]) {
              case 14:
                2 !== t4 && this._onRequestWindowsOptionsReport.fire(y.GET_WIN_SIZE_PIXELS);
                break;
              case 16:
                this._onRequestWindowsOptionsReport.fire(y.GET_CELL_SIZE_PIXELS);
                break;
              case 18:
                this._bufferService && this._coreService.triggerDataEvent(`${n.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
                break;
              case 22:
                0 !== t4 && 2 !== t4 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), 0 !== t4 && 1 !== t4 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
                break;
              case 23:
                0 !== t4 && 2 !== t4 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), 0 !== t4 && 1 !== t4 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
            }
            return true;
          }
          saveCursor(e4) {
            return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, true;
          }
          restoreCursor(e4) {
            return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), true;
          }
          setTitle(e4) {
            return this._windowTitle = e4, this._onTitleChange.fire(e4), true;
          }
          setIconName(e4) {
            return this._iconName = e4, true;
          }
          setOrReportIndexedColor(e4) {
            const t4 = [], i3 = e4.split(";");
            for (; i3.length > 1; ) {
              const e5 = i3.shift(), s3 = i3.shift();
              if (/^\d+$/.exec(e5)) {
                const i4 = parseInt(e5);
                if (D(i4)) if ("?" === s3) t4.push({ type: 0, index: i4 });
                else {
                  const e6 = (0, S.parseColor)(s3);
                  e6 && t4.push({ type: 1, index: i4, color: e6 });
                }
              }
            }
            return t4.length && this._onColor.fire(t4), true;
          }
          setHyperlink(e4) {
            const t4 = e4.split(";");
            return !(t4.length < 2) && (t4[1] ? this._createHyperlink(t4[0], t4[1]) : !t4[0] && this._finishHyperlink());
          }
          _createHyperlink(e4, t4) {
            this._getCurrentLinkId() && this._finishHyperlink();
            const i3 = e4.split(":");
            let s3;
            const r2 = i3.findIndex(((e5) => e5.startsWith("id=")));
            return -1 !== r2 && (s3 = i3[r2].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: s3, uri: t4 }), this._curAttrData.updateExtended(), true;
          }
          _finishHyperlink() {
            return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), true;
          }
          _setOrReportSpecialColor(e4, t4) {
            const i3 = e4.split(";");
            for (let e5 = 0; e5 < i3.length && !(t4 >= this._specialColors.length); ++e5, ++t4) if ("?" === i3[e5]) this._onColor.fire([{ type: 0, index: this._specialColors[t4] }]);
            else {
              const s3 = (0, S.parseColor)(i3[e5]);
              s3 && this._onColor.fire([{ type: 1, index: this._specialColors[t4], color: s3 }]);
            }
            return true;
          }
          setOrReportFgColor(e4) {
            return this._setOrReportSpecialColor(e4, 0);
          }
          setOrReportBgColor(e4) {
            return this._setOrReportSpecialColor(e4, 1);
          }
          setOrReportCursorColor(e4) {
            return this._setOrReportSpecialColor(e4, 2);
          }
          restoreIndexedColor(e4) {
            if (!e4) return this._onColor.fire([{ type: 2 }]), true;
            const t4 = [], i3 = e4.split(";");
            for (let e5 = 0; e5 < i3.length; ++e5) if (/^\d+$/.exec(i3[e5])) {
              const s3 = parseInt(i3[e5]);
              D(s3) && t4.push({ type: 2, index: s3 });
            }
            return t4.length && this._onColor.fire(t4), true;
          }
          restoreFgColor(e4) {
            return this._onColor.fire([{ type: 2, index: 256 }]), true;
          }
          restoreBgColor(e4) {
            return this._onColor.fire([{ type: 2, index: 257 }]), true;
          }
          restoreCursorColor(e4) {
            return this._onColor.fire([{ type: 2, index: 258 }]), true;
          }
          nextLine() {
            return this._activeBuffer.x = 0, this.index(), true;
          }
          keypadApplicationMode() {
            return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire(), true;
          }
          keypadNumericMode() {
            return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire(), true;
          }
          selectDefaultCharset() {
            return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), true;
          }
          selectCharset(e4) {
            return 2 !== e4.length ? (this.selectDefaultCharset(), true) : ("/" === e4[0] || this._charsetService.setgCharset(C[e4[0]], o.CHARSETS[e4[1]] || o.DEFAULT_CHARSET), true);
          }
          index() {
            return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), true;
          }
          tabSet() {
            return this._activeBuffer.tabs[this._activeBuffer.x] = true, true;
          }
          reverseIndex() {
            if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
              const e4 = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
              this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, e4, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
            } else this._activeBuffer.y--, this._restrictCursor();
            return true;
          }
          fullReset() {
            return this._parser.reset(), this._onRequestReset.fire(), true;
          }
          reset() {
            this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone();
          }
          _eraseAttrData() {
            return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
          }
          setgLevel(e4) {
            return this._charsetService.setgLevel(e4), true;
          }
          screenAlignmentPattern() {
            const e4 = new u.CellData();
            e4.content = 1 << 22 | "E".charCodeAt(0), e4.fg = this._curAttrData.fg, e4.bg = this._curAttrData.bg, this._setCursor(0, 0);
            for (let t4 = 0; t4 < this._bufferService.rows; ++t4) {
              const i3 = this._activeBuffer.ybase + this._activeBuffer.y + t4, s3 = this._activeBuffer.lines.get(i3);
              s3 && (s3.fill(e4), s3.isWrapped = false);
            }
            return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), true;
          }
          requestStatusString(e4, t4) {
            const i3 = this._bufferService.buffer, s3 = this._optionsService.rawOptions;
            return ((e5) => (this._coreService.triggerDataEvent(`${n.C0.ESC}${e5}${n.C0.ESC}\\`), true))('"q' === e4 ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : '"p' === e4 ? 'P1$r61;1"p' : "r" === e4 ? `P1$r${i3.scrollTop + 1};${i3.scrollBottom + 1}r` : "m" === e4 ? "P1$r0m" : " q" === e4 ? `P1$r${{ block: 2, underline: 4, bar: 6 }[s3.cursorStyle] - (s3.cursorBlink ? 1 : 0)} q` : "P0$r");
          }
          markRangeDirty(e4, t4) {
            this._dirtyRowTracker.markRangeDirty(e4, t4);
          }
        };
        __name(_k, "k");
        let k = _k;
        t3.InputHandler = k;
        let L = (_a2 = class {
          constructor(e4) {
            this._bufferService = e4, this.clearRange();
          }
          clearRange() {
            this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
          }
          markDirty(e4) {
            e4 < this.start ? this.start = e4 : e4 > this.end && (this.end = e4);
          }
          markRangeDirty(e4, t4) {
            e4 > t4 && (E = e4, e4 = t4, t4 = E), e4 < this.start && (this.start = e4), t4 > this.end && (this.end = t4);
          }
          markAllDirty() {
            this.markRangeDirty(0, this._bufferService.rows - 1);
          }
        }, __name(_a2, "L"), _a2);
        function D(e4) {
          return 0 <= e4 && e4 < 256;
        }
        __name(D, "D");
        L = s2([r(0, v.IBufferService)], L);
      }, 844: (e3, t3) => {
        function i2(e4) {
          for (const t4 of e4) t4.dispose();
          e4.length = 0;
        }
        __name(i2, "i");
        Object.defineProperty(t3, "__esModule", { value: true }), t3.getDisposeArrayDisposable = t3.disposeArray = t3.toDisposable = t3.MutableDisposable = t3.Disposable = void 0, t3.Disposable = class {
          constructor() {
            this._disposables = [], this._isDisposed = false;
          }
          dispose() {
            this._isDisposed = true;
            for (const e4 of this._disposables) e4.dispose();
            this._disposables.length = 0;
          }
          register(e4) {
            return this._disposables.push(e4), e4;
          }
          unregister(e4) {
            const t4 = this._disposables.indexOf(e4);
            -1 !== t4 && this._disposables.splice(t4, 1);
          }
        }, t3.MutableDisposable = class {
          constructor() {
            this._isDisposed = false;
          }
          get value() {
            return this._isDisposed ? void 0 : this._value;
          }
          set value(e4) {
            this._isDisposed || e4 === this._value || (this._value?.dispose(), this._value = e4);
          }
          clear() {
            this.value = void 0;
          }
          dispose() {
            this._isDisposed = true, this._value?.dispose(), this._value = void 0;
          }
        }, t3.toDisposable = function(e4) {
          return { dispose: e4 };
        }, t3.disposeArray = i2, t3.getDisposeArrayDisposable = function(e4) {
          return { dispose: /* @__PURE__ */ __name(() => i2(e4), "dispose") };
        };
      }, 1505: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.FourKeyMap = t3.TwoKeyMap = void 0;
        const _i = class _i {
          constructor() {
            this._data = {};
          }
          set(e4, t4, i3) {
            this._data[e4] || (this._data[e4] = {}), this._data[e4][t4] = i3;
          }
          get(e4, t4) {
            return this._data[e4] ? this._data[e4][t4] : void 0;
          }
          clear() {
            this._data = {};
          }
        };
        __name(_i, "i");
        let i2 = _i;
        t3.TwoKeyMap = i2, t3.FourKeyMap = class {
          constructor() {
            this._data = new i2();
          }
          set(e4, t4, s2, r, n) {
            this._data.get(e4, t4) || this._data.set(e4, t4, new i2()), this._data.get(e4, t4).set(s2, r, n);
          }
          get(e4, t4, i3, s2) {
            return this._data.get(e4, t4)?.get(i3, s2);
          }
          clear() {
            this._data.clear();
          }
        };
      }, 6114: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.isChromeOS = t3.isLinux = t3.isWindows = t3.isIphone = t3.isIpad = t3.isMac = t3.getSafariVersion = t3.isSafari = t3.isLegacyEdge = t3.isFirefox = t3.isNode = void 0, t3.isNode = "undefined" != typeof process$1 && "title" in process$1;
        const i2 = t3.isNode ? "node" : navigator.userAgent, s2 = t3.isNode ? "node" : navigator.platform;
        t3.isFirefox = i2.includes("Firefox"), t3.isLegacyEdge = i2.includes("Edge"), t3.isSafari = /^((?!chrome|android).)*safari/i.test(i2), t3.getSafariVersion = function() {
          if (!t3.isSafari) return 0;
          const e4 = i2.match(/Version\/(\d+)/);
          return null === e4 || e4.length < 2 ? 0 : parseInt(e4[1]);
        }, t3.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(s2), t3.isIpad = "iPad" === s2, t3.isIphone = "iPhone" === s2, t3.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(s2), t3.isLinux = s2.indexOf("Linux") >= 0, t3.isChromeOS = /\bCrOS\b/.test(i2);
      }, 6106: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.SortedList = void 0;
        let i2 = 0;
        t3.SortedList = class {
          constructor(e4) {
            this._getKey = e4, this._array = [];
          }
          clear() {
            this._array.length = 0;
          }
          insert(e4) {
            0 !== this._array.length ? (i2 = this._search(this._getKey(e4)), this._array.splice(i2, 0, e4)) : this._array.push(e4);
          }
          delete(e4) {
            if (0 === this._array.length) return false;
            const t4 = this._getKey(e4);
            if (void 0 === t4) return false;
            if (i2 = this._search(t4), -1 === i2) return false;
            if (this._getKey(this._array[i2]) !== t4) return false;
            do {
              if (this._array[i2] === e4) return this._array.splice(i2, 1), true;
            } while (++i2 < this._array.length && this._getKey(this._array[i2]) === t4);
            return false;
          }
          *getKeyIterator(e4) {
            if (0 !== this._array.length && (i2 = this._search(e4), !(i2 < 0 || i2 >= this._array.length) && this._getKey(this._array[i2]) === e4)) do {
              yield this._array[i2];
            } while (++i2 < this._array.length && this._getKey(this._array[i2]) === e4);
          }
          forEachByKey(e4, t4) {
            if (0 !== this._array.length && (i2 = this._search(e4), !(i2 < 0 || i2 >= this._array.length) && this._getKey(this._array[i2]) === e4)) do {
              t4(this._array[i2]);
            } while (++i2 < this._array.length && this._getKey(this._array[i2]) === e4);
          }
          values() {
            return [...this._array].values();
          }
          _search(e4) {
            let t4 = 0, i3 = this._array.length - 1;
            for (; i3 >= t4; ) {
              let s2 = t4 + i3 >> 1;
              const r = this._getKey(this._array[s2]);
              if (r > e4) i3 = s2 - 1;
              else {
                if (!(r < e4)) {
                  for (; s2 > 0 && this._getKey(this._array[s2 - 1]) === e4; ) s2--;
                  return s2;
                }
                t4 = s2 + 1;
              }
            }
            return t4;
          }
        };
      }, 7226: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.DebouncedIdleTask = t3.IdleTaskQueue = t3.PriorityTaskQueue = void 0;
        const s2 = i2(6114);
        const _r = class _r {
          constructor() {
            this._tasks = [], this._i = 0;
          }
          enqueue(e4) {
            this._tasks.push(e4), this._start();
          }
          flush() {
            for (; this._i < this._tasks.length; ) this._tasks[this._i]() || this._i++;
            this.clear();
          }
          clear() {
            this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
          }
          _start() {
            this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
          }
          _process(e4) {
            this._idleCallback = void 0;
            let t4 = 0, i3 = 0, s3 = e4.timeRemaining(), r2 = 0;
            for (; this._i < this._tasks.length; ) {
              if (t4 = Date.now(), this._tasks[this._i]() || this._i++, t4 = Math.max(1, Date.now() - t4), i3 = Math.max(t4, i3), r2 = e4.timeRemaining(), 1.5 * i3 > r2) return s3 - t4 < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(s3 - t4))}ms`), void this._start();
              s3 = r2;
            }
            this.clear();
          }
        };
        __name(_r, "r");
        let r = _r;
        const _n = class _n extends r {
          _requestCallback(e4) {
            return setTimeout((() => e4(this._createDeadline(16))));
          }
          _cancelCallback(e4) {
            clearTimeout(e4);
          }
          _createDeadline(e4) {
            const t4 = Date.now() + e4;
            return { timeRemaining: /* @__PURE__ */ __name(() => Math.max(0, t4 - Date.now()), "timeRemaining") };
          }
        };
        __name(_n, "n");
        let n = _n;
        t3.PriorityTaskQueue = n, t3.IdleTaskQueue = !s2.isNode && "requestIdleCallback" in window ? class extends r {
          _requestCallback(e4) {
            return requestIdleCallback(e4);
          }
          _cancelCallback(e4) {
            cancelIdleCallback(e4);
          }
        } : n, t3.DebouncedIdleTask = class {
          constructor() {
            this._queue = new t3.IdleTaskQueue();
          }
          set(e4) {
            this._queue.clear(), this._queue.enqueue(e4);
          }
          flush() {
            this._queue.flush();
          }
        };
      }, 9282: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.updateWindowsModeWrappedState = void 0;
        const s2 = i2(643);
        t3.updateWindowsModeWrappedState = function(e4) {
          const t4 = e4.buffer.lines.get(e4.buffer.ybase + e4.buffer.y - 1), i3 = t4?.get(e4.cols - 1), r = e4.buffer.lines.get(e4.buffer.ybase + e4.buffer.y);
          r && i3 && (r.isWrapped = i3[s2.CHAR_DATA_CODE_INDEX] !== s2.NULL_CELL_CODE && i3[s2.CHAR_DATA_CODE_INDEX] !== s2.WHITESPACE_CELL_CODE);
        };
      }, 3734: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.ExtendedAttrs = t3.AttributeData = void 0;
        const _i = class _i {
          constructor() {
            this.fg = 0, this.bg = 0, this.extended = new s2();
          }
          static toColorRGB(e4) {
            return [e4 >>> 16 & 255, e4 >>> 8 & 255, 255 & e4];
          }
          static fromColorRGB(e4) {
            return (255 & e4[0]) << 16 | (255 & e4[1]) << 8 | 255 & e4[2];
          }
          clone() {
            const e4 = new _i();
            return e4.fg = this.fg, e4.bg = this.bg, e4.extended = this.extended.clone(), e4;
          }
          isInverse() {
            return 67108864 & this.fg;
          }
          isBold() {
            return 134217728 & this.fg;
          }
          isUnderline() {
            return this.hasExtendedAttrs() && 0 !== this.extended.underlineStyle ? 1 : 268435456 & this.fg;
          }
          isBlink() {
            return 536870912 & this.fg;
          }
          isInvisible() {
            return 1073741824 & this.fg;
          }
          isItalic() {
            return 67108864 & this.bg;
          }
          isDim() {
            return 134217728 & this.bg;
          }
          isStrikethrough() {
            return 2147483648 & this.fg;
          }
          isProtected() {
            return 536870912 & this.bg;
          }
          isOverline() {
            return 1073741824 & this.bg;
          }
          getFgColorMode() {
            return 50331648 & this.fg;
          }
          getBgColorMode() {
            return 50331648 & this.bg;
          }
          isFgRGB() {
            return 50331648 == (50331648 & this.fg);
          }
          isBgRGB() {
            return 50331648 == (50331648 & this.bg);
          }
          isFgPalette() {
            return 16777216 == (50331648 & this.fg) || 33554432 == (50331648 & this.fg);
          }
          isBgPalette() {
            return 16777216 == (50331648 & this.bg) || 33554432 == (50331648 & this.bg);
          }
          isFgDefault() {
            return 0 == (50331648 & this.fg);
          }
          isBgDefault() {
            return 0 == (50331648 & this.bg);
          }
          isAttributeDefault() {
            return 0 === this.fg && 0 === this.bg;
          }
          getFgColor() {
            switch (50331648 & this.fg) {
              case 16777216:
              case 33554432:
                return 255 & this.fg;
              case 50331648:
                return 16777215 & this.fg;
              default:
                return -1;
            }
          }
          getBgColor() {
            switch (50331648 & this.bg) {
              case 16777216:
              case 33554432:
                return 255 & this.bg;
              case 50331648:
                return 16777215 & this.bg;
              default:
                return -1;
            }
          }
          hasExtendedAttrs() {
            return 268435456 & this.bg;
          }
          updateExtended() {
            this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
          }
          getUnderlineColor() {
            if (268435456 & this.bg && ~this.extended.underlineColor) switch (50331648 & this.extended.underlineColor) {
              case 16777216:
              case 33554432:
                return 255 & this.extended.underlineColor;
              case 50331648:
                return 16777215 & this.extended.underlineColor;
              default:
                return this.getFgColor();
            }
            return this.getFgColor();
          }
          getUnderlineColorMode() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
          }
          isUnderlineColorRGB() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 == (50331648 & this.extended.underlineColor) : this.isFgRGB();
          }
          isUnderlineColorPalette() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 16777216 == (50331648 & this.extended.underlineColor) || 33554432 == (50331648 & this.extended.underlineColor) : this.isFgPalette();
          }
          isUnderlineColorDefault() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 0 == (50331648 & this.extended.underlineColor) : this.isFgDefault();
          }
          getUnderlineStyle() {
            return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
          }
          getUnderlineVariantOffset() {
            return this.extended.underlineVariantOffset;
          }
        };
        __name(_i, "i");
        let i2 = _i;
        t3.AttributeData = i2;
        const _s = class _s {
          get ext() {
            return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
          }
          set ext(e4) {
            this._ext = e4;
          }
          get underlineStyle() {
            return this._urlId ? 5 : (469762048 & this._ext) >> 26;
          }
          set underlineStyle(e4) {
            this._ext &= -469762049, this._ext |= e4 << 26 & 469762048;
          }
          get underlineColor() {
            return 67108863 & this._ext;
          }
          set underlineColor(e4) {
            this._ext &= -67108864, this._ext |= 67108863 & e4;
          }
          get urlId() {
            return this._urlId;
          }
          set urlId(e4) {
            this._urlId = e4;
          }
          get underlineVariantOffset() {
            const e4 = (3758096384 & this._ext) >> 29;
            return e4 < 0 ? 4294967288 ^ e4 : e4;
          }
          set underlineVariantOffset(e4) {
            this._ext &= 536870911, this._ext |= e4 << 29 & 3758096384;
          }
          constructor(e4 = 0, t4 = 0) {
            this._ext = 0, this._urlId = 0, this._ext = e4, this._urlId = t4;
          }
          clone() {
            return new _s(this._ext, this._urlId);
          }
          isEmpty() {
            return 0 === this.underlineStyle && 0 === this._urlId;
          }
        };
        __name(_s, "s");
        let s2 = _s;
        t3.ExtendedAttrs = s2;
      }, 9092: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.Buffer = t3.MAX_BUFFER_SIZE = void 0;
        const s2 = i2(6349), r = i2(7226), n = i2(3734), o = i2(8437), a = i2(4634), h = i2(511), c = i2(643), l = i2(4863), d = i2(7116);
        t3.MAX_BUFFER_SIZE = 4294967295, t3.Buffer = class {
          constructor(e4, t4, i3) {
            this._hasScrollback = e4, this._optionsService = t4, this._bufferService = i3, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = o.DEFAULT_ATTR_DATA.clone(), this.savedCharset = d.DEFAULT_CHARSET, this.markers = [], this._nullCell = h.CellData.fromCharData([0, c.NULL_CELL_CHAR, c.NULL_CELL_WIDTH, c.NULL_CELL_CODE]), this._whitespaceCell = h.CellData.fromCharData([0, c.WHITESPACE_CELL_CHAR, c.WHITESPACE_CELL_WIDTH, c.WHITESPACE_CELL_CODE]), this._isClearing = false, this._memoryCleanupQueue = new r.IdleTaskQueue(), this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
          }
          getNullCell(e4) {
            return e4 ? (this._nullCell.fg = e4.fg, this._nullCell.bg = e4.bg, this._nullCell.extended = e4.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new n.ExtendedAttrs()), this._nullCell;
          }
          getWhitespaceCell(e4) {
            return e4 ? (this._whitespaceCell.fg = e4.fg, this._whitespaceCell.bg = e4.bg, this._whitespaceCell.extended = e4.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new n.ExtendedAttrs()), this._whitespaceCell;
          }
          getBlankLine(e4, t4) {
            return new o.BufferLine(this._bufferService.cols, this.getNullCell(e4), t4);
          }
          get hasScrollback() {
            return this._hasScrollback && this.lines.maxLength > this._rows;
          }
          get isCursorInViewport() {
            const e4 = this.ybase + this.y - this.ydisp;
            return e4 >= 0 && e4 < this._rows;
          }
          _getCorrectBufferLength(e4) {
            if (!this._hasScrollback) return e4;
            const i3 = e4 + this._optionsService.rawOptions.scrollback;
            return i3 > t3.MAX_BUFFER_SIZE ? t3.MAX_BUFFER_SIZE : i3;
          }
          fillViewportRows(e4) {
            if (0 === this.lines.length) {
              void 0 === e4 && (e4 = o.DEFAULT_ATTR_DATA);
              let t4 = this._rows;
              for (; t4--; ) this.lines.push(this.getBlankLine(e4));
            }
          }
          clear() {
            this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
          }
          resize(e4, t4) {
            const i3 = this.getNullCell(o.DEFAULT_ATTR_DATA);
            let s3 = 0;
            const r2 = this._getCorrectBufferLength(t4);
            if (r2 > this.lines.maxLength && (this.lines.maxLength = r2), this.lines.length > 0) {
              if (this._cols < e4) for (let t5 = 0; t5 < this.lines.length; t5++) s3 += +this.lines.get(t5).resize(e4, i3);
              let n2 = 0;
              if (this._rows < t4) for (let s4 = this._rows; s4 < t4; s4++) this.lines.length < t4 + this.ybase && (this._optionsService.rawOptions.windowsMode || void 0 !== this._optionsService.rawOptions.windowsPty.backend || void 0 !== this._optionsService.rawOptions.windowsPty.buildNumber ? this.lines.push(new o.BufferLine(e4, i3)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + n2 + 1 ? (this.ybase--, n2++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new o.BufferLine(e4, i3)));
              else for (let e5 = this._rows; e5 > t4; e5--) this.lines.length > t4 + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
              if (r2 < this.lines.maxLength) {
                const e5 = this.lines.length - r2;
                e5 > 0 && (this.lines.trimStart(e5), this.ybase = Math.max(this.ybase - e5, 0), this.ydisp = Math.max(this.ydisp - e5, 0), this.savedY = Math.max(this.savedY - e5, 0)), this.lines.maxLength = r2;
              }
              this.x = Math.min(this.x, e4 - 1), this.y = Math.min(this.y, t4 - 1), n2 && (this.y += n2), this.savedX = Math.min(this.savedX, e4 - 1), this.scrollTop = 0;
            }
            if (this.scrollBottom = t4 - 1, this._isReflowEnabled && (this._reflow(e4, t4), this._cols > e4)) for (let t5 = 0; t5 < this.lines.length; t5++) s3 += +this.lines.get(t5).resize(e4, i3);
            this._cols = e4, this._rows = t4, this._memoryCleanupQueue.clear(), s3 > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue((() => this._batchedMemoryCleanup())));
          }
          _batchedMemoryCleanup() {
            let e4 = true;
            this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, e4 = false);
            let t4 = 0;
            for (; this._memoryCleanupPosition < this.lines.length; ) if (t4 += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), t4 > 100) return true;
            return e4;
          }
          get _isReflowEnabled() {
            const e4 = this._optionsService.rawOptions.windowsPty;
            return e4 && e4.buildNumber ? this._hasScrollback && "conpty" === e4.backend && e4.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
          }
          _reflow(e4, t4) {
            this._cols !== e4 && (e4 > this._cols ? this._reflowLarger(e4, t4) : this._reflowSmaller(e4, t4));
          }
          _reflowLarger(e4, t4) {
            const i3 = (0, a.reflowLargerGetLinesToRemove)(this.lines, this._cols, e4, this.ybase + this.y, this.getNullCell(o.DEFAULT_ATTR_DATA));
            if (i3.length > 0) {
              const s3 = (0, a.reflowLargerCreateNewLayout)(this.lines, i3);
              (0, a.reflowLargerApplyNewLayout)(this.lines, s3.layout), this._reflowLargerAdjustViewport(e4, t4, s3.countRemoved);
            }
          }
          _reflowLargerAdjustViewport(e4, t4, i3) {
            const s3 = this.getNullCell(o.DEFAULT_ATTR_DATA);
            let r2 = i3;
            for (; r2-- > 0; ) 0 === this.ybase ? (this.y > 0 && this.y--, this.lines.length < t4 && this.lines.push(new o.BufferLine(e4, s3))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
            this.savedY = Math.max(this.savedY - i3, 0);
          }
          _reflowSmaller(e4, t4) {
            const i3 = this.getNullCell(o.DEFAULT_ATTR_DATA), s3 = [];
            let r2 = 0;
            for (let n2 = this.lines.length - 1; n2 >= 0; n2--) {
              let h2 = this.lines.get(n2);
              if (!h2 || !h2.isWrapped && h2.getTrimmedLength() <= e4) continue;
              const c2 = [h2];
              for (; h2.isWrapped && n2 > 0; ) h2 = this.lines.get(--n2), c2.unshift(h2);
              const l2 = this.ybase + this.y;
              if (l2 >= n2 && l2 < n2 + c2.length) continue;
              const d2 = c2[c2.length - 1].getTrimmedLength(), _ = (0, a.reflowSmallerGetNewLineLengths)(c2, this._cols, e4), u = _.length - c2.length;
              let f;
              f = 0 === this.ybase && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + u) : Math.max(0, this.lines.length - this.lines.maxLength + u);
              const v = [];
              for (let e5 = 0; e5 < u; e5++) {
                const e6 = this.getBlankLine(o.DEFAULT_ATTR_DATA, true);
                v.push(e6);
              }
              v.length > 0 && (s3.push({ start: n2 + c2.length + r2, newLines: v }), r2 += v.length), c2.push(...v);
              let p = _.length - 1, g = _[p];
              0 === g && (p--, g = _[p]);
              let m = c2.length - u - 1, S = d2;
              for (; m >= 0; ) {
                const e5 = Math.min(S, g);
                if (void 0 === c2[p]) break;
                if (c2[p].copyCellsFrom(c2[m], S - e5, g - e5, e5, true), g -= e5, 0 === g && (p--, g = _[p]), S -= e5, 0 === S) {
                  m--;
                  const e6 = Math.max(m, 0);
                  S = (0, a.getWrappedLineTrimmedLength)(c2, e6, this._cols);
                }
              }
              for (let t5 = 0; t5 < c2.length; t5++) _[t5] < e4 && c2[t5].setCell(_[t5], i3);
              let C = u - f;
              for (; C-- > 0; ) 0 === this.ybase ? this.y < t4 - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + r2) - t4 && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
              this.savedY = Math.min(this.savedY + u, this.ybase + t4 - 1);
            }
            if (s3.length > 0) {
              const e5 = [], t5 = [];
              for (let e6 = 0; e6 < this.lines.length; e6++) t5.push(this.lines.get(e6));
              const i4 = this.lines.length;
              let n2 = i4 - 1, o2 = 0, a2 = s3[o2];
              this.lines.length = Math.min(this.lines.maxLength, this.lines.length + r2);
              let h2 = 0;
              for (let c3 = Math.min(this.lines.maxLength - 1, i4 + r2 - 1); c3 >= 0; c3--) if (a2 && a2.start > n2 + h2) {
                for (let e6 = a2.newLines.length - 1; e6 >= 0; e6--) this.lines.set(c3--, a2.newLines[e6]);
                c3++, e5.push({ index: n2 + 1, amount: a2.newLines.length }), h2 += a2.newLines.length, a2 = s3[++o2];
              } else this.lines.set(c3, t5[n2--]);
              let c2 = 0;
              for (let t6 = e5.length - 1; t6 >= 0; t6--) e5[t6].index += c2, this.lines.onInsertEmitter.fire(e5[t6]), c2 += e5[t6].amount;
              const l2 = Math.max(0, i4 + r2 - this.lines.maxLength);
              l2 > 0 && this.lines.onTrimEmitter.fire(l2);
            }
          }
          translateBufferLineToString(e4, t4, i3 = 0, s3) {
            const r2 = this.lines.get(e4);
            return r2 ? r2.translateToString(t4, i3, s3) : "";
          }
          getWrappedRangeForLine(e4) {
            let t4 = e4, i3 = e4;
            for (; t4 > 0 && this.lines.get(t4).isWrapped; ) t4--;
            for (; i3 + 1 < this.lines.length && this.lines.get(i3 + 1).isWrapped; ) i3++;
            return { first: t4, last: i3 };
          }
          setupTabStops(e4) {
            for (null != e4 ? this.tabs[e4] || (e4 = this.prevStop(e4)) : (this.tabs = {}, e4 = 0); e4 < this._cols; e4 += this._optionsService.rawOptions.tabStopWidth) this.tabs[e4] = true;
          }
          prevStop(e4) {
            for (null == e4 && (e4 = this.x); !this.tabs[--e4] && e4 > 0; ) ;
            return e4 >= this._cols ? this._cols - 1 : e4 < 0 ? 0 : e4;
          }
          nextStop(e4) {
            for (null == e4 && (e4 = this.x); !this.tabs[++e4] && e4 < this._cols; ) ;
            return e4 >= this._cols ? this._cols - 1 : e4 < 0 ? 0 : e4;
          }
          clearMarkers(e4) {
            this._isClearing = true;
            for (let t4 = 0; t4 < this.markers.length; t4++) this.markers[t4].line === e4 && (this.markers[t4].dispose(), this.markers.splice(t4--, 1));
            this._isClearing = false;
          }
          clearAllMarkers() {
            this._isClearing = true;
            for (let e4 = 0; e4 < this.markers.length; e4++) this.markers[e4].dispose(), this.markers.splice(e4--, 1);
            this._isClearing = false;
          }
          addMarker(e4) {
            const t4 = new l.Marker(e4);
            return this.markers.push(t4), t4.register(this.lines.onTrim(((e5) => {
              t4.line -= e5, t4.line < 0 && t4.dispose();
            }))), t4.register(this.lines.onInsert(((e5) => {
              t4.line >= e5.index && (t4.line += e5.amount);
            }))), t4.register(this.lines.onDelete(((e5) => {
              t4.line >= e5.index && t4.line < e5.index + e5.amount && t4.dispose(), t4.line > e5.index && (t4.line -= e5.amount);
            }))), t4.register(t4.onDispose((() => this._removeMarker(t4)))), t4;
          }
          _removeMarker(e4) {
            this._isClearing || this.markers.splice(this.markers.indexOf(e4), 1);
          }
        };
      }, 8437: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.BufferLine = t3.DEFAULT_ATTR_DATA = void 0;
        const s2 = i2(3734), r = i2(511), n = i2(643), o = i2(482);
        t3.DEFAULT_ATTR_DATA = Object.freeze(new s2.AttributeData());
        let a = 0;
        const _h = class _h {
          constructor(e4, t4, i3 = false) {
            this.isWrapped = i3, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * e4);
            const s3 = t4 || r.CellData.fromCharData([0, n.NULL_CELL_CHAR, n.NULL_CELL_WIDTH, n.NULL_CELL_CODE]);
            for (let t5 = 0; t5 < e4; ++t5) this.setCell(t5, s3);
            this.length = e4;
          }
          get(e4) {
            const t4 = this._data[3 * e4 + 0], i3 = 2097151 & t4;
            return [this._data[3 * e4 + 1], 2097152 & t4 ? this._combined[e4] : i3 ? (0, o.stringFromCodePoint)(i3) : "", t4 >> 22, 2097152 & t4 ? this._combined[e4].charCodeAt(this._combined[e4].length - 1) : i3];
          }
          set(e4, t4) {
            this._data[3 * e4 + 1] = t4[n.CHAR_DATA_ATTR_INDEX], t4[n.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[e4] = t4[1], this._data[3 * e4 + 0] = 2097152 | e4 | t4[n.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * e4 + 0] = t4[n.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | t4[n.CHAR_DATA_WIDTH_INDEX] << 22;
          }
          getWidth(e4) {
            return this._data[3 * e4 + 0] >> 22;
          }
          hasWidth(e4) {
            return 12582912 & this._data[3 * e4 + 0];
          }
          getFg(e4) {
            return this._data[3 * e4 + 1];
          }
          getBg(e4) {
            return this._data[3 * e4 + 2];
          }
          hasContent(e4) {
            return 4194303 & this._data[3 * e4 + 0];
          }
          getCodePoint(e4) {
            const t4 = this._data[3 * e4 + 0];
            return 2097152 & t4 ? this._combined[e4].charCodeAt(this._combined[e4].length - 1) : 2097151 & t4;
          }
          isCombined(e4) {
            return 2097152 & this._data[3 * e4 + 0];
          }
          getString(e4) {
            const t4 = this._data[3 * e4 + 0];
            return 2097152 & t4 ? this._combined[e4] : 2097151 & t4 ? (0, o.stringFromCodePoint)(2097151 & t4) : "";
          }
          isProtected(e4) {
            return 536870912 & this._data[3 * e4 + 2];
          }
          loadCell(e4, t4) {
            return a = 3 * e4, t4.content = this._data[a + 0], t4.fg = this._data[a + 1], t4.bg = this._data[a + 2], 2097152 & t4.content && (t4.combinedData = this._combined[e4]), 268435456 & t4.bg && (t4.extended = this._extendedAttrs[e4]), t4;
          }
          setCell(e4, t4) {
            2097152 & t4.content && (this._combined[e4] = t4.combinedData), 268435456 & t4.bg && (this._extendedAttrs[e4] = t4.extended), this._data[3 * e4 + 0] = t4.content, this._data[3 * e4 + 1] = t4.fg, this._data[3 * e4 + 2] = t4.bg;
          }
          setCellFromCodepoint(e4, t4, i3, s3) {
            268435456 & s3.bg && (this._extendedAttrs[e4] = s3.extended), this._data[3 * e4 + 0] = t4 | i3 << 22, this._data[3 * e4 + 1] = s3.fg, this._data[3 * e4 + 2] = s3.bg;
          }
          addCodepointToCell(e4, t4, i3) {
            let s3 = this._data[3 * e4 + 0];
            2097152 & s3 ? this._combined[e4] += (0, o.stringFromCodePoint)(t4) : 2097151 & s3 ? (this._combined[e4] = (0, o.stringFromCodePoint)(2097151 & s3) + (0, o.stringFromCodePoint)(t4), s3 &= -2097152, s3 |= 2097152) : s3 = t4 | 1 << 22, i3 && (s3 &= -12582913, s3 |= i3 << 22), this._data[3 * e4 + 0] = s3;
          }
          insertCells(e4, t4, i3) {
            if ((e4 %= this.length) && 2 === this.getWidth(e4 - 1) && this.setCellFromCodepoint(e4 - 1, 0, 1, i3), t4 < this.length - e4) {
              const s3 = new r.CellData();
              for (let i4 = this.length - e4 - t4 - 1; i4 >= 0; --i4) this.setCell(e4 + t4 + i4, this.loadCell(e4 + i4, s3));
              for (let s4 = 0; s4 < t4; ++s4) this.setCell(e4 + s4, i3);
            } else for (let t5 = e4; t5 < this.length; ++t5) this.setCell(t5, i3);
            2 === this.getWidth(this.length - 1) && this.setCellFromCodepoint(this.length - 1, 0, 1, i3);
          }
          deleteCells(e4, t4, i3) {
            if (e4 %= this.length, t4 < this.length - e4) {
              const s3 = new r.CellData();
              for (let i4 = 0; i4 < this.length - e4 - t4; ++i4) this.setCell(e4 + i4, this.loadCell(e4 + t4 + i4, s3));
              for (let e5 = this.length - t4; e5 < this.length; ++e5) this.setCell(e5, i3);
            } else for (let t5 = e4; t5 < this.length; ++t5) this.setCell(t5, i3);
            e4 && 2 === this.getWidth(e4 - 1) && this.setCellFromCodepoint(e4 - 1, 0, 1, i3), 0 !== this.getWidth(e4) || this.hasContent(e4) || this.setCellFromCodepoint(e4, 0, 1, i3);
          }
          replaceCells(e4, t4, i3, s3 = false) {
            if (s3) for (e4 && 2 === this.getWidth(e4 - 1) && !this.isProtected(e4 - 1) && this.setCellFromCodepoint(e4 - 1, 0, 1, i3), t4 < this.length && 2 === this.getWidth(t4 - 1) && !this.isProtected(t4) && this.setCellFromCodepoint(t4, 0, 1, i3); e4 < t4 && e4 < this.length; ) this.isProtected(e4) || this.setCell(e4, i3), e4++;
            else for (e4 && 2 === this.getWidth(e4 - 1) && this.setCellFromCodepoint(e4 - 1, 0, 1, i3), t4 < this.length && 2 === this.getWidth(t4 - 1) && this.setCellFromCodepoint(t4, 0, 1, i3); e4 < t4 && e4 < this.length; ) this.setCell(e4++, i3);
          }
          resize(e4, t4) {
            if (e4 === this.length) return 4 * this._data.length * 2 < this._data.buffer.byteLength;
            const i3 = 3 * e4;
            if (e4 > this.length) {
              if (this._data.buffer.byteLength >= 4 * i3) this._data = new Uint32Array(this._data.buffer, 0, i3);
              else {
                const e5 = new Uint32Array(i3);
                e5.set(this._data), this._data = e5;
              }
              for (let i4 = this.length; i4 < e4; ++i4) this.setCell(i4, t4);
            } else {
              this._data = this._data.subarray(0, i3);
              const t5 = Object.keys(this._combined);
              for (let i4 = 0; i4 < t5.length; i4++) {
                const s4 = parseInt(t5[i4], 10);
                s4 >= e4 && delete this._combined[s4];
              }
              const s3 = Object.keys(this._extendedAttrs);
              for (let t6 = 0; t6 < s3.length; t6++) {
                const i4 = parseInt(s3[t6], 10);
                i4 >= e4 && delete this._extendedAttrs[i4];
              }
            }
            return this.length = e4, 4 * i3 * 2 < this._data.buffer.byteLength;
          }
          cleanupMemory() {
            if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
              const e4 = new Uint32Array(this._data.length);
              return e4.set(this._data), this._data = e4, 1;
            }
            return 0;
          }
          fill(e4, t4 = false) {
            if (t4) for (let t5 = 0; t5 < this.length; ++t5) this.isProtected(t5) || this.setCell(t5, e4);
            else {
              this._combined = {}, this._extendedAttrs = {};
              for (let t5 = 0; t5 < this.length; ++t5) this.setCell(t5, e4);
            }
          }
          copyFrom(e4) {
            this.length !== e4.length ? this._data = new Uint32Array(e4._data) : this._data.set(e4._data), this.length = e4.length, this._combined = {};
            for (const t4 in e4._combined) this._combined[t4] = e4._combined[t4];
            this._extendedAttrs = {};
            for (const t4 in e4._extendedAttrs) this._extendedAttrs[t4] = e4._extendedAttrs[t4];
            this.isWrapped = e4.isWrapped;
          }
          clone() {
            const e4 = new _h(0);
            e4._data = new Uint32Array(this._data), e4.length = this.length;
            for (const t4 in this._combined) e4._combined[t4] = this._combined[t4];
            for (const t4 in this._extendedAttrs) e4._extendedAttrs[t4] = this._extendedAttrs[t4];
            return e4.isWrapped = this.isWrapped, e4;
          }
          getTrimmedLength() {
            for (let e4 = this.length - 1; e4 >= 0; --e4) if (4194303 & this._data[3 * e4 + 0]) return e4 + (this._data[3 * e4 + 0] >> 22);
            return 0;
          }
          getNoBgTrimmedLength() {
            for (let e4 = this.length - 1; e4 >= 0; --e4) if (4194303 & this._data[3 * e4 + 0] || 50331648 & this._data[3 * e4 + 2]) return e4 + (this._data[3 * e4 + 0] >> 22);
            return 0;
          }
          copyCellsFrom(e4, t4, i3, s3, r2) {
            const n2 = e4._data;
            if (r2) for (let r3 = s3 - 1; r3 >= 0; r3--) {
              for (let e5 = 0; e5 < 3; e5++) this._data[3 * (i3 + r3) + e5] = n2[3 * (t4 + r3) + e5];
              268435456 & n2[3 * (t4 + r3) + 2] && (this._extendedAttrs[i3 + r3] = e4._extendedAttrs[t4 + r3]);
            }
            else for (let r3 = 0; r3 < s3; r3++) {
              for (let e5 = 0; e5 < 3; e5++) this._data[3 * (i3 + r3) + e5] = n2[3 * (t4 + r3) + e5];
              268435456 & n2[3 * (t4 + r3) + 2] && (this._extendedAttrs[i3 + r3] = e4._extendedAttrs[t4 + r3]);
            }
            const o2 = Object.keys(e4._combined);
            for (let s4 = 0; s4 < o2.length; s4++) {
              const r3 = parseInt(o2[s4], 10);
              r3 >= t4 && (this._combined[r3 - t4 + i3] = e4._combined[r3]);
            }
          }
          translateToString(e4, t4, i3, s3) {
            t4 = t4 ?? 0, i3 = i3 ?? this.length, e4 && (i3 = Math.min(i3, this.getTrimmedLength())), s3 && (s3.length = 0);
            let r2 = "";
            for (; t4 < i3; ) {
              const e5 = this._data[3 * t4 + 0], i4 = 2097151 & e5, a2 = 2097152 & e5 ? this._combined[t4] : i4 ? (0, o.stringFromCodePoint)(i4) : n.WHITESPACE_CELL_CHAR;
              if (r2 += a2, s3) for (let e6 = 0; e6 < a2.length; ++e6) s3.push(t4);
              t4 += e5 >> 22 || 1;
            }
            return s3 && s3.push(t4), r2;
          }
        };
        __name(_h, "h");
        let h = _h;
        t3.BufferLine = h;
      }, 4841: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.getRangeLength = void 0, t3.getRangeLength = function(e4, t4) {
          if (e4.start.y > e4.end.y) throw new Error(`Buffer range end (${e4.end.x}, ${e4.end.y}) cannot be before start (${e4.start.x}, ${e4.start.y})`);
          return t4 * (e4.end.y - e4.start.y) + (e4.end.x - e4.start.x + 1);
        };
      }, 4634: (e3, t3) => {
        function i2(e4, t4, i3) {
          if (t4 === e4.length - 1) return e4[t4].getTrimmedLength();
          const s2 = !e4[t4].hasContent(i3 - 1) && 1 === e4[t4].getWidth(i3 - 1), r = 2 === e4[t4 + 1].getWidth(0);
          return s2 && r ? i3 - 1 : i3;
        }
        __name(i2, "i");
        Object.defineProperty(t3, "__esModule", { value: true }), t3.getWrappedLineTrimmedLength = t3.reflowSmallerGetNewLineLengths = t3.reflowLargerApplyNewLayout = t3.reflowLargerCreateNewLayout = t3.reflowLargerGetLinesToRemove = void 0, t3.reflowLargerGetLinesToRemove = function(e4, t4, s2, r, n) {
          const o = [];
          for (let a = 0; a < e4.length - 1; a++) {
            let h = a, c = e4.get(++h);
            if (!c.isWrapped) continue;
            const l = [e4.get(a)];
            for (; h < e4.length && c.isWrapped; ) l.push(c), c = e4.get(++h);
            if (r >= a && r < h) {
              a += l.length - 1;
              continue;
            }
            let d = 0, _ = i2(l, d, t4), u = 1, f = 0;
            for (; u < l.length; ) {
              const e5 = i2(l, u, t4), r2 = e5 - f, o2 = s2 - _, a2 = Math.min(r2, o2);
              l[d].copyCellsFrom(l[u], f, _, a2, false), _ += a2, _ === s2 && (d++, _ = 0), f += a2, f === e5 && (u++, f = 0), 0 === _ && 0 !== d && 2 === l[d - 1].getWidth(s2 - 1) && (l[d].copyCellsFrom(l[d - 1], s2 - 1, _++, 1, false), l[d - 1].setCell(s2 - 1, n));
            }
            l[d].replaceCells(_, s2, n);
            let v = 0;
            for (let e5 = l.length - 1; e5 > 0 && (e5 > d || 0 === l[e5].getTrimmedLength()); e5--) v++;
            v > 0 && (o.push(a + l.length - v), o.push(v)), a += l.length - 1;
          }
          return o;
        }, t3.reflowLargerCreateNewLayout = function(e4, t4) {
          const i3 = [];
          let s2 = 0, r = t4[s2], n = 0;
          for (let o = 0; o < e4.length; o++) if (r === o) {
            const i4 = t4[++s2];
            e4.onDeleteEmitter.fire({ index: o - n, amount: i4 }), o += i4 - 1, n += i4, r = t4[++s2];
          } else i3.push(o);
          return { layout: i3, countRemoved: n };
        }, t3.reflowLargerApplyNewLayout = function(e4, t4) {
          const i3 = [];
          for (let s2 = 0; s2 < t4.length; s2++) i3.push(e4.get(t4[s2]));
          for (let t5 = 0; t5 < i3.length; t5++) e4.set(t5, i3[t5]);
          e4.length = t4.length;
        }, t3.reflowSmallerGetNewLineLengths = function(e4, t4, s2) {
          const r = [], n = e4.map(((s3, r2) => i2(e4, r2, t4))).reduce(((e5, t5) => e5 + t5));
          let o = 0, a = 0, h = 0;
          for (; h < n; ) {
            if (n - h < s2) {
              r.push(n - h);
              break;
            }
            o += s2;
            const c = i2(e4, a, t4);
            o > c && (o -= c, a++);
            const l = 2 === e4[a].getWidth(o - 1);
            l && o--;
            const d = l ? s2 - 1 : s2;
            r.push(d), h += d;
          }
          return r;
        }, t3.getWrappedLineTrimmedLength = i2;
      }, 5295: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.BufferSet = void 0;
        const s2 = i2(8460), r = i2(844), n = i2(9092);
        const _o = class _o extends r.Disposable {
          constructor(e4, t4) {
            super(), this._optionsService = e4, this._bufferService = t4, this._onBufferActivate = this.register(new s2.EventEmitter()), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", (() => this.resize(this._bufferService.cols, this._bufferService.rows)))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", (() => this.setupTabStops())));
          }
          reset() {
            this._normal = new n.Buffer(true, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new n.Buffer(false, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops();
          }
          get alt() {
            return this._alt;
          }
          get active() {
            return this._activeBuffer;
          }
          get normal() {
            return this._normal;
          }
          activateNormalBuffer() {
            this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }));
          }
          activateAltBuffer(e4) {
            this._activeBuffer !== this._alt && (this._alt.fillViewportRows(e4), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal }));
          }
          resize(e4, t4) {
            this._normal.resize(e4, t4), this._alt.resize(e4, t4), this.setupTabStops(e4);
          }
          setupTabStops(e4) {
            this._normal.setupTabStops(e4), this._alt.setupTabStops(e4);
          }
        };
        __name(_o, "o");
        let o = _o;
        t3.BufferSet = o;
      }, 511: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.CellData = void 0;
        const s2 = i2(482), r = i2(643), n = i2(3734);
        const _o = class _o extends n.AttributeData {
          constructor() {
            super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new n.ExtendedAttrs(), this.combinedData = "";
          }
          static fromCharData(e4) {
            const t4 = new _o();
            return t4.setFromCharData(e4), t4;
          }
          isCombined() {
            return 2097152 & this.content;
          }
          getWidth() {
            return this.content >> 22;
          }
          getChars() {
            return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, s2.stringFromCodePoint)(2097151 & this.content) : "";
          }
          getCode() {
            return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
          }
          setFromCharData(e4) {
            this.fg = e4[r.CHAR_DATA_ATTR_INDEX], this.bg = 0;
            let t4 = false;
            if (e4[r.CHAR_DATA_CHAR_INDEX].length > 2) t4 = true;
            else if (2 === e4[r.CHAR_DATA_CHAR_INDEX].length) {
              const i3 = e4[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
              if (55296 <= i3 && i3 <= 56319) {
                const s3 = e4[r.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
                56320 <= s3 && s3 <= 57343 ? this.content = 1024 * (i3 - 55296) + s3 - 56320 + 65536 | e4[r.CHAR_DATA_WIDTH_INDEX] << 22 : t4 = true;
              } else t4 = true;
            } else this.content = e4[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | e4[r.CHAR_DATA_WIDTH_INDEX] << 22;
            t4 && (this.combinedData = e4[r.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | e4[r.CHAR_DATA_WIDTH_INDEX] << 22);
          }
          getAsCharData() {
            return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
          }
        };
        __name(_o, "o");
        let o = _o;
        t3.CellData = o;
      }, 643: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.WHITESPACE_CELL_CODE = t3.WHITESPACE_CELL_WIDTH = t3.WHITESPACE_CELL_CHAR = t3.NULL_CELL_CODE = t3.NULL_CELL_WIDTH = t3.NULL_CELL_CHAR = t3.CHAR_DATA_CODE_INDEX = t3.CHAR_DATA_WIDTH_INDEX = t3.CHAR_DATA_CHAR_INDEX = t3.CHAR_DATA_ATTR_INDEX = t3.DEFAULT_EXT = t3.DEFAULT_ATTR = t3.DEFAULT_COLOR = void 0, t3.DEFAULT_COLOR = 0, t3.DEFAULT_ATTR = 256 | t3.DEFAULT_COLOR << 9, t3.DEFAULT_EXT = 0, t3.CHAR_DATA_ATTR_INDEX = 0, t3.CHAR_DATA_CHAR_INDEX = 1, t3.CHAR_DATA_WIDTH_INDEX = 2, t3.CHAR_DATA_CODE_INDEX = 3, t3.NULL_CELL_CHAR = "", t3.NULL_CELL_WIDTH = 1, t3.NULL_CELL_CODE = 0, t3.WHITESPACE_CELL_CHAR = " ", t3.WHITESPACE_CELL_WIDTH = 1, t3.WHITESPACE_CELL_CODE = 32;
      }, 4863: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.Marker = void 0;
        const s2 = i2(8460), r = i2(844);
        const _n = class _n {
          get id() {
            return this._id;
          }
          constructor(e4) {
            this.line = e4, this.isDisposed = false, this._disposables = [], this._id = _n._nextId++, this._onDispose = this.register(new s2.EventEmitter()), this.onDispose = this._onDispose.event;
          }
          dispose() {
            this.isDisposed || (this.isDisposed = true, this.line = -1, this._onDispose.fire(), (0, r.disposeArray)(this._disposables), this._disposables.length = 0);
          }
          register(e4) {
            return this._disposables.push(e4), e4;
          }
        };
        __name(_n, "n");
        let n = _n;
        t3.Marker = n, n._nextId = 1;
      }, 7116: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.DEFAULT_CHARSET = t3.CHARSETS = void 0, t3.CHARSETS = {}, t3.DEFAULT_CHARSET = t3.CHARSETS.B, t3.CHARSETS[0] = { "`": "◆", a: "▒", b: "␉", c: "␌", d: "␍", e: "␊", f: "°", g: "±", h: "␤", i: "␋", j: "┘", k: "┐", l: "┌", m: "└", n: "┼", o: "⎺", p: "⎻", q: "─", r: "⎼", s: "⎽", t: "├", u: "┤", v: "┴", w: "┬", x: "│", y: "≤", z: "≥", "{": "π", "|": "≠", "}": "£", "~": "·" }, t3.CHARSETS.A = { "#": "£" }, t3.CHARSETS.B = void 0, t3.CHARSETS[4] = { "#": "£", "@": "¾", "[": "ij", "\\": "½", "]": "|", "{": "¨", "|": "f", "}": "¼", "~": "´" }, t3.CHARSETS.C = t3.CHARSETS[5] = { "[": "Ä", "\\": "Ö", "]": "Å", "^": "Ü", "`": "é", "{": "ä", "|": "ö", "}": "å", "~": "ü" }, t3.CHARSETS.R = { "#": "£", "@": "à", "[": "°", "\\": "ç", "]": "§", "{": "é", "|": "ù", "}": "è", "~": "¨" }, t3.CHARSETS.Q = { "@": "à", "[": "â", "\\": "ç", "]": "ê", "^": "î", "`": "ô", "{": "é", "|": "ù", "}": "è", "~": "û" }, t3.CHARSETS.K = { "@": "§", "[": "Ä", "\\": "Ö", "]": "Ü", "{": "ä", "|": "ö", "}": "ü", "~": "ß" }, t3.CHARSETS.Y = { "#": "£", "@": "§", "[": "°", "\\": "ç", "]": "é", "`": "ù", "{": "à", "|": "ò", "}": "è", "~": "ì" }, t3.CHARSETS.E = t3.CHARSETS[6] = { "@": "Ä", "[": "Æ", "\\": "Ø", "]": "Å", "^": "Ü", "`": "ä", "{": "æ", "|": "ø", "}": "å", "~": "ü" }, t3.CHARSETS.Z = { "#": "£", "@": "§", "[": "¡", "\\": "Ñ", "]": "¿", "{": "°", "|": "ñ", "}": "ç" }, t3.CHARSETS.H = t3.CHARSETS[7] = { "@": "É", "[": "Ä", "\\": "Ö", "]": "Å", "^": "Ü", "`": "é", "{": "ä", "|": "ö", "}": "å", "~": "ü" }, t3.CHARSETS["="] = { "#": "ù", "@": "à", "[": "é", "\\": "ç", "]": "ê", "^": "î", _: "è", "`": "ô", "{": "ä", "|": "ö", "}": "ü", "~": "û" };
      }, 2584: (e3, t3) => {
        var i2, s2, r;
        Object.defineProperty(t3, "__esModule", { value: true }), t3.C1_ESCAPED = t3.C1 = t3.C0 = void 0, (function(e4) {
          e4.NUL = "\0", e4.SOH = "", e4.STX = "", e4.ETX = "", e4.EOT = "", e4.ENQ = "", e4.ACK = "", e4.BEL = "\x07", e4.BS = "\b", e4.HT = "	", e4.LF = "\n", e4.VT = "\v", e4.FF = "\f", e4.CR = "\r", e4.SO = "", e4.SI = "", e4.DLE = "", e4.DC1 = "", e4.DC2 = "", e4.DC3 = "", e4.DC4 = "", e4.NAK = "", e4.SYN = "", e4.ETB = "", e4.CAN = "", e4.EM = "", e4.SUB = "", e4.ESC = "\x1B", e4.FS = "", e4.GS = "", e4.RS = "", e4.US = "", e4.SP = " ", e4.DEL = "";
        })(i2 || (t3.C0 = i2 = {})), (function(e4) {
          e4.PAD = "", e4.HOP = "", e4.BPH = "", e4.NBH = "", e4.IND = "", e4.NEL = "", e4.SSA = "", e4.ESA = "", e4.HTS = "", e4.HTJ = "", e4.VTS = "", e4.PLD = "", e4.PLU = "", e4.RI = "", e4.SS2 = "", e4.SS3 = "", e4.DCS = "", e4.PU1 = "", e4.PU2 = "", e4.STS = "", e4.CCH = "", e4.MW = "", e4.SPA = "", e4.EPA = "", e4.SOS = "", e4.SGCI = "", e4.SCI = "", e4.CSI = "", e4.ST = "", e4.OSC = "", e4.PM = "", e4.APC = "";
        })(s2 || (t3.C1 = s2 = {})), (function(e4) {
          e4.ST = `${i2.ESC}\\`;
        })(r || (t3.C1_ESCAPED = r = {}));
      }, 7399: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.evaluateKeyboardEvent = void 0;
        const s2 = i2(2584), r = { 48: ["0", ")"], 49: ["1", "!"], 50: ["2", "@"], 51: ["3", "#"], 52: ["4", "$"], 53: ["5", "%"], 54: ["6", "^"], 55: ["7", "&"], 56: ["8", "*"], 57: ["9", "("], 186: [";", ":"], 187: ["=", "+"], 188: [",", "<"], 189: ["-", "_"], 190: [".", ">"], 191: ["/", "?"], 192: ["`", "~"], 219: ["[", "{"], 220: ["\\", "|"], 221: ["]", "}"], 222: ["'", '"'] };
        t3.evaluateKeyboardEvent = function(e4, t4, i3, n) {
          const o = { type: 0, cancel: false, key: void 0 }, a = (e4.shiftKey ? 1 : 0) | (e4.altKey ? 2 : 0) | (e4.ctrlKey ? 4 : 0) | (e4.metaKey ? 8 : 0);
          switch (e4.keyCode) {
            case 0:
              "UIKeyInputUpArrow" === e4.key ? o.key = t4 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A" : "UIKeyInputLeftArrow" === e4.key ? o.key = t4 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D" : "UIKeyInputRightArrow" === e4.key ? o.key = t4 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C" : "UIKeyInputDownArrow" === e4.key && (o.key = t4 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B");
              break;
            case 8:
              o.key = e4.ctrlKey ? "\b" : s2.C0.DEL, e4.altKey && (o.key = s2.C0.ESC + o.key);
              break;
            case 9:
              if (e4.shiftKey) {
                o.key = s2.C0.ESC + "[Z";
                break;
              }
              o.key = s2.C0.HT, o.cancel = true;
              break;
            case 13:
              o.key = e4.altKey ? s2.C0.ESC + s2.C0.CR : s2.C0.CR, o.cancel = true;
              break;
            case 27:
              o.key = s2.C0.ESC, e4.altKey && (o.key = s2.C0.ESC + s2.C0.ESC), o.cancel = true;
              break;
            case 37:
              if (e4.metaKey) break;
              a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "D", o.key === s2.C0.ESC + "[1;3D" && (o.key = s2.C0.ESC + (i3 ? "b" : "[1;5D"))) : o.key = t4 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D";
              break;
            case 39:
              if (e4.metaKey) break;
              a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "C", o.key === s2.C0.ESC + "[1;3C" && (o.key = s2.C0.ESC + (i3 ? "f" : "[1;5C"))) : o.key = t4 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C";
              break;
            case 38:
              if (e4.metaKey) break;
              a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "A", i3 || o.key !== s2.C0.ESC + "[1;3A" || (o.key = s2.C0.ESC + "[1;5A")) : o.key = t4 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A";
              break;
            case 40:
              if (e4.metaKey) break;
              a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "B", i3 || o.key !== s2.C0.ESC + "[1;3B" || (o.key = s2.C0.ESC + "[1;5B")) : o.key = t4 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B";
              break;
            case 45:
              e4.shiftKey || e4.ctrlKey || (o.key = s2.C0.ESC + "[2~");
              break;
            case 46:
              o.key = a ? s2.C0.ESC + "[3;" + (a + 1) + "~" : s2.C0.ESC + "[3~";
              break;
            case 36:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "H" : t4 ? s2.C0.ESC + "OH" : s2.C0.ESC + "[H";
              break;
            case 35:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "F" : t4 ? s2.C0.ESC + "OF" : s2.C0.ESC + "[F";
              break;
            case 33:
              e4.shiftKey ? o.type = 2 : e4.ctrlKey ? o.key = s2.C0.ESC + "[5;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[5~";
              break;
            case 34:
              e4.shiftKey ? o.type = 3 : e4.ctrlKey ? o.key = s2.C0.ESC + "[6;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[6~";
              break;
            case 112:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "P" : s2.C0.ESC + "OP";
              break;
            case 113:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "Q" : s2.C0.ESC + "OQ";
              break;
            case 114:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "R" : s2.C0.ESC + "OR";
              break;
            case 115:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "S" : s2.C0.ESC + "OS";
              break;
            case 116:
              o.key = a ? s2.C0.ESC + "[15;" + (a + 1) + "~" : s2.C0.ESC + "[15~";
              break;
            case 117:
              o.key = a ? s2.C0.ESC + "[17;" + (a + 1) + "~" : s2.C0.ESC + "[17~";
              break;
            case 118:
              o.key = a ? s2.C0.ESC + "[18;" + (a + 1) + "~" : s2.C0.ESC + "[18~";
              break;
            case 119:
              o.key = a ? s2.C0.ESC + "[19;" + (a + 1) + "~" : s2.C0.ESC + "[19~";
              break;
            case 120:
              o.key = a ? s2.C0.ESC + "[20;" + (a + 1) + "~" : s2.C0.ESC + "[20~";
              break;
            case 121:
              o.key = a ? s2.C0.ESC + "[21;" + (a + 1) + "~" : s2.C0.ESC + "[21~";
              break;
            case 122:
              o.key = a ? s2.C0.ESC + "[23;" + (a + 1) + "~" : s2.C0.ESC + "[23~";
              break;
            case 123:
              o.key = a ? s2.C0.ESC + "[24;" + (a + 1) + "~" : s2.C0.ESC + "[24~";
              break;
            default:
              if (!e4.ctrlKey || e4.shiftKey || e4.altKey || e4.metaKey) if (i3 && !n || !e4.altKey || e4.metaKey) !i3 || e4.altKey || e4.ctrlKey || e4.shiftKey || !e4.metaKey ? e4.key && !e4.ctrlKey && !e4.altKey && !e4.metaKey && e4.keyCode >= 48 && 1 === e4.key.length ? o.key = e4.key : e4.key && e4.ctrlKey && ("_" === e4.key && (o.key = s2.C0.US), "@" === e4.key && (o.key = s2.C0.NUL)) : 65 === e4.keyCode && (o.type = 1);
              else {
                const t5 = r[e4.keyCode], i4 = t5?.[e4.shiftKey ? 1 : 0];
                if (i4) o.key = s2.C0.ESC + i4;
                else if (e4.keyCode >= 65 && e4.keyCode <= 90) {
                  const t6 = e4.ctrlKey ? e4.keyCode - 64 : e4.keyCode + 32;
                  let i5 = String.fromCharCode(t6);
                  e4.shiftKey && (i5 = i5.toUpperCase()), o.key = s2.C0.ESC + i5;
                } else if (32 === e4.keyCode) o.key = s2.C0.ESC + (e4.ctrlKey ? s2.C0.NUL : " ");
                else if ("Dead" === e4.key && e4.code.startsWith("Key")) {
                  let t6 = e4.code.slice(3, 4);
                  e4.shiftKey || (t6 = t6.toLowerCase()), o.key = s2.C0.ESC + t6, o.cancel = true;
                }
              }
              else e4.keyCode >= 65 && e4.keyCode <= 90 ? o.key = String.fromCharCode(e4.keyCode - 64) : 32 === e4.keyCode ? o.key = s2.C0.NUL : e4.keyCode >= 51 && e4.keyCode <= 55 ? o.key = String.fromCharCode(e4.keyCode - 51 + 27) : 56 === e4.keyCode ? o.key = s2.C0.DEL : 219 === e4.keyCode ? o.key = s2.C0.ESC : 220 === e4.keyCode ? o.key = s2.C0.FS : 221 === e4.keyCode && (o.key = s2.C0.GS);
          }
          return o;
        };
      }, 482: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.Utf8ToUtf32 = t3.StringToUtf32 = t3.utf32ToString = t3.stringFromCodePoint = void 0, t3.stringFromCodePoint = function(e4) {
          return e4 > 65535 ? (e4 -= 65536, String.fromCharCode(55296 + (e4 >> 10)) + String.fromCharCode(e4 % 1024 + 56320)) : String.fromCharCode(e4);
        }, t3.utf32ToString = function(e4, t4 = 0, i2 = e4.length) {
          let s2 = "";
          for (let r = t4; r < i2; ++r) {
            let t5 = e4[r];
            t5 > 65535 ? (t5 -= 65536, s2 += String.fromCharCode(55296 + (t5 >> 10)) + String.fromCharCode(t5 % 1024 + 56320)) : s2 += String.fromCharCode(t5);
          }
          return s2;
        }, t3.StringToUtf32 = class {
          constructor() {
            this._interim = 0;
          }
          clear() {
            this._interim = 0;
          }
          decode(e4, t4) {
            const i2 = e4.length;
            if (!i2) return 0;
            let s2 = 0, r = 0;
            if (this._interim) {
              const i3 = e4.charCodeAt(r++);
              56320 <= i3 && i3 <= 57343 ? t4[s2++] = 1024 * (this._interim - 55296) + i3 - 56320 + 65536 : (t4[s2++] = this._interim, t4[s2++] = i3), this._interim = 0;
            }
            for (let n = r; n < i2; ++n) {
              const r2 = e4.charCodeAt(n);
              if (55296 <= r2 && r2 <= 56319) {
                if (++n >= i2) return this._interim = r2, s2;
                const o = e4.charCodeAt(n);
                56320 <= o && o <= 57343 ? t4[s2++] = 1024 * (r2 - 55296) + o - 56320 + 65536 : (t4[s2++] = r2, t4[s2++] = o);
              } else 65279 !== r2 && (t4[s2++] = r2);
            }
            return s2;
          }
        }, t3.Utf8ToUtf32 = class {
          constructor() {
            this.interim = new Uint8Array(3);
          }
          clear() {
            this.interim.fill(0);
          }
          decode(e4, t4) {
            const i2 = e4.length;
            if (!i2) return 0;
            let s2, r, n, o, a = 0, h = 0, c = 0;
            if (this.interim[0]) {
              let s3 = false, r2 = this.interim[0];
              r2 &= 192 == (224 & r2) ? 31 : 224 == (240 & r2) ? 15 : 7;
              let n2, o2 = 0;
              for (; (n2 = 63 & this.interim[++o2]) && o2 < 4; ) r2 <<= 6, r2 |= n2;
              const h2 = 192 == (224 & this.interim[0]) ? 2 : 224 == (240 & this.interim[0]) ? 3 : 4, l2 = h2 - o2;
              for (; c < l2; ) {
                if (c >= i2) return 0;
                if (n2 = e4[c++], 128 != (192 & n2)) {
                  c--, s3 = true;
                  break;
                }
                this.interim[o2++] = n2, r2 <<= 6, r2 |= 63 & n2;
              }
              s3 || (2 === h2 ? r2 < 128 ? c-- : t4[a++] = r2 : 3 === h2 ? r2 < 2048 || r2 >= 55296 && r2 <= 57343 || 65279 === r2 || (t4[a++] = r2) : r2 < 65536 || r2 > 1114111 || (t4[a++] = r2)), this.interim.fill(0);
            }
            const l = i2 - 4;
            let d = c;
            for (; d < i2; ) {
              for (; !(!(d < l) || 128 & (s2 = e4[d]) || 128 & (r = e4[d + 1]) || 128 & (n = e4[d + 2]) || 128 & (o = e4[d + 3])); ) t4[a++] = s2, t4[a++] = r, t4[a++] = n, t4[a++] = o, d += 4;
              if (s2 = e4[d++], s2 < 128) t4[a++] = s2;
              else if (192 == (224 & s2)) {
                if (d >= i2) return this.interim[0] = s2, a;
                if (r = e4[d++], 128 != (192 & r)) {
                  d--;
                  continue;
                }
                if (h = (31 & s2) << 6 | 63 & r, h < 128) {
                  d--;
                  continue;
                }
                t4[a++] = h;
              } else if (224 == (240 & s2)) {
                if (d >= i2) return this.interim[0] = s2, a;
                if (r = e4[d++], 128 != (192 & r)) {
                  d--;
                  continue;
                }
                if (d >= i2) return this.interim[0] = s2, this.interim[1] = r, a;
                if (n = e4[d++], 128 != (192 & n)) {
                  d--;
                  continue;
                }
                if (h = (15 & s2) << 12 | (63 & r) << 6 | 63 & n, h < 2048 || h >= 55296 && h <= 57343 || 65279 === h) continue;
                t4[a++] = h;
              } else if (240 == (248 & s2)) {
                if (d >= i2) return this.interim[0] = s2, a;
                if (r = e4[d++], 128 != (192 & r)) {
                  d--;
                  continue;
                }
                if (d >= i2) return this.interim[0] = s2, this.interim[1] = r, a;
                if (n = e4[d++], 128 != (192 & n)) {
                  d--;
                  continue;
                }
                if (d >= i2) return this.interim[0] = s2, this.interim[1] = r, this.interim[2] = n, a;
                if (o = e4[d++], 128 != (192 & o)) {
                  d--;
                  continue;
                }
                if (h = (7 & s2) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & o, h < 65536 || h > 1114111) continue;
                t4[a++] = h;
              }
            }
            return a;
          }
        };
      }, 225: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.UnicodeV6 = void 0;
        const s2 = i2(1480), r = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], n = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];
        let o;
        t3.UnicodeV6 = class {
          constructor() {
            if (this.version = "6", !o) {
              o = new Uint8Array(65536), o.fill(1), o[0] = 0, o.fill(0, 1, 32), o.fill(0, 127, 160), o.fill(2, 4352, 4448), o[9001] = 2, o[9002] = 2, o.fill(2, 11904, 42192), o[12351] = 1, o.fill(2, 44032, 55204), o.fill(2, 63744, 64256), o.fill(2, 65040, 65050), o.fill(2, 65072, 65136), o.fill(2, 65280, 65377), o.fill(2, 65504, 65511);
              for (let e4 = 0; e4 < r.length; ++e4) o.fill(0, r[e4][0], r[e4][1] + 1);
            }
          }
          wcwidth(e4) {
            return e4 < 32 ? 0 : e4 < 127 ? 1 : e4 < 65536 ? o[e4] : (function(e5, t4) {
              let i3, s3 = 0, r2 = t4.length - 1;
              if (e5 < t4[0][0] || e5 > t4[r2][1]) return false;
              for (; r2 >= s3; ) if (i3 = s3 + r2 >> 1, e5 > t4[i3][1]) s3 = i3 + 1;
              else {
                if (!(e5 < t4[i3][0])) return true;
                r2 = i3 - 1;
              }
              return false;
            })(e4, n) ? 0 : e4 >= 131072 && e4 <= 196605 || e4 >= 196608 && e4 <= 262141 ? 2 : 1;
          }
          charProperties(e4, t4) {
            let i3 = this.wcwidth(e4), r2 = 0 === i3 && 0 !== t4;
            if (r2) {
              const e5 = s2.UnicodeService.extractWidth(t4);
              0 === e5 ? r2 = false : e5 > i3 && (i3 = e5);
            }
            return s2.UnicodeService.createPropertyValue(0, i3, r2);
          }
        };
      }, 5981: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.WriteBuffer = void 0;
        const s2 = i2(8460), r = i2(844);
        const _n = class _n extends r.Disposable {
          constructor(e4) {
            super(), this._action = e4, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = false, this._syncCalls = 0, this._didUserInput = false, this._onWriteParsed = this.register(new s2.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event;
          }
          handleUserInput() {
            this._didUserInput = true;
          }
          writeSync(e4, t4) {
            if (void 0 !== t4 && this._syncCalls > t4) return void (this._syncCalls = 0);
            if (this._pendingData += e4.length, this._writeBuffer.push(e4), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting) return;
            let i3;
            for (this._isSyncWriting = true; i3 = this._writeBuffer.shift(); ) {
              this._action(i3);
              const e5 = this._callbacks.shift();
              e5 && e5();
            }
            this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = false, this._syncCalls = 0;
          }
          write(e4, t4) {
            if (this._pendingData > 5e7) throw new Error("write data discarded, use flow control to avoid losing data");
            if (!this._writeBuffer.length) {
              if (this._bufferOffset = 0, this._didUserInput) return this._didUserInput = false, this._pendingData += e4.length, this._writeBuffer.push(e4), this._callbacks.push(t4), void this._innerWrite();
              setTimeout((() => this._innerWrite()));
            }
            this._pendingData += e4.length, this._writeBuffer.push(e4), this._callbacks.push(t4);
          }
          _innerWrite(e4 = 0, t4 = true) {
            const i3 = e4 || Date.now();
            for (; this._writeBuffer.length > this._bufferOffset; ) {
              const e5 = this._writeBuffer[this._bufferOffset], s3 = this._action(e5, t4);
              if (s3) {
                const e6 = /* @__PURE__ */ __name((e7) => Date.now() - i3 >= 12 ? setTimeout((() => this._innerWrite(0, e7))) : this._innerWrite(i3, e7), "e");
                return void s3.catch(((e7) => (queueMicrotask((() => {
                  throw e7;
                })), Promise.resolve(false)))).then(e6);
              }
              const r2 = this._callbacks[this._bufferOffset];
              if (r2 && r2(), this._bufferOffset++, this._pendingData -= e5.length, Date.now() - i3 >= 12) break;
            }
            this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout((() => this._innerWrite()))) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
          }
        };
        __name(_n, "n");
        let n = _n;
        t3.WriteBuffer = n;
      }, 5941: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.toRgbString = t3.parseColor = void 0;
        const i2 = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, s2 = /^[\da-f]+$/;
        function r(e4, t4) {
          const i3 = e4.toString(16), s3 = i3.length < 2 ? "0" + i3 : i3;
          switch (t4) {
            case 4:
              return i3[0];
            case 8:
              return s3;
            case 12:
              return (s3 + s3).slice(0, 3);
            default:
              return s3 + s3;
          }
        }
        __name(r, "r");
        t3.parseColor = function(e4) {
          if (!e4) return;
          let t4 = e4.toLowerCase();
          if (0 === t4.indexOf("rgb:")) {
            t4 = t4.slice(4);
            const e5 = i2.exec(t4);
            if (e5) {
              const t5 = e5[1] ? 15 : e5[4] ? 255 : e5[7] ? 4095 : 65535;
              return [Math.round(parseInt(e5[1] || e5[4] || e5[7] || e5[10], 16) / t5 * 255), Math.round(parseInt(e5[2] || e5[5] || e5[8] || e5[11], 16) / t5 * 255), Math.round(parseInt(e5[3] || e5[6] || e5[9] || e5[12], 16) / t5 * 255)];
            }
          } else if (0 === t4.indexOf("#") && (t4 = t4.slice(1), s2.exec(t4) && [3, 6, 9, 12].includes(t4.length))) {
            const e5 = t4.length / 3, i3 = [0, 0, 0];
            for (let s3 = 0; s3 < 3; ++s3) {
              const r2 = parseInt(t4.slice(e5 * s3, e5 * s3 + e5), 16);
              i3[s3] = 1 === e5 ? r2 << 4 : 2 === e5 ? r2 : 3 === e5 ? r2 >> 4 : r2 >> 8;
            }
            return i3;
          }
        }, t3.toRgbString = function(e4, t4 = 16) {
          const [i3, s3, n] = e4;
          return `rgb:${r(i3, t4)}/${r(s3, t4)}/${r(n, t4)}`;
        };
      }, 5770: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.PAYLOAD_LIMIT = void 0, t3.PAYLOAD_LIMIT = 1e7;
      }, 6351: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.DcsHandler = t3.DcsParser = void 0;
        const s2 = i2(482), r = i2(8742), n = i2(5770), o = [];
        t3.DcsParser = class {
          constructor() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._active = o, this._ident = 0, this._handlerFb = () => {
            }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
          }
          dispose() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._active = o;
          }
          registerHandler(e4, t4) {
            void 0 === this._handlers[e4] && (this._handlers[e4] = []);
            const i3 = this._handlers[e4];
            return i3.push(t4), { dispose: /* @__PURE__ */ __name(() => {
              const e5 = i3.indexOf(t4);
              -1 !== e5 && i3.splice(e5, 1);
            }, "dispose") };
          }
          clearHandler(e4) {
            this._handlers[e4] && delete this._handlers[e4];
          }
          setHandlerFallback(e4) {
            this._handlerFb = e4;
          }
          reset() {
            if (this._active.length) for (let e4 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e4 >= 0; --e4) this._active[e4].unhook(false);
            this._stack.paused = false, this._active = o, this._ident = 0;
          }
          hook(e4, t4) {
            if (this.reset(), this._ident = e4, this._active = this._handlers[e4] || o, this._active.length) for (let e5 = this._active.length - 1; e5 >= 0; e5--) this._active[e5].hook(t4);
            else this._handlerFb(this._ident, "HOOK", t4);
          }
          put(e4, t4, i3) {
            if (this._active.length) for (let s3 = this._active.length - 1; s3 >= 0; s3--) this._active[s3].put(e4, t4, i3);
            else this._handlerFb(this._ident, "PUT", (0, s2.utf32ToString)(e4, t4, i3));
          }
          unhook(e4, t4 = true) {
            if (this._active.length) {
              let i3 = false, s3 = this._active.length - 1, r2 = false;
              if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i3 = t4, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && false === i3) {
                for (; s3 >= 0 && (i3 = this._active[s3].unhook(e4), true !== i3); s3--) if (i3 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i3;
                s3--;
              }
              for (; s3 >= 0; s3--) if (i3 = this._active[s3].unhook(false), i3 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i3;
            } else this._handlerFb(this._ident, "UNHOOK", e4);
            this._active = o, this._ident = 0;
          }
        };
        const a = new r.Params();
        a.addParam(0), t3.DcsHandler = class {
          constructor(e4) {
            this._handler = e4, this._data = "", this._params = a, this._hitLimit = false;
          }
          hook(e4) {
            this._params = e4.length > 1 || e4.params[0] ? e4.clone() : a, this._data = "", this._hitLimit = false;
          }
          put(e4, t4, i3) {
            this._hitLimit || (this._data += (0, s2.utf32ToString)(e4, t4, i3), this._data.length > n.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
          }
          unhook(e4) {
            let t4 = false;
            if (this._hitLimit) t4 = false;
            else if (e4 && (t4 = this._handler(this._data, this._params), t4 instanceof Promise)) return t4.then(((e5) => (this._params = a, this._data = "", this._hitLimit = false, e5)));
            return this._params = a, this._data = "", this._hitLimit = false, t4;
          }
        };
      }, 2015: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.EscapeSequenceParser = t3.VT500_TRANSITION_TABLE = t3.TransitionTable = void 0;
        const s2 = i2(844), r = i2(8742), n = i2(6242), o = i2(6351);
        const _a2 = class _a2 {
          constructor(e4) {
            this.table = new Uint8Array(e4);
          }
          setDefault(e4, t4) {
            this.table.fill(e4 << 4 | t4);
          }
          add(e4, t4, i3, s3) {
            this.table[t4 << 8 | e4] = i3 << 4 | s3;
          }
          addMany(e4, t4, i3, s3) {
            for (let r2 = 0; r2 < e4.length; r2++) this.table[t4 << 8 | e4[r2]] = i3 << 4 | s3;
          }
        };
        __name(_a2, "a");
        let a = _a2;
        t3.TransitionTable = a;
        const h = 160;
        t3.VT500_TRANSITION_TABLE = (function() {
          const e4 = new a(4095), t4 = Array.apply(null, Array(256)).map(((e5, t5) => t5)), i3 = /* @__PURE__ */ __name((e5, i4) => t4.slice(e5, i4), "i"), s3 = i3(32, 127), r2 = i3(0, 24);
          r2.push(25), r2.push.apply(r2, i3(28, 32));
          const n2 = i3(0, 14);
          let o2;
          for (o2 in e4.setDefault(1, 0), e4.addMany(s3, 0, 2, 0), n2) e4.addMany([24, 26, 153, 154], o2, 3, 0), e4.addMany(i3(128, 144), o2, 3, 0), e4.addMany(i3(144, 152), o2, 3, 0), e4.add(156, o2, 0, 0), e4.add(27, o2, 11, 1), e4.add(157, o2, 4, 8), e4.addMany([152, 158, 159], o2, 0, 7), e4.add(155, o2, 11, 3), e4.add(144, o2, 11, 9);
          return e4.addMany(r2, 0, 3, 0), e4.addMany(r2, 1, 3, 1), e4.add(127, 1, 0, 1), e4.addMany(r2, 8, 0, 8), e4.addMany(r2, 3, 3, 3), e4.add(127, 3, 0, 3), e4.addMany(r2, 4, 3, 4), e4.add(127, 4, 0, 4), e4.addMany(r2, 6, 3, 6), e4.addMany(r2, 5, 3, 5), e4.add(127, 5, 0, 5), e4.addMany(r2, 2, 3, 2), e4.add(127, 2, 0, 2), e4.add(93, 1, 4, 8), e4.addMany(s3, 8, 5, 8), e4.add(127, 8, 5, 8), e4.addMany([156, 27, 24, 26, 7], 8, 6, 0), e4.addMany(i3(28, 32), 8, 0, 8), e4.addMany([88, 94, 95], 1, 0, 7), e4.addMany(s3, 7, 0, 7), e4.addMany(r2, 7, 0, 7), e4.add(156, 7, 0, 0), e4.add(127, 7, 0, 7), e4.add(91, 1, 11, 3), e4.addMany(i3(64, 127), 3, 7, 0), e4.addMany(i3(48, 60), 3, 8, 4), e4.addMany([60, 61, 62, 63], 3, 9, 4), e4.addMany(i3(48, 60), 4, 8, 4), e4.addMany(i3(64, 127), 4, 7, 0), e4.addMany([60, 61, 62, 63], 4, 0, 6), e4.addMany(i3(32, 64), 6, 0, 6), e4.add(127, 6, 0, 6), e4.addMany(i3(64, 127), 6, 0, 0), e4.addMany(i3(32, 48), 3, 9, 5), e4.addMany(i3(32, 48), 5, 9, 5), e4.addMany(i3(48, 64), 5, 0, 6), e4.addMany(i3(64, 127), 5, 7, 0), e4.addMany(i3(32, 48), 4, 9, 5), e4.addMany(i3(32, 48), 1, 9, 2), e4.addMany(i3(32, 48), 2, 9, 2), e4.addMany(i3(48, 127), 2, 10, 0), e4.addMany(i3(48, 80), 1, 10, 0), e4.addMany(i3(81, 88), 1, 10, 0), e4.addMany([89, 90, 92], 1, 10, 0), e4.addMany(i3(96, 127), 1, 10, 0), e4.add(80, 1, 11, 9), e4.addMany(r2, 9, 0, 9), e4.add(127, 9, 0, 9), e4.addMany(i3(28, 32), 9, 0, 9), e4.addMany(i3(32, 48), 9, 9, 12), e4.addMany(i3(48, 60), 9, 8, 10), e4.addMany([60, 61, 62, 63], 9, 9, 10), e4.addMany(r2, 11, 0, 11), e4.addMany(i3(32, 128), 11, 0, 11), e4.addMany(i3(28, 32), 11, 0, 11), e4.addMany(r2, 10, 0, 10), e4.add(127, 10, 0, 10), e4.addMany(i3(28, 32), 10, 0, 10), e4.addMany(i3(48, 60), 10, 8, 10), e4.addMany([60, 61, 62, 63], 10, 0, 11), e4.addMany(i3(32, 48), 10, 9, 12), e4.addMany(r2, 12, 0, 12), e4.add(127, 12, 0, 12), e4.addMany(i3(28, 32), 12, 0, 12), e4.addMany(i3(32, 48), 12, 9, 12), e4.addMany(i3(48, 64), 12, 0, 11), e4.addMany(i3(64, 127), 12, 12, 13), e4.addMany(i3(64, 127), 10, 12, 13), e4.addMany(i3(64, 127), 9, 12, 13), e4.addMany(r2, 13, 13, 13), e4.addMany(s3, 13, 13, 13), e4.add(127, 13, 0, 13), e4.addMany([27, 156, 24, 26], 13, 14, 0), e4.add(h, 0, 2, 0), e4.add(h, 8, 5, 8), e4.add(h, 6, 0, 6), e4.add(h, 11, 0, 11), e4.add(h, 13, 13, 13), e4;
        })();
        const _c2 = class _c2 extends s2.Disposable {
          constructor(e4 = t3.VT500_TRANSITION_TABLE) {
            super(), this._transitions = e4, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new r.Params(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0, this._printHandlerFb = (e5, t4, i3) => {
            }, this._executeHandlerFb = (e5) => {
            }, this._csiHandlerFb = (e5, t4) => {
            }, this._escHandlerFb = (e5) => {
            }, this._errorHandlerFb = (e5) => e5, this._printHandler = this._printHandlerFb, this._executeHandlers = /* @__PURE__ */ Object.create(null), this._csiHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null), this.register((0, s2.toDisposable)((() => {
              this._csiHandlers = /* @__PURE__ */ Object.create(null), this._executeHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null);
            }))), this._oscParser = this.register(new n.OscParser()), this._dcsParser = this.register(new o.DcsParser()), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, (() => true));
          }
          _identifier(e4, t4 = [64, 126]) {
            let i3 = 0;
            if (e4.prefix) {
              if (e4.prefix.length > 1) throw new Error("only one byte as prefix supported");
              if (i3 = e4.prefix.charCodeAt(0), i3 && 60 > i3 || i3 > 63) throw new Error("prefix must be in range 0x3c .. 0x3f");
            }
            if (e4.intermediates) {
              if (e4.intermediates.length > 2) throw new Error("only two bytes as intermediates are supported");
              for (let t5 = 0; t5 < e4.intermediates.length; ++t5) {
                const s4 = e4.intermediates.charCodeAt(t5);
                if (32 > s4 || s4 > 47) throw new Error("intermediate must be in range 0x20 .. 0x2f");
                i3 <<= 8, i3 |= s4;
              }
            }
            if (1 !== e4.final.length) throw new Error("final must be a single byte");
            const s3 = e4.final.charCodeAt(0);
            if (t4[0] > s3 || s3 > t4[1]) throw new Error(`final must be in range ${t4[0]} .. ${t4[1]}`);
            return i3 <<= 8, i3 |= s3, i3;
          }
          identToString(e4) {
            const t4 = [];
            for (; e4; ) t4.push(String.fromCharCode(255 & e4)), e4 >>= 8;
            return t4.reverse().join("");
          }
          setPrintHandler(e4) {
            this._printHandler = e4;
          }
          clearPrintHandler() {
            this._printHandler = this._printHandlerFb;
          }
          registerEscHandler(e4, t4) {
            const i3 = this._identifier(e4, [48, 126]);
            void 0 === this._escHandlers[i3] && (this._escHandlers[i3] = []);
            const s3 = this._escHandlers[i3];
            return s3.push(t4), { dispose: /* @__PURE__ */ __name(() => {
              const e5 = s3.indexOf(t4);
              -1 !== e5 && s3.splice(e5, 1);
            }, "dispose") };
          }
          clearEscHandler(e4) {
            this._escHandlers[this._identifier(e4, [48, 126])] && delete this._escHandlers[this._identifier(e4, [48, 126])];
          }
          setEscHandlerFallback(e4) {
            this._escHandlerFb = e4;
          }
          setExecuteHandler(e4, t4) {
            this._executeHandlers[e4.charCodeAt(0)] = t4;
          }
          clearExecuteHandler(e4) {
            this._executeHandlers[e4.charCodeAt(0)] && delete this._executeHandlers[e4.charCodeAt(0)];
          }
          setExecuteHandlerFallback(e4) {
            this._executeHandlerFb = e4;
          }
          registerCsiHandler(e4, t4) {
            const i3 = this._identifier(e4);
            void 0 === this._csiHandlers[i3] && (this._csiHandlers[i3] = []);
            const s3 = this._csiHandlers[i3];
            return s3.push(t4), { dispose: /* @__PURE__ */ __name(() => {
              const e5 = s3.indexOf(t4);
              -1 !== e5 && s3.splice(e5, 1);
            }, "dispose") };
          }
          clearCsiHandler(e4) {
            this._csiHandlers[this._identifier(e4)] && delete this._csiHandlers[this._identifier(e4)];
          }
          setCsiHandlerFallback(e4) {
            this._csiHandlerFb = e4;
          }
          registerDcsHandler(e4, t4) {
            return this._dcsParser.registerHandler(this._identifier(e4), t4);
          }
          clearDcsHandler(e4) {
            this._dcsParser.clearHandler(this._identifier(e4));
          }
          setDcsHandlerFallback(e4) {
            this._dcsParser.setHandlerFallback(e4);
          }
          registerOscHandler(e4, t4) {
            return this._oscParser.registerHandler(e4, t4);
          }
          clearOscHandler(e4) {
            this._oscParser.clearHandler(e4);
          }
          setOscHandlerFallback(e4) {
            this._oscParser.setHandlerFallback(e4);
          }
          setErrorHandler(e4) {
            this._errorHandler = e4;
          }
          clearErrorHandler() {
            this._errorHandler = this._errorHandlerFb;
          }
          reset() {
            this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0, 0 !== this._parseStack.state && (this._parseStack.state = 2, this._parseStack.handlers = []);
          }
          _preserveStack(e4, t4, i3, s3, r2) {
            this._parseStack.state = e4, this._parseStack.handlers = t4, this._parseStack.handlerPos = i3, this._parseStack.transition = s3, this._parseStack.chunkPos = r2;
          }
          parse(e4, t4, i3) {
            let s3, r2 = 0, n2 = 0, o2 = 0;
            if (this._parseStack.state) if (2 === this._parseStack.state) this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1;
            else {
              if (void 0 === i3 || 1 === this._parseStack.state) throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
              const t5 = this._parseStack.handlers;
              let n3 = this._parseStack.handlerPos - 1;
              switch (this._parseStack.state) {
                case 3:
                  if (false === i3 && n3 > -1) {
                    for (; n3 >= 0 && (s3 = t5[n3](this._params), true !== s3); n3--) if (s3 instanceof Promise) return this._parseStack.handlerPos = n3, s3;
                  }
                  this._parseStack.handlers = [];
                  break;
                case 4:
                  if (false === i3 && n3 > -1) {
                    for (; n3 >= 0 && (s3 = t5[n3](), true !== s3); n3--) if (s3 instanceof Promise) return this._parseStack.handlerPos = n3, s3;
                  }
                  this._parseStack.handlers = [];
                  break;
                case 6:
                  if (r2 = e4[this._parseStack.chunkPos], s3 = this._dcsParser.unhook(24 !== r2 && 26 !== r2, i3), s3) return s3;
                  27 === r2 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                  break;
                case 5:
                  if (r2 = e4[this._parseStack.chunkPos], s3 = this._oscParser.end(24 !== r2 && 26 !== r2, i3), s3) return s3;
                  27 === r2 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
              }
              this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1, this.precedingJoinState = 0, this.currentState = 15 & this._parseStack.transition;
            }
            for (let i4 = o2; i4 < t4; ++i4) {
              switch (r2 = e4[i4], n2 = this._transitions.table[this.currentState << 8 | (r2 < 160 ? r2 : h)], n2 >> 4) {
                case 2:
                  for (let s4 = i4 + 1; ; ++s4) {
                    if (s4 >= t4 || (r2 = e4[s4]) < 32 || r2 > 126 && r2 < h) {
                      this._printHandler(e4, i4, s4), i4 = s4 - 1;
                      break;
                    }
                    if (++s4 >= t4 || (r2 = e4[s4]) < 32 || r2 > 126 && r2 < h) {
                      this._printHandler(e4, i4, s4), i4 = s4 - 1;
                      break;
                    }
                    if (++s4 >= t4 || (r2 = e4[s4]) < 32 || r2 > 126 && r2 < h) {
                      this._printHandler(e4, i4, s4), i4 = s4 - 1;
                      break;
                    }
                    if (++s4 >= t4 || (r2 = e4[s4]) < 32 || r2 > 126 && r2 < h) {
                      this._printHandler(e4, i4, s4), i4 = s4 - 1;
                      break;
                    }
                  }
                  break;
                case 3:
                  this._executeHandlers[r2] ? this._executeHandlers[r2]() : this._executeHandlerFb(r2), this.precedingJoinState = 0;
                  break;
                case 0:
                  break;
                case 1:
                  if (this._errorHandler({ position: i4, code: r2, currentState: this.currentState, collect: this._collect, params: this._params, abort: false }).abort) return;
                  break;
                case 7:
                  const o3 = this._csiHandlers[this._collect << 8 | r2];
                  let a2 = o3 ? o3.length - 1 : -1;
                  for (; a2 >= 0 && (s3 = o3[a2](this._params), true !== s3); a2--) if (s3 instanceof Promise) return this._preserveStack(3, o3, a2, n2, i4), s3;
                  a2 < 0 && this._csiHandlerFb(this._collect << 8 | r2, this._params), this.precedingJoinState = 0;
                  break;
                case 8:
                  do {
                    switch (r2) {
                      case 59:
                        this._params.addParam(0);
                        break;
                      case 58:
                        this._params.addSubParam(-1);
                        break;
                      default:
                        this._params.addDigit(r2 - 48);
                    }
                  } while (++i4 < t4 && (r2 = e4[i4]) > 47 && r2 < 60);
                  i4--;
                  break;
                case 9:
                  this._collect <<= 8, this._collect |= r2;
                  break;
                case 10:
                  const c2 = this._escHandlers[this._collect << 8 | r2];
                  let l = c2 ? c2.length - 1 : -1;
                  for (; l >= 0 && (s3 = c2[l](), true !== s3); l--) if (s3 instanceof Promise) return this._preserveStack(4, c2, l, n2, i4), s3;
                  l < 0 && this._escHandlerFb(this._collect << 8 | r2), this.precedingJoinState = 0;
                  break;
                case 11:
                  this._params.reset(), this._params.addParam(0), this._collect = 0;
                  break;
                case 12:
                  this._dcsParser.hook(this._collect << 8 | r2, this._params);
                  break;
                case 13:
                  for (let s4 = i4 + 1; ; ++s4) if (s4 >= t4 || 24 === (r2 = e4[s4]) || 26 === r2 || 27 === r2 || r2 > 127 && r2 < h) {
                    this._dcsParser.put(e4, i4, s4), i4 = s4 - 1;
                    break;
                  }
                  break;
                case 14:
                  if (s3 = this._dcsParser.unhook(24 !== r2 && 26 !== r2), s3) return this._preserveStack(6, [], 0, n2, i4), s3;
                  27 === r2 && (n2 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0;
                  break;
                case 4:
                  this._oscParser.start();
                  break;
                case 5:
                  for (let s4 = i4 + 1; ; s4++) if (s4 >= t4 || (r2 = e4[s4]) < 32 || r2 > 127 && r2 < h) {
                    this._oscParser.put(e4, i4, s4), i4 = s4 - 1;
                    break;
                  }
                  break;
                case 6:
                  if (s3 = this._oscParser.end(24 !== r2 && 26 !== r2), s3) return this._preserveStack(5, [], 0, n2, i4), s3;
                  27 === r2 && (n2 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0;
              }
              this.currentState = 15 & n2;
            }
          }
        };
        __name(_c2, "c");
        let c = _c2;
        t3.EscapeSequenceParser = c;
      }, 6242: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.OscHandler = t3.OscParser = void 0;
        const s2 = i2(5770), r = i2(482), n = [];
        t3.OscParser = class {
          constructor() {
            this._state = 0, this._active = n, this._id = -1, this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
          }
          registerHandler(e4, t4) {
            void 0 === this._handlers[e4] && (this._handlers[e4] = []);
            const i3 = this._handlers[e4];
            return i3.push(t4), { dispose: /* @__PURE__ */ __name(() => {
              const e5 = i3.indexOf(t4);
              -1 !== e5 && i3.splice(e5, 1);
            }, "dispose") };
          }
          clearHandler(e4) {
            this._handlers[e4] && delete this._handlers[e4];
          }
          setHandlerFallback(e4) {
            this._handlerFb = e4;
          }
          dispose() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._active = n;
          }
          reset() {
            if (2 === this._state) for (let e4 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e4 >= 0; --e4) this._active[e4].end(false);
            this._stack.paused = false, this._active = n, this._id = -1, this._state = 0;
          }
          _start() {
            if (this._active = this._handlers[this._id] || n, this._active.length) for (let e4 = this._active.length - 1; e4 >= 0; e4--) this._active[e4].start();
            else this._handlerFb(this._id, "START");
          }
          _put(e4, t4, i3) {
            if (this._active.length) for (let s3 = this._active.length - 1; s3 >= 0; s3--) this._active[s3].put(e4, t4, i3);
            else this._handlerFb(this._id, "PUT", (0, r.utf32ToString)(e4, t4, i3));
          }
          start() {
            this.reset(), this._state = 1;
          }
          put(e4, t4, i3) {
            if (3 !== this._state) {
              if (1 === this._state) for (; t4 < i3; ) {
                const i4 = e4[t4++];
                if (59 === i4) {
                  this._state = 2, this._start();
                  break;
                }
                if (i4 < 48 || 57 < i4) return void (this._state = 3);
                -1 === this._id && (this._id = 0), this._id = 10 * this._id + i4 - 48;
              }
              2 === this._state && i3 - t4 > 0 && this._put(e4, t4, i3);
            }
          }
          end(e4, t4 = true) {
            if (0 !== this._state) {
              if (3 !== this._state) if (1 === this._state && this._start(), this._active.length) {
                let i3 = false, s3 = this._active.length - 1, r2 = false;
                if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i3 = t4, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && false === i3) {
                  for (; s3 >= 0 && (i3 = this._active[s3].end(e4), true !== i3); s3--) if (i3 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i3;
                  s3--;
                }
                for (; s3 >= 0; s3--) if (i3 = this._active[s3].end(false), i3 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i3;
              } else this._handlerFb(this._id, "END", e4);
              this._active = n, this._id = -1, this._state = 0;
            }
          }
        }, t3.OscHandler = class {
          constructor(e4) {
            this._handler = e4, this._data = "", this._hitLimit = false;
          }
          start() {
            this._data = "", this._hitLimit = false;
          }
          put(e4, t4, i3) {
            this._hitLimit || (this._data += (0, r.utf32ToString)(e4, t4, i3), this._data.length > s2.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
          }
          end(e4) {
            let t4 = false;
            if (this._hitLimit) t4 = false;
            else if (e4 && (t4 = this._handler(this._data), t4 instanceof Promise)) return t4.then(((e5) => (this._data = "", this._hitLimit = false, e5)));
            return this._data = "", this._hitLimit = false, t4;
          }
        };
      }, 8742: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.Params = void 0;
        const i2 = 2147483647;
        const _s = class _s {
          static fromArray(e4) {
            const t4 = new _s();
            if (!e4.length) return t4;
            for (let i3 = Array.isArray(e4[0]) ? 1 : 0; i3 < e4.length; ++i3) {
              const s3 = e4[i3];
              if (Array.isArray(s3)) for (let e5 = 0; e5 < s3.length; ++e5) t4.addSubParam(s3[e5]);
              else t4.addParam(s3);
            }
            return t4;
          }
          constructor(e4 = 32, t4 = 32) {
            if (this.maxLength = e4, this.maxSubParamsLength = t4, t4 > 256) throw new Error("maxSubParamsLength must not be greater than 256");
            this.params = new Int32Array(e4), this.length = 0, this._subParams = new Int32Array(t4), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(e4), this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
          }
          clone() {
            const e4 = new _s(this.maxLength, this.maxSubParamsLength);
            return e4.params.set(this.params), e4.length = this.length, e4._subParams.set(this._subParams), e4._subParamsLength = this._subParamsLength, e4._subParamsIdx.set(this._subParamsIdx), e4._rejectDigits = this._rejectDigits, e4._rejectSubDigits = this._rejectSubDigits, e4._digitIsSub = this._digitIsSub, e4;
          }
          toArray() {
            const e4 = [];
            for (let t4 = 0; t4 < this.length; ++t4) {
              e4.push(this.params[t4]);
              const i3 = this._subParamsIdx[t4] >> 8, s3 = 255 & this._subParamsIdx[t4];
              s3 - i3 > 0 && e4.push(Array.prototype.slice.call(this._subParams, i3, s3));
            }
            return e4;
          }
          reset() {
            this.length = 0, this._subParamsLength = 0, this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
          }
          addParam(e4) {
            if (this._digitIsSub = false, this.length >= this.maxLength) this._rejectDigits = true;
            else {
              if (e4 < -1) throw new Error("values lesser than -1 are not allowed");
              this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = e4 > i2 ? i2 : e4;
            }
          }
          addSubParam(e4) {
            if (this._digitIsSub = true, this.length) if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength) this._rejectSubDigits = true;
            else {
              if (e4 < -1) throw new Error("values lesser than -1 are not allowed");
              this._subParams[this._subParamsLength++] = e4 > i2 ? i2 : e4, this._subParamsIdx[this.length - 1]++;
            }
          }
          hasSubParams(e4) {
            return (255 & this._subParamsIdx[e4]) - (this._subParamsIdx[e4] >> 8) > 0;
          }
          getSubParams(e4) {
            const t4 = this._subParamsIdx[e4] >> 8, i3 = 255 & this._subParamsIdx[e4];
            return i3 - t4 > 0 ? this._subParams.subarray(t4, i3) : null;
          }
          getSubParamsAll() {
            const e4 = {};
            for (let t4 = 0; t4 < this.length; ++t4) {
              const i3 = this._subParamsIdx[t4] >> 8, s3 = 255 & this._subParamsIdx[t4];
              s3 - i3 > 0 && (e4[t4] = this._subParams.slice(i3, s3));
            }
            return e4;
          }
          addDigit(e4) {
            let t4;
            if (this._rejectDigits || !(t4 = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits) return;
            const s3 = this._digitIsSub ? this._subParams : this.params, r = s3[t4 - 1];
            s3[t4 - 1] = ~r ? Math.min(10 * r + e4, i2) : e4;
          }
        };
        __name(_s, "s");
        let s2 = _s;
        t3.Params = s2;
      }, 5741: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.AddonManager = void 0, t3.AddonManager = class {
          constructor() {
            this._addons = [];
          }
          dispose() {
            for (let e4 = this._addons.length - 1; e4 >= 0; e4--) this._addons[e4].instance.dispose();
          }
          loadAddon(e4, t4) {
            const i2 = { instance: t4, dispose: t4.dispose, isDisposed: false };
            this._addons.push(i2), t4.dispose = () => this._wrappedAddonDispose(i2), t4.activate(e4);
          }
          _wrappedAddonDispose(e4) {
            if (e4.isDisposed) return;
            let t4 = -1;
            for (let i2 = 0; i2 < this._addons.length; i2++) if (this._addons[i2] === e4) {
              t4 = i2;
              break;
            }
            if (-1 === t4) throw new Error("Could not dispose an addon that has not been loaded");
            e4.isDisposed = true, e4.dispose.apply(e4.instance), this._addons.splice(t4, 1);
          }
        };
      }, 8771: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.BufferApiView = void 0;
        const s2 = i2(3785), r = i2(511);
        t3.BufferApiView = class {
          constructor(e4, t4) {
            this._buffer = e4, this.type = t4;
          }
          init(e4) {
            return this._buffer = e4, this;
          }
          get cursorY() {
            return this._buffer.y;
          }
          get cursorX() {
            return this._buffer.x;
          }
          get viewportY() {
            return this._buffer.ydisp;
          }
          get baseY() {
            return this._buffer.ybase;
          }
          get length() {
            return this._buffer.lines.length;
          }
          getLine(e4) {
            const t4 = this._buffer.lines.get(e4);
            if (t4) return new s2.BufferLineApiView(t4);
          }
          getNullCell() {
            return new r.CellData();
          }
        };
      }, 3785: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.BufferLineApiView = void 0;
        const s2 = i2(511);
        t3.BufferLineApiView = class {
          constructor(e4) {
            this._line = e4;
          }
          get isWrapped() {
            return this._line.isWrapped;
          }
          get length() {
            return this._line.length;
          }
          getCell(e4, t4) {
            if (!(e4 < 0 || e4 >= this._line.length)) return t4 ? (this._line.loadCell(e4, t4), t4) : this._line.loadCell(e4, new s2.CellData());
          }
          translateToString(e4, t4, i3) {
            return this._line.translateToString(e4, t4, i3);
          }
        };
      }, 8285: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.BufferNamespaceApi = void 0;
        const s2 = i2(8771), r = i2(8460), n = i2(844);
        const _o = class _o extends n.Disposable {
          constructor(e4) {
            super(), this._core = e4, this._onBufferChange = this.register(new r.EventEmitter()), this.onBufferChange = this._onBufferChange.event, this._normal = new s2.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new s2.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate((() => this._onBufferChange.fire(this.active)));
          }
          get active() {
            if (this._core.buffers.active === this._core.buffers.normal) return this.normal;
            if (this._core.buffers.active === this._core.buffers.alt) return this.alternate;
            throw new Error("Active buffer is neither normal nor alternate");
          }
          get normal() {
            return this._normal.init(this._core.buffers.normal);
          }
          get alternate() {
            return this._alternate.init(this._core.buffers.alt);
          }
        };
        __name(_o, "o");
        let o = _o;
        t3.BufferNamespaceApi = o;
      }, 7975: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.ParserApi = void 0, t3.ParserApi = class {
          constructor(e4) {
            this._core = e4;
          }
          registerCsiHandler(e4, t4) {
            return this._core.registerCsiHandler(e4, ((e5) => t4(e5.toArray())));
          }
          addCsiHandler(e4, t4) {
            return this.registerCsiHandler(e4, t4);
          }
          registerDcsHandler(e4, t4) {
            return this._core.registerDcsHandler(e4, ((e5, i2) => t4(e5, i2.toArray())));
          }
          addDcsHandler(e4, t4) {
            return this.registerDcsHandler(e4, t4);
          }
          registerEscHandler(e4, t4) {
            return this._core.registerEscHandler(e4, t4);
          }
          addEscHandler(e4, t4) {
            return this.registerEscHandler(e4, t4);
          }
          registerOscHandler(e4, t4) {
            return this._core.registerOscHandler(e4, t4);
          }
          addOscHandler(e4, t4) {
            return this.registerOscHandler(e4, t4);
          }
        };
      }, 7090: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.UnicodeApi = void 0, t3.UnicodeApi = class {
          constructor(e4) {
            this._core = e4;
          }
          register(e4) {
            this._core.unicodeService.register(e4);
          }
          get versions() {
            return this._core.unicodeService.versions;
          }
          get activeVersion() {
            return this._core.unicodeService.activeVersion;
          }
          set activeVersion(e4) {
            this._core.unicodeService.activeVersion = e4;
          }
        };
      }, 744: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.BufferService = t3.MINIMUM_ROWS = t3.MINIMUM_COLS = void 0;
        const n = i2(8460), o = i2(844), a = i2(5295), h = i2(2585);
        t3.MINIMUM_COLS = 2, t3.MINIMUM_ROWS = 1;
        let c = t3.BufferService = class extends o.Disposable {
          get buffer() {
            return this.buffers.active;
          }
          constructor(e4) {
            super(), this.isUserScrolling = false, this._onResize = this.register(new n.EventEmitter()), this.onResize = this._onResize.event, this._onScroll = this.register(new n.EventEmitter()), this.onScroll = this._onScroll.event, this.cols = Math.max(e4.rawOptions.cols || 0, t3.MINIMUM_COLS), this.rows = Math.max(e4.rawOptions.rows || 0, t3.MINIMUM_ROWS), this.buffers = this.register(new a.BufferSet(e4, this));
          }
          resize(e4, t4) {
            this.cols = e4, this.rows = t4, this.buffers.resize(e4, t4), this._onResize.fire({ cols: e4, rows: t4 });
          }
          reset() {
            this.buffers.reset(), this.isUserScrolling = false;
          }
          scroll(e4, t4 = false) {
            const i3 = this.buffer;
            let s3;
            s3 = this._cachedBlankLine, s3 && s3.length === this.cols && s3.getFg(0) === e4.fg && s3.getBg(0) === e4.bg || (s3 = i3.getBlankLine(e4, t4), this._cachedBlankLine = s3), s3.isWrapped = t4;
            const r2 = i3.ybase + i3.scrollTop, n2 = i3.ybase + i3.scrollBottom;
            if (0 === i3.scrollTop) {
              const e5 = i3.lines.isFull;
              n2 === i3.lines.length - 1 ? e5 ? i3.lines.recycle().copyFrom(s3) : i3.lines.push(s3.clone()) : i3.lines.splice(n2 + 1, 0, s3.clone()), e5 ? this.isUserScrolling && (i3.ydisp = Math.max(i3.ydisp - 1, 0)) : (i3.ybase++, this.isUserScrolling || i3.ydisp++);
            } else {
              const e5 = n2 - r2 + 1;
              i3.lines.shiftElements(r2 + 1, e5 - 1, -1), i3.lines.set(n2, s3.clone());
            }
            this.isUserScrolling || (i3.ydisp = i3.ybase), this._onScroll.fire(i3.ydisp);
          }
          scrollLines(e4, t4, i3) {
            const s3 = this.buffer;
            if (e4 < 0) {
              if (0 === s3.ydisp) return;
              this.isUserScrolling = true;
            } else e4 + s3.ydisp >= s3.ybase && (this.isUserScrolling = false);
            const r2 = s3.ydisp;
            s3.ydisp = Math.max(Math.min(s3.ydisp + e4, s3.ybase), 0), r2 !== s3.ydisp && (t4 || this._onScroll.fire(s3.ydisp));
          }
        };
        t3.BufferService = c = s2([r(0, h.IOptionsService)], c);
      }, 7994: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.CharsetService = void 0, t3.CharsetService = class {
          constructor() {
            this.glevel = 0, this._charsets = [];
          }
          reset() {
            this.charset = void 0, this._charsets = [], this.glevel = 0;
          }
          setgLevel(e4) {
            this.glevel = e4, this.charset = this._charsets[e4];
          }
          setgCharset(e4, t4) {
            this._charsets[e4] = t4, this.glevel === e4 && (this.charset = t4);
          }
        };
      }, 1753: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.CoreMouseService = void 0;
        const n = i2(2585), o = i2(8460), a = i2(844), h = { NONE: { events: 0, restrict: /* @__PURE__ */ __name(() => false, "restrict") }, X10: { events: 1, restrict: /* @__PURE__ */ __name((e4) => 4 !== e4.button && 1 === e4.action && (e4.ctrl = false, e4.alt = false, e4.shift = false, true), "restrict") }, VT200: { events: 19, restrict: /* @__PURE__ */ __name((e4) => 32 !== e4.action, "restrict") }, DRAG: { events: 23, restrict: /* @__PURE__ */ __name((e4) => 32 !== e4.action || 3 !== e4.button, "restrict") }, ANY: { events: 31, restrict: /* @__PURE__ */ __name((e4) => true, "restrict") } };
        function c(e4, t4) {
          let i3 = (e4.ctrl ? 16 : 0) | (e4.shift ? 4 : 0) | (e4.alt ? 8 : 0);
          return 4 === e4.button ? (i3 |= 64, i3 |= e4.action) : (i3 |= 3 & e4.button, 4 & e4.button && (i3 |= 64), 8 & e4.button && (i3 |= 128), 32 === e4.action ? i3 |= 32 : 0 !== e4.action || t4 || (i3 |= 3)), i3;
        }
        __name(c, "c");
        const l = String.fromCharCode, d = { DEFAULT: /* @__PURE__ */ __name((e4) => {
          const t4 = [c(e4, false) + 32, e4.col + 32, e4.row + 32];
          return t4[0] > 255 || t4[1] > 255 || t4[2] > 255 ? "" : `\x1B[M${l(t4[0])}${l(t4[1])}${l(t4[2])}`;
        }, "DEFAULT"), SGR: /* @__PURE__ */ __name((e4) => {
          const t4 = 0 === e4.action && 4 !== e4.button ? "m" : "M";
          return `\x1B[<${c(e4, true)};${e4.col};${e4.row}${t4}`;
        }, "SGR"), SGR_PIXELS: /* @__PURE__ */ __name((e4) => {
          const t4 = 0 === e4.action && 4 !== e4.button ? "m" : "M";
          return `\x1B[<${c(e4, true)};${e4.x};${e4.y}${t4}`;
        }, "SGR_PIXELS") };
        let _ = t3.CoreMouseService = class extends a.Disposable {
          constructor(e4, t4) {
            super(), this._bufferService = e4, this._coreService = t4, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new o.EventEmitter()), this.onProtocolChange = this._onProtocolChange.event;
            for (const e5 of Object.keys(h)) this.addProtocol(e5, h[e5]);
            for (const e5 of Object.keys(d)) this.addEncoding(e5, d[e5]);
            this.reset();
          }
          addProtocol(e4, t4) {
            this._protocols[e4] = t4;
          }
          addEncoding(e4, t4) {
            this._encodings[e4] = t4;
          }
          get activeProtocol() {
            return this._activeProtocol;
          }
          get areMouseEventsActive() {
            return 0 !== this._protocols[this._activeProtocol].events;
          }
          set activeProtocol(e4) {
            if (!this._protocols[e4]) throw new Error(`unknown protocol "${e4}"`);
            this._activeProtocol = e4, this._onProtocolChange.fire(this._protocols[e4].events);
          }
          get activeEncoding() {
            return this._activeEncoding;
          }
          set activeEncoding(e4) {
            if (!this._encodings[e4]) throw new Error(`unknown encoding "${e4}"`);
            this._activeEncoding = e4;
          }
          reset() {
            this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
          }
          triggerMouseEvent(e4) {
            if (e4.col < 0 || e4.col >= this._bufferService.cols || e4.row < 0 || e4.row >= this._bufferService.rows) return false;
            if (4 === e4.button && 32 === e4.action) return false;
            if (3 === e4.button && 32 !== e4.action) return false;
            if (4 !== e4.button && (2 === e4.action || 3 === e4.action)) return false;
            if (e4.col++, e4.row++, 32 === e4.action && this._lastEvent && this._equalEvents(this._lastEvent, e4, "SGR_PIXELS" === this._activeEncoding)) return false;
            if (!this._protocols[this._activeProtocol].restrict(e4)) return false;
            const t4 = this._encodings[this._activeEncoding](e4);
            return t4 && ("DEFAULT" === this._activeEncoding ? this._coreService.triggerBinaryEvent(t4) : this._coreService.triggerDataEvent(t4, true)), this._lastEvent = e4, true;
          }
          explainEvents(e4) {
            return { down: !!(1 & e4), up: !!(2 & e4), drag: !!(4 & e4), move: !!(8 & e4), wheel: !!(16 & e4) };
          }
          _equalEvents(e4, t4, i3) {
            if (i3) {
              if (e4.x !== t4.x) return false;
              if (e4.y !== t4.y) return false;
            } else {
              if (e4.col !== t4.col) return false;
              if (e4.row !== t4.row) return false;
            }
            return e4.button === t4.button && e4.action === t4.action && e4.ctrl === t4.ctrl && e4.alt === t4.alt && e4.shift === t4.shift;
          }
        };
        t3.CoreMouseService = _ = s2([r(0, n.IBufferService), r(1, n.ICoreService)], _);
      }, 6975: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.CoreService = void 0;
        const n = i2(1439), o = i2(8460), a = i2(844), h = i2(2585), c = Object.freeze({ insertMode: false }), l = Object.freeze({ applicationCursorKeys: false, applicationKeypad: false, bracketedPasteMode: false, origin: false, reverseWraparound: false, sendFocus: false, wraparound: true });
        let d = t3.CoreService = class extends a.Disposable {
          constructor(e4, t4, i3) {
            super(), this._bufferService = e4, this._logService = t4, this._optionsService = i3, this.isCursorInitialized = false, this.isCursorHidden = false, this._onData = this.register(new o.EventEmitter()), this.onData = this._onData.event, this._onUserInput = this.register(new o.EventEmitter()), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new o.EventEmitter()), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new o.EventEmitter()), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, n.clone)(c), this.decPrivateModes = (0, n.clone)(l);
          }
          reset() {
            this.modes = (0, n.clone)(c), this.decPrivateModes = (0, n.clone)(l);
          }
          triggerDataEvent(e4, t4 = false) {
            if (this._optionsService.rawOptions.disableStdin) return;
            const i3 = this._bufferService.buffer;
            t4 && this._optionsService.rawOptions.scrollOnUserInput && i3.ybase !== i3.ydisp && this._onRequestScrollToBottom.fire(), t4 && this._onUserInput.fire(), this._logService.debug(`sending data "${e4}"`, (() => e4.split("").map(((e5) => e5.charCodeAt(0))))), this._onData.fire(e4);
          }
          triggerBinaryEvent(e4) {
            this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${e4}"`, (() => e4.split("").map(((e5) => e5.charCodeAt(0))))), this._onBinary.fire(e4));
          }
        };
        t3.CoreService = d = s2([r(0, h.IBufferService), r(1, h.ILogService), r(2, h.IOptionsService)], d);
      }, 9074: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.DecorationService = void 0;
        const s2 = i2(8055), r = i2(8460), n = i2(844), o = i2(6106);
        let a = 0, h = 0;
        const _c2 = class _c2 extends n.Disposable {
          get decorations() {
            return this._decorations.values();
          }
          constructor() {
            super(), this._decorations = new o.SortedList(((e4) => e4?.marker.line)), this._onDecorationRegistered = this.register(new r.EventEmitter()), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new r.EventEmitter()), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, n.toDisposable)((() => this.reset())));
          }
          registerDecoration(e4) {
            if (e4.marker.isDisposed) return;
            const t4 = new l(e4);
            if (t4) {
              const e5 = t4.marker.onDispose((() => t4.dispose()));
              t4.onDispose((() => {
                t4 && (this._decorations.delete(t4) && this._onDecorationRemoved.fire(t4), e5.dispose());
              })), this._decorations.insert(t4), this._onDecorationRegistered.fire(t4);
            }
            return t4;
          }
          reset() {
            for (const e4 of this._decorations.values()) e4.dispose();
            this._decorations.clear();
          }
          *getDecorationsAtCell(e4, t4, i3) {
            let s3 = 0, r2 = 0;
            for (const n2 of this._decorations.getKeyIterator(t4)) s3 = n2.options.x ?? 0, r2 = s3 + (n2.options.width ?? 1), e4 >= s3 && e4 < r2 && (!i3 || (n2.options.layer ?? "bottom") === i3) && (yield n2);
          }
          forEachDecorationAtCell(e4, t4, i3, s3) {
            this._decorations.forEachByKey(t4, ((t5) => {
              a = t5.options.x ?? 0, h = a + (t5.options.width ?? 1), e4 >= a && e4 < h && (!i3 || (t5.options.layer ?? "bottom") === i3) && s3(t5);
            }));
          }
        };
        __name(_c2, "c");
        let c = _c2;
        t3.DecorationService = c;
        const _l = class _l extends n.Disposable {
          get isDisposed() {
            return this._isDisposed;
          }
          get backgroundColorRGB() {
            return null === this._cachedBg && (this.options.backgroundColor ? this._cachedBg = s2.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;
          }
          get foregroundColorRGB() {
            return null === this._cachedFg && (this.options.foregroundColor ? this._cachedFg = s2.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;
          }
          constructor(e4) {
            super(), this.options = e4, this.onRenderEmitter = this.register(new r.EventEmitter()), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new r.EventEmitter()), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = e4.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
          }
          dispose() {
            this._onDispose.fire(), super.dispose();
          }
        };
        __name(_l, "l");
        let l = _l;
      }, 4348: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.InstantiationService = t3.ServiceCollection = void 0;
        const s2 = i2(2585), r = i2(8343);
        const _n = class _n {
          constructor(...e4) {
            this._entries = /* @__PURE__ */ new Map();
            for (const [t4, i3] of e4) this.set(t4, i3);
          }
          set(e4, t4) {
            const i3 = this._entries.get(e4);
            return this._entries.set(e4, t4), i3;
          }
          forEach(e4) {
            for (const [t4, i3] of this._entries.entries()) e4(t4, i3);
          }
          has(e4) {
            return this._entries.has(e4);
          }
          get(e4) {
            return this._entries.get(e4);
          }
        };
        __name(_n, "n");
        let n = _n;
        t3.ServiceCollection = n, t3.InstantiationService = class {
          constructor() {
            this._services = new n(), this._services.set(s2.IInstantiationService, this);
          }
          setService(e4, t4) {
            this._services.set(e4, t4);
          }
          getService(e4) {
            return this._services.get(e4);
          }
          createInstance(e4, ...t4) {
            const i3 = (0, r.getServiceDependencies)(e4).sort(((e5, t5) => e5.index - t5.index)), s3 = [];
            for (const t5 of i3) {
              const i4 = this._services.get(t5.id);
              if (!i4) throw new Error(`[createInstance] ${e4.name} depends on UNKNOWN service ${t5.id}.`);
              s3.push(i4);
            }
            const n2 = i3.length > 0 ? i3[0].index : t4.length;
            if (t4.length !== n2) throw new Error(`[createInstance] First service dependency of ${e4.name} at position ${n2 + 1} conflicts with ${t4.length} static arguments`);
            return new e4(...[...t4, ...s3]);
          }
        };
      }, 7866: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a2 = e4.length - 1; a2 >= 0; a2--) (r2 = e4[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.traceCall = t3.setTraceLogger = t3.LogService = void 0;
        const n = i2(844), o = i2(2585), a = { trace: o.LogLevelEnum.TRACE, debug: o.LogLevelEnum.DEBUG, info: o.LogLevelEnum.INFO, warn: o.LogLevelEnum.WARN, error: o.LogLevelEnum.ERROR, off: o.LogLevelEnum.OFF };
        let h, c = t3.LogService = class extends n.Disposable {
          get logLevel() {
            return this._logLevel;
          }
          constructor(e4) {
            super(), this._optionsService = e4, this._logLevel = o.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", (() => this._updateLogLevel()))), h = this;
          }
          _updateLogLevel() {
            this._logLevel = a[this._optionsService.rawOptions.logLevel];
          }
          _evalLazyOptionalParams(e4) {
            for (let t4 = 0; t4 < e4.length; t4++) "function" == typeof e4[t4] && (e4[t4] = e4[t4]());
          }
          _log(e4, t4, i3) {
            this._evalLazyOptionalParams(i3), e4.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + t4, ...i3);
          }
          trace(e4, ...t4) {
            this._logLevel <= o.LogLevelEnum.TRACE && this._log(this._optionsService.options.logger?.trace.bind(this._optionsService.options.logger) ?? console.log, e4, t4);
          }
          debug(e4, ...t4) {
            this._logLevel <= o.LogLevelEnum.DEBUG && this._log(this._optionsService.options.logger?.debug.bind(this._optionsService.options.logger) ?? console.log, e4, t4);
          }
          info(e4, ...t4) {
            this._logLevel <= o.LogLevelEnum.INFO && this._log(this._optionsService.options.logger?.info.bind(this._optionsService.options.logger) ?? console.info, e4, t4);
          }
          warn(e4, ...t4) {
            this._logLevel <= o.LogLevelEnum.WARN && this._log(this._optionsService.options.logger?.warn.bind(this._optionsService.options.logger) ?? console.warn, e4, t4);
          }
          error(e4, ...t4) {
            this._logLevel <= o.LogLevelEnum.ERROR && this._log(this._optionsService.options.logger?.error.bind(this._optionsService.options.logger) ?? console.error, e4, t4);
          }
        };
        t3.LogService = c = s2([r(0, o.IOptionsService)], c), t3.setTraceLogger = function(e4) {
          h = e4;
        }, t3.traceCall = function(e4, t4, i3) {
          if ("function" != typeof i3.value) throw new Error("not supported");
          const s3 = i3.value;
          i3.value = function(...e5) {
            if (h.logLevel !== o.LogLevelEnum.TRACE) return s3.apply(this, e5);
            h.trace(`GlyphRenderer#${s3.name}(${e5.map(((e6) => JSON.stringify(e6))).join(", ")})`);
            const t5 = s3.apply(this, e5);
            return h.trace(`GlyphRenderer#${s3.name} return`, t5), t5;
          };
        };
      }, 7302: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.OptionsService = t3.DEFAULT_OPTIONS = void 0;
        const s2 = i2(8460), r = i2(844), n = i2(6114);
        t3.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: false, cursorStyle: "block", cursorWidth: 1, cursorInactiveStyle: "outline", customGlyphs: true, drawBoldTextInBrightColors: true, documentOverride: null, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", ignoreBracketedPasteMode: false, lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", logger: null, scrollback: 1e3, scrollOnUserInput: true, scrollSensitivity: 1, screenReaderMode: false, smoothScrollDuration: 0, macOptionIsMeta: false, macOptionClickForcesSelection: false, minimumContrastRatio: 1, disableStdin: false, allowProposedApi: false, allowTransparency: false, tabStopWidth: 8, theme: {}, rescaleOverlappingGlyphs: false, rightClickSelectsWord: n.isMac, windowOptions: {}, windowsMode: false, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: true, convertEol: false, termName: "xterm", cancelEvents: false, overviewRulerWidth: 0 };
        const o = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
        const _a2 = class _a2 extends r.Disposable {
          constructor(e4) {
            super(), this._onOptionChange = this.register(new s2.EventEmitter()), this.onOptionChange = this._onOptionChange.event;
            const i3 = { ...t3.DEFAULT_OPTIONS };
            for (const t4 in e4) if (t4 in i3) try {
              const s3 = e4[t4];
              i3[t4] = this._sanitizeAndValidateOption(t4, s3);
            } catch (e5) {
              console.error(e5);
            }
            this.rawOptions = i3, this.options = { ...i3 }, this._setupOptions(), this.register((0, r.toDisposable)((() => {
              this.rawOptions.linkHandler = null, this.rawOptions.documentOverride = null;
            })));
          }
          onSpecificOptionChange(e4, t4) {
            return this.onOptionChange(((i3) => {
              i3 === e4 && t4(this.rawOptions[e4]);
            }));
          }
          onMultipleOptionChange(e4, t4) {
            return this.onOptionChange(((i3) => {
              -1 !== e4.indexOf(i3) && t4();
            }));
          }
          _setupOptions() {
            const e4 = /* @__PURE__ */ __name((e5) => {
              if (!(e5 in t3.DEFAULT_OPTIONS)) throw new Error(`No option with key "${e5}"`);
              return this.rawOptions[e5];
            }, "e"), i3 = /* @__PURE__ */ __name((e5, i4) => {
              if (!(e5 in t3.DEFAULT_OPTIONS)) throw new Error(`No option with key "${e5}"`);
              i4 = this._sanitizeAndValidateOption(e5, i4), this.rawOptions[e5] !== i4 && (this.rawOptions[e5] = i4, this._onOptionChange.fire(e5));
            }, "i");
            for (const t4 in this.rawOptions) {
              const s3 = { get: e4.bind(this, t4), set: i3.bind(this, t4) };
              Object.defineProperty(this.options, t4, s3);
            }
          }
          _sanitizeAndValidateOption(e4, i3) {
            switch (e4) {
              case "cursorStyle":
                if (i3 || (i3 = t3.DEFAULT_OPTIONS[e4]), !/* @__PURE__ */ (function(e5) {
                  return "block" === e5 || "underline" === e5 || "bar" === e5;
                })(i3)) throw new Error(`"${i3}" is not a valid value for ${e4}`);
                break;
              case "wordSeparator":
                i3 || (i3 = t3.DEFAULT_OPTIONS[e4]);
                break;
              case "fontWeight":
              case "fontWeightBold":
                if ("number" == typeof i3 && 1 <= i3 && i3 <= 1e3) break;
                i3 = o.includes(i3) ? i3 : t3.DEFAULT_OPTIONS[e4];
                break;
              case "cursorWidth":
                i3 = Math.floor(i3);
              case "lineHeight":
              case "tabStopWidth":
                if (i3 < 1) throw new Error(`${e4} cannot be less than 1, value: ${i3}`);
                break;
              case "minimumContrastRatio":
                i3 = Math.max(1, Math.min(21, Math.round(10 * i3) / 10));
                break;
              case "scrollback":
                if ((i3 = Math.min(i3, 4294967295)) < 0) throw new Error(`${e4} cannot be less than 0, value: ${i3}`);
                break;
              case "fastScrollSensitivity":
              case "scrollSensitivity":
                if (i3 <= 0) throw new Error(`${e4} cannot be less than or equal to 0, value: ${i3}`);
                break;
              case "rows":
              case "cols":
                if (!i3 && 0 !== i3) throw new Error(`${e4} must be numeric, value: ${i3}`);
                break;
              case "windowsPty":
                i3 = i3 ?? {};
            }
            return i3;
          }
        };
        __name(_a2, "a");
        let a = _a2;
        t3.OptionsService = a;
      }, 2660: function(e3, t3, i2) {
        var s2 = this && this.__decorate || function(e4, t4, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e4, t4, i3, s3);
          else for (var a = e4.length - 1; a >= 0; a--) (r2 = e4[a]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i3, o2) : r2(t4, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t4, i3, o2), o2;
        }, r = this && this.__param || function(e4, t4) {
          return function(i3, s3) {
            t4(i3, s3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.OscLinkService = void 0;
        const n = i2(2585);
        let o = t3.OscLinkService = class {
          constructor(e4) {
            this._bufferService = e4, this._nextId = 1, this._entriesWithId = /* @__PURE__ */ new Map(), this._dataByLinkId = /* @__PURE__ */ new Map();
          }
          registerLink(e4) {
            const t4 = this._bufferService.buffer;
            if (void 0 === e4.id) {
              const i4 = t4.addMarker(t4.ybase + t4.y), s4 = { data: e4, id: this._nextId++, lines: [i4] };
              return i4.onDispose((() => this._removeMarkerFromLink(s4, i4))), this._dataByLinkId.set(s4.id, s4), s4.id;
            }
            const i3 = e4, s3 = this._getEntryIdKey(i3), r2 = this._entriesWithId.get(s3);
            if (r2) return this.addLineToLink(r2.id, t4.ybase + t4.y), r2.id;
            const n2 = t4.addMarker(t4.ybase + t4.y), o2 = { id: this._nextId++, key: this._getEntryIdKey(i3), data: i3, lines: [n2] };
            return n2.onDispose((() => this._removeMarkerFromLink(o2, n2))), this._entriesWithId.set(o2.key, o2), this._dataByLinkId.set(o2.id, o2), o2.id;
          }
          addLineToLink(e4, t4) {
            const i3 = this._dataByLinkId.get(e4);
            if (i3 && i3.lines.every(((e5) => e5.line !== t4))) {
              const e5 = this._bufferService.buffer.addMarker(t4);
              i3.lines.push(e5), e5.onDispose((() => this._removeMarkerFromLink(i3, e5)));
            }
          }
          getLinkData(e4) {
            return this._dataByLinkId.get(e4)?.data;
          }
          _getEntryIdKey(e4) {
            return `${e4.id};;${e4.uri}`;
          }
          _removeMarkerFromLink(e4, t4) {
            const i3 = e4.lines.indexOf(t4);
            -1 !== i3 && (e4.lines.splice(i3, 1), 0 === e4.lines.length && (void 0 !== e4.data.id && this._entriesWithId.delete(e4.key), this._dataByLinkId.delete(e4.id)));
          }
        };
        t3.OscLinkService = o = s2([r(0, n.IBufferService)], o);
      }, 8343: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.createDecorator = t3.getServiceDependencies = t3.serviceRegistry = void 0;
        const i2 = "di$target", s2 = "di$dependencies";
        t3.serviceRegistry = /* @__PURE__ */ new Map(), t3.getServiceDependencies = function(e4) {
          return e4[s2] || [];
        }, t3.createDecorator = function(e4) {
          if (t3.serviceRegistry.has(e4)) return t3.serviceRegistry.get(e4);
          const r = /* @__PURE__ */ __name(function(e5, t4, n) {
            if (3 !== arguments.length) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
            !(function(e6, t5, r2) {
              t5[i2] === t5 ? t5[s2].push({ id: e6, index: r2 }) : (t5[s2] = [{ id: e6, index: r2 }], t5[i2] = t5);
            })(r, e5, n);
          }, "r");
          return r.toString = () => e4, t3.serviceRegistry.set(e4, r), r;
        };
      }, 2585: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.IDecorationService = t3.IUnicodeService = t3.IOscLinkService = t3.IOptionsService = t3.ILogService = t3.LogLevelEnum = t3.IInstantiationService = t3.ICharsetService = t3.ICoreService = t3.ICoreMouseService = t3.IBufferService = void 0;
        const s2 = i2(8343);
        var r;
        t3.IBufferService = (0, s2.createDecorator)("BufferService"), t3.ICoreMouseService = (0, s2.createDecorator)("CoreMouseService"), t3.ICoreService = (0, s2.createDecorator)("CoreService"), t3.ICharsetService = (0, s2.createDecorator)("CharsetService"), t3.IInstantiationService = (0, s2.createDecorator)("InstantiationService"), (function(e4) {
          e4[e4.TRACE = 0] = "TRACE", e4[e4.DEBUG = 1] = "DEBUG", e4[e4.INFO = 2] = "INFO", e4[e4.WARN = 3] = "WARN", e4[e4.ERROR = 4] = "ERROR", e4[e4.OFF = 5] = "OFF";
        })(r || (t3.LogLevelEnum = r = {})), t3.ILogService = (0, s2.createDecorator)("LogService"), t3.IOptionsService = (0, s2.createDecorator)("OptionsService"), t3.IOscLinkService = (0, s2.createDecorator)("OscLinkService"), t3.IUnicodeService = (0, s2.createDecorator)("UnicodeService"), t3.IDecorationService = (0, s2.createDecorator)("DecorationService");
      }, 1480: (e3, t3, i2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.UnicodeService = void 0;
        const s2 = i2(8460), r = i2(225);
        const _n = class _n {
          static extractShouldJoin(e4) {
            return 0 != (1 & e4);
          }
          static extractWidth(e4) {
            return e4 >> 1 & 3;
          }
          static extractCharKind(e4) {
            return e4 >> 3;
          }
          static createPropertyValue(e4, t4, i3 = false) {
            return (16777215 & e4) << 3 | (3 & t4) << 1 | (i3 ? 1 : 0);
          }
          constructor() {
            this._providers = /* @__PURE__ */ Object.create(null), this._active = "", this._onChange = new s2.EventEmitter(), this.onChange = this._onChange.event;
            const e4 = new r.UnicodeV6();
            this.register(e4), this._active = e4.version, this._activeProvider = e4;
          }
          dispose() {
            this._onChange.dispose();
          }
          get versions() {
            return Object.keys(this._providers);
          }
          get activeVersion() {
            return this._active;
          }
          set activeVersion(e4) {
            if (!this._providers[e4]) throw new Error(`unknown Unicode version "${e4}"`);
            this._active = e4, this._activeProvider = this._providers[e4], this._onChange.fire(e4);
          }
          register(e4) {
            this._providers[e4.version] = e4;
          }
          wcwidth(e4) {
            return this._activeProvider.wcwidth(e4);
          }
          getStringCellWidth(e4) {
            let t4 = 0, i3 = 0;
            const s3 = e4.length;
            for (let r2 = 0; r2 < s3; ++r2) {
              let o = e4.charCodeAt(r2);
              if (55296 <= o && o <= 56319) {
                if (++r2 >= s3) return t4 + this.wcwidth(o);
                const i4 = e4.charCodeAt(r2);
                56320 <= i4 && i4 <= 57343 ? o = 1024 * (o - 55296) + i4 - 56320 + 65536 : t4 += this.wcwidth(i4);
              }
              const a = this.charProperties(o, i3);
              let h = _n.extractWidth(a);
              _n.extractShouldJoin(a) && (h -= _n.extractWidth(i3)), t4 += h, i3 = a;
            }
            return t4;
          }
          charProperties(e4, t4) {
            return this._activeProvider.charProperties(e4, t4);
          }
        };
        __name(_n, "n");
        let n = _n;
        t3.UnicodeService = n;
      } }, t2 = {};
      function i(s2) {
        var r = t2[s2];
        if (void 0 !== r) return r.exports;
        var n = t2[s2] = { exports: {} };
        return e2[s2].call(n.exports, n, n.exports, i), n.exports;
      }
      __name(i, "i");
      var s = {};
      return (() => {
        var e3 = s;
        Object.defineProperty(e3, "__esModule", { value: true }), e3.Terminal = void 0;
        const t3 = i(9042), r = i(3236), n = i(844), o = i(5741), a = i(8285), h = i(7975), c = i(7090), l = ["cols", "rows"];
        const _d2 = class _d2 extends n.Disposable {
          constructor(e4) {
            super(), this._core = this.register(new r.Terminal(e4)), this._addonManager = this.register(new o.AddonManager()), this._publicOptions = { ...this._core.options };
            const t4 = /* @__PURE__ */ __name((e5) => this._core.options[e5], "t"), i2 = /* @__PURE__ */ __name((e5, t5) => {
              this._checkReadonlyOptions(e5), this._core.options[e5] = t5;
            }, "i");
            for (const e5 in this._core.options) {
              const s2 = { get: t4.bind(this, e5), set: i2.bind(this, e5) };
              Object.defineProperty(this._publicOptions, e5, s2);
            }
          }
          _checkReadonlyOptions(e4) {
            if (l.includes(e4)) throw new Error(`Option "${e4}" can only be set in the constructor`);
          }
          _checkProposedApi() {
            if (!this._core.optionsService.rawOptions.allowProposedApi) throw new Error("You must set the allowProposedApi option to true to use proposed API");
          }
          get onBell() {
            return this._core.onBell;
          }
          get onBinary() {
            return this._core.onBinary;
          }
          get onCursorMove() {
            return this._core.onCursorMove;
          }
          get onData() {
            return this._core.onData;
          }
          get onKey() {
            return this._core.onKey;
          }
          get onLineFeed() {
            return this._core.onLineFeed;
          }
          get onRender() {
            return this._core.onRender;
          }
          get onResize() {
            return this._core.onResize;
          }
          get onScroll() {
            return this._core.onScroll;
          }
          get onSelectionChange() {
            return this._core.onSelectionChange;
          }
          get onTitleChange() {
            return this._core.onTitleChange;
          }
          get onWriteParsed() {
            return this._core.onWriteParsed;
          }
          get element() {
            return this._core.element;
          }
          get parser() {
            return this._parser || (this._parser = new h.ParserApi(this._core)), this._parser;
          }
          get unicode() {
            return this._checkProposedApi(), new c.UnicodeApi(this._core);
          }
          get textarea() {
            return this._core.textarea;
          }
          get rows() {
            return this._core.rows;
          }
          get cols() {
            return this._core.cols;
          }
          get buffer() {
            return this._buffer || (this._buffer = this.register(new a.BufferNamespaceApi(this._core))), this._buffer;
          }
          get markers() {
            return this._checkProposedApi(), this._core.markers;
          }
          get modes() {
            const e4 = this._core.coreService.decPrivateModes;
            let t4 = "none";
            switch (this._core.coreMouseService.activeProtocol) {
              case "X10":
                t4 = "x10";
                break;
              case "VT200":
                t4 = "vt200";
                break;
              case "DRAG":
                t4 = "drag";
                break;
              case "ANY":
                t4 = "any";
            }
            return { applicationCursorKeysMode: e4.applicationCursorKeys, applicationKeypadMode: e4.applicationKeypad, bracketedPasteMode: e4.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: t4, originMode: e4.origin, reverseWraparoundMode: e4.reverseWraparound, sendFocusMode: e4.sendFocus, wraparoundMode: e4.wraparound };
          }
          get options() {
            return this._publicOptions;
          }
          set options(e4) {
            for (const t4 in e4) this._publicOptions[t4] = e4[t4];
          }
          blur() {
            this._core.blur();
          }
          focus() {
            this._core.focus();
          }
          input(e4, t4 = true) {
            this._core.input(e4, t4);
          }
          resize(e4, t4) {
            this._verifyIntegers(e4, t4), this._core.resize(e4, t4);
          }
          open(e4) {
            this._core.open(e4);
          }
          attachCustomKeyEventHandler(e4) {
            this._core.attachCustomKeyEventHandler(e4);
          }
          attachCustomWheelEventHandler(e4) {
            this._core.attachCustomWheelEventHandler(e4);
          }
          registerLinkProvider(e4) {
            return this._core.registerLinkProvider(e4);
          }
          registerCharacterJoiner(e4) {
            return this._checkProposedApi(), this._core.registerCharacterJoiner(e4);
          }
          deregisterCharacterJoiner(e4) {
            this._checkProposedApi(), this._core.deregisterCharacterJoiner(e4);
          }
          registerMarker(e4 = 0) {
            return this._verifyIntegers(e4), this._core.registerMarker(e4);
          }
          registerDecoration(e4) {
            return this._checkProposedApi(), this._verifyPositiveIntegers(e4.x ?? 0, e4.width ?? 0, e4.height ?? 0), this._core.registerDecoration(e4);
          }
          hasSelection() {
            return this._core.hasSelection();
          }
          select(e4, t4, i2) {
            this._verifyIntegers(e4, t4, i2), this._core.select(e4, t4, i2);
          }
          getSelection() {
            return this._core.getSelection();
          }
          getSelectionPosition() {
            return this._core.getSelectionPosition();
          }
          clearSelection() {
            this._core.clearSelection();
          }
          selectAll() {
            this._core.selectAll();
          }
          selectLines(e4, t4) {
            this._verifyIntegers(e4, t4), this._core.selectLines(e4, t4);
          }
          dispose() {
            super.dispose();
          }
          scrollLines(e4) {
            this._verifyIntegers(e4), this._core.scrollLines(e4);
          }
          scrollPages(e4) {
            this._verifyIntegers(e4), this._core.scrollPages(e4);
          }
          scrollToTop() {
            this._core.scrollToTop();
          }
          scrollToBottom() {
            this._core.scrollToBottom();
          }
          scrollToLine(e4) {
            this._verifyIntegers(e4), this._core.scrollToLine(e4);
          }
          clear() {
            this._core.clear();
          }
          write(e4, t4) {
            this._core.write(e4, t4);
          }
          writeln(e4, t4) {
            this._core.write(e4), this._core.write("\r\n", t4);
          }
          paste(e4) {
            this._core.paste(e4);
          }
          refresh(e4, t4) {
            this._verifyIntegers(e4, t4), this._core.refresh(e4, t4);
          }
          reset() {
            this._core.reset();
          }
          clearTextureAtlas() {
            this._core.clearTextureAtlas();
          }
          loadAddon(e4) {
            this._addonManager.loadAddon(this, e4);
          }
          static get strings() {
            return t3;
          }
          _verifyIntegers(...e4) {
            for (const t4 of e4) if (t4 === 1 / 0 || isNaN(t4) || t4 % 1 != 0) throw new Error("This API only accepts integers");
          }
          _verifyPositiveIntegers(...e4) {
            for (const t4 of e4) if (t4 && (t4 === 1 / 0 || isNaN(t4) || t4 % 1 != 0 || t4 < 0)) throw new Error("This API only accepts positive integers");
          }
        };
        __name(_d2, "d");
        let d = _d2;
        e3.Terminal = d;
      })(), s;
    })()));
  })(xterm);
  return xterm.exports;
}
__name(requireXterm, "requireXterm");
var xtermExports = requireXterm();
var addonAttach = { exports: {} };
var hasRequiredAddonAttach;
function requireAddonAttach() {
  if (hasRequiredAddonAttach) return addonAttach.exports;
  hasRequiredAddonAttach = 1;
  (function(module, exports) {
    !(function(e2, t2) {
      module.exports = t2();
    })(self, (() => (() => {
      var e2 = {};
      return (() => {
        var t2 = e2;
        function s(e3, t3, s2) {
          return e3.addEventListener(t3, s2), { dispose: /* @__PURE__ */ __name(() => {
            s2 && e3.removeEventListener(t3, s2);
          }, "dispose") };
        }
        __name(s, "s");
        Object.defineProperty(t2, "__esModule", { value: true }), t2.AttachAddon = void 0, t2.AttachAddon = class {
          constructor(e3, t3) {
            this._disposables = [], this._socket = e3, this._socket.binaryType = "arraybuffer", this._bidirectional = !(t3 && false === t3.bidirectional);
          }
          activate(e3) {
            this._disposables.push(s(this._socket, "message", ((t3) => {
              const s2 = t3.data;
              e3.write("string" == typeof s2 ? s2 : new Uint8Array(s2));
            }))), this._bidirectional && (this._disposables.push(e3.onData(((e4) => this._sendData(e4)))), this._disposables.push(e3.onBinary(((e4) => this._sendBinary(e4))))), this._disposables.push(s(this._socket, "close", (() => this.dispose()))), this._disposables.push(s(this._socket, "error", (() => this.dispose())));
          }
          dispose() {
            for (const e3 of this._disposables) e3.dispose();
          }
          _sendData(e3) {
            this._checkOpenSocket() && this._socket.send(e3);
          }
          _sendBinary(e3) {
            if (!this._checkOpenSocket()) return;
            const t3 = new Uint8Array(e3.length);
            for (let s2 = 0; s2 < e3.length; ++s2) t3[s2] = 255 & e3.charCodeAt(s2);
            this._socket.send(t3);
          }
          _checkOpenSocket() {
            switch (this._socket.readyState) {
              case WebSocket.OPEN:
                return true;
              case WebSocket.CONNECTING:
                throw new Error("Attach addon was loaded before socket was open");
              case WebSocket.CLOSING:
                return console.warn("Attach addon socket is closing"), false;
              case WebSocket.CLOSED:
                throw new Error("Attach addon socket is closed");
              default:
                throw new Error("Unexpected socket state");
            }
          }
        };
      })(), e2;
    })()));
  })(addonAttach);
  return addonAttach.exports;
}
__name(requireAddonAttach, "requireAddonAttach");
var addonAttachExports = requireAddonAttach();
var addonFit = { exports: {} };
var hasRequiredAddonFit;
function requireAddonFit() {
  if (hasRequiredAddonFit) return addonFit.exports;
  hasRequiredAddonFit = 1;
  (function(module, exports) {
    !(function(e2, t2) {
      module.exports = t2();
    })(self, (() => (() => {
      var e2 = {};
      return (() => {
        var t2 = e2;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.FitAddon = void 0, t2.FitAddon = class {
          activate(e3) {
            this._terminal = e3;
          }
          dispose() {
          }
          fit() {
            const e3 = this.proposeDimensions();
            if (!e3 || !this._terminal || isNaN(e3.cols) || isNaN(e3.rows)) return;
            const t3 = this._terminal._core;
            this._terminal.rows === e3.rows && this._terminal.cols === e3.cols || (t3._renderService.clear(), this._terminal.resize(e3.cols, e3.rows));
          }
          proposeDimensions() {
            if (!this._terminal) return;
            if (!this._terminal.element || !this._terminal.element.parentElement) return;
            const e3 = this._terminal._core, t3 = e3._renderService.dimensions;
            if (0 === t3.css.cell.width || 0 === t3.css.cell.height) return;
            const r = 0 === this._terminal.options.scrollback ? 0 : e3.viewport.scrollBarWidth, i = window.getComputedStyle(this._terminal.element.parentElement), o = parseInt(i.getPropertyValue("height")), s = Math.max(0, parseInt(i.getPropertyValue("width"))), n = window.getComputedStyle(this._terminal.element), l = o - (parseInt(n.getPropertyValue("padding-top")) + parseInt(n.getPropertyValue("padding-bottom"))), a = s - (parseInt(n.getPropertyValue("padding-right")) + parseInt(n.getPropertyValue("padding-left"))) - r;
            return { cols: Math.max(2, Math.floor(a / t3.css.cell.width)), rows: Math.max(1, Math.floor(l / t3.css.cell.height)) };
          }
        };
      })(), e2;
    })()));
  })(addonFit);
  return addonFit.exports;
}
__name(requireAddonFit, "requireAddonFit");
var addonFitExports = requireAddonFit();
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
__name(getLens, "getLens");
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
__name(byteLength, "byteLength");
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
__name(_byteLength, "_byteLength");
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
__name(toByteArray, "toByteArray");
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
__name(tripletToBase64, "tripletToBase64");
function encodeChunk(uint82, start, end) {
  var tmp;
  var output2 = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint82[i] << 16 & 16711680) + (uint82[i + 1] << 8 & 65280) + (uint82[i + 2] & 255);
    output2.push(tripletToBase64(tmp));
  }
  return output2.join("");
}
__name(encodeChunk, "encodeChunk");
function fromByteArray(uint82) {
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint82, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
__name(fromByteArray, "fromByteArray");
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e2, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer2[offset + i];
  i += d;
  e2 = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  m = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e2, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e2)) < 1) {
      e2--;
      c *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e2++;
      c /= 2;
    }
    if (e2 + eBias >= eMax) {
      m = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e2 & 255, i += d, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base64 = base64Js;
  const ieee754$12 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer3;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new GlobalUint8Array(1);
      const proto2 = { foo: /* @__PURE__ */ __name(function() {
        return 42;
      }, "foo") };
      Object.setPrototypeOf(proto2, GlobalUint8Array.prototype);
      Object.setPrototypeOf(arr, proto2);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  __name(typedArraySupport, "typedArraySupport");
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: /* @__PURE__ */ __name(function() {
      if (!Buffer3.isBuffer(this)) return void 0;
      return this.buffer;
    }, "get")
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: /* @__PURE__ */ __name(function() {
      if (!Buffer3.isBuffer(this)) return void 0;
      return this.byteOffset;
    }, "get")
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new GlobalUint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  __name(createBuffer, "createBuffer");
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  __name(Buffer3, "Buffer");
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (GlobalArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  __name(from, "from");
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, GlobalUint8Array.prototype);
  Object.setPrototypeOf(Buffer3, GlobalUint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  __name(assertSize, "assertSize");
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  __name(alloc, "alloc");
  Buffer3.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  __name(allocUnsafe, "allocUnsafe");
  Buffer3.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer3.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  __name(fromString, "fromString");
  function fromArrayLike(array2) {
    const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array2[i] & 255;
    }
    return buf;
  }
  __name(fromArrayLike, "fromArrayLike");
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, GlobalUint8Array)) {
      const copy2 = new GlobalUint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  __name(fromArrayView, "fromArrayView");
  function fromArrayBuffer(array2, byteOffset, length) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array2.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new GlobalUint8Array(array2);
    } else if (length === void 0) {
      buf = new GlobalUint8Array(array2, byteOffset);
    } else {
      buf = new GlobalUint8Array(array2, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  __name(fromArrayBuffer, "fromArrayBuffer");
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  __name(fromObject, "fromObject");
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  __name(checked, "checked");
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  __name(SlowBuffer, "SlowBuffer");
  Buffer3.isBuffer = /* @__PURE__ */ __name(function isBuffer2(b) {
    return b != null && b._isBuffer === true && b !== Buffer3.prototype;
  }, "isBuffer");
  Buffer3.compare = /* @__PURE__ */ __name(function compare(a, b) {
    if (isInstance(a, GlobalUint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
    if (isInstance(b, GlobalUint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
    if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for (let i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  }, "compare");
  Buffer3.isEncoding = /* @__PURE__ */ __name(function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, "isEncoding");
  Buffer3.concat = /* @__PURE__ */ __name(function concat2(list2, length) {
    if (!Array.isArray(list2)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list2.length === 0) {
      return Buffer3.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list2.length; ++i) {
        length += list2[i].length;
      }
    }
    const buffer2 = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list2.length; ++i) {
      let buf = list2[i];
      if (isInstance(buf, GlobalUint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
          buf.copy(buffer2, pos);
        } else {
          GlobalUint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  }, "concat");
  function byteLength2(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  __name(byteLength2, "byteLength");
  Buffer3.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  __name(slowToString, "slowToString");
  Buffer3.prototype._isBuffer = true;
  function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  __name(swap, "swap");
  Buffer3.prototype.swap16 = /* @__PURE__ */ __name(function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  }, "swap16");
  Buffer3.prototype.swap32 = /* @__PURE__ */ __name(function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  }, "swap32");
  Buffer3.prototype.swap64 = /* @__PURE__ */ __name(function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  }, "swap64");
  Buffer3.prototype.toString = /* @__PURE__ */ __name(function toString2() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  }, "toString");
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = /* @__PURE__ */ __name(function equals(b) {
    if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer3.compare(this, b) === 0;
  }, "equals");
  Buffer3.prototype.inspect = /* @__PURE__ */ __name(function inspect2() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
  }, "inspect");
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = /* @__PURE__ */ __name(function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, GlobalUint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  }, "compare");
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
        if (dir) {
          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  __name(bidirectionalIndexOf, "bidirectionalIndexOf");
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    __name(read2, "read");
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read2(arr, i + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  __name(arrayIndexOf, "arrayIndexOf");
  Buffer3.prototype.includes = /* @__PURE__ */ __name(function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  }, "includes");
  Buffer3.prototype.indexOf = /* @__PURE__ */ __name(function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  }, "indexOf");
  Buffer3.prototype.lastIndexOf = /* @__PURE__ */ __name(function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  }, "lastIndexOf");
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  __name(hexWrite, "hexWrite");
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  __name(utf8Write, "utf8Write");
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  __name(asciiWrite, "asciiWrite");
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  __name(base64Write, "base64Write");
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  __name(ucs2Write, "ucs2Write");
  Buffer3.prototype.write = /* @__PURE__ */ __name(function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }, "write");
  Buffer3.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  }, "toJSON");
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  __name(base64Slice, "base64Slice");
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  __name(utf8Slice, "utf8Slice");
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  __name(decodeCodePointsArray, "decodeCodePointsArray");
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  __name(asciiSlice, "asciiSlice");
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  __name(latin1Slice, "latin1Slice");
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  __name(hexSlice, "hexSlice");
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  __name(utf16leSlice, "utf16leSlice");
  Buffer3.prototype.slice = /* @__PURE__ */ __name(function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  }, "slice");
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  __name(checkOffset, "checkOffset");
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = /* @__PURE__ */ __name(function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  }, "readUIntLE");
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = /* @__PURE__ */ __name(function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  }, "readUIntBE");
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = /* @__PURE__ */ __name(function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  }, "readUInt8");
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = /* @__PURE__ */ __name(function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  }, "readUInt16LE");
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = /* @__PURE__ */ __name(function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  }, "readUInt16BE");
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = /* @__PURE__ */ __name(function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  }, "readUInt32LE");
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = /* @__PURE__ */ __name(function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  }, "readUInt32BE");
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  }, "readBigUInt64LE"));
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  }, "readBigUInt64BE"));
  Buffer3.prototype.readIntLE = /* @__PURE__ */ __name(function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  }, "readIntLE");
  Buffer3.prototype.readIntBE = /* @__PURE__ */ __name(function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  }, "readIntBE");
  Buffer3.prototype.readInt8 = /* @__PURE__ */ __name(function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  }, "readInt8");
  Buffer3.prototype.readInt16LE = /* @__PURE__ */ __name(function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  }, "readInt16LE");
  Buffer3.prototype.readInt16BE = /* @__PURE__ */ __name(function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  }, "readInt16BE");
  Buffer3.prototype.readInt32LE = /* @__PURE__ */ __name(function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  }, "readInt32LE");
  Buffer3.prototype.readInt32BE = /* @__PURE__ */ __name(function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  }, "readInt32BE");
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  }, "readBigInt64LE"));
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  }, "readBigInt64BE"));
  Buffer3.prototype.readFloatLE = /* @__PURE__ */ __name(function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$12.read(this, offset, true, 23, 4);
  }, "readFloatLE");
  Buffer3.prototype.readFloatBE = /* @__PURE__ */ __name(function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$12.read(this, offset, false, 23, 4);
  }, "readFloatBE");
  Buffer3.prototype.readDoubleLE = /* @__PURE__ */ __name(function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$12.read(this, offset, true, 52, 8);
  }, "readDoubleLE");
  Buffer3.prototype.readDoubleBE = /* @__PURE__ */ __name(function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$12.read(this, offset, false, 52, 8);
  }, "readDoubleBE");
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  __name(checkInt, "checkInt");
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = /* @__PURE__ */ __name(function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  }, "writeUIntLE");
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = /* @__PURE__ */ __name(function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  }, "writeUIntBE");
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = /* @__PURE__ */ __name(function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  }, "writeUInt8");
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = /* @__PURE__ */ __name(function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  }, "writeUInt16LE");
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = /* @__PURE__ */ __name(function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  }, "writeUInt16BE");
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = /* @__PURE__ */ __name(function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  }, "writeUInt32LE");
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = /* @__PURE__ */ __name(function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  }, "writeUInt32BE");
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  __name(wrtBigUInt64LE, "wrtBigUInt64LE");
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  __name(wrtBigUInt64BE, "wrtBigUInt64BE");
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  }, "writeBigUInt64LE"));
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  }, "writeBigUInt64BE"));
  Buffer3.prototype.writeIntLE = /* @__PURE__ */ __name(function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  }, "writeIntLE");
  Buffer3.prototype.writeIntBE = /* @__PURE__ */ __name(function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  }, "writeIntBE");
  Buffer3.prototype.writeInt8 = /* @__PURE__ */ __name(function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  }, "writeInt8");
  Buffer3.prototype.writeInt16LE = /* @__PURE__ */ __name(function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  }, "writeInt16LE");
  Buffer3.prototype.writeInt16BE = /* @__PURE__ */ __name(function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  }, "writeInt16BE");
  Buffer3.prototype.writeInt32LE = /* @__PURE__ */ __name(function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  }, "writeInt32LE");
  Buffer3.prototype.writeInt32BE = /* @__PURE__ */ __name(function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  }, "writeInt32BE");
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }, "writeBigInt64LE"));
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }, "writeBigInt64BE"));
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  __name(checkIEEE754, "checkIEEE754");
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$12.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  __name(writeFloat, "writeFloat");
  Buffer3.prototype.writeFloatLE = /* @__PURE__ */ __name(function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  }, "writeFloatLE");
  Buffer3.prototype.writeFloatBE = /* @__PURE__ */ __name(function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  }, "writeFloatBE");
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$12.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  __name(writeDouble, "writeDouble");
  Buffer3.prototype.writeDoubleLE = /* @__PURE__ */ __name(function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  }, "writeDoubleLE");
  Buffer3.prototype.writeDoubleBE = /* @__PURE__ */ __name(function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  }, "writeDoubleBE");
  Buffer3.prototype.copy = /* @__PURE__ */ __name(function copy2(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      GlobalUint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  }, "copy");
  Buffer3.prototype.fill = /* @__PURE__ */ __name(function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  }, "fill");
  const errors2 = {};
  function E(sym, getMessage, Base) {
    var _a2;
    errors2[sym] = (_a2 = class extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    }, __name(_a2, "NodeError"), _a2);
  }
  __name(E, "E");
  E(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E(
    "ERR_OUT_OF_RANGE",
    function(str, range2, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range2}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  __name(addNumericalSeparator, "addNumericalSeparator");
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  __name(checkBounds, "checkBounds");
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range2;
      {
        if (min === 0 || min === BigInt(0)) {
          range2 = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range2 = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  __name(checkIntBI, "checkIntBI");
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  __name(validateNumber, "validateNumber");
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors2.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length}`,
      value
    );
  }
  __name(boundsError, "boundsError");
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  __name(base64clean, "base64clean");
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  __name(utf8ToBytes, "utf8ToBytes");
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  __name(asciiToBytes, "asciiToBytes");
  function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  __name(utf16leToBytes, "utf16leToBytes");
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  __name(base64ToBytes, "base64ToBytes");
  function blitBuffer(src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  __name(blitBuffer, "blitBuffer");
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  __name(isInstance, "isInstance");
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  __name(numberIsNaN, "numberIsNaN");
  const hexSliceLookupTable = (function() {
    const alphabet = "0123456789abcdef";
    const table2 = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j = 0; j < 16; ++j) {
        table2[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table2;
  })();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  __name(defineBigIntMethod, "defineBigIntMethod");
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  __name(BufferBigIntNotDefined, "BufferBigIntNotDefined");
})(buffer);
const Buffer2 = buffer.Buffer;
var addonImage = { exports: {} };
var hasRequiredAddonImage;
function requireAddonImage() {
  if (hasRequiredAddonImage) return addonImage.exports;
  hasRequiredAddonImage = 1;
  (function(module, exports) {
    !(function(A, e2) {
      module.exports = e2();
    })(self, (() => (() => {
      var A = { 615: (A2, e3) => {
        function t3(A3) {
          if ("undefined" != typeof Buffer2) return Buffer2.from(A3, "base64");
          const e4 = atob(A3), t4 = new Uint8Array(e4.length);
          for (let A4 = 0; A4 < t4.length; ++A4) t4[A4] = e4.charCodeAt(A4);
          return t4;
        }
        __name(t3, "t");
        Object.defineProperty(e3, "__esModule", { value: true }), e3.InWasm = void 0, e3.InWasm = function(A3) {
          if (A3.d) {
            const { t: e4, s: i2, d: s } = A3;
            let r, g;
            const a = WebAssembly;
            return 2 === e4 ? i2 ? () => r || (r = t3(s)) : () => Promise.resolve(r || (r = t3(s))) : 1 === e4 ? i2 ? () => g || (g = new a.Module(r || (r = t3(s)))) : () => g ? Promise.resolve(g) : a.compile(r || (r = t3(s))).then(((A4) => g = A4)) : i2 ? (A4) => new a.Instance(g || (g = new a.Module(r || (r = t3(s)))), A4) : (A4) => g ? a.instantiate(g, A4) : a.instantiate(r || (r = t3(s)), A4).then(((A5) => (g = A5.module) && A5.instance));
          }
          if ("undefined" == typeof _wasmCtx) throw new Error('must run "inwasm"');
          _wasmCtx.add(A3);
        };
      }, 477: (A2, e3) => {
        function t3(A3) {
          return 255 & A3;
        }
        __name(t3, "t");
        function i2(A3) {
          return A3 >>> 8 & 255;
        }
        __name(i2, "i");
        function s(A3) {
          return A3 >>> 16 & 255;
        }
        __name(s, "s");
        function r(A3, e4, t4, i3 = 255) {
          return ((255 & i3) << 24 | (255 & t4) << 16 | (255 & e4) << 8 | 255 & A3) >>> 0;
        }
        __name(r, "r");
        function g(A3, e4, t4) {
          return Math.max(A3, Math.min(t4, e4));
        }
        __name(g, "g");
        function a(A3, e4, t4) {
          return t4 < 0 && (t4 += 1), t4 > 1 && (t4 -= 1), 6 * t4 < 1 ? e4 + 6 * (A3 - e4) * t4 : 2 * t4 < 1 ? A3 : 3 * t4 < 2 ? e4 + (A3 - e4) * (4 - 6 * t4) : e4;
        }
        __name(a, "a");
        function o(A3, e4, t4) {
          return (4278190080 | Math.round(t4 / 100 * 255) << 16 | Math.round(e4 / 100 * 255) << 8 | Math.round(A3 / 100 * 255)) >>> 0;
        }
        __name(o, "o");
        Object.defineProperty(e3, "__esModule", { value: true }), e3.DEFAULT_FOREGROUND = e3.DEFAULT_BACKGROUND = e3.PALETTE_ANSI_256 = e3.PALETTE_VT340_GREY = e3.PALETTE_VT340_COLOR = e3.normalizeHLS = e3.normalizeRGB = e3.nearestColorIndex = e3.fromRGBA8888 = e3.toRGBA8888 = e3.alpha = e3.blue = e3.green = e3.red = e3.BIG_ENDIAN = void 0, e3.BIG_ENDIAN = 255 === new Uint8Array(new Uint32Array([4278190080]).buffer)[0], e3.BIG_ENDIAN && console.warn("BE platform detected. This version of node-sixel works only on LE properly."), e3.red = t3, e3.green = i2, e3.blue = s, e3.alpha = function(A3) {
          return A3 >>> 24 & 255;
        }, e3.toRGBA8888 = r, e3.fromRGBA8888 = function(A3) {
          return [255 & A3, A3 >> 8 & 255, A3 >> 16 & 255, A3 >>> 24];
        }, e3.nearestColorIndex = function(A3, e4) {
          const r2 = t3(A3), g2 = i2(A3), a2 = s(A3);
          let o2 = Number.MAX_SAFE_INTEGER, h = -1;
          for (let A4 = 0; A4 < e4.length; ++A4) {
            const t4 = r2 - e4[A4][0], i3 = g2 - e4[A4][1], s2 = a2 - e4[A4][2], n = t4 * t4 + i3 * i3 + s2 * s2;
            if (!n) return A4;
            n < o2 && (o2 = n, h = A4);
          }
          return h;
        }, e3.normalizeRGB = o, e3.normalizeHLS = function(A3, e4, t4) {
          return (function(A4, e5, t5) {
            if (!t5) {
              const A5 = Math.round(255 * e5);
              return r(A5, A5, A5);
            }
            const i3 = e5 < 0.5 ? e5 * (1 + t5) : e5 + t5 - e5 * t5, s2 = 2 * e5 - i3;
            return r(g(0, 255, Math.round(255 * a(i3, s2, A4 + 1 / 3))), g(0, 255, Math.round(255 * a(i3, s2, A4))), g(0, 255, Math.round(255 * a(i3, s2, A4 - 1 / 3))));
          })((A3 + 240) / 360, e4 / 100, t4 / 100);
        }, e3.PALETTE_VT340_COLOR = new Uint32Array([o(0, 0, 0), o(20, 20, 80), o(80, 13, 13), o(20, 80, 20), o(80, 20, 80), o(20, 80, 80), o(80, 80, 20), o(53, 53, 53), o(26, 26, 26), o(33, 33, 60), o(60, 26, 26), o(33, 60, 33), o(60, 33, 60), o(33, 60, 60), o(60, 60, 33), o(80, 80, 80)]), e3.PALETTE_VT340_GREY = new Uint32Array([o(0, 0, 0), o(13, 13, 13), o(26, 26, 26), o(40, 40, 40), o(6, 6, 6), o(20, 20, 20), o(33, 33, 33), o(46, 46, 46), o(0, 0, 0), o(13, 13, 13), o(26, 26, 26), o(40, 40, 40), o(6, 6, 6), o(20, 20, 20), o(33, 33, 33), o(46, 46, 46)]), e3.PALETTE_ANSI_256 = (() => {
          const A3 = [r(0, 0, 0), r(205, 0, 0), r(0, 205, 0), r(205, 205, 0), r(0, 0, 238), r(205, 0, 205), r(0, 250, 205), r(229, 229, 229), r(127, 127, 127), r(255, 0, 0), r(0, 255, 0), r(255, 255, 0), r(92, 92, 255), r(255, 0, 255), r(0, 255, 255), r(255, 255, 255)], e4 = [0, 95, 135, 175, 215, 255];
          for (let t4 = 0; t4 < 6; ++t4) for (let i3 = 0; i3 < 6; ++i3) for (let s2 = 0; s2 < 6; ++s2) A3.push(r(e4[t4], e4[i3], e4[s2]));
          for (let e5 = 8; e5 <= 238; e5 += 10) A3.push(r(e5, e5, e5));
          return new Uint32Array(A3);
        })(), e3.DEFAULT_BACKGROUND = r(0, 0, 0, 255), e3.DEFAULT_FOREGROUND = r(255, 255, 255, 255);
      }, 710: (A2, e3, t3) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.decodeAsync = e3.decode = e3.Decoder = e3.DecoderAsync = void 0;
        const i2 = t3(477), s = t3(343), r = (function(A3) {
          if ("undefined" != typeof Buffer2) return Buffer2.from(A3, "base64");
          const e4 = atob(A3), t4 = new Uint8Array(e4.length);
          for (let A4 = 0; A4 < t4.length; ++A4) t4[A4] = e4.charCodeAt(A4);
          return t4;
        })(s.LIMITS.BYTES);
        let g;
        const a = new Uint32Array();
        const _o = class _o {
          constructor() {
            this.bandHandler = (A3) => 1, this.modeHandler = (A3) => 1;
          }
          handle_band(A3) {
            return this.bandHandler(A3);
          }
          mode_parsed(A3) {
            return this.modeHandler(A3);
          }
        };
        __name(_o, "o");
        let o = _o;
        const h = { memoryLimit: 134217728, sixelColor: i2.DEFAULT_FOREGROUND, fillColor: i2.DEFAULT_BACKGROUND, palette: i2.PALETTE_VT340_COLOR, paletteLimit: s.LIMITS.PALETTE_SIZE, truncate: true };
        function n(A3) {
          const e4 = new o(), t4 = { env: { handle_band: e4.handle_band.bind(e4), mode_parsed: e4.mode_parsed.bind(e4) } };
          return WebAssembly.instantiate(g || r, t4).then(((t5) => (g = g || t5.module, new I(A3, t5.instance || t5, e4))));
        }
        __name(n, "n");
        e3.DecoderAsync = n;
        const _I = class _I {
          constructor(A3, e4, t4) {
            if (this._PIXEL_OFFSET = s.LIMITS.MAX_WIDTH + 4, this._canvas = a, this._bandWidths = [], this._maxWidth = 0, this._minWidth = s.LIMITS.MAX_WIDTH, this._lastOffset = 0, this._currentHeight = 0, this._opts = Object.assign({}, h, A3), this._opts.paletteLimit > s.LIMITS.PALETTE_SIZE) throw new Error(`DecoderOptions.paletteLimit must not exceed ${s.LIMITS.PALETTE_SIZE}`);
            if (e4) t4.bandHandler = this._handle_band.bind(this), t4.modeHandler = this._initCanvas.bind(this);
            else {
              const A4 = g || (g = new WebAssembly.Module(r));
              e4 = new WebAssembly.Instance(A4, { env: { handle_band: this._handle_band.bind(this), mode_parsed: this._initCanvas.bind(this) } });
            }
            this._instance = e4, this._wasm = this._instance.exports, this._chunk = new Uint8Array(this._wasm.memory.buffer, this._wasm.get_chunk_address(), s.LIMITS.CHUNK_SIZE), this._states = new Uint32Array(this._wasm.memory.buffer, this._wasm.get_state_address(), 12), this._palette = new Uint32Array(this._wasm.memory.buffer, this._wasm.get_palette_address(), s.LIMITS.PALETTE_SIZE), this._palette.set(this._opts.palette), this._pSrc = new Uint32Array(this._wasm.memory.buffer, this._wasm.get_p0_address()), this._wasm.init(i2.DEFAULT_FOREGROUND, 0, this._opts.paletteLimit, 0);
          }
          get _fillColor() {
            return this._states[0];
          }
          get _truncate() {
            return this._states[8];
          }
          get _rasterWidth() {
            return this._states[6];
          }
          get _rasterHeight() {
            return this._states[7];
          }
          get _width() {
            return this._states[2] ? this._states[2] - 4 : 0;
          }
          get _height() {
            return this._states[3];
          }
          get _level() {
            return this._states[9];
          }
          get _mode() {
            return this._states[10];
          }
          get _paletteLimit() {
            return this._states[11];
          }
          _initCanvas(A3) {
            if (2 === A3) {
              const A4 = this.width * this.height;
              if (A4 > this._canvas.length) {
                if (this._opts.memoryLimit && 4 * A4 > this._opts.memoryLimit) throw this.release(), new Error("image exceeds memory limit");
                this._canvas = new Uint32Array(A4);
              }
              this._maxWidth = this._width;
            } else if (1 === A3) if (2 === this._level) {
              const A4 = Math.min(this._rasterWidth, s.LIMITS.MAX_WIDTH) * this._rasterHeight;
              if (A4 > this._canvas.length) {
                if (this._opts.memoryLimit && 4 * A4 > this._opts.memoryLimit) throw this.release(), new Error("image exceeds memory limit");
                this._canvas = new Uint32Array(A4);
              }
            } else this._canvas.length < 65536 && (this._canvas = new Uint32Array(65536));
            return 0;
          }
          _realloc(A3, e4) {
            const t4 = A3 + e4;
            if (t4 > this._canvas.length) {
              if (this._opts.memoryLimit && 4 * t4 > this._opts.memoryLimit) throw this.release(), new Error("image exceeds memory limit");
              const A4 = new Uint32Array(65536 * Math.ceil(t4 / 65536));
              A4.set(this._canvas), this._canvas = A4;
            }
          }
          _handle_band(A3) {
            const e4 = this._PIXEL_OFFSET;
            let t4 = this._lastOffset;
            if (2 === this._mode) {
              let i3 = this.height - this._currentHeight, s2 = 0;
              for (; s2 < 6 && i3 > 0; ) this._canvas.set(this._pSrc.subarray(e4 * s2, e4 * s2 + A3), t4 + A3 * s2), s2++, i3--;
              this._lastOffset += A3 * s2, this._currentHeight += s2;
            } else if (1 === this._mode) {
              this._realloc(t4, 6 * A3), this._maxWidth = Math.max(this._maxWidth, A3), this._minWidth = Math.min(this._minWidth, A3);
              for (let i3 = 0; i3 < 6; ++i3) this._canvas.set(this._pSrc.subarray(e4 * i3, e4 * i3 + A3), t4 + A3 * i3);
              this._bandWidths.push(A3), this._lastOffset += 6 * A3, this._currentHeight += 6;
            }
            return 0;
          }
          get width() {
            return 1 !== this._mode ? this._width : Math.max(this._maxWidth, this._wasm.current_width());
          }
          get height() {
            return 1 !== this._mode ? this._height : this._wasm.current_width() ? 6 * this._bandWidths.length + this._wasm.current_height() : 6 * this._bandWidths.length;
          }
          get palette() {
            return this._palette.subarray(0, this._paletteLimit);
          }
          get memoryUsage() {
            return this._canvas.byteLength + this._wasm.memory.buffer.byteLength + 8 * this._bandWidths.length;
          }
          get properties() {
            return { width: this.width, height: this.height, mode: this._mode, level: this._level, truncate: !!this._truncate, paletteLimit: this._paletteLimit, fillColor: this._fillColor, memUsage: this.memoryUsage, rasterAttributes: { numerator: this._states[4], denominator: this._states[5], width: this._rasterWidth, height: this._rasterHeight } };
          }
          init(A3 = this._opts.fillColor, e4 = this._opts.palette, t4 = this._opts.paletteLimit, i3 = this._opts.truncate) {
            this._wasm.init(this._opts.sixelColor, A3, t4, i3 ? 1 : 0), e4 && this._palette.set(e4.subarray(0, s.LIMITS.PALETTE_SIZE)), this._bandWidths.length = 0, this._maxWidth = 0, this._minWidth = s.LIMITS.MAX_WIDTH, this._lastOffset = 0, this._currentHeight = 0;
          }
          decode(A3, e4 = 0, t4 = A3.length) {
            let i3 = e4;
            for (; i3 < t4; ) {
              const e5 = Math.min(t4 - i3, s.LIMITS.CHUNK_SIZE);
              this._chunk.set(A3.subarray(i3, i3 += e5)), this._wasm.decode(0, e5);
            }
          }
          decodeString(A3, e4 = 0, t4 = A3.length) {
            let i3 = e4;
            for (; i3 < t4; ) {
              const e5 = Math.min(t4 - i3, s.LIMITS.CHUNK_SIZE);
              for (let t5 = 0, s2 = i3; t5 < e5; ++t5, ++s2) this._chunk[t5] = A3.charCodeAt(s2);
              i3 += e5, this._wasm.decode(0, e5);
            }
          }
          get data32() {
            if (0 === this._mode || !this.width || !this.height) return a;
            const A3 = this._wasm.current_width();
            if (2 === this._mode) {
              let e4 = this.height - this._currentHeight;
              if (e4 > 0) {
                const t4 = this._PIXEL_OFFSET;
                let i3 = this._lastOffset, s2 = 0;
                for (; s2 < 6 && e4 > 0; ) this._canvas.set(this._pSrc.subarray(t4 * s2, t4 * s2 + A3), i3 + A3 * s2), s2++, e4--;
                e4 && this._canvas.fill(this._fillColor, i3 + A3 * s2);
              }
              return this._canvas.subarray(0, this.width * this.height);
            }
            if (1 === this._mode) {
              if (this._minWidth === this._maxWidth) {
                let e5 = false;
                if (A3) if (A3 !== this._minWidth) e5 = true;
                else {
                  const e6 = this._PIXEL_OFFSET;
                  let t5 = this._lastOffset;
                  this._realloc(t5, 6 * A3);
                  for (let i4 = 0; i4 < 6; ++i4) this._canvas.set(this._pSrc.subarray(e6 * i4, e6 * i4 + A3), t5 + A3 * i4);
                }
                if (!e5) return this._canvas.subarray(0, this.width * this.height);
              }
              const e4 = new Uint32Array(this.width * this.height);
              e4.fill(this._fillColor);
              let t4 = 0, i3 = 0;
              for (let A4 = 0; A4 < this._bandWidths.length; ++A4) {
                const s2 = this._bandWidths[A4];
                for (let A5 = 0; A5 < 6; ++A5) e4.set(this._canvas.subarray(i3, i3 += s2), t4), t4 += this.width;
              }
              if (A3) {
                const i4 = this._PIXEL_OFFSET, s2 = this._wasm.current_height();
                for (let r2 = 0; r2 < s2; ++r2) e4.set(this._pSrc.subarray(i4 * r2, i4 * r2 + A3), t4 + this.width * r2);
              }
              return e4;
            }
            return a;
          }
          get data8() {
            return new Uint8ClampedArray(this.data32.buffer, 0, this.width * this.height * 4);
          }
          release() {
            this._canvas = a, this._bandWidths.length = 0, this._maxWidth = 0, this._minWidth = s.LIMITS.MAX_WIDTH, this._wasm.init(i2.DEFAULT_FOREGROUND, 0, this._opts.paletteLimit, 0);
          }
        };
        __name(_I, "I");
        let I = _I;
        e3.Decoder = I, e3.decode = function(A3, e4) {
          const t4 = new I(e4);
          return t4.init(), "string" == typeof A3 ? t4.decodeString(A3) : t4.decode(A3), { width: t4.width, height: t4.height, data32: t4.data32, data8: t4.data8 };
        }, e3.decodeAsync = async function(A3, e4) {
          const t4 = await n(e4);
          return t4.init(), "string" == typeof A3 ? t4.decodeString(A3) : t4.decode(A3), { width: t4.width, height: t4.height, data32: t4.data32, data8: t4.data8 };
        };
      }, 343: (A2, e3) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.LIMITS = void 0, e3.LIMITS = { CHUNK_SIZE: 16384, PALETTE_SIZE: 4096, MAX_WIDTH: 16384, BYTES: "AGFzbQEAAAABJAdgAAF/YAJ/fwBgA39/fwF/YAF/AX9gAABgBH9/f38AYAF/AAIlAgNlbnYLaGFuZGxlX2JhbmQAAwNlbnYLbW9kZV9wYXJzZWQAAwMTEgQAAAAAAQQBAQUBAAACAgAGAwQFAXABBwcFBAEBBwcGCAF/AUGAihoLB9wBDgZtZW1vcnkCABFnZXRfc3RhdGVfYWRkcmVzcwADEWdldF9jaHVua19hZGRyZXNzAAQOZ2V0X3AwX2FkZHJlc3MABRNnZXRfcGFsZXR0ZV9hZGRyZXNzAAYEaW5pdAALBmRlY29kZQAMDWN1cnJlbnRfd2lkdGgADQ5jdXJyZW50X2hlaWdodAAOGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtfaW5pdGlhbGl6ZQACCXN0YWNrU2F2ZQARDHN0YWNrUmVzdG9yZQASCnN0YWNrQWxsb2MAEwkMAQBBAQsGCgcJDxACDAEBCq5UEgMAAQsFAEGgCAsGAEGQiQELBgBBsIkCCwUAQZAJC+okAQh/QeQIKAIAIQVB4AgoAgAhA0HoCCgCACEIIAFBkIkBaiIJQf8BOgAAIAAgAUgEQCAAQZCJAWohBgNAIAMhBCAGQQFqIQECQCAGLQAAQf8AcSIDQTBrQQlLBEAgASEGDAELQewIKAIAQQJ0QewIaiICKAIAIQADQCACIAMgAEEKbGpBMGsiADYCACABLQAAIQMgAUEBaiIGIQEgA0H/AHEiA0Ewa0EKSQ0ACwsCQAJAAkACQAJAAkACQAJ/AkACQCADQT9rIgBBP00EQCAERQ0BIARBIUYEQAJAQfAIKAIAIgFBASABGyIHIAhqIgFB1AgoAgAiA0gNACADQf//AEoNAANAIANBAnQiAkGgiQJqIgRBoAgpAwA3AwAgAkGoiQJqQaAIKQMANwMAIAJBsIkCakGgCCkDADcDACACQbiJAmpBoAgpAwA3AwAgAkHAiQJqQaAIKQMANwMAIAJByIkCakGgCCkDADcDACACQdCJAmpBoAgpAwA3AwAgAkHYiQJqQaAIKQMANwMAIAJB4IkCakGgCCkDADcDACACQeiJAmpBoAgpAwA3AwAgAkHwiQJqQaAIKQMANwMAIAJB+IkCakGgCCkDADcDACACQYCKAmpBoAgpAwA3AwAgAkGIigJqQaAIKQMANwMAIAJBkIoCakGgCCkDADcDACACQZiKAmpBoAgpAwA3AwAgAkGgigJqQaAIKQMANwMAIAJBqIoCakGgCCkDADcDACACQbCKAmpBoAgpAwA3AwAgAkG4igJqQaAIKQMANwMAIAJBwIoCakGgCCkDADcDACACQciKAmpBoAgpAwA3AwAgAkHQigJqQaAIKQMANwMAIAJB2IoCakGgCCkDADcDACACQeCKAmpBoAgpAwA3AwAgAkHoigJqQaAIKQMANwMAIAJB8IoCakGgCCkDADcDACACQfiKAmpBoAgpAwA3AwAgAkGAiwJqQaAIKQMANwMAIAJBiIsCakGgCCkDADcDACACQZCLAmpBoAgpAwA3AwAgAkGYiwJqQaAIKQMANwMAIAJBoIsCakGgCCkDADcDACACQaiLAmpBoAgpAwA3AwAgAkGwiwJqQaAIKQMANwMAIAJBuIsCakGgCCkDADcDACACQcCLAmpBoAgpAwA3AwAgAkHIiwJqQaAIKQMANwMAIAJB0IsCakGgCCkDADcDACACQdiLAmpBoAgpAwA3AwAgAkHgiwJqQaAIKQMANwMAIAJB6IsCakGgCCkDADcDACACQfCLAmpBoAgpAwA3AwAgAkH4iwJqQaAIKQMANwMAIAJBgIwCakGgCCkDADcDACACQYiMAmpBoAgpAwA3AwAgAkGQjAJqQaAIKQMANwMAIAJBmIwCakGgCCkDADcDACACQaCMAmpBoAgpAwA3AwAgAkGojAJqQaAIKQMANwMAIAJBsIwCakGgCCkDADcDACACQbiMAmpBoAgpAwA3AwAgAkHAjAJqQaAIKQMANwMAIAJByIwCakGgCCkDADcDACACQdCMAmpBoAgpAwA3AwAgAkHYjAJqQaAIKQMANwMAIAJB4IwCakGgCCkDADcDACACQeiMAmpBoAgpAwA3AwAgAkHwjAJqQaAIKQMANwMAIAJB+IwCakGgCCkDADcDACACQYCNAmpBoAgpAwA3AwAgAkGIjQJqQaAIKQMANwMAIAJBkI0CakGgCCkDADcDACACQZiNAmpBoAgpAwA3AwAgAkGwiQZqIARBgAT8CgAAQdQIKAIAQQJ0QcCJCmogBEGABPwKAABB1AgoAgBBAnRB0IkOaiAEQYAE/AoAAEHUCCgCAEECdEHgiRJqIARBgAT8CgAAQdQIKAIAQQJ0QfCJFmogBEGABPwKAABB1AhB1AgoAgAiAkGAAWoiAzYCACABIANIDQEgAkGA/wBIDQALCwJAIABFDQAgCEH//wBLDQBBgIABIAhrIAcgAUH//wBLGyECAkAgAEEBcUUNACACRQ0AIAhBAnRBoIkCaiEDIAIhBCACQQdxIgcEQANAIAMgBTYCACADQQRqIQMgBEEBayEEIAdBAWsiBw0ACwsgAkEBa0EHSQ0AA0AgAyAFNgIcIAMgBTYCGCADIAU2AhQgAyAFNgIQIAMgBTYCDCADIAU2AgggAyAFNgIEIAMgBTYCACADQSBqIQMgBEEIayIEDQALCwJAIABBAnFFDQAgAkUNACAIQQJ0QbCJBmohAyACIQQgAkEHcSIHBEADQCADIAU2AgAgA0EEaiEDIARBAWshBCAHQQFrIgcNAAsLIAJBAWtBB0kNAANAIAMgBTYCHCADIAU2AhggAyAFNgIUIAMgBTYCECADIAU2AgwgAyAFNgIIIAMgBTYCBCADIAU2AgAgA0EgaiEDIARBCGsiBA0ACwsCQCAAQQRxRQ0AIAJFDQAgCEECdEHAiQpqIQMgAiEEIAJBB3EiBwRAA0AgAyAFNgIAIANBBGohAyAEQQFrIQQgB0EBayIHDQALCyACQQFrQQdJDQADQCADIAU2AhwgAyAFNgIYIAMgBTYCFCADIAU2AhAgAyAFNgIMIAMgBTYCCCADIAU2AgQgAyAFNgIAIANBIGohAyAEQQhrIgQNAAsLAkAgAEEIcUUNACACRQ0AIAhBAnRB0IkOaiEDIAIhBCACQQdxIgcEQANAIAMgBTYCACADQQRqIQMgBEEBayEEIAdBAWsiBw0ACwsgAkEBa0EHSQ0AA0AgAyAFNgIcIAMgBTYCGCADIAU2AhQgAyAFNgIQIAMgBTYCDCADIAU2AgggAyAFNgIEIAMgBTYCACADQSBqIQMgBEEIayIEDQALCwJAIABBEHFFDQAgAkUNACAIQQJ0QeCJEmohAyACIQQgAkEHcSIHBEADQCADIAU2AgAgA0EEaiEDIARBAWshBCAHQQFrIgcNAAsLIAJBAWtBB0kNAANAIAMgBTYCHCADIAU2AhggAyAFNgIUIAMgBTYCECADIAU2AgwgAyAFNgIIIAMgBTYCBCADIAU2AgAgA0EgaiEDIARBCGsiBA0ACwsgAEEgcUUNACACRQ0AIAJBAWshByAIQQJ0QfCJFmohAyACQQdxIgQEQANAIAMgBTYCACADQQRqIQMgAkEBayECIARBAWsiBA0ACwsgB0EHSQ0AA0AgAyAFNgIcIAMgBTYCGCADIAU2AhQgAyAFNgIQIAMgBTYCDCADIAU2AgggAyAFNgIEIAMgBTYCACADQSBqIQMgAkEIayICDQALC0HcCEHcCCgCACAAcjYCACAGQQFqIgIgBi0AAEH/AHEiA0E/ayIAQT9LDQQaDAMLAkBB7AgoAgAiBEEBRgRAQfAIKAIAIgNBzAgoAgAiAUkNASADIAFwIQMMAQtB+AgoAgAhAkH0CCgCACEBAkACQCAEQQVHDQAgAUEBRw0AIAJB6QJODQQMAQsgAkHkAEoNA0H8CCgCAEHkAEoNA0GACSgCAEHkAEoNAwsCQCABRQ0AIAFBAkoNACACQfwIKAIAQYAJKAIAIAFBAnRBiAhqKAIAEQIAIQFB8AgoAgAiA0HMCCgCACICTwR/IAMgAnAFIAMLQQJ0QZAJaiABNgIAC0HwCCgCACIDQcwIKAIAIgFJDQAgAyABcCEDCyADQQJ0QZAJaigCACEFDAELIANB/QBxQSFHBEAgCCEBIAYhAgwECyAEQSNHDQQCQEHsCCgCACICQQFGBEBB8AgoAgAiAUHMCCgCACIASQ0BIAEgAHAhAQwBC0H4CCgCACEBQfQIKAIAIQACQAJAIAJBBUcNACAAQQFHDQAgAUHpAkgNAQwHCyABQeQASg0GQfwIKAIAQeQASg0GQYAJKAIAQeQASg0GCwJAIABFDQAgAEECSg0AIAFB/AgoAgBBgAkoAgAgAEECdEGICGooAgARAgAhAEHwCCgCACIBQcwIKAIAIgJPBH8gASACcAUgAQtBAnRBkAlqIAA2AgALQfAIKAIAIgFBzAgoAgAiAEkNACABIABwIQELIAFBAnRBkAlqKAIAIQUMBAsgCCEBIAYhAgtB1AgoAgAhBgNAAkAgASAGSA0AIAZB//8ASg0AIAZBAnQiBEGgiQJqIgZBoAgpAwA3AwAgBEGoiQJqQaAIKQMANwMAIARBsIkCakGgCCkDADcDACAEQbiJAmpBoAgpAwA3AwAgBEHAiQJqQaAIKQMANwMAIARByIkCakGgCCkDADcDACAEQdCJAmpBoAgpAwA3AwAgBEHYiQJqQaAIKQMANwMAIARB4IkCakGgCCkDADcDACAEQeiJAmpBoAgpAwA3AwAgBEHwiQJqQaAIKQMANwMAIARB+IkCakGgCCkDADcDACAEQYCKAmpBoAgpAwA3AwAgBEGIigJqQaAIKQMANwMAIARBkIoCakGgCCkDADcDACAEQZiKAmpBoAgpAwA3AwAgBEGgigJqQaAIKQMANwMAIARBqIoCakGgCCkDADcDACAEQbCKAmpBoAgpAwA3AwAgBEG4igJqQaAIKQMANwMAIARBwIoCakGgCCkDADcDACAEQciKAmpBoAgpAwA3AwAgBEHQigJqQaAIKQMANwMAIARB2IoCakGgCCkDADcDACAEQeCKAmpBoAgpAwA3AwAgBEHoigJqQaAIKQMANwMAIARB8IoCakGgCCkDADcDACAEQfiKAmpBoAgpAwA3AwAgBEGAiwJqQaAIKQMANwMAIARBiIsCakGgCCkDADcDACAEQZCLAmpBoAgpAwA3AwAgBEGYiwJqQaAIKQMANwMAIARBoIsCakGgCCkDADcDACAEQaiLAmpBoAgpAwA3AwAgBEGwiwJqQaAIKQMANwMAIARBuIsCakGgCCkDADcDACAEQcCLAmpBoAgpAwA3AwAgBEHIiwJqQaAIKQMANwMAIARB0IsCakGgCCkDADcDACAEQdiLAmpBoAgpAwA3AwAgBEHgiwJqQaAIKQMANwMAIARB6IsCakGgCCkDADcDACAEQfCLAmpBoAgpAwA3AwAgBEH4iwJqQaAIKQMANwMAIARBgIwCakGgCCkDADcDACAEQYiMAmpBoAgpAwA3AwAgBEGQjAJqQaAIKQMANwMAIARBmIwCakGgCCkDADcDACAEQaCMAmpBoAgpAwA3AwAgBEGojAJqQaAIKQMANwMAIARBsIwCakGgCCkDADcDACAEQbiMAmpBoAgpAwA3AwAgBEHAjAJqQaAIKQMANwMAIARByIwCakGgCCkDADcDACAEQdCMAmpBoAgpAwA3AwAgBEHYjAJqQaAIKQMANwMAIARB4IwCakGgCCkDADcDACAEQeiMAmpBoAgpAwA3AwAgBEHwjAJqQaAIKQMANwMAIARB+IwCakGgCCkDADcDACAEQYCNAmpBoAgpAwA3AwAgBEGIjQJqQaAIKQMANwMAIARBkI0CakGgCCkDADcDACAEQZiNAmpBoAgpAwA3AwAgBEGwiQZqIAZBgAT8CgAAQdQIKAIAQQJ0QcCJCmogBkGABPwKAABB1AgoAgBBAnRB0IkOaiAGQYAE/AoAAEHUCCgCAEECdEHgiRJqIAZBgAT8CgAAQdQIKAIAQQJ0QfCJFmogBkGABPwKAABB1AhB1AgoAgBBgAFqIgY2AgALIAFB//8ATQRAIABBAXEgAWxBAnRBoIkCaiAFNgIAIABBAXZBAXEgAWxBAnRBsIkGaiAFNgIAIABBAnZBAXEgAWxBAnRBwIkKaiAFNgIAIABBA3ZBAXEgAWxBAnRB0IkOaiAFNgIAIABBBHZBAXEgAWxBAnRB4IkSaiAFNgIAIABBBXYgAWxBAnRB8IkWaiAFNgIAQdQIKAIAIQYLIAFBAWohAUHcCEHcCCgCACAAcjYCACACLQAAIQAgAkEBaiIEIQIgAEH/AHEiA0E/ayIAQcAASQ0ACyAECyECQQAhBCACIQYgASEIIANB/QBxQSFGDQELIANBJGsOCgEDAwMDAwMDAwIDC0HsCEIBNwIADAQLQdgIIAFB2AgoAgAiACAAIAFIGyIAQYCAASAAQYCAAUgbNgIADAILQegIIAFB2AgoAgAiACAAIAFIGyIAQYCAASAAQYCAAUgbIgA2AgBB2AggADYCACAAQQRrEAAEQEHoCEEENgIAQdgIQQQ2AgBB0AhBATYCAA8LEAgMAQsCQCADQTtHDQBB7AgoAgAiAEEHSg0AQewIIABBAWo2AgAgAEECdEHwCGpBADYCAAsgAiEGIAQhAyABIQgMAQtBBCEIIAIhBiAEIQMLIAYgCUkNAAsLQeQIIAU2AgBB4AggAzYCAEHoCCAINgIAC9ELAgF+CH9B2AhCBDcDAEGojQJBoAgpAwAiADcDAEGgjQIgADcDAEGYjQIgADcDAEGQjQIgADcDAEGIjQIgADcDAEGAjQIgADcDAEH4jAIgADcDAEHwjAIgADcDAEHojAIgADcDAEHgjAIgADcDAEHYjAIgADcDAEHQjAIgADcDAEHIjAIgADcDAEHAjAIgADcDAEG4jAIgADcDAEGwjAIgADcDAEGojAIgADcDAEGgjAIgADcDAEGYjAIgADcDAEGQjAIgADcDAEGIjAIgADcDAEGAjAIgADcDAEH4iwIgADcDAEHwiwIgADcDAEHoiwIgADcDAEHgiwIgADcDAEHYiwIgADcDAEHQiwIgADcDAEHIiwIgADcDAEHAiwIgADcDAEG4iwIgADcDAEGwiwIgADcDAEGoiwIgADcDAEGgiwIgADcDAEGYiwIgADcDAEGQiwIgADcDAEGIiwIgADcDAEGAiwIgADcDAEH4igIgADcDAEHwigIgADcDAEHoigIgADcDAEHgigIgADcDAEHYigIgADcDAEHQigIgADcDAEHIigIgADcDAEHAigIgADcDAEG4igIgADcDAEGwigIgADcDAEGoigIgADcDAEGgigIgADcDAEGYigIgADcDAEGQigIgADcDAEGIigIgADcDAEGAigIgADcDAEH4iQIgADcDAEHwiQIgADcDAEHoiQIgADcDAEHgiQIgADcDAEHYiQIgADcDAEHQiQIgADcDAEHIiQIgADcDAEHAiQIgADcDAEG4iQIgADcDAEGwiQIgADcDAEGoCCgCACIEQf8AakGAAW0hCAJAIARBgQFIDQBBASEBIAhBAiAIQQJKG0EBayICQQFxIQMgBEGBAk4EQCACQX5xIQIDQCABQQl0IgdBEHJBoIkCakGwiQJBgAT8CgAAIAdBsI0CakGwiQJBgAT8CgAAIAFBAmohASACQQJrIgINAAsLIANFDQAgAUEJdEEQckGgiQJqQbCJAkGABPwKAAALAkAgBEEBSA0AIAhBASAIQQFKGyIDQQFxIQUCQCADQQFrIgdFBEBBACEBDAELIANB/v///wdxIQJBACEBA0AgAUEJdCIGQRByQbCJBmpBsIkCQYAE/AoAACAGQZAEckGwiQZqQbCJAkGABPwKAAAgAUECaiEBIAJBAmsiAg0ACwsgBQRAIAFBCXRBEHJBsIkGakGwiQJBgAT8CgAACyAEQQFIDQAgA0EBcSEFIAcEfyADQf7///8HcSECQQAhAQNAIAFBCXQiBkEQckHAiQpqQbCJAkGABPwKAAAgBkGQBHJBwIkKakGwiQJBgAT8CgAAIAFBAmohASACQQJrIgINAAsgAUEHdEEEcgVBBAshASAFBEAgAUECdEHAiQpqQbCJAkGABPwKAAALIARBAUgNACADQQFxIQUgBwR/IANB/v///wdxIQJBACEBA0AgAUEJdCIGQRByQdCJDmpBsIkCQYAE/AoAACAGQZAEckHQiQ5qQbCJAkGABPwKAAAgAUECaiEBIAJBAmsiAg0ACyABQQd0QQRyBUEECyEBIAUEQCABQQJ0QdCJDmpBsIkCQYAE/AoAAAsgBEEBSA0AIANBAXEhBSAHBH8gA0H+////B3EhAkEAIQEDQCABQQl0IgZBEHJB4IkSakGwiQJBgAT8CgAAIAZBkARyQeCJEmpBsIkCQYAE/AoAACABQQJqIQEgAkECayICDQALIAFBB3RBBHIFQQQLIQEgBQRAIAFBAnRB4IkSakGwiQJBgAT8CgAACyAEQQFIDQAgA0EBcSEEIAcEfyADQf7///8HcSECQQAhAQNAIAFBCXQiA0EQckHwiRZqQbCJAkGABPwKAAAgA0GQBHJB8IkWakGwiQJBgAT8CgAAIAFBAmohASACQQJrIgINAAsgAUEHdEEEcgVBBAshASAERQ0AIAFBAnRB8IkWakGwiQJBgAT8CgAAC0HUCCAIQQd0QQRyNgIAC58TAgh/AX5B5AgoAgAhA0HgCCgCACECQegIKAIAIQcgAUGQiQFqIglB/wE6AAAgACABSARAIABBkIkBaiEIA0AgAiEEIAhBAWohAQJAIAgtAABB/wBxIgJBMGtBCUsEQCABIQgMAQtB7AgoAgBBAnRB7AhqIgUoAgAhAANAIAUgAiAAQQpsakEwayIANgIAIAEtAAAhAiABQQFqIgghASACQf8AcSICQTBrQQpJDQALCwJAAkACQAJAAkACQAJ/AkAgAkE/ayIAQT9NBEAgBEUNASAEQSFGBEBB8AgoAgAiAUEBIAEbIgQgB2ohAQJAIABFDQAgB0H//wBLDQBBgIABIAdrIAQgAUH//wBLGyEFAkAgAEEBcUUNACAHQQJ0QaCJAmohAiAFIgRBB3EiBgRAA0AgAiADNgIAIAJBBGohAiAEQQFrIQQgBkEBayIGDQALCyAFQQFrQQdJDQADQCACIAM2AhwgAiADNgIYIAIgAzYCFCACIAM2AhAgAiADNgIMIAIgAzYCCCACIAM2AgQgAiADNgIAIAJBIGohAiAEQQhrIgQNAAsLAkAgAEECcUUNACAHQQJ0QbCJBmohAiAFIgRBB3EiBgRAA0AgAiADNgIAIAJBBGohAiAEQQFrIQQgBkEBayIGDQALCyAFQQFrQQdJDQADQCACIAM2AhwgAiADNgIYIAIgAzYCFCACIAM2AhAgAiADNgIMIAIgAzYCCCACIAM2AgQgAiADNgIAIAJBIGohAiAEQQhrIgQNAAsLAkAgAEEEcUUNACAHQQJ0QcCJCmohAiAFIgRBB3EiBgRAA0AgAiADNgIAIAJBBGohAiAEQQFrIQQgBkEBayIGDQALCyAFQQFrQQdJDQADQCACIAM2AhwgAiADNgIYIAIgAzYCFCACIAM2AhAgAiADNgIMIAIgAzYCCCACIAM2AgQgAiADNgIAIAJBIGohAiAEQQhrIgQNAAsLAkAgAEEIcUUNACAHQQJ0QdCJDmohAiAFIgRBB3EiBgRAA0AgAiADNgIAIAJBBGohAiAEQQFrIQQgBkEBayIGDQALCyAFQQFrQQdJDQADQCACIAM2AhwgAiADNgIYIAIgAzYCFCACIAM2AhAgAiADNgIMIAIgAzYCCCACIAM2AgQgAiADNgIAIAJBIGohAiAEQQhrIgQNAAsLAkAgAEEQcUUNACAHQQJ0QeCJEmohAiAFIgRBB3EiBgRAA0AgAiADNgIAIAJBBGohAiAEQQFrIQQgBkEBayIGDQALCyAFQQFrQQdJDQADQCACIAM2AhwgAiADNgIYIAIgAzYCFCACIAM2AhAgAiADNgIMIAIgAzYCCCACIAM2AgQgAiADNgIAIAJBIGohAiAEQQhrIgQNAAsLIABBIHFFDQAgBUEBayEEIAdBAnRB8IkWaiEAIAVBB3EiAgRAA0AgACADNgIAIABBBGohACAFQQFrIQUgAkEBayICDQALCyAEQQdJDQADQCAAIAM2AhwgACADNgIYIAAgAzYCFCAAIAM2AhAgACADNgIMIAAgAzYCCCAAIAM2AgQgACADNgIAIABBIGohACAFQQhrIgUNAAsLIAhBAWoiBSAILQAAQf8AcSICQT9rIgBBP00NAxoMBAsCQEHsCCgCACIFQQFGBEBB8AgoAgAiAUHMCCgCACIESQ0BIAEgBHAhAQwBC0H4CCgCACEEQfQIKAIAIQECQAJAIAVBBUcNACABQQFHDQAgBEHpAk4NBAwBCyAEQeQASg0DQfwIKAIAQeQASg0DQYAJKAIAQeQASg0DCwJAIAFFDQAgAUECSg0AIARB/AgoAgBBgAkoAgAgAUECdEGICGooAgARAgAhBEHwCCgCACIBQcwIKAIAIgVPBH8gASAFcAUgAQtBAnRBkAlqIAQ2AgALQfAIKAIAIgFBzAgoAgAiBEkNACABIARwIQELIAFBAnRBkAlqKAIAIQMMAQsgAkH9AHFBIUcEQCAHIQEgAiEADAQLIARBI0cNBAJAQewIKAIAIgRBAUYEQEHwCCgCACIBQcwIKAIAIgBJDQEgASAAcCEBDAELQfgIKAIAIQFB9AgoAgAhAAJAAkAgBEEFRw0AIABBAUcNACABQekCSA0BDAcLIAFB5ABKDQZB/AgoAgBB5ABKDQZBgAkoAgBB5ABKDQYLAkAgAEUNACAAQQJKDQAgAUH8CCgCAEGACSgCACAAQQJ0QYgIaigCABECACEAQfAIKAIAIgFBzAgoAgAiBE8EfyABIARwBSABC0ECdEGQCWogADYCAAtB8AgoAgAiAUHMCCgCACIASQ0AIAEgAHAhAQsgAUECdEGQCWooAgAhAwwECyAHIQEgCAshBQNAIAFB//8ATQRAIABBAXEgAWxBAnRBoIkCaiADNgIAIABBAXZBAXEgAWxBAnRBsIkGaiADNgIAIABBAnZBAXEgAWxBAnRBwIkKaiADNgIAIABBA3ZBAXEgAWxBAnRB0IkOaiADNgIAIABBBHZBAXEgAWxBAnRB4IkSaiADNgIAIABBBXYgAWxBAnRB8IkWaiADNgIACyABQQFqIQEgBS0AACEAIAVBAWoiBCEFIABB/wBxIgJBP2siAEHAAEkNAAsgBCEFC0EAIQQgBSEIIAEhByACIQAgAkH9AHFBIUYNAQtBBCEHIAQhAiAAQSRrDgoDAgICAgICAgIBAgtB7AhCATcCAAwCC0GoCCgCAEEEaxAABEBB0AhBATYCAA8LAkBBqAgoAgAiBkEFSA0AQaAIKQMAIQogBkEDa0EBdiIBQQdxIQJBACEAIAFBAWtBB08EQCABQfj///8HcSEFA0AgAEEDdCIBQbCJAmogCjcDACABQQhyQbCJAmogCjcDACABQRByQbCJAmogCjcDACABQRhyQbCJAmogCjcDACABQSByQbCJAmogCjcDACABQShyQbCJAmogCjcDACABQTByQbCJAmogCjcDACABQThyQbCJAmogCjcDACAAQQhqIQAgBUEIayIFDQALCyACRQ0AA0AgAEEDdEGwiQJqIAo3AwAgAEEBaiEAIAJBAWsiAg0ACwtBwIkGQbCJAiAGQQJ0IgD8CgAAQdCJCkGwiQIgAPwKAABB4IkOQbCJAiAA/AoAAEHwiRJBsIkCIAD8CgAAQYCKFkGwiQIgAPwKAAAgBCECDAELAkAgAEE7Rw0AQewIKAIAIgBBB0oNAEHsCCAAQQFqNgIAIABBAnRB8AhqQQA2AgALIAEhBwsgCCAJSQ0ACwtB5AggAzYCAEHgCCACNgIAQegIIAc2AgAL4gcCBX8BfgJAQdAIAn8CQAJAIAAgAU4NACABQZCJAWohBiAAQZCJAWohBQNAIAUtAAAiA0H/AHEhAgJAAkACQAJAAkACQAJAQeAIKAIAIgRBIkcEQCAEDQcgAkEiRgRAQewIQgE3AgBB4AhBIjYCAAwICyACQT9rQcAASQ0GIANBIWsiAkEMTQ0BDAULAkAgAkEwayIEQQlNBEBB7AgoAgBBAnRB7AhqIgIgBCACKAIAQQpsajYCAAwBC0HsCCgCACEEIAJBO0YEQCAEQQdKDQFB7AggBEEBajYCACAEQQJ0QfAIakEANgIADAELIARBBEYEQEHECEECNgIAQbAIQfAIKQMANwMAQbgIQfgIKAIAIgI2AgBBvAhB/AgoAgAiBDYCAEHICEECQQFBwAgoAgAiAxs2AgBBrAggBEEAIAMbNgIAQagIIAJBgIABIAJBgIABSBtBBGpBACADGzYCAEHgCEEANgIADAoLIAJBP2tBwABJDQQLIANBIWsiAkEMTQ0BDAILQQEgAnRBjSBxRQ0DDAQLQQEgAnRBjSBxDQELIANBoQFrIgJBDEsNA0EBIAJ0QY0gcUUNAwtBxAhCgYCAgBA3AgBBsAhB8AgoAgBBAEHsCCgCACICQQBKGzYCAEG0CEH0CCgCAEEAIAJBAUobNgIAQbgIQfgIKAIAQQAgAkECShs2AgBB4AhBADYCAEG8CEEANgIADAQLIANBoQFrIgJBDEsNAUEBIAJ0QY0gcUUNAQtBxAhCgYCAgBA3AgBBsAhCADcDAEG4CEIANwMADAMLIAVBAWoiBSAGSQ0ACwsCQEHICCgCAA4DAwEAAQsCQEGoCCgCACIFQQVIDQBBoAgpAwAhByAFQQNrQQF2IgNBB3EhBEEAIQIgA0EBa0EHTwRAIANB+P///wdxIQYDQCACQQN0IgNBsIkCaiAHNwMAIANBCHJBsIkCaiAHNwMAIANBEHJBsIkCaiAHNwMAIANBGHJBsIkCaiAHNwMAIANBIHJBsIkCaiAHNwMAIANBKHJBsIkCaiAHNwMAIANBMHJBsIkCaiAHNwMAIANBOHJBsIkCaiAHNwMAIAJBCGohAiAGQQhrIgYNAAsLIARFDQADQCACQQN0QbCJAmogBzcDACACQQFqIQIgBEEBayIEDQALC0HAiQZBsIkCIAVBAnQiA/wKAABB0IkKQbCJAiAD/AoAAEHgiQ5BsIkCIAP8CgAAQfCJEkGwiQIgA/wKAABBgIoWQbCJAiAD/AoAAEECDAELEAhByAgoAgALEAEiAjYCACACDQAgACABQcgIKAIAQQJ0QYAIaigCABEBAAsLdABB6AhBBDYCAEHkCCAANgIAQewIQgE3AgBBxAhCADcCAEHACCADNgIAQdwIQgA3AgBBqAhCADcDAEGwCEIANwMAQbgIQgA3AwBBzAggAkGAICACQYAgSRs2AgBBoAggAa1CgYCAgBB+NwMAQdAIQQA2AgALIwBB0AgoAgBFBEAgACABQcgIKAIAQQJ0QYAIaigCABEBAAsLWgECfwJAAkACQEHICCgCAEEBaw4CAAECC0HYCEHoCCgCACIAQdgIKAIAIgEgACABShsiAEGAgAEgAEGAgAFIGyIANgIAIABBBGsPC0GoCCgCAEEEayEACyAAC0IBAX8Cf0EGQdwIKAIAIgBBIHENABpBBSAAQRBxDQAaQQQgAEEIcQ0AGkEDIABBBHENABpBAiAAQQFxIABBAnEbCwu9BQEFfQJ/IAJFBEAgAUH/AWxBMmpB5ABtIgBBCHQgAHIgAEEQdHIMAQsgArJDAADIQpUhBiAAQfABarJDAAC0Q5UhBQJ9IAGyQwAAyEKVIgNDAAAAP10EQCADIAZDAACAP5KUDAELIAYgA0MAAIA/IAaTlJILIQcgAyADkiEGAkAgBUOrqqo+kiIEQwAAAABdBEAgBEMAAIA/kiEEDAELIARDAACAP15FDQAgBEMAAIC/kiEECyAGIAeTIQMgBUMAAAAAXSEAAn8CfSADIAcgA5NDAADAQJQgBJSSIARDq6oqPl0NABogByAEQwAAAD9dDQAaIAMgBEOrqio/XUUNABogAyAHIAOTIARDAADAwJRDAACAQJKUkgtDAAB/Q5RDAAAAP5IiBkMAAIBPXSAGQwAAAABgcQRAIAapDAELQQALIQECQCAABEAgBUMAAIA/kiEEDAELIAUiBEMAAIA/XkUNACAFQwAAgL+SIQQLIAVDq6qqvpIiBUMAAAAAXSECAn8CfSADIAcgA5NDAADAQJQgBJSSIARDq6oqPl0NABogByAEQwAAAD9dDQAaIAMgBEOrqio/XUUNABogAyAHIAOTIARDAADAwJRDAACAQJKUkgtDAAB/Q5RDAAAAP5IiBkMAAIBPXSAGQwAAAABgcQRAIAapDAELQQALIQACQCACBEAgBUMAAIA/kiEFDAELIAVDAACAP15FDQAgBUMAAIC/kiEFCwJAIAVDq6oqPl0EQCADIAcgA5NDAADAQJQgBZSSIQcMAQsgBUMAAAA/XQ0AIAVDq6oqP11FBEAgAyEHDAELIAMgByADkyAFQwAAwMCUQwAAgECSlJIhBwsgAEEIdAJ/IAdDAAB/Q5RDAAAAP5IiBkMAAIBPXSAGQwAAAABgcQRAIAapDAELQQALQRB0ciABcgtBgICAeHILNwAgAEH/AWxBMmpB5ABtIAFB/wFsQTJqQeQAbUEIdHIgAkH/AWxBMmpB5ABtQRB0ckGAgIB4cgsEACMACwYAIAAkAAsQACMAIABrQXBxIgAkACAACwsYAQBBgAgLEQEAAAACAAAAAwAAAAQAAAAF" };
      }, 280: (A2, e3, t3) => {
        Object.defineProperty(e3, "__esModule", { value: true });
        const i2 = (0, t3(615).InWasm)({ s: 1, t: 0, d: "AGFzbQEAAAABBQFgAAF/Ag8BA2VudgZtZW1vcnkCAAEDAwIAAAcNAgNkZWMAAANlbmQAAQqxAwKuAQEFf0GIKCgCAEGgKGohAUGEKCgCACIAQYAoKAIAQQFrQXxxIgJIBEAgAkGgKGohAyAAQaAoaiEAA0AgAC0AA0ECdCgCgCAgAC0AAkECdCgCgBggAC0AAUECdCgCgBAgAC0AAEECdCgCgAhycnIiBEH///8HSwRAQQEPCyABIAQ2AgAgAUEDaiEBIABBBGoiACADSQ0ACwtBhCggAjYCAEGIKCABQaAoazYCAEEAC/4BAQZ/AkBBgCgoAgAiAUGEKCgCACIAa0EFTgRAQQEhAxAADQFBgCgoAgAhAUGEKCgCACEAC0EBIQMgASAAayIEQQJIDQAgAEGhKGotAABBAnQoAoAQIABBoChqLQAAQQJ0KAKACHIhAQJAIARBAkYEQEEBIQIMAQtBASECIAAtAKIoIgVBPUcEQEECIQIgBUECdCgCgBggAXIhAQsgBEEERw0AIAAtAKMoIgBBPUYNACACQQFqIQIgAEECdCgCgCAgAXIhAQsgAUH///8HSw0AQYgoKAIAQaAoaiABNgIAQYgoQYgoKAIAIAJqIgA2AgAgAEGQKCgCAEchAwsgAwsAdglwcm9kdWNlcnMBDHByb2Nlc3NlZC1ieQEFY2xhbmdWMTguMC4wIChodHRwczovL2dpdGh1Yi5jb20vbGx2bS9sbHZtLXByb2plY3QgZDFlNjg1ZGY0NWRjNTk0NGI0M2QyNTQ3ZDAxMzhjZDRhM2VlNGVmZSkALA90YXJnZXRfZmVhdHVyZXMCKw9tdXRhYmxlLWdsb2JhbHMrCHNpZ24tZXh0" }), s = new Uint8Array("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("").map(((A3) => A3.charCodeAt(0)))), r = new Uint32Array(1024);
        r.fill(4278190080);
        for (let A3 = 0; A3 < s.length; ++A3) r[s[A3]] = A3 << 2;
        for (let A3 = 0; A3 < s.length; ++A3) r[256 + s[A3]] = A3 >> 4 | (A3 << 4 & 255) << 8;
        for (let A3 = 0; A3 < s.length; ++A3) r[512 + s[A3]] = A3 >> 2 << 8 | (A3 << 6 & 255) << 16;
        for (let A3 = 0; A3 < s.length; ++A3) r[768 + s[A3]] = A3 << 16;
        const g = new Uint8Array(0);
        e3.default = class {
          constructor(A3) {
            this.keepSize = A3;
          }
          get data8() {
            return this._inst ? this._d.subarray(0, this._m32[1282]) : g;
          }
          release() {
            this._inst && (this._mem.buffer.byteLength > this.keepSize ? this._inst = this._m32 = this._d = this._mem = null : (this._m32[1280] = 0, this._m32[1281] = 0, this._m32[1282] = 0));
          }
          init(A3) {
            let e4 = this._m32;
            const t4 = 4 * (Math.ceil(A3 / 3) + 1288);
            this._inst ? this._mem.buffer.byteLength < t4 && (this._mem.grow(Math.ceil((t4 - this._mem.buffer.byteLength) / 65536)), e4 = new Uint32Array(this._mem.buffer, 0), this._d = new Uint8Array(this._mem.buffer, 5152)) : (this._mem = new WebAssembly.Memory({ initial: Math.ceil(t4 / 65536) }), this._inst = i2({ env: { memory: this._mem } }), e4 = new Uint32Array(this._mem.buffer, 0), e4.set(r, 256), this._d = new Uint8Array(this._mem.buffer, 5152)), e4[1284] = A3, e4[1283] = 4 * Math.ceil(A3 / 3), e4[1280] = 0, e4[1281] = 0, e4[1282] = 0, this._m32 = e4;
          }
          put(A3, e4, t4) {
            if (!this._inst) return 1;
            const i3 = this._m32;
            return t4 - e4 + i3[1280] > i3[1283] ? 1 : (this._d.set(A3.subarray(e4, t4), i3[1280]), i3[1280] += t4 - e4, i3[1280] - i3[1281] >= 131072 ? this._inst.exports.dec() : 0);
          }
          end() {
            return this._inst ? this._inst.exports.end() : 1;
          }
        };
      }, 125: (A2, e3, t3) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.IIPHandler = void 0;
        const i2 = t3(782), s = t3(216), r = t3(280), g = t3(769), a = t3(326), o = { name: "Unnamed file", size: 0, width: "auto", height: "auto", preserveAspectRatio: 1, inline: 0 };
        e3.IIPHandler = class {
          constructor(A3, e4, t4, i3) {
            this._opts = A3, this._renderer = e4, this._storage = t4, this._coreTerminal = i3, this._aborted = false, this._hp = new g.HeaderParser(), this._header = o, this._dec = new r.default(4194304), this._metrics = a.UNSUPPORTED_TYPE;
          }
          reset() {
          }
          start() {
            this._aborted = false, this._header = o, this._metrics = a.UNSUPPORTED_TYPE, this._hp.reset();
          }
          put(A3, e4, t4) {
            if (!this._aborted) if (4 === this._hp.state) this._dec.put(A3, e4, t4) && (this._dec.release(), this._aborted = true);
            else {
              const i3 = this._hp.parse(A3, e4, t4);
              if (-1 === i3) return void (this._aborted = true);
              if (i3 > 0) {
                if (this._header = Object.assign({}, o, this._hp.fields), !this._header.inline || !this._header.size || this._header.size > this._opts.iipSizeLimit) return void (this._aborted = true);
                this._dec.init(this._header.size), this._dec.put(A3, i3, t4) && (this._dec.release(), this._aborted = true);
              }
            }
          }
          end(A3) {
            if (this._aborted) return true;
            let e4 = 0, t4 = 0, s2 = true;
            if ((s2 = A3) && (s2 = !this._dec.end()) && (this._metrics = (0, a.imageType)(this._dec.data8), (s2 = "unsupported" !== this._metrics.mime) && (e4 = this._metrics.width, t4 = this._metrics.height, (s2 = e4 && t4 && e4 * t4 < this._opts.pixelLimit) && ([e4, t4] = this._resize(e4, t4).map(Math.floor), s2 = e4 && t4 && e4 * t4 < this._opts.pixelLimit))), !s2) return this._dec.release(), true;
            const r2 = new Blob([this._dec.data8], { type: this._metrics.mime });
            if (this._dec.release(), !window.createImageBitmap) {
              const A4 = URL.createObjectURL(r2), s3 = new Image();
              return new Promise(((r3) => {
                s3.addEventListener("load", (() => {
                  var g2;
                  URL.revokeObjectURL(A4);
                  const a2 = i2.ImageRenderer.createCanvas(window.document, e4, t4);
                  null === (g2 = a2.getContext("2d")) || void 0 === g2 || g2.drawImage(s3, 0, 0, e4, t4), this._storage.addImage(a2), r3(true);
                })), s3.src = A4, setTimeout((() => r3(true)), 1e3);
              }));
            }
            return createImageBitmap(r2, { resizeWidth: e4, resizeHeight: t4 }).then(((A4) => (this._storage.addImage(A4), true)));
          }
          _resize(A3, e4) {
            var t4, i3, r2, g2;
            const a2 = (null === (t4 = this._renderer.dimensions) || void 0 === t4 ? void 0 : t4.css.cell.width) || s.CELL_SIZE_DEFAULT.width, o2 = (null === (i3 = this._renderer.dimensions) || void 0 === i3 ? void 0 : i3.css.cell.height) || s.CELL_SIZE_DEFAULT.height, h = (null === (r2 = this._renderer.dimensions) || void 0 === r2 ? void 0 : r2.css.canvas.width) || a2 * this._coreTerminal.cols, n = (null === (g2 = this._renderer.dimensions) || void 0 === g2 ? void 0 : g2.css.canvas.height) || o2 * this._coreTerminal.rows, I = this._dim(this._header.width, h, a2), C = this._dim(this._header.height, n, o2);
            if (!I && !C) {
              const t5 = h / A3, i4 = (n - o2) / e4, s2 = Math.min(t5, i4);
              return s2 < 1 ? [A3 * s2, e4 * s2] : [A3, e4];
            }
            return I ? !this._header.preserveAspectRatio && I && C ? [I, C] : [I, e4 * I / A3] : [A3 * C / e4, C];
          }
          _dim(A3, e4, t4) {
            return "auto" === A3 ? 0 : A3.endsWith("%") ? parseInt(A3.slice(0, -1)) * e4 / 100 : A3.endsWith("px") ? parseInt(A3.slice(0, -2)) : parseInt(A3) * t4;
          }
        };
      }, 769: (A2, e3) => {
        function t3(A3) {
          let e4 = "";
          for (let t4 = 0; t4 < A3.length; ++t4) e4 += String.fromCharCode(A3[t4]);
          return e4;
        }
        __name(t3, "t");
        function i2(A3) {
          let e4 = 0;
          for (let t4 = 0; t4 < A3.length; ++t4) {
            if (A3[t4] < 48 || A3[t4] > 57) throw new Error("illegal char");
            e4 = 10 * e4 + A3[t4] - 48;
          }
          return e4;
        }
        __name(i2, "i");
        function s(A3) {
          const e4 = t3(A3);
          if (!e4.match(/^((auto)|(\d+?((px)|(%)){0,1}))$/)) throw new Error("illegal size");
          return e4;
        }
        __name(s, "s");
        Object.defineProperty(e3, "__esModule", { value: true }), e3.HeaderParser = void 0;
        const r = { inline: i2, size: i2, name: /* @__PURE__ */ __name(function(A3) {
          if ("undefined" != typeof Buffer2) return Buffer2.from(t3(A3), "base64").toString();
          const e4 = atob(t3(A3)), i3 = new Uint8Array(e4.length);
          for (let A4 = 0; A4 < i3.length; ++A4) i3[A4] = e4.charCodeAt(A4);
          return new TextDecoder().decode(i3);
        }, "name"), width: s, height: s, preserveAspectRatio: i2 }, g = [70, 105, 108, 101], a = 1024;
        e3.HeaderParser = class {
          constructor() {
            this.state = 0, this._buffer = new Uint32Array(a), this._position = 0, this._key = "", this.fields = {};
          }
          reset() {
            this._buffer.fill(0), this.state = 0, this._position = 0, this.fields = {}, this._key = "";
          }
          parse(A3, e4, t4) {
            let i3 = this.state, s2 = this._position;
            const r2 = this._buffer;
            if (1 === i3 || 4 === i3) return -1;
            if (0 === i3 && s2 > 6) return -1;
            for (let o = e4; o < t4; ++o) {
              const e5 = A3[o];
              switch (e5) {
                case 59:
                  if (!this._storeValue(s2)) return this._a();
                  i3 = 2, s2 = 0;
                  break;
                case 61:
                  if (0 === i3) {
                    for (let A4 = 0; A4 < g.length; ++A4) if (r2[A4] !== g[A4]) return this._a();
                    i3 = 2, s2 = 0;
                  } else if (2 === i3) {
                    if (!this._storeKey(s2)) return this._a();
                    i3 = 3, s2 = 0;
                  } else if (3 === i3) {
                    if (s2 >= a) return this._a();
                    r2[s2++] = e5;
                  }
                  break;
                case 58:
                  return 3 !== i3 || this._storeValue(s2) ? (this.state = 4, o + 1) : this._a();
                default:
                  if (s2 >= a) return this._a();
                  r2[s2++] = e5;
              }
            }
            return this.state = i3, this._position = s2, -2;
          }
          _a() {
            return this.state = 1, -1;
          }
          _storeKey(A3) {
            const e4 = t3(this._buffer.subarray(0, A3));
            return !!e4 && (this._key = e4, this.fields[e4] = null, true);
          }
          _storeValue(A3) {
            if (this._key) {
              try {
                const e4 = this._buffer.slice(0, A3);
                this.fields[this._key] = r[this._key] ? r[this._key](e4) : e4;
              } catch (A4) {
                return false;
              }
              return true;
            }
            return false;
          }
        };
      }, 326: (A2, e3) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.imageType = e3.UNSUPPORTED_TYPE = void 0, e3.UNSUPPORTED_TYPE = { mime: "unsupported", width: 0, height: 0 }, e3.imageType = function(A3) {
          if (A3.length < 24) return e3.UNSUPPORTED_TYPE;
          const t3 = new Uint32Array(A3.buffer, A3.byteOffset, 6);
          if (1196314761 === t3[0] && 169478669 === t3[1] && 1380206665 === t3[3]) return { mime: "image/png", width: A3[16] << 24 | A3[17] << 16 | A3[18] << 8 | A3[19], height: A3[20] << 24 | A3[21] << 16 | A3[22] << 8 | A3[23] };
          if ((3774863615 === t3[0] || 3791640831 === t3[0]) && (74 === A3[6] && 70 === A3[7] && 73 === A3[8] && 70 === A3[9] || 69 === A3[6] && 120 === A3[7] && 105 === A3[8] && 102 === A3[9])) {
            const [e4, t4] = (function(A4) {
              const e5 = A4.length;
              let t5 = 4, i2 = A4[t5] << 8 | A4[t5 + 1];
              for (; ; ) {
                if (t5 += i2, t5 >= e5) return [0, 0];
                if (255 !== A4[t5]) return [0, 0];
                if (192 === A4[t5 + 1] || 194 === A4[t5 + 1]) return t5 + 8 < e5 ? [A4[t5 + 7] << 8 | A4[t5 + 8], A4[t5 + 5] << 8 | A4[t5 + 6]] : [0, 0];
                t5 += 2, i2 = A4[t5] << 8 | A4[t5 + 1];
              }
            })(A3);
            return { mime: "image/jpeg", width: e4, height: t4 };
          }
          return 944130375 !== t3[0] || 55 !== A3[4] && 57 !== A3[4] || 97 !== A3[5] ? e3.UNSUPPORTED_TYPE : { mime: "image/gif", width: A3[7] << 8 | A3[6], height: A3[9] << 8 | A3[8] };
        };
      }, 782: (A2, e3, t3) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.ImageRenderer = void 0;
        const i2 = t3(477), s = t3(859);
        const _r = class _r extends s.Disposable {
          static createCanvas(A3, e4, t4) {
            const i3 = (A3 || document).createElement("canvas");
            return i3.width = 0 | e4, i3.height = 0 | t4, i3;
          }
          static createImageData(A3, e4, t4, i3) {
            if ("function" != typeof ImageData) {
              const s2 = A3.createImageData(e4, t4);
              return i3 && s2.data.set(new Uint8ClampedArray(i3, 0, e4 * t4 * 4)), s2;
            }
            return i3 ? new ImageData(new Uint8ClampedArray(i3, 0, e4 * t4 * 4), e4, t4) : new ImageData(e4, t4);
          }
          static createImageBitmap(A3) {
            return "function" != typeof createImageBitmap ? Promise.resolve(void 0) : createImageBitmap(A3);
          }
          constructor(A3) {
            super(), this._terminal = A3, this._optionsRefresh = this.register(new s.MutableDisposable()), this._oldOpen = this._terminal._core.open, this._terminal._core.open = (A4) => {
              var e4;
              null === (e4 = this._oldOpen) || void 0 === e4 || e4.call(this._terminal._core, A4), this._open();
            }, this._terminal._core.screenElement && this._open(), this._optionsRefresh.value = this._terminal._core.optionsService.onOptionChange(((A4) => {
              var e4;
              "fontSize" === A4 && (this.rescaleCanvas(), null === (e4 = this._renderService) || void 0 === e4 || e4.refreshRows(0, this._terminal.rows));
            })), this.register((0, s.toDisposable)((() => {
              var A4;
              this.removeLayerFromDom(), this._terminal._core && this._oldOpen && (this._terminal._core.open = this._oldOpen, this._oldOpen = void 0), this._renderService && this._oldSetRenderer && (this._renderService.setRenderer = this._oldSetRenderer, this._oldSetRenderer = void 0), this._renderService = void 0, this.canvas = void 0, this._ctx = void 0, null === (A4 = this._placeholderBitmap) || void 0 === A4 || A4.close(), this._placeholderBitmap = void 0, this._placeholder = void 0;
            })));
          }
          showPlaceholder(A3) {
            var e4, t4;
            A3 ? this._placeholder || -1 === this.cellSize.height || this._createPlaceHolder(Math.max(this.cellSize.height + 1, 24)) : (null === (e4 = this._placeholderBitmap) || void 0 === e4 || e4.close(), this._placeholderBitmap = void 0, this._placeholder = void 0), null === (t4 = this._renderService) || void 0 === t4 || t4.refreshRows(0, this._terminal.rows);
          }
          get dimensions() {
            var A3;
            return null === (A3 = this._renderService) || void 0 === A3 ? void 0 : A3.dimensions;
          }
          get cellSize() {
            var A3, e4;
            return { width: (null === (A3 = this.dimensions) || void 0 === A3 ? void 0 : A3.css.cell.width) || -1, height: (null === (e4 = this.dimensions) || void 0 === e4 ? void 0 : e4.css.cell.height) || -1 };
          }
          clearLines(A3, e4) {
            var t4, i3, s2, r2;
            null === (t4 = this._ctx) || void 0 === t4 || t4.clearRect(0, A3 * ((null === (i3 = this.dimensions) || void 0 === i3 ? void 0 : i3.css.cell.height) || 0), (null === (s2 = this.dimensions) || void 0 === s2 ? void 0 : s2.css.canvas.width) || 0, (++e4 - A3) * ((null === (r2 = this.dimensions) || void 0 === r2 ? void 0 : r2.css.cell.height) || 0));
          }
          clearAll() {
            var A3, e4, t4;
            null === (A3 = this._ctx) || void 0 === A3 || A3.clearRect(0, 0, (null === (e4 = this.canvas) || void 0 === e4 ? void 0 : e4.width) || 0, (null === (t4 = this.canvas) || void 0 === t4 ? void 0 : t4.height) || 0);
          }
          draw(A3, e4, t4, i3, s2 = 1) {
            if (!this._ctx) return;
            const { width: r2, height: g } = this.cellSize;
            if (-1 === r2 || -1 === g) return;
            this._rescaleImage(A3, r2, g);
            const a = A3.actual, o = Math.ceil(a.width / r2), h = e4 % o * r2, n = Math.floor(e4 / o) * g, I = t4 * r2, C = i3 * g, l = s2 * r2 + h > a.width ? a.width - h : s2 * r2, B = n + g > a.height ? a.height - n : g;
            this._ctx.drawImage(a, Math.floor(h), Math.floor(n), Math.ceil(l), Math.ceil(B), Math.floor(I), Math.floor(C), Math.ceil(l), Math.ceil(B));
          }
          extractTile(A3, e4) {
            const { width: t4, height: i3 } = this.cellSize;
            if (-1 === t4 || -1 === i3) return;
            this._rescaleImage(A3, t4, i3);
            const s2 = A3.actual, g = Math.ceil(s2.width / t4), a = e4 % g * t4, o = Math.floor(e4 / g) * i3, h = t4 + a > s2.width ? s2.width - a : t4, n = o + i3 > s2.height ? s2.height - o : i3, I = _r.createCanvas(this.document, h, n), C = I.getContext("2d");
            return C ? (C.drawImage(s2, Math.floor(a), Math.floor(o), Math.floor(h), Math.floor(n), 0, 0, Math.floor(h), Math.floor(n)), I) : void 0;
          }
          drawPlaceholder(A3, e4, t4 = 1) {
            if (this._ctx) {
              const { width: i3, height: s2 } = this.cellSize;
              if (-1 === i3 || -1 === s2) return;
              if (this._placeholder ? s2 >= this._placeholder.height && this._createPlaceHolder(s2 + 1) : this._createPlaceHolder(Math.max(s2 + 1, 24)), !this._placeholder) return;
              this._ctx.drawImage(this._placeholderBitmap || this._placeholder, A3 * i3, e4 * s2 % 2 ? 0 : 1, i3 * t4, s2, A3 * i3, e4 * s2, i3 * t4, s2);
            }
          }
          rescaleCanvas() {
            this.canvas && (this.canvas.width === this.dimensions.css.canvas.width && this.canvas.height === this.dimensions.css.canvas.height || (this.canvas.width = this.dimensions.css.canvas.width || 0, this.canvas.height = this.dimensions.css.canvas.height || 0));
          }
          _rescaleImage(A3, e4, t4) {
            if (e4 === A3.actualCellSize.width && t4 === A3.actualCellSize.height) return;
            const { width: i3, height: s2 } = A3.origCellSize;
            if (e4 === i3 && t4 === s2) return A3.actual = A3.orig, A3.actualCellSize.width = i3, void (A3.actualCellSize.height = s2);
            const g = _r.createCanvas(this.document, Math.ceil(A3.orig.width * e4 / i3), Math.ceil(A3.orig.height * t4 / s2)), a = g.getContext("2d");
            a && (a.drawImage(A3.orig, 0, 0, g.width, g.height), A3.actual = g, A3.actualCellSize.width = e4, A3.actualCellSize.height = t4);
          }
          _open() {
            this._renderService = this._terminal._core._renderService, this._oldSetRenderer = this._renderService.setRenderer.bind(this._renderService), this._renderService.setRenderer = (A3) => {
              var e4;
              this.removeLayerFromDom(), null === (e4 = this._oldSetRenderer) || void 0 === e4 || e4.call(this._renderService, A3);
            };
          }
          insertLayerToDom() {
            var A3, e4;
            this.document && this._terminal._core.screenElement ? this.canvas || (this.canvas = _r.createCanvas(this.document, (null === (A3 = this.dimensions) || void 0 === A3 ? void 0 : A3.css.canvas.width) || 0, (null === (e4 = this.dimensions) || void 0 === e4 ? void 0 : e4.css.canvas.height) || 0), this.canvas.classList.add("xterm-image-layer"), this._terminal._core.screenElement.appendChild(this.canvas), this._ctx = this.canvas.getContext("2d", { alpha: true, desynchronized: true }), this.clearAll()) : console.warn("image addon: cannot insert output canvas to DOM, missing document or screenElement");
          }
          removeLayerFromDom() {
            this.canvas && (this._ctx = void 0, this.canvas.remove(), this.canvas = void 0);
          }
          _createPlaceHolder(A3 = 24) {
            var e4;
            null === (e4 = this._placeholderBitmap) || void 0 === e4 || e4.close(), this._placeholderBitmap = void 0;
            const t4 = 32, s2 = _r.createCanvas(this.document, t4, A3), g = s2.getContext("2d", { alpha: false });
            if (!g) return;
            const a = _r.createImageData(g, t4, A3), o = new Uint32Array(a.data.buffer), h = (0, i2.toRGBA8888)(0, 0, 0), n = (0, i2.toRGBA8888)(255, 255, 255);
            o.fill(h);
            for (let e5 = 0; e5 < A3; ++e5) {
              const A4 = e5 % 2, i3 = e5 * t4;
              for (let e6 = 0; e6 < t4; e6 += 2) o[i3 + e6 + A4] = n;
            }
            g.putImageData(a, 0, 0);
            const I = screen.width + t4 - 1 & -32 || 4096;
            this._placeholder = _r.createCanvas(this.document, I, A3);
            const C = this._placeholder.getContext("2d", { alpha: false });
            if (C) {
              for (let A4 = 0; A4 < I; A4 += t4) C.drawImage(s2, A4, 0);
              _r.createImageBitmap(this._placeholder).then(((A4) => this._placeholderBitmap = A4));
            } else this._placeholder = void 0;
          }
          get document() {
            var A3;
            return null === (A3 = this._terminal._core._coreBrowserService) || void 0 === A3 ? void 0 : A3.window.document;
          }
        };
        __name(_r, "r");
        let r = _r;
        e3.ImageRenderer = r;
      }, 216: (A2, e3, t3) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.ImageStorage = e3.CELL_SIZE_DEFAULT = void 0;
        const i2 = t3(782);
        e3.CELL_SIZE_DEFAULT = { width: 7, height: 14 };
        const _s = class _s {
          get ext() {
            return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
          }
          set ext(A3) {
            this._ext = A3;
          }
          get underlineStyle() {
            return this._urlId ? 5 : (469762048 & this._ext) >> 26;
          }
          set underlineStyle(A3) {
            this._ext &= -469762049, this._ext |= A3 << 26 & 469762048;
          }
          get underlineColor() {
            return 67108863 & this._ext;
          }
          set underlineColor(A3) {
            this._ext &= -67108864, this._ext |= 67108863 & A3;
          }
          get underlineVariantOffset() {
            const A3 = (3758096384 & this._ext) >> 29;
            return A3 < 0 ? 4294967288 ^ A3 : A3;
          }
          set underlineVariantOffset(A3) {
            this._ext &= 536870911, this._ext |= A3 << 29 & 3758096384;
          }
          get urlId() {
            return this._urlId;
          }
          set urlId(A3) {
            this._urlId = A3;
          }
          constructor(A3 = 0, e4 = 0, t4 = -1, i3 = -1) {
            this.imageId = t4, this.tileId = i3, this._ext = 0, this._urlId = 0, this._ext = A3, this._urlId = e4;
          }
          clone() {
            return new _s(this._ext, this._urlId, this.imageId, this.tileId);
          }
          isEmpty() {
            return 0 === this.underlineStyle && 0 === this._urlId && -1 === this.imageId;
          }
        };
        __name(_s, "s");
        let s = _s;
        const r = new s();
        e3.ImageStorage = class {
          constructor(A3, e4, t4) {
            this._terminal = A3, this._renderer = e4, this._opts = t4, this._images = /* @__PURE__ */ new Map(), this._lastId = 0, this._lowestId = 0, this._fullyCleared = false, this._needsFullClear = false, this._pixelLimit = 25e5;
            try {
              this.setLimit(this._opts.storageLimit);
            } catch (A4) {
              console.error(A4.message), console.warn(`storageLimit is set to ${this.getLimit()} MB`);
            }
            this._viewportMetrics = { cols: this._terminal.cols, rows: this._terminal.rows };
          }
          dispose() {
            this.reset();
          }
          reset() {
            var A3;
            for (const e4 of this._images.values()) null === (A3 = e4.marker) || void 0 === A3 || A3.dispose();
            this._images.clear(), this._renderer.clearAll();
          }
          getLimit() {
            return 4 * this._pixelLimit / 1e6;
          }
          setLimit(A3) {
            if (A3 < 0.5 || A3 > 1e3) throw RangeError("invalid storageLimit, should be at least 0.5 MB and not exceed 1G");
            this._pixelLimit = A3 / 4 * 1e6 >>> 0, this._evictOldest(0);
          }
          getUsage() {
            return 4 * this._getStoredPixels() / 1e6;
          }
          _getStoredPixels() {
            let A3 = 0;
            for (const e4 of this._images.values()) e4.orig && (A3 += e4.orig.width * e4.orig.height, e4.actual && e4.actual !== e4.orig && (A3 += e4.actual.width * e4.actual.height));
            return A3;
          }
          _delImg(A3) {
            const e4 = this._images.get(A3);
            this._images.delete(A3), e4 && window.ImageBitmap && e4.orig instanceof ImageBitmap && e4.orig.close();
          }
          wipeAlternate() {
            var A3;
            const e4 = [];
            for (const [t4, i3] of this._images.entries()) "alternate" === i3.bufferType && (null === (A3 = i3.marker) || void 0 === A3 || A3.dispose(), e4.push(t4));
            for (const A4 of e4) this._delImg(A4);
            this._needsFullClear = true, this._fullyCleared = false;
          }
          advanceCursor(A3) {
            if (this._opts.sixelScrolling) {
              let t4 = this._renderer.cellSize;
              -1 !== t4.width && -1 !== t4.height || (t4 = e3.CELL_SIZE_DEFAULT);
              const i3 = Math.ceil(A3 / t4.height);
              for (let A4 = 1; A4 < i3; ++A4) this._terminal._core._inputHandler.lineFeed();
            }
          }
          addImage(A3) {
            var t4;
            this._evictOldest(A3.width * A3.height);
            let i3 = this._renderer.cellSize;
            -1 !== i3.width && -1 !== i3.height || (i3 = e3.CELL_SIZE_DEFAULT);
            const s2 = Math.ceil(A3.width / i3.width), r2 = Math.ceil(A3.height / i3.height), g = ++this._lastId, a = this._terminal._core.buffer, o = this._terminal.cols, h = this._terminal.rows, n = a.x, I = a.y;
            let C = n, l = 0;
            this._opts.sixelScrolling || (a.x = 0, a.y = 0, C = 0), this._terminal._core._inputHandler._dirtyRowTracker.markDirty(a.y);
            for (let A4 = 0; A4 < r2; ++A4) {
              const e4 = a.lines.get(a.y + a.ybase);
              for (let t5 = 0; t5 < s2 && !(C + t5 >= o); ++t5) this._writeToCell(e4, C + t5, g, A4 * s2 + t5), l++;
              if (this._opts.sixelScrolling) A4 < r2 - 1 && this._terminal._core._inputHandler.lineFeed();
              else if (++a.y >= h) break;
              a.x = C;
            }
            this._terminal._core._inputHandler._dirtyRowTracker.markDirty(a.y), this._opts.sixelScrolling ? a.x = C : (a.x = n, a.y = I);
            const B = [];
            for (const [A4, e4] of this._images.entries()) e4.tileCount < 1 && (null === (t4 = e4.marker) || void 0 === t4 || t4.dispose(), B.push(A4));
            for (const A4 of B) this._delImg(A4);
            const Q = this._terminal.registerMarker(0);
            null == Q || Q.onDispose((() => {
              this._images.get(g) && this._delImg(g);
            })), "alternate" === this._terminal.buffer.active.type && this._evictOnAlternate();
            const d = { orig: A3, origCellSize: i3, actual: A3, actualCellSize: Object.assign({}, i3), marker: Q || void 0, tileCount: l, bufferType: this._terminal.buffer.active.type };
            this._images.set(g, d);
          }
          render(A3) {
            if (!this._renderer.canvas && this._images.size && (this._renderer.insertLayerToDom(), !this._renderer.canvas)) return;
            if (this._renderer.rescaleCanvas(), !this._images.size) return this._fullyCleared || (this._renderer.clearAll(), this._fullyCleared = true, this._needsFullClear = false), void (this._renderer.canvas && this._renderer.removeLayerFromDom());
            this._needsFullClear && (this._renderer.clearAll(), this._fullyCleared = true, this._needsFullClear = false);
            const { start: e4, end: t4 } = A3, i3 = this._terminal._core.buffer, s2 = this._terminal._core.cols;
            this._renderer.clearLines(e4, t4);
            for (let A4 = e4; A4 <= t4; ++A4) {
              const e5 = i3.lines.get(A4 + i3.ydisp);
              if (!e5) return;
              for (let t5 = 0; t5 < s2; ++t5) if (268435456 & e5.getBg(t5)) {
                let i4 = e5._extendedAttrs[t5] || r;
                const g = i4.imageId;
                if (void 0 === g || -1 === g) continue;
                const a = this._images.get(g);
                if (-1 !== i4.tileId) {
                  const o = i4.tileId, h = t5;
                  let n = 1;
                  for (; ++t5 < s2 && 268435456 & e5.getBg(t5) && (i4 = e5._extendedAttrs[t5] || r) && i4.imageId === g && i4.tileId === o + n; ) n++;
                  t5--, a ? a.actual && this._renderer.draw(a, o, h, A4, n) : this._opts.showPlaceholder && this._renderer.drawPlaceholder(h, A4, n), this._fullyCleared = false;
                }
              }
            }
          }
          viewportResize(A3) {
            var e4;
            if (!this._images.size) return void (this._viewportMetrics = A3);
            if (this._viewportMetrics.cols >= A3.cols) return void (this._viewportMetrics = A3);
            const t4 = this._terminal._core.buffer, i3 = t4.lines.length, s2 = this._viewportMetrics.cols - 1;
            for (let g = 0; g < i3; ++g) {
              const i4 = t4.lines.get(g);
              if (268435456 & i4.getBg(s2)) {
                const t5 = i4._extendedAttrs[s2] || r, g2 = t5.imageId;
                if (void 0 === g2 || -1 === g2) continue;
                const a = this._images.get(g2);
                if (!a) continue;
                const o = Math.ceil(((null === (e4 = a.actual) || void 0 === e4 ? void 0 : e4.width) || 0) / a.actualCellSize.width);
                if (t5.tileId % o + 1 >= o) continue;
                let h = false;
                for (let e5 = s2 + 1; e5 > A3.cols; ++e5) if (4194303 & i4._data[3 * e5 + 0]) {
                  h = true;
                  break;
                }
                if (h) continue;
                const n = Math.min(A3.cols, o - t5.tileId % o + s2);
                let I = t5.tileId;
                for (let A4 = s2 + 1; A4 < n; ++A4) this._writeToCell(i4, A4, g2, ++I), a.tileCount++;
              }
            }
            this._viewportMetrics = A3;
          }
          getImageAtBufferCell(A3, e4) {
            var t4, s2;
            const g = this._terminal._core.buffer.lines.get(e4);
            if (g && 268435456 & g.getBg(A3)) {
              const e5 = g._extendedAttrs[A3] || r;
              if (e5.imageId && -1 !== e5.imageId) {
                const A4 = null === (t4 = this._images.get(e5.imageId)) || void 0 === t4 ? void 0 : t4.orig;
                if (window.ImageBitmap && A4 instanceof ImageBitmap) {
                  const e6 = i2.ImageRenderer.createCanvas(window.document, A4.width, A4.height);
                  return null === (s2 = e6.getContext("2d")) || void 0 === s2 || s2.drawImage(A4, 0, 0, A4.width, A4.height), e6;
                }
                return A4;
              }
            }
          }
          extractTileAtBufferCell(A3, e4) {
            const t4 = this._terminal._core.buffer.lines.get(e4);
            if (t4 && 268435456 & t4.getBg(A3)) {
              const e5 = t4._extendedAttrs[A3] || r;
              if (e5.imageId && -1 !== e5.imageId && -1 !== e5.tileId) {
                const A4 = this._images.get(e5.imageId);
                if (A4) return this._renderer.extractTile(A4, e5.tileId);
              }
            }
          }
          _evictOldest(A3) {
            var e4;
            const t4 = this._getStoredPixels();
            let i3 = t4;
            for (; this._pixelLimit < i3 + A3 && this._images.size; ) {
              const A4 = this._images.get(++this._lowestId);
              A4 && A4.orig && (i3 -= A4.orig.width * A4.orig.height, A4.actual && A4.orig !== A4.actual && (i3 -= A4.actual.width * A4.actual.height), null === (e4 = A4.marker) || void 0 === e4 || e4.dispose(), this._delImg(this._lowestId));
            }
            return t4 - i3;
          }
          _writeToCell(A3, e4, t4, i3) {
            if (268435456 & A3._data[3 * e4 + 2]) {
              const r2 = A3._extendedAttrs[e4];
              if (r2) {
                if (void 0 !== r2.imageId) {
                  const A4 = this._images.get(r2.imageId);
                  return A4 && A4.tileCount--, r2.imageId = t4, void (r2.tileId = i3);
                }
                return void (A3._extendedAttrs[e4] = new s(r2.ext, r2.urlId, t4, i3));
              }
            }
            A3._data[3 * e4 + 2] |= 268435456, A3._extendedAttrs[e4] = new s(0, 0, t4, i3);
          }
          _evictOnAlternate() {
            var A3, e4;
            for (const A4 of this._images.values()) "alternate" === A4.bufferType && (A4.tileCount = 0);
            const t4 = this._terminal._core.buffer;
            for (let e5 = 0; e5 < this._terminal.rows; ++e5) {
              const i4 = t4.lines.get(e5);
              if (i4) {
                for (let e6 = 0; e6 < this._terminal.cols; ++e6) if (268435456 & i4._data[3 * e6 + 2]) {
                  const t5 = null === (A3 = i4._extendedAttrs[e6]) || void 0 === A3 ? void 0 : A3.imageId;
                  if (t5) {
                    const A4 = this._images.get(t5);
                    A4 && A4.tileCount++;
                  }
                }
              }
            }
            const i3 = [];
            for (const [A4, t5] of this._images.entries()) "alternate" !== t5.bufferType || t5.tileCount || (null === (e4 = t5.marker) || void 0 === e4 || e4.dispose(), i3.push(A4));
            for (const A4 of i3) this._delImg(A4);
          }
        };
      }, 973: (A2, e3, t3) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.SixelHandler = void 0;
        const i2 = t3(477), s = t3(782), r = t3(710), g = i2.PALETTE_ANSI_256;
        function a(A3) {
          return i2.BIG_ENDIAN ? A3 : (255 & A3) << 24 | (A3 >>> 8 & 255) << 16 | (A3 >>> 16 & 255) << 8 | A3 >>> 24 & 255;
        }
        __name(a, "a");
        g.set(i2.PALETTE_VT340_COLOR), e3.SixelHandler = class {
          constructor(A3, e4, t4) {
            this._opts = A3, this._storage = e4, this._coreTerminal = t4, this._size = 0, this._aborted = false, (0, r.DecoderAsync)({ memoryLimit: 4 * this._opts.pixelLimit, palette: g, paletteLimit: this._opts.sixelPaletteLimit }).then(((A4) => this._dec = A4));
          }
          reset() {
            this._dec && (this._dec.release(), this._dec._palette.fill(0), this._dec.init(0, g, this._opts.sixelPaletteLimit));
          }
          hook(A3) {
            var e4;
            if (this._size = 0, this._aborted = false, this._dec) {
              const t4 = 1 === A3.params[1] ? 0 : (function(A4, e5) {
                let t5 = 0;
                if (!e5) return t5;
                if (A4.isInverse()) if (A4.isFgDefault()) t5 = a(e5.foreground.rgba);
                else if (A4.isFgRGB()) {
                  const e6 = A4.constructor.toColorRGB(A4.getFgColor());
                  t5 = (0, i2.toRGBA8888)(...e6);
                } else t5 = a(e5.ansi[A4.getFgColor()].rgba);
                else if (A4.isBgDefault()) t5 = a(e5.background.rgba);
                else if (A4.isBgRGB()) {
                  const e6 = A4.constructor.toColorRGB(A4.getBgColor());
                  t5 = (0, i2.toRGBA8888)(...e6);
                } else t5 = a(e5.ansi[A4.getBgColor()].rgba);
                return t5;
              })(this._coreTerminal._core._inputHandler._curAttrData, null === (e4 = this._coreTerminal._core._themeService) || void 0 === e4 ? void 0 : e4.colors);
              this._dec.init(t4, null, this._opts.sixelPaletteLimit);
            }
          }
          put(A3, e4, t4) {
            if (!this._aborted && this._dec) {
              if (this._size += t4 - e4, this._size > this._opts.sixelSizeLimit) return console.warn("SIXEL: too much data, aborting"), this._aborted = true, void this._dec.release();
              try {
                this._dec.decode(A3, e4, t4);
              } catch (A4) {
                console.warn(`SIXEL: error while decoding image - ${A4}`), this._aborted = true, this._dec.release();
              }
            }
          }
          unhook(A3) {
            var e4;
            if (this._aborted || !A3 || !this._dec) return true;
            const t4 = this._dec.width, i3 = this._dec.height;
            if (!t4 || !i3) return i3 && this._storage.advanceCursor(i3), true;
            const r2 = s.ImageRenderer.createCanvas(void 0, t4, i3);
            return null === (e4 = r2.getContext("2d")) || void 0 === e4 || e4.putImageData(new ImageData(this._dec.data8, t4, i3), 0, 0), this._dec.memoryUsage > 4194304 && this._dec.release(), this._storage.addImage(r2), true;
          }
        };
      }, 859: (A2, e3) => {
        function t3(A3) {
          for (const e4 of A3) e4.dispose();
          A3.length = 0;
        }
        __name(t3, "t");
        Object.defineProperty(e3, "__esModule", { value: true }), e3.getDisposeArrayDisposable = e3.disposeArray = e3.toDisposable = e3.MutableDisposable = e3.Disposable = void 0, e3.Disposable = class {
          constructor() {
            this._disposables = [], this._isDisposed = false;
          }
          dispose() {
            this._isDisposed = true;
            for (const A3 of this._disposables) A3.dispose();
            this._disposables.length = 0;
          }
          register(A3) {
            return this._disposables.push(A3), A3;
          }
          unregister(A3) {
            const e4 = this._disposables.indexOf(A3);
            -1 !== e4 && this._disposables.splice(e4, 1);
          }
        }, e3.MutableDisposable = class {
          constructor() {
            this._isDisposed = false;
          }
          get value() {
            return this._isDisposed ? void 0 : this._value;
          }
          set value(A3) {
            this._isDisposed || A3 === this._value || (this._value?.dispose(), this._value = A3);
          }
          clear() {
            this.value = void 0;
          }
          dispose() {
            this._isDisposed = true, this._value?.dispose(), this._value = void 0;
          }
        }, e3.toDisposable = function(A3) {
          return { dispose: A3 };
        }, e3.disposeArray = t3, e3.getDisposeArrayDisposable = function(A3) {
          return { dispose: /* @__PURE__ */ __name(() => t3(A3), "dispose") };
        };
      } }, e2 = {};
      function t2(i2) {
        var s = e2[i2];
        if (void 0 !== s) return s.exports;
        var r = e2[i2] = { exports: {} };
        return A[i2](r, r.exports, t2), r.exports;
      }
      __name(t2, "t");
      var i = {};
      return (() => {
        var A2 = i;
        Object.defineProperty(A2, "__esModule", { value: true }), A2.ImageAddon = void 0;
        const e3 = t2(125), s = t2(782), r = t2(216), g = t2(973), a = { enableSizeReports: true, pixelLimit: 16777216, sixelSupport: true, sixelScrolling: true, sixelPaletteLimit: 256, sixelSizeLimit: 25e6, storageLimit: 128, showPlaceholder: true, iipSupport: true, iipSizeLimit: 2e7 };
        A2.ImageAddon = class {
          constructor(A3) {
            this._disposables = [], this._handlers = /* @__PURE__ */ new Map(), this._opts = Object.assign({}, a, A3), this._defaultOpts = Object.assign({}, a, A3);
          }
          dispose() {
            for (const A3 of this._disposables) A3.dispose();
            this._disposables.length = 0, this._handlers.clear();
          }
          _disposeLater(...A3) {
            for (const e4 of A3) this._disposables.push(e4);
          }
          activate(A3) {
            if (this._terminal = A3, this._renderer = new s.ImageRenderer(A3), this._storage = new r.ImageStorage(A3, this._renderer, this._opts), this._opts.enableSizeReports) {
              const e4 = A3.options.windowOptions || {};
              e4.getWinSizePixels = true, e4.getCellSizePixels = true, e4.getWinSizeChars = true, A3.options.windowOptions = e4;
            }
            if (this._disposeLater(this._renderer, this._storage, A3.parser.registerCsiHandler({ prefix: "?", final: "h" }, ((A4) => this._decset(A4))), A3.parser.registerCsiHandler({ prefix: "?", final: "l" }, ((A4) => this._decrst(A4))), A3.parser.registerCsiHandler({ final: "c" }, ((A4) => this._da1(A4))), A3.parser.registerCsiHandler({ prefix: "?", final: "S" }, ((A4) => this._xtermGraphicsAttributes(A4))), A3.onRender(((A4) => {
              var e4;
              return null === (e4 = this._storage) || void 0 === e4 ? void 0 : e4.render(A4);
            })), A3.parser.registerCsiHandler({ intermediates: "!", final: "p" }, (() => this.reset())), A3.parser.registerEscHandler({ final: "c" }, (() => this.reset())), A3._core._inputHandler.onRequestReset((() => this.reset())), A3.buffer.onBufferChange((() => {
              var A4;
              return null === (A4 = this._storage) || void 0 === A4 ? void 0 : A4.wipeAlternate();
            })), A3.onResize(((A4) => {
              var e4;
              return null === (e4 = this._storage) || void 0 === e4 ? void 0 : e4.viewportResize(A4);
            }))), this._opts.sixelSupport) {
              const e4 = new g.SixelHandler(this._opts, this._storage, A3);
              this._handlers.set("sixel", e4), this._disposeLater(A3._core._inputHandler._parser.registerDcsHandler({ final: "q" }, e4));
            }
            if (this._opts.iipSupport) {
              const t3 = new e3.IIPHandler(this._opts, this._renderer, this._storage, A3);
              this._handlers.set("iip", t3), this._disposeLater(A3._core._inputHandler._parser.registerOscHandler(1337, t3));
            }
          }
          reset() {
            var A3;
            this._opts.sixelScrolling = this._defaultOpts.sixelScrolling, this._opts.sixelPaletteLimit = this._defaultOpts.sixelPaletteLimit, null === (A3 = this._storage) || void 0 === A3 || A3.reset();
            for (const A4 of this._handlers.values()) A4.reset();
            return false;
          }
          get storageLimit() {
            var A3;
            return (null === (A3 = this._storage) || void 0 === A3 ? void 0 : A3.getLimit()) || -1;
          }
          set storageLimit(A3) {
            var e4;
            null === (e4 = this._storage) || void 0 === e4 || e4.setLimit(A3), this._opts.storageLimit = A3;
          }
          get storageUsage() {
            return this._storage ? this._storage.getUsage() : -1;
          }
          get showPlaceholder() {
            return this._opts.showPlaceholder;
          }
          set showPlaceholder(A3) {
            var e4;
            this._opts.showPlaceholder = A3, null === (e4 = this._renderer) || void 0 === e4 || e4.showPlaceholder(A3);
          }
          getImageAtBufferCell(A3, e4) {
            var t3;
            return null === (t3 = this._storage) || void 0 === t3 ? void 0 : t3.getImageAtBufferCell(A3, e4);
          }
          extractTileAtBufferCell(A3, e4) {
            var t3;
            return null === (t3 = this._storage) || void 0 === t3 ? void 0 : t3.extractTileAtBufferCell(A3, e4);
          }
          _report(A3) {
            var e4;
            null === (e4 = this._terminal) || void 0 === e4 || e4._core.coreService.triggerDataEvent(A3);
          }
          _decset(A3) {
            for (let e4 = 0; e4 < A3.length; ++e4) 80 === A3[e4] && (this._opts.sixelScrolling = false);
            return false;
          }
          _decrst(A3) {
            for (let e4 = 0; e4 < A3.length; ++e4) 80 === A3[e4] && (this._opts.sixelScrolling = true);
            return false;
          }
          _da1(A3) {
            return !!A3[0] || !!this._opts.sixelSupport && (this._report("\x1B[?62;4;9;22c"), true);
          }
          _xtermGraphicsAttributes(A3) {
            var e4, t3, i2, s2, g2, a2;
            if (A3.length < 2) return true;
            if (1 === A3[0]) switch (A3[1]) {
              case 1:
                return this._report(`\x1B[?${A3[0]};0;${this._opts.sixelPaletteLimit}S`), true;
              case 2:
                this._opts.sixelPaletteLimit = this._defaultOpts.sixelPaletteLimit, this._report(`\x1B[?${A3[0]};0;${this._opts.sixelPaletteLimit}S`);
                for (const A4 of this._handlers.values()) A4.reset();
                return true;
              case 3:
                return A3.length > 2 && !(A3[2] instanceof Array) && A3[2] <= 4096 ? (this._opts.sixelPaletteLimit = A3[2], this._report(`\x1B[?${A3[0]};0;${this._opts.sixelPaletteLimit}S`)) : this._report(`\x1B[?${A3[0]};2S`), true;
              case 4:
                return this._report(`\x1B[?${A3[0]};0;4096S`), true;
              default:
                return this._report(`\x1B[?${A3[0]};2S`), true;
            }
            if (2 === A3[0]) switch (A3[1]) {
              case 1:
                let o = null === (t3 = null === (e4 = this._renderer) || void 0 === e4 ? void 0 : e4.dimensions) || void 0 === t3 ? void 0 : t3.css.canvas.width, h = null === (s2 = null === (i2 = this._renderer) || void 0 === i2 ? void 0 : i2.dimensions) || void 0 === s2 ? void 0 : s2.css.canvas.height;
                if (!o || !h) {
                  const A4 = r.CELL_SIZE_DEFAULT;
                  o = ((null === (g2 = this._terminal) || void 0 === g2 ? void 0 : g2.cols) || 80) * A4.width, h = ((null === (a2 = this._terminal) || void 0 === a2 ? void 0 : a2.rows) || 24) * A4.height;
                }
                if (o * h < this._opts.pixelLimit) this._report(`\x1B[?${A3[0]};0;${o.toFixed(0)};${h.toFixed(0)}S`);
                else {
                  const e5 = Math.floor(Math.sqrt(this._opts.pixelLimit));
                  this._report(`\x1B[?${A3[0]};0;${e5};${e5}S`);
                }
                return true;
              case 4:
                const n = Math.floor(Math.sqrt(this._opts.pixelLimit));
                return this._report(`\x1B[?${A3[0]};0;${n};${n}S`), true;
              default:
                return this._report(`\x1B[?${A3[0]};2S`), true;
            }
            return this._report(`\x1B[?${A3[0]};1S`), true;
          }
        };
      })(), i;
    })()));
  })(addonImage);
  return addonImage.exports;
}
__name(requireAddonImage, "requireAddonImage");
var addonImageExports = requireAddonImage();
var addonSearch = { exports: {} };
var hasRequiredAddonSearch;
function requireAddonSearch() {
  if (hasRequiredAddonSearch) return addonSearch.exports;
  hasRequiredAddonSearch = 1;
  (function(module, exports) {
    !(function(e2, t2) {
      module.exports = t2();
    })(self, (() => (() => {
      var e2 = { 345: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.runAndSubscribe = t3.forwardEvent = t3.EventEmitter = void 0, t3.EventEmitter = class {
          constructor() {
            this._listeners = [], this._disposed = false;
          }
          get event() {
            return this._event || (this._event = (e4) => (this._listeners.push(e4), { dispose: /* @__PURE__ */ __name(() => {
              if (!this._disposed) {
                for (let t4 = 0; t4 < this._listeners.length; t4++) if (this._listeners[t4] === e4) return void this._listeners.splice(t4, 1);
              }
            }, "dispose") })), this._event;
          }
          fire(e4, t4) {
            const i2 = [];
            for (let e5 = 0; e5 < this._listeners.length; e5++) i2.push(this._listeners[e5]);
            for (let s2 = 0; s2 < i2.length; s2++) i2[s2].call(void 0, e4, t4);
          }
          dispose() {
            this.clearListeners(), this._disposed = true;
          }
          clearListeners() {
            this._listeners && (this._listeners.length = 0);
          }
        }, t3.forwardEvent = function(e4, t4) {
          return e4(((e5) => t4.fire(e5)));
        }, t3.runAndSubscribe = function(e4, t4) {
          return t4(void 0), e4(((e5) => t4(e5)));
        };
      }, 859: (e3, t3) => {
        function i2(e4) {
          for (const t4 of e4) t4.dispose();
          e4.length = 0;
        }
        __name(i2, "i");
        Object.defineProperty(t3, "__esModule", { value: true }), t3.getDisposeArrayDisposable = t3.disposeArray = t3.toDisposable = t3.MutableDisposable = t3.Disposable = void 0, t3.Disposable = class {
          constructor() {
            this._disposables = [], this._isDisposed = false;
          }
          dispose() {
            this._isDisposed = true;
            for (const e4 of this._disposables) e4.dispose();
            this._disposables.length = 0;
          }
          register(e4) {
            return this._disposables.push(e4), e4;
          }
          unregister(e4) {
            const t4 = this._disposables.indexOf(e4);
            -1 !== t4 && this._disposables.splice(t4, 1);
          }
        }, t3.MutableDisposable = class {
          constructor() {
            this._isDisposed = false;
          }
          get value() {
            return this._isDisposed ? void 0 : this._value;
          }
          set value(e4) {
            this._isDisposed || e4 === this._value || (this._value?.dispose(), this._value = e4);
          }
          clear() {
            this.value = void 0;
          }
          dispose() {
            this._isDisposed = true, this._value?.dispose(), this._value = void 0;
          }
        }, t3.toDisposable = function(e4) {
          return { dispose: e4 };
        }, t3.disposeArray = i2, t3.getDisposeArrayDisposable = function(e4) {
          return { dispose: /* @__PURE__ */ __name(() => i2(e4), "dispose") };
        };
      } }, t2 = {};
      function i(s2) {
        var r = t2[s2];
        if (void 0 !== r) return r.exports;
        var o = t2[s2] = { exports: {} };
        return e2[s2](o, o.exports, i), o.exports;
      }
      __name(i, "i");
      var s = {};
      return (() => {
        var e3 = s;
        Object.defineProperty(e3, "__esModule", { value: true }), e3.SearchAddon = void 0;
        const t3 = i(345), r = i(859), o = " ~!@#$%^&*()+`-=[]{}|\\;:\"',./<>?";
        const _n = class _n extends r.Disposable {
          constructor(e4) {
            super(), this._highlightedLines = /* @__PURE__ */ new Set(), this._highlightDecorations = [], this._selectedDecoration = this.register(new r.MutableDisposable()), this._linesCacheTimeoutId = 0, this._linesCacheDisposables = new r.MutableDisposable(), this._onDidChangeResults = this.register(new t3.EventEmitter()), this.onDidChangeResults = this._onDidChangeResults.event, this._highlightLimit = e4?.highlightLimit ?? 1e3;
          }
          activate(e4) {
            this._terminal = e4, this.register(this._terminal.onWriteParsed((() => this._updateMatches()))), this.register(this._terminal.onResize((() => this._updateMatches()))), this.register((0, r.toDisposable)((() => this.clearDecorations())));
          }
          _updateMatches() {
            this._highlightTimeout && window.clearTimeout(this._highlightTimeout), this._cachedSearchTerm && this._lastSearchOptions?.decorations && (this._highlightTimeout = setTimeout((() => {
              const e4 = this._cachedSearchTerm;
              this._cachedSearchTerm = void 0, this.findPrevious(e4, { ...this._lastSearchOptions, incremental: true, noScroll: true });
            }), 200));
          }
          clearDecorations(e4) {
            this._selectedDecoration.clear(), (0, r.disposeArray)(this._highlightDecorations), this._highlightDecorations = [], this._highlightedLines.clear(), e4 || (this._cachedSearchTerm = void 0);
          }
          clearActiveDecoration() {
            this._selectedDecoration.clear();
          }
          findNext(e4, t4) {
            if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
            const i2 = !this._lastSearchOptions || this._didOptionsChange(this._lastSearchOptions, t4);
            this._lastSearchOptions = t4, t4?.decorations && (void 0 === this._cachedSearchTerm || e4 !== this._cachedSearchTerm || i2) && this._highlightAllMatches(e4, t4);
            const s2 = this._findNextAndSelect(e4, t4);
            return this._fireResults(t4), this._cachedSearchTerm = e4, s2;
          }
          _highlightAllMatches(e4, t4) {
            if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
            if (!e4 || 0 === e4.length) return void this.clearDecorations();
            t4 = t4 || {}, this.clearDecorations(true);
            const i2 = [];
            let s2, r2 = this._find(e4, 0, 0, t4);
            for (; r2 && (s2?.row !== r2.row || s2?.col !== r2.col) && !(i2.length >= this._highlightLimit); ) s2 = r2, i2.push(s2), r2 = this._find(e4, s2.col + s2.term.length >= this._terminal.cols ? s2.row + 1 : s2.row, s2.col + s2.term.length >= this._terminal.cols ? 0 : s2.col + 1, t4);
            for (const e5 of i2) {
              const i3 = this._createResultDecoration(e5, t4.decorations);
              i3 && (this._highlightedLines.add(i3.marker.line), this._highlightDecorations.push({ decoration: i3, match: e5, dispose() {
                i3.dispose();
              } }));
            }
          }
          _find(e4, t4, i2, s2) {
            if (!this._terminal || !e4 || 0 === e4.length) return this._terminal?.clearSelection(), void this.clearDecorations();
            if (i2 > this._terminal.cols) throw new Error(`Invalid col: ${i2} to search in terminal of ${this._terminal.cols} cols`);
            let r2;
            this._initLinesCache();
            const o2 = { startRow: t4, startCol: i2 };
            if (r2 = this._findInLine(e4, o2, s2), !r2) for (let i3 = t4 + 1; i3 < this._terminal.buffer.active.baseY + this._terminal.rows && (o2.startRow = i3, o2.startCol = 0, r2 = this._findInLine(e4, o2, s2), !r2); i3++) ;
            return r2;
          }
          _findNextAndSelect(e4, t4) {
            if (!this._terminal || !e4 || 0 === e4.length) return this._terminal?.clearSelection(), this.clearDecorations(), false;
            const i2 = this._terminal.getSelectionPosition();
            this._terminal.clearSelection();
            let s2 = 0, r2 = 0;
            i2 && (this._cachedSearchTerm === e4 ? (s2 = i2.end.x, r2 = i2.end.y) : (s2 = i2.start.x, r2 = i2.start.y)), this._initLinesCache();
            const o2 = { startRow: r2, startCol: s2 };
            let n2 = this._findInLine(e4, o2, t4);
            if (!n2) for (let i3 = r2 + 1; i3 < this._terminal.buffer.active.baseY + this._terminal.rows && (o2.startRow = i3, o2.startCol = 0, n2 = this._findInLine(e4, o2, t4), !n2); i3++) ;
            if (!n2 && 0 !== r2) for (let i3 = 0; i3 < r2 && (o2.startRow = i3, o2.startCol = 0, n2 = this._findInLine(e4, o2, t4), !n2); i3++) ;
            return !n2 && i2 && (o2.startRow = i2.start.y, o2.startCol = 0, n2 = this._findInLine(e4, o2, t4)), this._selectResult(n2, t4?.decorations, t4?.noScroll);
          }
          findPrevious(e4, t4) {
            if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
            const i2 = !this._lastSearchOptions || this._didOptionsChange(this._lastSearchOptions, t4);
            this._lastSearchOptions = t4, t4?.decorations && (void 0 === this._cachedSearchTerm || e4 !== this._cachedSearchTerm || i2) && this._highlightAllMatches(e4, t4);
            const s2 = this._findPreviousAndSelect(e4, t4);
            return this._fireResults(t4), this._cachedSearchTerm = e4, s2;
          }
          _didOptionsChange(e4, t4) {
            return !!t4 && (e4.caseSensitive !== t4.caseSensitive || e4.regex !== t4.regex || e4.wholeWord !== t4.wholeWord);
          }
          _fireResults(e4) {
            if (e4?.decorations) {
              let e5 = -1;
              if (this._selectedDecoration.value) {
                const t4 = this._selectedDecoration.value.match;
                for (let i2 = 0; i2 < this._highlightDecorations.length; i2++) {
                  const s2 = this._highlightDecorations[i2].match;
                  if (s2.row === t4.row && s2.col === t4.col && s2.size === t4.size) {
                    e5 = i2;
                    break;
                  }
                }
              }
              this._onDidChangeResults.fire({ resultIndex: e5, resultCount: this._highlightDecorations.length });
            }
          }
          _findPreviousAndSelect(e4, t4) {
            if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
            if (!this._terminal || !e4 || 0 === e4.length) return this._terminal?.clearSelection(), this.clearDecorations(), false;
            const i2 = this._terminal.getSelectionPosition();
            this._terminal.clearSelection();
            let s2 = this._terminal.buffer.active.baseY + this._terminal.rows - 1, r2 = this._terminal.cols;
            const o2 = true;
            this._initLinesCache();
            const n2 = { startRow: s2, startCol: r2 };
            let h;
            if (i2 && (n2.startRow = s2 = i2.start.y, n2.startCol = r2 = i2.start.x, this._cachedSearchTerm !== e4 && (h = this._findInLine(e4, n2, t4, false), h || (n2.startRow = s2 = i2.end.y, n2.startCol = r2 = i2.end.x))), h || (h = this._findInLine(e4, n2, t4, o2)), !h) {
              n2.startCol = Math.max(n2.startCol, this._terminal.cols);
              for (let i3 = s2 - 1; i3 >= 0 && (n2.startRow = i3, h = this._findInLine(e4, n2, t4, o2), !h); i3--) ;
            }
            if (!h && s2 !== this._terminal.buffer.active.baseY + this._terminal.rows - 1) for (let i3 = this._terminal.buffer.active.baseY + this._terminal.rows - 1; i3 >= s2 && (n2.startRow = i3, h = this._findInLine(e4, n2, t4, o2), !h); i3--) ;
            return this._selectResult(h, t4?.decorations, t4?.noScroll);
          }
          _initLinesCache() {
            const e4 = this._terminal;
            this._linesCache || (this._linesCache = new Array(e4.buffer.active.length), this._linesCacheDisposables.value = (0, r.getDisposeArrayDisposable)([e4.onLineFeed((() => this._destroyLinesCache())), e4.onCursorMove((() => this._destroyLinesCache())), e4.onResize((() => this._destroyLinesCache()))])), window.clearTimeout(this._linesCacheTimeoutId), this._linesCacheTimeoutId = window.setTimeout((() => this._destroyLinesCache()), 15e3);
          }
          _destroyLinesCache() {
            this._linesCache = void 0, this._linesCacheDisposables.clear(), this._linesCacheTimeoutId && (window.clearTimeout(this._linesCacheTimeoutId), this._linesCacheTimeoutId = 0);
          }
          _isWholeWord(e4, t4, i2) {
            return (0 === e4 || o.includes(t4[e4 - 1])) && (e4 + i2.length === t4.length || o.includes(t4[e4 + i2.length]));
          }
          _findInLine(e4, t4, i2 = {}, s2 = false) {
            const r2 = this._terminal, o2 = t4.startRow, n2 = t4.startCol, h = r2.buffer.active.getLine(o2);
            if (h?.isWrapped) return s2 ? void (t4.startCol += r2.cols) : (t4.startRow--, t4.startCol += r2.cols, this._findInLine(e4, t4, i2));
            let a = this._linesCache?.[o2];
            a || (a = this._translateBufferLineToStringWithWrap(o2, true), this._linesCache && (this._linesCache[o2] = a));
            const [l, c] = a, d = this._bufferColsToStringOffset(o2, n2), _ = i2.caseSensitive ? e4 : e4.toLowerCase(), u = i2.caseSensitive ? l : l.toLowerCase();
            let f = -1;
            if (i2.regex) {
              const t5 = RegExp(_, "g");
              let i3;
              if (s2) for (; i3 = t5.exec(u.slice(0, d)); ) f = t5.lastIndex - i3[0].length, e4 = i3[0], t5.lastIndex -= e4.length - 1;
              else i3 = t5.exec(u.slice(d)), i3 && i3[0].length > 0 && (f = d + (t5.lastIndex - i3[0].length), e4 = i3[0]);
            } else s2 ? d - _.length >= 0 && (f = u.lastIndexOf(_, d - _.length)) : f = u.indexOf(_, d);
            if (f >= 0) {
              if (i2.wholeWord && !this._isWholeWord(f, u, e4)) return;
              let t5 = 0;
              for (; t5 < c.length - 1 && f >= c[t5 + 1]; ) t5++;
              let s3 = t5;
              for (; s3 < c.length - 1 && f + e4.length >= c[s3 + 1]; ) s3++;
              const n3 = f - c[t5], h2 = f + e4.length - c[s3], a2 = this._stringLengthToBufferSize(o2 + t5, n3);
              return { term: e4, col: a2, row: o2 + t5, size: this._stringLengthToBufferSize(o2 + s3, h2) - a2 + r2.cols * (s3 - t5) };
            }
          }
          _stringLengthToBufferSize(e4, t4) {
            const i2 = this._terminal.buffer.active.getLine(e4);
            if (!i2) return 0;
            for (let e5 = 0; e5 < t4; e5++) {
              const s2 = i2.getCell(e5);
              if (!s2) break;
              const r2 = s2.getChars();
              r2.length > 1 && (t4 -= r2.length - 1);
              const o2 = i2.getCell(e5 + 1);
              o2 && 0 === o2.getWidth() && t4++;
            }
            return t4;
          }
          _bufferColsToStringOffset(e4, t4) {
            const i2 = this._terminal;
            let s2 = e4, r2 = 0, o2 = i2.buffer.active.getLine(s2);
            for (; t4 > 0 && o2; ) {
              for (let e5 = 0; e5 < t4 && e5 < i2.cols; e5++) {
                const t5 = o2.getCell(e5);
                if (!t5) break;
                t5.getWidth() && (r2 += 0 === t5.getCode() ? 1 : t5.getChars().length);
              }
              if (s2++, o2 = i2.buffer.active.getLine(s2), o2 && !o2.isWrapped) break;
              t4 -= i2.cols;
            }
            return r2;
          }
          _translateBufferLineToStringWithWrap(e4, t4) {
            const i2 = this._terminal, s2 = [], r2 = [0];
            let o2 = i2.buffer.active.getLine(e4);
            for (; o2; ) {
              const n2 = i2.buffer.active.getLine(e4 + 1), h = !!n2 && n2.isWrapped;
              let a = o2.translateToString(!h && t4);
              if (h && n2) {
                const e5 = o2.getCell(o2.length - 1);
                e5 && 0 === e5.getCode() && 1 === e5.getWidth() && 2 === n2.getCell(0)?.getWidth() && (a = a.slice(0, -1));
              }
              if (s2.push(a), !h) break;
              r2.push(r2[r2.length - 1] + a.length), e4++, o2 = n2;
            }
            return [s2.join(""), r2];
          }
          _selectResult(e4, t4, i2) {
            const s2 = this._terminal;
            if (this._selectedDecoration.clear(), !e4) return s2.clearSelection(), false;
            if (s2.select(e4.col, e4.row, e4.size), t4) {
              const i3 = s2.registerMarker(-s2.buffer.active.baseY - s2.buffer.active.cursorY + e4.row);
              if (i3) {
                const o2 = s2.registerDecoration({ marker: i3, x: e4.col, width: e4.size, backgroundColor: t4.activeMatchBackground, layer: "top", overviewRulerOptions: { color: t4.activeMatchColorOverviewRuler } });
                if (o2) {
                  const s3 = [];
                  s3.push(i3), s3.push(o2.onRender(((e5) => this._applyStyles(e5, t4.activeMatchBorder, true)))), s3.push(o2.onDispose((() => (0, r.disposeArray)(s3)))), this._selectedDecoration.value = { decoration: o2, match: e4, dispose() {
                    o2.dispose();
                  } };
                }
              }
            }
            if (!i2 && (e4.row >= s2.buffer.active.viewportY + s2.rows || e4.row < s2.buffer.active.viewportY)) {
              let t5 = e4.row - s2.buffer.active.viewportY;
              t5 -= Math.floor(s2.rows / 2), s2.scrollLines(t5);
            }
            return true;
          }
          _applyStyles(e4, t4, i2) {
            e4.classList.contains("xterm-find-result-decoration") || (e4.classList.add("xterm-find-result-decoration"), t4 && (e4.style.outline = `1px solid ${t4}`)), i2 && e4.classList.add("xterm-find-active-result-decoration");
          }
          _createResultDecoration(e4, t4) {
            const i2 = this._terminal, s2 = i2.registerMarker(-i2.buffer.active.baseY - i2.buffer.active.cursorY + e4.row);
            if (!s2) return;
            const o2 = i2.registerDecoration({ marker: s2, x: e4.col, width: e4.size, backgroundColor: t4.matchBackground, overviewRulerOptions: this._highlightedLines.has(s2.line) ? void 0 : { color: t4.matchOverviewRuler, position: "center" } });
            if (o2) {
              const e5 = [];
              e5.push(s2), e5.push(o2.onRender(((e6) => this._applyStyles(e6, t4.matchBorder, false)))), e5.push(o2.onDispose((() => (0, r.disposeArray)(e5))));
            }
            return o2;
          }
        };
        __name(_n, "n");
        let n = _n;
        e3.SearchAddon = n;
      })(), s;
    })()));
  })(addonSearch);
  return addonSearch.exports;
}
__name(requireAddonSearch, "requireAddonSearch");
var addonSearchExports = requireAddonSearch();
var addonSerialize$1 = { exports: {} };
var addonSerialize = addonSerialize$1.exports;
var hasRequiredAddonSerialize;
function requireAddonSerialize() {
  if (hasRequiredAddonSerialize) return addonSerialize$1.exports;
  hasRequiredAddonSerialize = 1;
  (function(module, exports) {
    !(function(e2, t2) {
      module.exports = t2();
    })(addonSerialize, (() => (() => {
      var e2 = { 930: (e3, t3, s2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.ColorContrastCache = void 0;
        const r2 = s2(485);
        t3.ColorContrastCache = class {
          constructor() {
            this._color = new r2.TwoKeyMap(), this._css = new r2.TwoKeyMap();
          }
          setCss(e4, t4, s3) {
            this._css.set(e4, t4, s3);
          }
          getCss(e4, t4) {
            return this._css.get(e4, t4);
          }
          setColor(e4, t4, s3) {
            this._color.set(e4, t4, s3);
          }
          getColor(e4, t4) {
            return this._color.get(e4, t4);
          }
          clear() {
            this._color.clear(), this._css.clear();
          }
        };
      }, 997: function(e3, t3, s2) {
        var r2 = this && this.__decorate || function(e4, t4, s3, r3) {
          var o2, i2 = arguments.length, n2 = i2 < 3 ? t4 : null === r3 ? r3 = Object.getOwnPropertyDescriptor(t4, s3) : r3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n2 = Reflect.decorate(e4, t4, s3, r3);
          else for (var l2 = e4.length - 1; l2 >= 0; l2--) (o2 = e4[l2]) && (n2 = (i2 < 3 ? o2(n2) : i2 > 3 ? o2(t4, s3, n2) : o2(t4, s3)) || n2);
          return i2 > 3 && n2 && Object.defineProperty(t4, s3, n2), n2;
        }, o = this && this.__param || function(e4, t4) {
          return function(s3, r3) {
            t4(s3, r3, e4);
          };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.ThemeService = t3.DEFAULT_ANSI_COLORS = void 0;
        const i = s2(930), n = s2(160), l = s2(345), a = s2(859), c = s2(97), h = n.css.toColor("#ffffff"), u = n.css.toColor("#000000"), _ = n.css.toColor("#ffffff"), d = n.css.toColor("#000000"), C = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 };
        t3.DEFAULT_ANSI_COLORS = Object.freeze((() => {
          const e4 = [n.css.toColor("#2e3436"), n.css.toColor("#cc0000"), n.css.toColor("#4e9a06"), n.css.toColor("#c4a000"), n.css.toColor("#3465a4"), n.css.toColor("#75507b"), n.css.toColor("#06989a"), n.css.toColor("#d3d7cf"), n.css.toColor("#555753"), n.css.toColor("#ef2929"), n.css.toColor("#8ae234"), n.css.toColor("#fce94f"), n.css.toColor("#729fcf"), n.css.toColor("#ad7fa8"), n.css.toColor("#34e2e2"), n.css.toColor("#eeeeec")], t4 = [0, 95, 135, 175, 215, 255];
          for (let s3 = 0; s3 < 216; s3++) {
            const r3 = t4[s3 / 36 % 6 | 0], o2 = t4[s3 / 6 % 6 | 0], i2 = t4[s3 % 6];
            e4.push({ css: n.channels.toCss(r3, o2, i2), rgba: n.channels.toRgba(r3, o2, i2) });
          }
          for (let t5 = 0; t5 < 24; t5++) {
            const s3 = 8 + 10 * t5;
            e4.push({ css: n.channels.toCss(s3, s3, s3), rgba: n.channels.toRgba(s3, s3, s3) });
          }
          return e4;
        })());
        let f = t3.ThemeService = class extends a.Disposable {
          get colors() {
            return this._colors;
          }
          constructor(e4) {
            super(), this._optionsService = e4, this._contrastCache = new i.ColorContrastCache(), this._halfContrastCache = new i.ColorContrastCache(), this._onChangeColors = this.register(new l.EventEmitter()), this.onChangeColors = this._onChangeColors.event, this._colors = { foreground: h, background: u, cursor: _, cursorAccent: d, selectionForeground: void 0, selectionBackgroundTransparent: C, selectionBackgroundOpaque: n.color.blend(u, C), selectionInactiveBackgroundTransparent: C, selectionInactiveBackgroundOpaque: n.color.blend(u, C), ansi: t3.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache, halfContrastCache: this._halfContrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", (() => this._contrastCache.clear()))), this.register(this._optionsService.onSpecificOptionChange("theme", (() => this._setTheme(this._optionsService.rawOptions.theme))));
          }
          _setTheme(e4 = {}) {
            const s3 = this._colors;
            if (s3.foreground = g(e4.foreground, h), s3.background = g(e4.background, u), s3.cursor = g(e4.cursor, _), s3.cursorAccent = g(e4.cursorAccent, d), s3.selectionBackgroundTransparent = g(e4.selectionBackground, C), s3.selectionBackgroundOpaque = n.color.blend(s3.background, s3.selectionBackgroundTransparent), s3.selectionInactiveBackgroundTransparent = g(e4.selectionInactiveBackground, s3.selectionBackgroundTransparent), s3.selectionInactiveBackgroundOpaque = n.color.blend(s3.background, s3.selectionInactiveBackgroundTransparent), s3.selectionForeground = e4.selectionForeground ? g(e4.selectionForeground, n.NULL_COLOR) : void 0, s3.selectionForeground === n.NULL_COLOR && (s3.selectionForeground = void 0), n.color.isOpaque(s3.selectionBackgroundTransparent)) {
              const e5 = 0.3;
              s3.selectionBackgroundTransparent = n.color.opacity(s3.selectionBackgroundTransparent, e5);
            }
            if (n.color.isOpaque(s3.selectionInactiveBackgroundTransparent)) {
              const e5 = 0.3;
              s3.selectionInactiveBackgroundTransparent = n.color.opacity(s3.selectionInactiveBackgroundTransparent, e5);
            }
            if (s3.ansi = t3.DEFAULT_ANSI_COLORS.slice(), s3.ansi[0] = g(e4.black, t3.DEFAULT_ANSI_COLORS[0]), s3.ansi[1] = g(e4.red, t3.DEFAULT_ANSI_COLORS[1]), s3.ansi[2] = g(e4.green, t3.DEFAULT_ANSI_COLORS[2]), s3.ansi[3] = g(e4.yellow, t3.DEFAULT_ANSI_COLORS[3]), s3.ansi[4] = g(e4.blue, t3.DEFAULT_ANSI_COLORS[4]), s3.ansi[5] = g(e4.magenta, t3.DEFAULT_ANSI_COLORS[5]), s3.ansi[6] = g(e4.cyan, t3.DEFAULT_ANSI_COLORS[6]), s3.ansi[7] = g(e4.white, t3.DEFAULT_ANSI_COLORS[7]), s3.ansi[8] = g(e4.brightBlack, t3.DEFAULT_ANSI_COLORS[8]), s3.ansi[9] = g(e4.brightRed, t3.DEFAULT_ANSI_COLORS[9]), s3.ansi[10] = g(e4.brightGreen, t3.DEFAULT_ANSI_COLORS[10]), s3.ansi[11] = g(e4.brightYellow, t3.DEFAULT_ANSI_COLORS[11]), s3.ansi[12] = g(e4.brightBlue, t3.DEFAULT_ANSI_COLORS[12]), s3.ansi[13] = g(e4.brightMagenta, t3.DEFAULT_ANSI_COLORS[13]), s3.ansi[14] = g(e4.brightCyan, t3.DEFAULT_ANSI_COLORS[14]), s3.ansi[15] = g(e4.brightWhite, t3.DEFAULT_ANSI_COLORS[15]), e4.extendedAnsi) {
              const r3 = Math.min(s3.ansi.length - 16, e4.extendedAnsi.length);
              for (let o2 = 0; o2 < r3; o2++) s3.ansi[o2 + 16] = g(e4.extendedAnsi[o2], t3.DEFAULT_ANSI_COLORS[o2 + 16]);
            }
            this._contrastCache.clear(), this._halfContrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
          }
          restoreColor(e4) {
            this._restoreColor(e4), this._onChangeColors.fire(this.colors);
          }
          _restoreColor(e4) {
            if (void 0 !== e4) switch (e4) {
              case 256:
                this._colors.foreground = this._restoreColors.foreground;
                break;
              case 257:
                this._colors.background = this._restoreColors.background;
                break;
              case 258:
                this._colors.cursor = this._restoreColors.cursor;
                break;
              default:
                this._colors.ansi[e4] = this._restoreColors.ansi[e4];
            }
            else for (let e5 = 0; e5 < this._restoreColors.ansi.length; ++e5) this._colors.ansi[e5] = this._restoreColors.ansi[e5];
          }
          modifyColors(e4) {
            e4(this._colors), this._onChangeColors.fire(this.colors);
          }
          _updateRestoreColors() {
            this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() };
          }
        };
        function g(e4, t4) {
          if (void 0 !== e4) try {
            return n.css.toColor(e4);
          } catch {
          }
          return t4;
        }
        __name(g, "g");
        t3.ThemeService = f = r2([o(0, c.IOptionsService)], f);
      }, 160: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.contrastRatio = t3.toPaddedHex = t3.rgba = t3.rgb = t3.css = t3.color = t3.channels = t3.NULL_COLOR = void 0;
        let s2 = 0, r2 = 0, o = 0, i = 0;
        var n, l, a, c, h;
        function u(e4) {
          const t4 = e4.toString(16);
          return t4.length < 2 ? "0" + t4 : t4;
        }
        __name(u, "u");
        function _(e4, t4) {
          return e4 < t4 ? (t4 + 0.05) / (e4 + 0.05) : (e4 + 0.05) / (t4 + 0.05);
        }
        __name(_, "_");
        t3.NULL_COLOR = { css: "#00000000", rgba: 0 }, (function(e4) {
          e4.toCss = function(e5, t4, s3, r3) {
            return void 0 !== r3 ? `#${u(e5)}${u(t4)}${u(s3)}${u(r3)}` : `#${u(e5)}${u(t4)}${u(s3)}`;
          }, e4.toRgba = function(e5, t4, s3, r3 = 255) {
            return (e5 << 24 | t4 << 16 | s3 << 8 | r3) >>> 0;
          }, e4.toColor = function(t4, s3, r3, o2) {
            return { css: e4.toCss(t4, s3, r3, o2), rgba: e4.toRgba(t4, s3, r3, o2) };
          };
        })(n || (t3.channels = n = {})), (function(e4) {
          function t4(e5, t5) {
            return i = Math.round(255 * t5), [s2, r2, o] = h.toChannels(e5.rgba), { css: n.toCss(s2, r2, o, i), rgba: n.toRgba(s2, r2, o, i) };
          }
          __name(t4, "t");
          e4.blend = function(e5, t5) {
            if (i = (255 & t5.rgba) / 255, 1 === i) return { css: t5.css, rgba: t5.rgba };
            const l2 = t5.rgba >> 24 & 255, a2 = t5.rgba >> 16 & 255, c2 = t5.rgba >> 8 & 255, h2 = e5.rgba >> 24 & 255, u2 = e5.rgba >> 16 & 255, _2 = e5.rgba >> 8 & 255;
            return s2 = h2 + Math.round((l2 - h2) * i), r2 = u2 + Math.round((a2 - u2) * i), o = _2 + Math.round((c2 - _2) * i), { css: n.toCss(s2, r2, o), rgba: n.toRgba(s2, r2, o) };
          }, e4.isOpaque = function(e5) {
            return 255 == (255 & e5.rgba);
          }, e4.ensureContrastRatio = function(e5, t5, s3) {
            const r3 = h.ensureContrastRatio(e5.rgba, t5.rgba, s3);
            if (r3) return n.toColor(r3 >> 24 & 255, r3 >> 16 & 255, r3 >> 8 & 255);
          }, e4.opaque = function(e5) {
            const t5 = (255 | e5.rgba) >>> 0;
            return [s2, r2, o] = h.toChannels(t5), { css: n.toCss(s2, r2, o), rgba: t5 };
          }, e4.opacity = t4, e4.multiplyOpacity = function(e5, s3) {
            return i = 255 & e5.rgba, t4(e5, i * s3 / 255);
          }, e4.toColorRGB = function(e5) {
            return [e5.rgba >> 24 & 255, e5.rgba >> 16 & 255, e5.rgba >> 8 & 255];
          };
        })(l || (t3.color = l = {})), (function(e4) {
          let t4, l2;
          try {
            const e5 = document.createElement("canvas");
            e5.width = 1, e5.height = 1;
            const s3 = e5.getContext("2d", { willReadFrequently: true });
            s3 && (t4 = s3, t4.globalCompositeOperation = "copy", l2 = t4.createLinearGradient(0, 0, 1, 1));
          } catch {
          }
          e4.toColor = function(e5) {
            if (e5.match(/#[\da-f]{3,8}/i)) switch (e5.length) {
              case 4:
                return s2 = parseInt(e5.slice(1, 2).repeat(2), 16), r2 = parseInt(e5.slice(2, 3).repeat(2), 16), o = parseInt(e5.slice(3, 4).repeat(2), 16), n.toColor(s2, r2, o);
              case 5:
                return s2 = parseInt(e5.slice(1, 2).repeat(2), 16), r2 = parseInt(e5.slice(2, 3).repeat(2), 16), o = parseInt(e5.slice(3, 4).repeat(2), 16), i = parseInt(e5.slice(4, 5).repeat(2), 16), n.toColor(s2, r2, o, i);
              case 7:
                return { css: e5, rgba: (parseInt(e5.slice(1), 16) << 8 | 255) >>> 0 };
              case 9:
                return { css: e5, rgba: parseInt(e5.slice(1), 16) >>> 0 };
            }
            const a2 = e5.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
            if (a2) return s2 = parseInt(a2[1]), r2 = parseInt(a2[2]), o = parseInt(a2[3]), i = Math.round(255 * (void 0 === a2[5] ? 1 : parseFloat(a2[5]))), n.toColor(s2, r2, o, i);
            if (!t4 || !l2) throw new Error("css.toColor: Unsupported css format");
            if (t4.fillStyle = l2, t4.fillStyle = e5, "string" != typeof t4.fillStyle) throw new Error("css.toColor: Unsupported css format");
            if (t4.fillRect(0, 0, 1, 1), [s2, r2, o, i] = t4.getImageData(0, 0, 1, 1).data, 255 !== i) throw new Error("css.toColor: Unsupported css format");
            return { rgba: n.toRgba(s2, r2, o, i), css: e5 };
          };
        })(a || (t3.css = a = {})), (function(e4) {
          function t4(e5, t5, s3) {
            const r3 = e5 / 255, o2 = t5 / 255, i2 = s3 / 255;
            return 0.2126 * (r3 <= 0.03928 ? r3 / 12.92 : Math.pow((r3 + 0.055) / 1.055, 2.4)) + 0.7152 * (o2 <= 0.03928 ? o2 / 12.92 : Math.pow((o2 + 0.055) / 1.055, 2.4)) + 0.0722 * (i2 <= 0.03928 ? i2 / 12.92 : Math.pow((i2 + 0.055) / 1.055, 2.4));
          }
          __name(t4, "t");
          e4.relativeLuminance = function(e5) {
            return t4(e5 >> 16 & 255, e5 >> 8 & 255, 255 & e5);
          }, e4.relativeLuminance2 = t4;
        })(c || (t3.rgb = c = {})), (function(e4) {
          function t4(e5, t5, s3) {
            const r3 = e5 >> 24 & 255, o2 = e5 >> 16 & 255, i2 = e5 >> 8 & 255;
            let n2 = t5 >> 24 & 255, l3 = t5 >> 16 & 255, a2 = t5 >> 8 & 255, h2 = _(c.relativeLuminance2(n2, l3, a2), c.relativeLuminance2(r3, o2, i2));
            for (; h2 < s3 && (n2 > 0 || l3 > 0 || a2 > 0); ) n2 -= Math.max(0, Math.ceil(0.1 * n2)), l3 -= Math.max(0, Math.ceil(0.1 * l3)), a2 -= Math.max(0, Math.ceil(0.1 * a2)), h2 = _(c.relativeLuminance2(n2, l3, a2), c.relativeLuminance2(r3, o2, i2));
            return (n2 << 24 | l3 << 16 | a2 << 8 | 255) >>> 0;
          }
          __name(t4, "t");
          function l2(e5, t5, s3) {
            const r3 = e5 >> 24 & 255, o2 = e5 >> 16 & 255, i2 = e5 >> 8 & 255;
            let n2 = t5 >> 24 & 255, l3 = t5 >> 16 & 255, a2 = t5 >> 8 & 255, h2 = _(c.relativeLuminance2(n2, l3, a2), c.relativeLuminance2(r3, o2, i2));
            for (; h2 < s3 && (n2 < 255 || l3 < 255 || a2 < 255); ) n2 = Math.min(255, n2 + Math.ceil(0.1 * (255 - n2))), l3 = Math.min(255, l3 + Math.ceil(0.1 * (255 - l3))), a2 = Math.min(255, a2 + Math.ceil(0.1 * (255 - a2))), h2 = _(c.relativeLuminance2(n2, l3, a2), c.relativeLuminance2(r3, o2, i2));
            return (n2 << 24 | l3 << 16 | a2 << 8 | 255) >>> 0;
          }
          __name(l2, "l");
          e4.blend = function(e5, t5) {
            if (i = (255 & t5) / 255, 1 === i) return t5;
            const l3 = t5 >> 24 & 255, a2 = t5 >> 16 & 255, c2 = t5 >> 8 & 255, h2 = e5 >> 24 & 255, u2 = e5 >> 16 & 255, _2 = e5 >> 8 & 255;
            return s2 = h2 + Math.round((l3 - h2) * i), r2 = u2 + Math.round((a2 - u2) * i), o = _2 + Math.round((c2 - _2) * i), n.toRgba(s2, r2, o);
          }, e4.ensureContrastRatio = function(e5, s3, r3) {
            const o2 = c.relativeLuminance(e5 >> 8), i2 = c.relativeLuminance(s3 >> 8);
            if (_(o2, i2) < r3) {
              if (i2 < o2) {
                const i3 = t4(e5, s3, r3), n3 = _(o2, c.relativeLuminance(i3 >> 8));
                if (n3 < r3) {
                  const t5 = l2(e5, s3, r3);
                  return n3 > _(o2, c.relativeLuminance(t5 >> 8)) ? i3 : t5;
                }
                return i3;
              }
              const n2 = l2(e5, s3, r3), a2 = _(o2, c.relativeLuminance(n2 >> 8));
              if (a2 < r3) {
                const i3 = t4(e5, s3, r3);
                return a2 > _(o2, c.relativeLuminance(i3 >> 8)) ? n2 : i3;
              }
              return n2;
            }
          }, e4.reduceLuminance = t4, e4.increaseLuminance = l2, e4.toChannels = function(e5) {
            return [e5 >> 24 & 255, e5 >> 16 & 255, e5 >> 8 & 255, 255 & e5];
          };
        })(h || (t3.rgba = h = {})), t3.toPaddedHex = u, t3.contrastRatio = _;
      }, 345: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.runAndSubscribe = t3.forwardEvent = t3.EventEmitter = void 0, t3.EventEmitter = class {
          constructor() {
            this._listeners = [], this._disposed = false;
          }
          get event() {
            return this._event || (this._event = (e4) => (this._listeners.push(e4), { dispose: /* @__PURE__ */ __name(() => {
              if (!this._disposed) {
                for (let t4 = 0; t4 < this._listeners.length; t4++) if (this._listeners[t4] === e4) return void this._listeners.splice(t4, 1);
              }
            }, "dispose") })), this._event;
          }
          fire(e4, t4) {
            const s2 = [];
            for (let e5 = 0; e5 < this._listeners.length; e5++) s2.push(this._listeners[e5]);
            for (let r2 = 0; r2 < s2.length; r2++) s2[r2].call(void 0, e4, t4);
          }
          dispose() {
            this.clearListeners(), this._disposed = true;
          }
          clearListeners() {
            this._listeners && (this._listeners.length = 0);
          }
        }, t3.forwardEvent = function(e4, t4) {
          return e4(((e5) => t4.fire(e5)));
        }, t3.runAndSubscribe = function(e4, t4) {
          return t4(void 0), e4(((e5) => t4(e5)));
        };
      }, 859: (e3, t3) => {
        function s2(e4) {
          for (const t4 of e4) t4.dispose();
          e4.length = 0;
        }
        __name(s2, "s");
        Object.defineProperty(t3, "__esModule", { value: true }), t3.getDisposeArrayDisposable = t3.disposeArray = t3.toDisposable = t3.MutableDisposable = t3.Disposable = void 0, t3.Disposable = class {
          constructor() {
            this._disposables = [], this._isDisposed = false;
          }
          dispose() {
            this._isDisposed = true;
            for (const e4 of this._disposables) e4.dispose();
            this._disposables.length = 0;
          }
          register(e4) {
            return this._disposables.push(e4), e4;
          }
          unregister(e4) {
            const t4 = this._disposables.indexOf(e4);
            -1 !== t4 && this._disposables.splice(t4, 1);
          }
        }, t3.MutableDisposable = class {
          constructor() {
            this._isDisposed = false;
          }
          get value() {
            return this._isDisposed ? void 0 : this._value;
          }
          set value(e4) {
            this._isDisposed || e4 === this._value || (this._value?.dispose(), this._value = e4);
          }
          clear() {
            this.value = void 0;
          }
          dispose() {
            this._isDisposed = true, this._value?.dispose(), this._value = void 0;
          }
        }, t3.toDisposable = function(e4) {
          return { dispose: e4 };
        }, t3.disposeArray = s2, t3.getDisposeArrayDisposable = function(e4) {
          return { dispose: /* @__PURE__ */ __name(() => s2(e4), "dispose") };
        };
      }, 485: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.FourKeyMap = t3.TwoKeyMap = void 0;
        const _s = class _s {
          constructor() {
            this._data = {};
          }
          set(e4, t4, s3) {
            this._data[e4] || (this._data[e4] = {}), this._data[e4][t4] = s3;
          }
          get(e4, t4) {
            return this._data[e4] ? this._data[e4][t4] : void 0;
          }
          clear() {
            this._data = {};
          }
        };
        __name(_s, "s");
        let s2 = _s;
        t3.TwoKeyMap = s2, t3.FourKeyMap = class {
          constructor() {
            this._data = new s2();
          }
          set(e4, t4, r2, o, i) {
            this._data.get(e4, t4) || this._data.set(e4, t4, new s2()), this._data.get(e4, t4).set(r2, o, i);
          }
          get(e4, t4, s3, r2) {
            return this._data.get(e4, t4)?.get(s3, r2);
          }
          clear() {
            this._data.clear();
          }
        };
      }, 726: (e3, t3) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.createDecorator = t3.getServiceDependencies = t3.serviceRegistry = void 0;
        const s2 = "di$target", r2 = "di$dependencies";
        t3.serviceRegistry = /* @__PURE__ */ new Map(), t3.getServiceDependencies = function(e4) {
          return e4[r2] || [];
        }, t3.createDecorator = function(e4) {
          if (t3.serviceRegistry.has(e4)) return t3.serviceRegistry.get(e4);
          const o = /* @__PURE__ */ __name(function(e5, t4, i) {
            if (3 !== arguments.length) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
            !(function(e6, t5, o2) {
              t5[s2] === t5 ? t5[r2].push({ id: e6, index: o2 }) : (t5[r2] = [{ id: e6, index: o2 }], t5[s2] = t5);
            })(o, e5, i);
          }, "o");
          return o.toString = () => e4, t3.serviceRegistry.set(e4, o), o;
        };
      }, 97: (e3, t3, s2) => {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.IDecorationService = t3.IUnicodeService = t3.IOscLinkService = t3.IOptionsService = t3.ILogService = t3.LogLevelEnum = t3.IInstantiationService = t3.ICharsetService = t3.ICoreService = t3.ICoreMouseService = t3.IBufferService = void 0;
        const r2 = s2(726);
        var o;
        t3.IBufferService = (0, r2.createDecorator)("BufferService"), t3.ICoreMouseService = (0, r2.createDecorator)("CoreMouseService"), t3.ICoreService = (0, r2.createDecorator)("CoreService"), t3.ICharsetService = (0, r2.createDecorator)("CharsetService"), t3.IInstantiationService = (0, r2.createDecorator)("InstantiationService"), (function(e4) {
          e4[e4.TRACE = 0] = "TRACE", e4[e4.DEBUG = 1] = "DEBUG", e4[e4.INFO = 2] = "INFO", e4[e4.WARN = 3] = "WARN", e4[e4.ERROR = 4] = "ERROR", e4[e4.OFF = 5] = "OFF";
        })(o || (t3.LogLevelEnum = o = {})), t3.ILogService = (0, r2.createDecorator)("LogService"), t3.IOptionsService = (0, r2.createDecorator)("OptionsService"), t3.IOscLinkService = (0, r2.createDecorator)("OscLinkService"), t3.IUnicodeService = (0, r2.createDecorator)("UnicodeService"), t3.IDecorationService = (0, r2.createDecorator)("DecorationService");
      } }, t2 = {};
      function s(r2) {
        var o = t2[r2];
        if (void 0 !== o) return o.exports;
        var i = t2[r2] = { exports: {} };
        return e2[r2].call(i.exports, i, i.exports, s), i.exports;
      }
      __name(s, "s");
      var r = {};
      return (() => {
        var e3 = r;
        Object.defineProperty(e3, "__esModule", { value: true }), e3.HTMLSerializeHandler = e3.SerializeAddon = void 0;
        const t3 = s(997);
        function o(e4, t4, s2) {
          return Math.max(t4, Math.min(e4, s2));
        }
        __name(o, "o");
        const _i = class _i {
          constructor(e4) {
            this._buffer = e4;
          }
          serialize(e4, t4) {
            const s2 = this._buffer.getNullCell(), r2 = this._buffer.getNullCell();
            let o2 = s2;
            const i2 = e4.start.y, n2 = e4.end.y, l2 = e4.start.x, a2 = e4.end.x;
            this._beforeSerialize(n2 - i2, i2, n2);
            for (let t5 = i2; t5 <= n2; t5++) {
              const i3 = this._buffer.getLine(t5);
              if (i3) {
                const n3 = t5 === e4.start.y ? l2 : 0, c2 = t5 === e4.end.y ? a2 : i3.length;
                for (let e5 = n3; e5 < c2; e5++) {
                  const n4 = i3.getCell(e5, o2 === s2 ? r2 : s2);
                  n4 ? (this._nextCell(n4, o2, t5, e5), o2 = n4) : console.warn(`Can't get cell at row=${t5}, col=${e5}`);
                }
              }
              this._rowEnd(t5, t5 === n2);
            }
            return this._afterSerialize(), this._serializeString(t4);
          }
          _nextCell(e4, t4, s2, r2) {
          }
          _rowEnd(e4, t4) {
          }
          _beforeSerialize(e4, t4, s2) {
          }
          _afterSerialize() {
          }
          _serializeString(e4) {
            return "";
          }
        };
        __name(_i, "i");
        let i = _i;
        function n(e4, t4) {
          return e4.getFgColorMode() === t4.getFgColorMode() && e4.getFgColor() === t4.getFgColor();
        }
        __name(n, "n");
        function l(e4, t4) {
          return e4.getBgColorMode() === t4.getBgColorMode() && e4.getBgColor() === t4.getBgColor();
        }
        __name(l, "l");
        function a(e4, t4) {
          return e4.isInverse() === t4.isInverse() && e4.isBold() === t4.isBold() && e4.isUnderline() === t4.isUnderline() && e4.isOverline() === t4.isOverline() && e4.isBlink() === t4.isBlink() && e4.isInvisible() === t4.isInvisible() && e4.isItalic() === t4.isItalic() && e4.isDim() === t4.isDim() && e4.isStrikethrough() === t4.isStrikethrough();
        }
        __name(a, "a");
        const _c2 = class _c2 extends i {
          constructor(e4, t4) {
            super(e4), this._terminal = t4, this._rowIndex = 0, this._allRows = new Array(), this._allRowSeparators = new Array(), this._currentRow = "", this._nullCellCount = 0, this._cursorStyle = this._buffer.getNullCell(), this._cursorStyleRow = 0, this._cursorStyleCol = 0, this._backgroundCell = this._buffer.getNullCell(), this._firstRow = 0, this._lastCursorRow = 0, this._lastCursorCol = 0, this._lastContentCursorRow = 0, this._lastContentCursorCol = 0, this._thisRowLastChar = this._buffer.getNullCell(), this._thisRowLastSecondChar = this._buffer.getNullCell(), this._nextRowFirstChar = this._buffer.getNullCell();
          }
          _beforeSerialize(e4, t4, s2) {
            this._allRows = new Array(e4), this._lastContentCursorRow = t4, this._lastCursorRow = t4, this._firstRow = t4;
          }
          _rowEnd(e4, t4) {
            this._nullCellCount > 0 && !l(this._cursorStyle, this._backgroundCell) && (this._currentRow += `\x1B[${this._nullCellCount}X`);
            let s2 = "";
            if (!t4) {
              e4 - this._firstRow >= this._terminal.rows && this._buffer.getLine(this._cursorStyleRow)?.getCell(this._cursorStyleCol, this._backgroundCell);
              const t5 = this._buffer.getLine(e4), r2 = this._buffer.getLine(e4 + 1);
              if (r2.isWrapped) {
                s2 = "";
                const o2 = t5.getCell(t5.length - 1, this._thisRowLastChar), i2 = t5.getCell(t5.length - 2, this._thisRowLastSecondChar), n2 = r2.getCell(0, this._nextRowFirstChar), a2 = n2.getWidth() > 1;
                let c2 = false;
                (n2.getChars() && a2 ? this._nullCellCount <= 1 : this._nullCellCount <= 0) && ((o2.getChars() || 0 === o2.getWidth()) && l(o2, n2) && (c2 = true), a2 && (i2.getChars() || 0 === i2.getWidth()) && l(o2, n2) && l(i2, n2) && (c2 = true)), c2 || (s2 = "-".repeat(this._nullCellCount + 1), s2 += "\x1B[1D\x1B[1X", this._nullCellCount > 0 && (s2 += "\x1B[A", s2 += `\x1B[${t5.length - this._nullCellCount}C`, s2 += `\x1B[${this._nullCellCount}X`, s2 += `\x1B[${t5.length - this._nullCellCount}D`, s2 += "\x1B[B"), this._lastContentCursorRow = e4 + 1, this._lastContentCursorCol = 0, this._lastCursorRow = e4 + 1, this._lastCursorCol = 0);
              } else s2 = "\r\n", this._lastCursorRow = e4 + 1, this._lastCursorCol = 0;
            }
            this._allRows[this._rowIndex] = this._currentRow, this._allRowSeparators[this._rowIndex++] = s2, this._currentRow = "", this._nullCellCount = 0;
          }
          _diffStyle(e4, t4) {
            const s2 = [], r2 = !n(e4, t4), o2 = !l(e4, t4), i2 = !a(e4, t4);
            if (r2 || o2 || i2) if (e4.isAttributeDefault()) t4.isAttributeDefault() || s2.push(0);
            else {
              if (r2) {
                const t5 = e4.getFgColor();
                e4.isFgRGB() ? s2.push(38, 2, t5 >>> 16 & 255, t5 >>> 8 & 255, 255 & t5) : e4.isFgPalette() ? t5 >= 16 ? s2.push(38, 5, t5) : s2.push(8 & t5 ? 90 + (7 & t5) : 30 + (7 & t5)) : s2.push(39);
              }
              if (o2) {
                const t5 = e4.getBgColor();
                e4.isBgRGB() ? s2.push(48, 2, t5 >>> 16 & 255, t5 >>> 8 & 255, 255 & t5) : e4.isBgPalette() ? t5 >= 16 ? s2.push(48, 5, t5) : s2.push(8 & t5 ? 100 + (7 & t5) : 40 + (7 & t5)) : s2.push(49);
              }
              i2 && (e4.isInverse() !== t4.isInverse() && s2.push(e4.isInverse() ? 7 : 27), e4.isBold() !== t4.isBold() && s2.push(e4.isBold() ? 1 : 22), e4.isUnderline() !== t4.isUnderline() && s2.push(e4.isUnderline() ? 4 : 24), e4.isOverline() !== t4.isOverline() && s2.push(e4.isOverline() ? 53 : 55), e4.isBlink() !== t4.isBlink() && s2.push(e4.isBlink() ? 5 : 25), e4.isInvisible() !== t4.isInvisible() && s2.push(e4.isInvisible() ? 8 : 28), e4.isItalic() !== t4.isItalic() && s2.push(e4.isItalic() ? 3 : 23), e4.isDim() !== t4.isDim() && s2.push(e4.isDim() ? 2 : 22), e4.isStrikethrough() !== t4.isStrikethrough() && s2.push(e4.isStrikethrough() ? 9 : 29));
            }
            return s2;
          }
          _nextCell(e4, t4, s2, r2) {
            if (0 === e4.getWidth()) return;
            const o2 = "" === e4.getChars(), i2 = this._diffStyle(e4, this._cursorStyle);
            if (o2 ? !l(this._cursorStyle, e4) : i2.length > 0) {
              this._nullCellCount > 0 && (l(this._cursorStyle, this._backgroundCell) || (this._currentRow += `\x1B[${this._nullCellCount}X`), this._currentRow += `\x1B[${this._nullCellCount}C`, this._nullCellCount = 0), this._lastContentCursorRow = this._lastCursorRow = s2, this._lastContentCursorCol = this._lastCursorCol = r2, this._currentRow += `\x1B[${i2.join(";")}m`;
              const e5 = this._buffer.getLine(s2);
              void 0 !== e5 && (e5.getCell(r2, this._cursorStyle), this._cursorStyleRow = s2, this._cursorStyleCol = r2);
            }
            o2 ? this._nullCellCount += e4.getWidth() : (this._nullCellCount > 0 && (l(this._cursorStyle, this._backgroundCell) || (this._currentRow += `\x1B[${this._nullCellCount}X`), this._currentRow += `\x1B[${this._nullCellCount}C`, this._nullCellCount = 0), this._currentRow += e4.getChars(), this._lastContentCursorRow = this._lastCursorRow = s2, this._lastContentCursorCol = this._lastCursorCol = r2 + e4.getWidth());
          }
          _serializeString(e4) {
            let t4 = this._allRows.length;
            this._buffer.length - this._firstRow <= this._terminal.rows && (t4 = this._lastContentCursorRow + 1 - this._firstRow, this._lastCursorCol = this._lastContentCursorCol, this._lastCursorRow = this._lastContentCursorRow);
            let s2 = "";
            for (let e5 = 0; e5 < t4; e5++) s2 += this._allRows[e5], e5 + 1 < t4 && (s2 += this._allRowSeparators[e5]);
            if (!e4) {
              const e5 = this._buffer.baseY + this._buffer.cursorY, t5 = this._buffer.cursorX, o3 = /* @__PURE__ */ __name((e6) => {
                e6 > 0 ? s2 += `\x1B[${e6}C` : e6 < 0 && (s2 += `\x1B[${-e6}D`);
              }, "o");
              (e5 !== this._lastCursorRow || t5 !== this._lastCursorCol) && ((r2 = e5 - this._lastCursorRow) > 0 ? s2 += `\x1B[${r2}B` : r2 < 0 && (s2 += `\x1B[${-r2}A`), o3(t5 - this._lastCursorCol));
            }
            var r2;
            const o2 = this._terminal._core._inputHandler._curAttrData, i2 = this._diffStyle(o2, this._cursorStyle);
            return i2.length > 0 && (s2 += `\x1B[${i2.join(";")}m`), s2;
          }
        };
        __name(_c2, "c");
        let c = _c2;
        e3.SerializeAddon = class {
          activate(e4) {
            this._terminal = e4;
          }
          _serializeBufferByScrollback(e4, t4, s2) {
            const r2 = t4.length, i2 = void 0 === s2 ? r2 : o(s2 + e4.rows, 0, r2);
            return this._serializeBufferByRange(e4, t4, { start: r2 - i2, end: r2 - 1 }, false);
          }
          _serializeBufferByRange(e4, t4, s2, r2) {
            return new c(t4, e4).serialize({ start: { x: 0, y: "number" == typeof s2.start ? s2.start : s2.start.line }, end: { x: e4.cols, y: "number" == typeof s2.end ? s2.end : s2.end.line } }, r2);
          }
          _serializeBufferAsHTML(e4, t4) {
            const s2 = e4.buffer.active, r2 = new h(s2, e4, t4);
            if (!t4.onlySelection) {
              const i3 = s2.length, n2 = t4.scrollback, l2 = void 0 === n2 ? i3 : o(n2 + e4.rows, 0, i3);
              return r2.serialize({ start: { x: 0, y: i3 - l2 }, end: { x: e4.cols, y: i3 - 1 } });
            }
            const i2 = this._terminal?.getSelectionPosition();
            return void 0 !== i2 ? r2.serialize({ start: { x: i2.start.x, y: i2.start.y }, end: { x: i2.end.x, y: i2.end.y } }) : "";
          }
          _serializeModes(e4) {
            let t4 = "";
            const s2 = e4.modes;
            if (s2.applicationCursorKeysMode && (t4 += "\x1B[?1h"), s2.applicationKeypadMode && (t4 += "\x1B[?66h"), s2.bracketedPasteMode && (t4 += "\x1B[?2004h"), s2.insertMode && (t4 += "\x1B[4h"), s2.originMode && (t4 += "\x1B[?6h"), s2.reverseWraparoundMode && (t4 += "\x1B[?45h"), s2.sendFocusMode && (t4 += "\x1B[?1004h"), false === s2.wraparoundMode && (t4 += "\x1B[?7l"), "none" !== s2.mouseTrackingMode) switch (s2.mouseTrackingMode) {
              case "x10":
                t4 += "\x1B[?9h";
                break;
              case "vt200":
                t4 += "\x1B[?1000h";
                break;
              case "drag":
                t4 += "\x1B[?1002h";
                break;
              case "any":
                t4 += "\x1B[?1003h";
            }
            return t4;
          }
          serialize(e4) {
            if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
            let t4 = e4?.range ? this._serializeBufferByRange(this._terminal, this._terminal.buffer.normal, e4.range, true) : this._serializeBufferByScrollback(this._terminal, this._terminal.buffer.normal, e4?.scrollback);
            return e4?.excludeAltBuffer || "alternate" !== this._terminal.buffer.active.type || (t4 += `\x1B[?1049h\x1B[H${this._serializeBufferByScrollback(this._terminal, this._terminal.buffer.alternate, void 0)}`), e4?.excludeModes || (t4 += this._serializeModes(this._terminal)), t4;
          }
          serializeAsHTML(e4) {
            if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
            return this._serializeBufferAsHTML(this._terminal, e4 || {});
          }
          dispose() {
          }
        };
        const _h = class _h extends i {
          constructor(e4, s2, r2) {
            super(e4), this._terminal = s2, this._options = r2, this._currentRow = "", this._htmlContent = "", s2._core._themeService ? this._ansiColors = s2._core._themeService.colors.ansi : this._ansiColors = t3.DEFAULT_ANSI_COLORS;
          }
          _padStart(e4, t4, s2) {
            return t4 >>= 0, s2 = s2 ?? " ", e4.length > t4 ? e4 : ((t4 -= e4.length) > s2.length && (s2 += s2.repeat(t4 / s2.length)), s2.slice(0, t4) + e4);
          }
          _beforeSerialize(e4, t4, s2) {
            this._htmlContent += "<html><body><!--StartFragment--><pre>";
            let r2 = "#000000", o2 = "#ffffff";
            this._options.includeGlobalBackground && (r2 = this._terminal.options.theme?.foreground ?? "#ffffff", o2 = this._terminal.options.theme?.background ?? "#000000");
            const i2 = [];
            i2.push("color: " + r2 + ";"), i2.push("background-color: " + o2 + ";"), i2.push("font-family: " + this._terminal.options.fontFamily + ";"), i2.push("font-size: " + this._terminal.options.fontSize + "px;"), this._htmlContent += "<div style='" + i2.join(" ") + "'>";
          }
          _afterSerialize() {
            this._htmlContent += "</div>", this._htmlContent += "</pre><!--EndFragment--></body></html>";
          }
          _rowEnd(e4, t4) {
            this._htmlContent += "<div><span>" + this._currentRow + "</span></div>", this._currentRow = "";
          }
          _getHexColor(e4, t4) {
            const s2 = t4 ? e4.getFgColor() : e4.getBgColor();
            return (t4 ? e4.isFgRGB() : e4.isBgRGB()) ? "#" + [s2 >> 16 & 255, s2 >> 8 & 255, 255 & s2].map(((e5) => this._padStart(e5.toString(16), 2, "0"))).join("") : (t4 ? e4.isFgPalette() : e4.isBgPalette()) ? this._ansiColors[s2].css : void 0;
          }
          _diffStyle(e4, t4) {
            const s2 = [], r2 = !n(e4, t4), o2 = !l(e4, t4), i2 = !a(e4, t4);
            if (r2 || o2 || i2) {
              const t5 = this._getHexColor(e4, true);
              t5 && s2.push("color: " + t5 + ";");
              const r3 = this._getHexColor(e4, false);
              return r3 && s2.push("background-color: " + r3 + ";"), e4.isInverse() && s2.push("color: #000000; background-color: #BFBFBF;"), e4.isBold() && s2.push("font-weight: bold;"), e4.isUnderline() && e4.isOverline() ? s2.push("text-decoration: overline underline;") : e4.isUnderline() ? s2.push("text-decoration: underline;") : e4.isOverline() && s2.push("text-decoration: overline;"), e4.isBlink() && s2.push("text-decoration: blink;"), e4.isInvisible() && s2.push("visibility: hidden;"), e4.isItalic() && s2.push("font-style: italic;"), e4.isDim() && s2.push("opacity: 0.5;"), e4.isStrikethrough() && s2.push("text-decoration: line-through;"), s2;
            }
          }
          _nextCell(e4, t4, s2, r2) {
            if (0 === e4.getWidth()) return;
            const o2 = "" === e4.getChars(), i2 = this._diffStyle(e4, t4);
            i2 && (this._currentRow += 0 === i2.length ? "</span><span>" : "</span><span style='" + i2.join(" ") + "'>"), this._currentRow += o2 ? " " : e4.getChars();
          }
          _serializeString() {
            return this._htmlContent;
          }
        };
        __name(_h, "h");
        let h = _h;
        e3.HTMLSerializeHandler = h;
      })(), r;
    })()));
  })(addonSerialize$1);
  return addonSerialize$1.exports;
}
__name(requireAddonSerialize, "requireAddonSerialize");
var addonSerializeExports = requireAddonSerialize();
var addonWebLinks = { exports: {} };
var hasRequiredAddonWebLinks;
function requireAddonWebLinks() {
  if (hasRequiredAddonWebLinks) return addonWebLinks.exports;
  hasRequiredAddonWebLinks = 1;
  (function(module, exports) {
    !(function(e2, t2) {
      module.exports = t2();
    })(self, (() => (() => {
      var e2 = { 6: (e3, t3) => {
        function n2(e4) {
          try {
            const t4 = new URL(e4), n3 = t4.password && t4.username ? `${t4.protocol}//${t4.username}:${t4.password}@${t4.host}` : t4.username ? `${t4.protocol}//${t4.username}@${t4.host}` : `${t4.protocol}//${t4.host}`;
            return e4.toLocaleLowerCase().startsWith(n3.toLocaleLowerCase());
          } catch (e5) {
            return false;
          }
        }
        __name(n2, "n");
        Object.defineProperty(t3, "__esModule", { value: true }), t3.LinkComputer = t3.WebLinkProvider = void 0, t3.WebLinkProvider = class {
          constructor(e4, t4, n3, o3 = {}) {
            this._terminal = e4, this._regex = t4, this._handler = n3, this._options = o3;
          }
          provideLinks(e4, t4) {
            const n3 = o2.computeLink(e4, this._regex, this._terminal, this._handler);
            t4(this._addCallbacks(n3));
          }
          _addCallbacks(e4) {
            return e4.map(((e5) => (e5.leave = this._options.leave, e5.hover = (t4, n3) => {
              if (this._options.hover) {
                const { range: o3 } = e5;
                this._options.hover(t4, n3, o3);
              }
            }, e5)));
          }
        };
        const _o = class _o {
          static computeLink(e4, t4, r, i) {
            const s = new RegExp(t4.source, (t4.flags || "") + "g"), [a, c] = _o._getWindowedLineStrings(e4 - 1, r), l = a.join("");
            let d;
            const p = [];
            for (; d = s.exec(l); ) {
              const e5 = d[0];
              if (!n2(e5)) continue;
              const [t5, s2] = _o._mapStrIdx(r, c, 0, d.index), [a2, l2] = _o._mapStrIdx(r, t5, s2, e5.length);
              if (-1 === t5 || -1 === s2 || -1 === a2 || -1 === l2) continue;
              const h = { start: { x: s2 + 1, y: t5 + 1 }, end: { x: l2, y: a2 + 1 } };
              p.push({ range: h, text: e5, activate: i });
            }
            return p;
          }
          static _getWindowedLineStrings(e4, t4) {
            let n3, o3 = e4, r = e4, i = 0, s = "";
            const a = [];
            if (n3 = t4.buffer.active.getLine(e4)) {
              const e5 = n3.translateToString(true);
              if (n3.isWrapped && " " !== e5[0]) {
                for (i = 0; (n3 = t4.buffer.active.getLine(--o3)) && i < 2048 && (s = n3.translateToString(true), i += s.length, a.push(s), n3.isWrapped && -1 === s.indexOf(" ")); ) ;
                a.reverse();
              }
              for (a.push(e5), i = 0; (n3 = t4.buffer.active.getLine(++r)) && n3.isWrapped && i < 2048 && (s = n3.translateToString(true), i += s.length, a.push(s), -1 === s.indexOf(" ")); ) ;
            }
            return [a, o3];
          }
          static _mapStrIdx(e4, t4, n3, o3) {
            const r = e4.buffer.active, i = r.getNullCell();
            let s = n3;
            for (; o3; ) {
              const e5 = r.getLine(t4);
              if (!e5) return [-1, -1];
              for (let n4 = s; n4 < e5.length; ++n4) {
                e5.getCell(n4, i);
                const s2 = i.getChars();
                if (i.getWidth() && (o3 -= s2.length || 1, n4 === e5.length - 1 && "" === s2)) {
                  const e6 = r.getLine(t4 + 1);
                  e6 && e6.isWrapped && (e6.getCell(0, i), 2 === i.getWidth() && (o3 += 1));
                }
                if (o3 < 0) return [t4, n4];
              }
              t4++, s = 0;
            }
            return [t4, s];
          }
        };
        __name(_o, "o");
        let o2 = _o;
        t3.LinkComputer = o2;
      } }, t2 = {};
      function n(o2) {
        var r = t2[o2];
        if (void 0 !== r) return r.exports;
        var i = t2[o2] = { exports: {} };
        return e2[o2](i, i.exports, n), i.exports;
      }
      __name(n, "n");
      var o = {};
      return (() => {
        var e3 = o;
        Object.defineProperty(e3, "__esModule", { value: true }), e3.WebLinksAddon = void 0;
        const t3 = n(6), r = /(https?|HTTPS?):[/]{2}[^\s"'!*(){}|\\\^<>`]*[^\s"':,.!?{}|\\\^~\[\]`()<>]/;
        function i(e4, t4) {
          const n2 = window.open();
          if (n2) {
            try {
              n2.opener = null;
            } catch {
            }
            n2.location.href = t4;
          } else console.warn("Opening link blocked as opener could not be cleared");
        }
        __name(i, "i");
        e3.WebLinksAddon = class {
          constructor(e4 = i, t4 = {}) {
            this._handler = e4, this._options = t4;
          }
          activate(e4) {
            this._terminal = e4;
            const n2 = this._options, o2 = n2.urlRegex || r;
            this._linkProvider = this._terminal.registerLinkProvider(new t3.WebLinkProvider(this._terminal, o2, this._handler, n2));
          }
          dispose() {
            this._linkProvider?.dispose();
          }
        };
      })(), o;
    })()));
  })(addonWebLinks);
  return addonWebLinks.exports;
}
__name(requireAddonWebLinks, "requireAddonWebLinks");
var addonWebLinksExports = requireAddonWebLinks();
var humanFormat$2 = { exports: {} };
var humanFormat$1 = humanFormat$2.exports;
var hasRequiredHumanFormat;
function requireHumanFormat() {
  if (hasRequiredHumanFormat) return humanFormat$2.exports;
  hasRequiredHumanFormat = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory();
      }
    })(humanFormat$1, function() {
      function assign2(dst, src) {
        var i, n, prop;
        for (i = 1, n = arguments.length; i < n; ++i) {
          src = arguments[i];
          if (src != null) {
            for (prop in src) {
              if (has2(src, prop)) {
                dst[prop] = src[prop];
              }
            }
          }
        }
        return dst;
      }
      __name(assign2, "assign");
      function compareLongestFirst(a, b) {
        return b.length - a.length;
      }
      __name(compareLongestFirst, "compareLongestFirst");
      function compareSmallestFactorFirst(a, b) {
        return a.factor - b.factor;
      }
      __name(compareSmallestFactorFirst, "compareSmallestFactorFirst");
      function escapeRegexp(str) {
        return str.replace(/([.*+?=^!:${}()|[\]/\\])/g, "\\$1");
      }
      __name(escapeRegexp, "escapeRegexp");
      function forEach(arr, iterator) {
        var i, n;
        for (i = 0, n = arr.length; i < n; ++i) {
          iterator(arr[i], i);
        }
      }
      __name(forEach, "forEach");
      function forOwn(obj, iterator) {
        var prop;
        for (prop in obj) {
          if (has2(obj, prop)) {
            iterator(obj[prop], prop);
          }
        }
      }
      __name(forOwn, "forOwn");
      var has2 = /* @__PURE__ */ (function(hasOwnProperty) {
        return /* @__PURE__ */ __name(function has3(obj, prop) {
          return obj != null && hasOwnProperty.call(obj, prop);
        }, "has");
      })(Object.prototype.hasOwnProperty);
      function resolve2(container, entry) {
        while (typeof entry === "string") {
          entry = container[entry];
        }
        return entry;
      }
      __name(resolve2, "resolve");
      function Scale(prefixes) {
        this._prefixes = prefixes;
        var escapedPrefixes = [];
        var list2 = [];
        forOwn(prefixes, function(factor, prefix) {
          escapedPrefixes.push(escapeRegexp(prefix));
          list2.push({
            factor,
            prefix
          });
        });
        var lcPrefixes = this._lcPrefixes = {};
        forOwn(prefixes, function(factor, prefix) {
          var lcPrefix = prefix.toLowerCase();
          if (!has2(prefixes, lcPrefix)) {
            lcPrefixes[lcPrefix] = prefix;
          }
        });
        list2.sort(compareSmallestFactorFirst);
        this._list = list2;
        escapedPrefixes.sort(compareLongestFirst);
        this._regexp = new RegExp(
          "^\\s*(-)?\\s*(\\d+(?:\\.\\d+)?)\\s*(" + escapedPrefixes.join("|") + ")\\s*(.*)\\s*?$",
          "i"
        );
      }
      __name(Scale, "Scale");
      Scale.create = /* @__PURE__ */ __name(function Scale$create(prefixesList, base, initExp) {
        var prefixes = {};
        if (initExp === void 0) {
          initExp = 0;
        }
        forEach(prefixesList, function(prefix, i) {
          prefixes[prefix] = Math.pow(base, i + initExp);
        });
        return new Scale(prefixes);
      }, "Scale$create");
      Scale.prototype.findPrefix = /* @__PURE__ */ __name(function Scale$findPrefix(value) {
        var list2 = this._list;
        var low = 0;
        var high = list2.length - 1;
        var mid, current;
        while (low !== high) {
          mid = low + high + 1 >> 1;
          current = list2[mid].factor;
          if (current > value) {
            high = mid - 1;
          } else {
            low = mid;
          }
        }
        return list2[low];
      }, "Scale$findPrefix");
      Scale.prototype.parse = /* @__PURE__ */ __name(function Scale$parse(str, strict) {
        var matches = str.match(this._regexp);
        if (matches === null) {
          return;
        }
        var prefix = matches[3];
        var factor;
        if (has2(this._prefixes, prefix)) {
          factor = this._prefixes[prefix];
        } else if (!strict && (prefix = prefix.toLowerCase(), has2(this._lcPrefixes, prefix))) {
          prefix = this._lcPrefixes[prefix];
          factor = this._prefixes[prefix];
        } else {
          return;
        }
        var value = +matches[2];
        if (matches[1] !== void 0) {
          value = -value;
        }
        return {
          factor,
          prefix,
          unit: matches[4],
          value
        };
      }, "Scale$parse");
      var scales = {
        // https://en.wikipedia.org/wiki/Binary_prefix
        binary: Scale.create(",Ki,Mi,Gi,Ti,Pi,Ei,Zi,Yi".split(","), 1024),
        // https://en.wikipedia.org/wiki/Metric_prefix
        //
        // Not all prefixes are present, only those which are multiple of
        // 1000, because humans usually prefer to see close numbers using
        // the same unit to ease the comparison.
        SI: Scale.create("y,z,a,f,p,n,µ,m,,k,M,G,T,P,E,Z,Y".split(","), 1e3, -8)
      };
      var defaults = {
        // Decimal digits for formatting.
        maxDecimals: 2,
        // separator to use between value and units
        separator: " ",
        // Unit to use for formatting.
        unit: ""
      };
      var rawDefaults = {
        scale: "SI",
        // Strict mode prevents parsing of incorrectly cased prefixes.
        strict: false
      };
      function humanFormat2(value, opts) {
        opts = assign2({}, defaults, opts);
        var decimals = opts.decimals;
        if (decimals !== void 0) {
          delete opts.maxDecimals;
        }
        var info2 = humanFormat$raw(value, opts);
        value = decimals !== void 0 ? info2.value.toFixed(decimals) : String(info2.value);
        var suffix = info2.prefix + opts.unit;
        return suffix === "" ? value : value + opts.separator + suffix;
      }
      __name(humanFormat2, "humanFormat");
      var humanFormat$bytes$opts = { scale: "binary", unit: "B" };
      function humanFormat$bytes(value, opts) {
        return humanFormat2(
          value,
          opts === void 0 ? humanFormat$bytes$opts : assign2({}, humanFormat$bytes$opts, opts)
        );
      }
      __name(humanFormat$bytes, "humanFormat$bytes");
      function humanFormat$parse(str, opts) {
        var info2 = humanFormat$parse$raw(str, opts);
        return info2.value * info2.factor;
      }
      __name(humanFormat$parse, "humanFormat$parse");
      function humanFormat$parse$raw(str, opts) {
        if (typeof str !== "string") {
          throw new TypeError("str must be a string");
        }
        opts = assign2({}, rawDefaults, opts);
        var scale = resolve2(scales, opts.scale);
        if (scale === void 0) {
          throw new Error("missing scale");
        }
        var info2 = scale.parse(str, opts.strict);
        if (info2 === void 0) {
          throw new Error("cannot parse str");
        }
        return info2;
      }
      __name(humanFormat$parse$raw, "humanFormat$parse$raw");
      function humanFormat$raw(value, opts) {
        if (value === 0) {
          return {
            value: 0,
            prefix: ""
          };
        } else if (value < 0) {
          var result = humanFormat$raw(-value, opts);
          result.value = -result.value;
          return result;
        }
        if (typeof value !== "number" || Number.isNaN(value)) {
          throw new TypeError("value must be a number");
        }
        opts = assign2({}, rawDefaults, opts);
        var scale = resolve2(scales, opts.scale);
        if (scale === void 0) {
          throw new Error("missing scale");
        }
        var power;
        var maxDecimals = opts.maxDecimals;
        var autoMaxDecimals = maxDecimals === "auto";
        if (autoMaxDecimals) {
          power = 10;
        } else if (maxDecimals !== void 0) {
          power = Math.pow(10, maxDecimals);
        }
        var prefix = opts.prefix;
        var factor;
        if (prefix !== void 0) {
          if (!has2(scale._prefixes, prefix)) {
            throw new Error("invalid prefix");
          }
          factor = scale._prefixes[prefix];
        } else {
          var _ref = scale.findPrefix(value);
          if (power !== void 0) {
            do {
              factor = _ref.factor;
              var r = factor / power;
              value = Math.round(value / r) * r;
            } while ((_ref = scale.findPrefix(value)).factor !== factor);
          } else {
            factor = _ref.factor;
          }
          prefix = _ref.prefix;
        }
        value = power === void 0 ? value / factor : Math.round(value * power / factor) / power;
        if (autoMaxDecimals && Math.abs(value) >= 10) {
          value = Math.round(value);
        }
        return {
          prefix,
          value
        };
      }
      __name(humanFormat$raw, "humanFormat$raw");
      humanFormat2.bytes = humanFormat$bytes;
      humanFormat2.parse = humanFormat$parse;
      humanFormat$parse.raw = humanFormat$parse$raw;
      humanFormat2.raw = humanFormat$raw;
      humanFormat2.Scale = Scale;
      return humanFormat2;
    });
  })(humanFormat$2);
  return humanFormat$2.exports;
}
__name(requireHumanFormat, "requireHumanFormat");
var humanFormatExports = requireHumanFormat();
const humanFormat = /* @__PURE__ */ getDefaultExportFromCjs$1(humanFormatExports);
function findReplace(array2, findFn, ...replaceWiths) {
  const found = [];
  if (!Array.isArray(array2)) {
    throw new Error("Input must be an array");
  }
  for (const [index, value] of array2.entries()) {
    let expanded = [];
    replaceWiths.forEach((replaceWith) => {
      if (typeof replaceWith === "function") {
        expanded = expanded.concat(replaceWith(value));
      } else {
        expanded.push(replaceWith);
      }
    });
    if (findFn(value)) {
      found.push({
        index,
        replaceWithValue: expanded
      });
    }
  }
  for (const item of found.reverse()) {
    const spliceArgs = [item.index, 1].concat(item.replaceWithValue);
    array2.splice.apply(array2, spliceArgs);
  }
  return array2;
}
__name(findReplace, "findReplace");
const re$1 = {
  short: /^-([^\d-])$/,
  long: /^--(\S+)/,
  combinedShort: /^-[^\d-]{2,}$/,
  optEquals: /^(--\S+?)=(.*)/
};
const _ArgvArray = class _ArgvArray extends Array {
  /**
   * Clears the array has loads the supplied input.
   * @param {string[]} argv - The argv list to load. Defaults to `process.argv`.
   */
  load(argv) {
    this.clear();
    if (argv && argv !== process$1.argv) {
      argv = arrayify$5(argv);
    } else {
      argv = process$1.argv.slice(0);
      const deleteCount = process$1.execArgv.some(isExecArg) ? 1 : 2;
      argv.splice(0, deleteCount);
    }
    argv.forEach((arg) => this.push(String(arg)));
  }
  /**
   * Clear the array.
   */
  clear() {
    this.length = 0;
  }
  /**
   * expand ``--option=value` style args.
   */
  expandOptionEqualsNotation() {
    if (this.some((arg) => re$1.optEquals.test(arg))) {
      const expandedArgs = [];
      this.forEach((arg) => {
        const matches = arg.match(re$1.optEquals);
        if (matches) {
          expandedArgs.push(matches[1], matches[2]);
        } else {
          expandedArgs.push(arg);
        }
      });
      this.clear();
      this.load(expandedArgs);
    }
  }
  /**
   * expand getopt-style combinedShort options.
   */
  expandGetoptNotation() {
    if (this.hasCombinedShortOptions()) {
      findReplace(this, re$1.combinedShort, expandCombinedShortArg);
    }
  }
  /**
   * Returns true if the array contains combined short options (e.g. `-ab`).
   * @returns {boolean}
   */
  hasCombinedShortOptions() {
    return this.some((arg) => re$1.combinedShort.test(arg));
  }
  static from(argv) {
    const result = new this();
    result.load(argv);
    return result;
  }
};
__name(_ArgvArray, "ArgvArray");
let ArgvArray = _ArgvArray;
function expandCombinedShortArg(arg) {
  arg = arg.slice(1);
  return arg.split("").map((letter) => "-" + letter);
}
__name(expandCombinedShortArg, "expandCombinedShortArg");
function isOptionEqualsNotation(arg) {
  return re$1.optEquals.test(arg);
}
__name(isOptionEqualsNotation, "isOptionEqualsNotation");
function isOption(arg) {
  return (re$1.short.test(arg) || re$1.long.test(arg)) && !re$1.optEquals.test(arg);
}
__name(isOption, "isOption");
function isLongOption(arg) {
  return re$1.long.test(arg) && !isOptionEqualsNotation(arg);
}
__name(isLongOption, "isLongOption");
function getOptionName(arg) {
  if (re$1.short.test(arg)) {
    return arg.match(re$1.short)[1];
  } else if (isLongOption(arg)) {
    return arg.match(re$1.long)[1];
  } else if (isOptionEqualsNotation(arg)) {
    return arg.match(re$1.optEquals)[1].replace(/^--/, "");
  } else {
    return null;
  }
}
__name(getOptionName, "getOptionName");
function isValue(arg) {
  return !(isOption(arg) || re$1.combinedShort.test(arg) || re$1.optEquals.test(arg));
}
__name(isValue, "isValue");
function isExecArg(arg) {
  return ["--eval", "-e"].indexOf(arg) > -1 || arg.startsWith("--eval=");
}
__name(isExecArg, "isExecArg");
function isNumber(n) {
  return !isNaN(parseFloat(n));
}
__name(isNumber, "isNumber");
function isFiniteNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
__name(isFiniteNumber, "isFiniteNumber");
function isPlainObject(input) {
  return input !== null && typeof input === "object" && input.constructor === Object;
}
__name(isPlainObject, "isPlainObject");
function isArrayLike(input) {
  return isObject(input) && typeof input.length === "number";
}
__name(isArrayLike, "isArrayLike");
function isObject(input) {
  return typeof input === "object" && input !== null;
}
__name(isObject, "isObject");
function isDefined(input) {
  return typeof input !== "undefined";
}
__name(isDefined, "isDefined");
function isUndefined(input) {
  return !isDefined(input);
}
__name(isUndefined, "isUndefined");
function isNull(input) {
  return input === null;
}
__name(isNull, "isNull");
function isDefinedValue(input) {
  return isDefined(input) && !isNull(input) && !Number.isNaN(input);
}
__name(isDefinedValue, "isDefinedValue");
function isClass(input) {
  if (typeof input === "function") {
    return /^class /.test(Function.prototype.toString.call(input));
  } else {
    return false;
  }
}
__name(isClass, "isClass");
function isPrimitive(input) {
  if (input === null) return true;
  switch (typeof input) {
    case "string":
    case "number":
    case "symbol":
    case "undefined":
    case "boolean":
      return true;
    default:
      return false;
  }
}
__name(isPrimitive, "isPrimitive");
function isPromise(input) {
  if (input) {
    const isPromise2 = isDefined(Promise) && input instanceof Promise;
    const isThenable = input.then && typeof input.then === "function";
    return !!(isPromise2 || isThenable);
  } else {
    return false;
  }
}
__name(isPromise, "isPromise");
function isIterable(input) {
  if (input === null || !isDefined(input)) {
    return false;
  } else {
    return typeof input[Symbol.iterator] === "function" || typeof input[Symbol.asyncIterator] === "function";
  }
}
__name(isIterable, "isIterable");
function isString$1(input) {
  return typeof input === "string";
}
__name(isString$1, "isString$1");
function isFunction(input) {
  return typeof input === "function";
}
__name(isFunction, "isFunction");
function isAsyncFunction(input) {
  return typeof input === "function" && input.constructor.name === "AsyncFunction";
}
__name(isAsyncFunction, "isAsyncFunction");
const t = {
  isNumber,
  isFiniteNumber,
  isPlainObject,
  isArrayLike,
  isObject,
  isDefined,
  isUndefined,
  isNull,
  isDefinedValue,
  isClass,
  isPrimitive,
  isPromise,
  isIterable,
  isString: isString$1,
  isFunction,
  isAsyncFunction
};
const _OptionDefinition = class _OptionDefinition {
  constructor(definition) {
    this.name = definition.name;
    this.type = definition.type || String;
    this.alias = definition.alias;
    this.multiple = definition.multiple;
    this.lazyMultiple = definition.lazyMultiple;
    this.defaultOption = definition.defaultOption;
    this.defaultValue = definition.defaultValue;
    this.group = definition.group;
    for (const prop in definition) {
      if (!this[prop]) this[prop] = definition[prop];
    }
  }
  isBoolean() {
    return this.type === Boolean || t.isFunction(this.type) && this.type.name === "Boolean";
  }
  isMultiple() {
    return this.multiple || this.lazyMultiple;
  }
  static create(def) {
    const result = new this(def);
    return result;
  }
};
__name(_OptionDefinition, "OptionDefinition");
let OptionDefinition = _OptionDefinition;
const _Definitions = class _Definitions extends Array {
  /**
   * validate option definitions
   * @param {boolean} [caseInsensitive=false] - whether arguments will be parsed in a case insensitive manner
   * @returns {string}
   */
  validate(caseInsensitive) {
    const someHaveNoName = this.some((def) => !def.name);
    if (someHaveNoName) {
      halt(
        "INVALID_DEFINITIONS",
        "Invalid option definitions: the `name` property is required on each definition"
      );
    }
    const someDontHaveFunctionType = this.some((def) => def.type && typeof def.type !== "function");
    if (someDontHaveFunctionType) {
      halt(
        "INVALID_DEFINITIONS",
        "Invalid option definitions: the `type` property must be a setter fuction (default: `Boolean`)"
      );
    }
    let invalidOption;
    const numericAlias = this.some((def) => {
      invalidOption = def;
      return t.isDefined(def.alias) && t.isNumber(def.alias);
    });
    if (numericAlias) {
      halt(
        "INVALID_DEFINITIONS",
        "Invalid option definition: to avoid ambiguity an alias cannot be numeric [--" + invalidOption.name + " alias is -" + invalidOption.alias + "]"
      );
    }
    const multiCharacterAlias = this.some((def) => {
      invalidOption = def;
      return t.isDefined(def.alias) && def.alias.length !== 1;
    });
    if (multiCharacterAlias) {
      halt(
        "INVALID_DEFINITIONS",
        "Invalid option definition: an alias must be a single character"
      );
    }
    const hypenAlias = this.some((def) => {
      invalidOption = def;
      return def.alias === "-";
    });
    if (hypenAlias) {
      halt(
        "INVALID_DEFINITIONS",
        'Invalid option definition: an alias cannot be "-"'
      );
    }
    const duplicateName = hasDuplicates(this.map((def) => caseInsensitive ? def.name.toLowerCase() : def.name));
    if (duplicateName) {
      halt(
        "INVALID_DEFINITIONS",
        "Two or more option definitions have the same name"
      );
    }
    const duplicateAlias = hasDuplicates(this.map((def) => caseInsensitive && t.isDefined(def.alias) ? def.alias.toLowerCase() : def.alias));
    if (duplicateAlias) {
      halt(
        "INVALID_DEFINITIONS",
        "Two or more option definitions have the same alias"
      );
    }
    const duplicateDefaultOption = this.filter((def) => def.defaultOption === true).length > 1;
    if (duplicateDefaultOption) {
      halt(
        "INVALID_DEFINITIONS",
        "Only one option definition can be the defaultOption"
      );
    }
    const defaultBoolean = this.some((def) => {
      invalidOption = def;
      return def.isBoolean() && def.defaultOption;
    });
    if (defaultBoolean) {
      halt(
        "INVALID_DEFINITIONS",
        `A boolean option ["${invalidOption.name}"] can not also be the defaultOption.`
      );
    }
  }
  /**
   * Get definition by option arg (e.g. `--one` or `-o`)
   * @param {string} [arg] the argument name to get the definition for
   * @param {boolean} [caseInsensitive] whether to use case insensitive comparisons when finding the appropriate definition
   * @returns {Definition}
   */
  get(arg, caseInsensitive) {
    if (isOption(arg)) {
      if (re$1.short.test(arg)) {
        const shortOptionName = getOptionName(arg);
        if (caseInsensitive) {
          const lowercaseShortOptionName = shortOptionName.toLowerCase();
          return this.find((def) => t.isDefined(def.alias) && def.alias.toLowerCase() === lowercaseShortOptionName);
        } else {
          return this.find((def) => def.alias === shortOptionName);
        }
      } else {
        const optionName = getOptionName(arg);
        if (caseInsensitive) {
          const lowercaseOptionName = optionName.toLowerCase();
          return this.find((def) => def.name.toLowerCase() === lowercaseOptionName);
        } else {
          return this.find((def) => def.name === optionName);
        }
      }
    } else {
      return this.find((def) => def.name === arg);
    }
  }
  getDefault() {
    return this.find((def) => def.defaultOption === true);
  }
  isGrouped() {
    return this.some((def) => def.group);
  }
  whereGrouped() {
    return this.filter(containsValidGroup);
  }
  whereNotGrouped() {
    return this.filter((def) => !containsValidGroup(def));
  }
  whereDefaultValueSet() {
    return this.filter((def) => t.isDefined(def.defaultValue));
  }
  static from(definitions, caseInsensitive) {
    if (definitions instanceof this) return definitions;
    const result = super.from(arrayify$5(definitions), (def) => OptionDefinition.create(def));
    result.validate(caseInsensitive);
    return result;
  }
};
__name(_Definitions, "Definitions");
let Definitions = _Definitions;
function halt(name, message) {
  const err2 = new Error(message);
  err2.name = name;
  throw err2;
}
__name(halt, "halt");
function containsValidGroup(def) {
  return arrayify$5(def.group).some((group) => group);
}
__name(containsValidGroup, "containsValidGroup");
function hasDuplicates(array2) {
  const items = {};
  for (let i = 0; i < array2.length; i++) {
    const value = array2[i];
    if (items[value]) {
      return true;
    } else {
      if (t.isDefined(value)) items[value] = true;
    }
  }
}
__name(hasDuplicates, "hasDuplicates");
const _ArgvParser = class _ArgvParser {
  /**
   * @param {OptionDefinitions} - Definitions array
   * @param {object} [options] - Options
   * @param {string[]} [options.argv] - Overrides `process.argv`
   * @param {boolean} [options.stopAtFirstUnknown] -
   * @param {boolean} [options.caseInsensitive] - Arguments will be parsed in a case insensitive manner. Defaults to false.
   */
  constructor(definitions, options) {
    this.options = Object.assign({}, options);
    this.definitions = Definitions.from(definitions, this.options.caseInsensitive);
    this.argv = ArgvArray.from(this.options.argv);
    if (this.argv.hasCombinedShortOptions()) {
      findReplace(this.argv, re$1.combinedShort.test.bind(re$1.combinedShort), (arg) => {
        arg = arg.slice(1);
        return arg.split("").map((letter) => ({ origArg: `-${arg}`, arg: "-" + letter }));
      });
    }
  }
  /**
   * Yields one `{ event, name, value, arg, def }` argInfo object for each arg in `process.argv` (or `options.argv`).
   */
  *[Symbol.iterator]() {
    const definitions = this.definitions;
    let def;
    let value;
    let name;
    let event;
    let singularDefaultSet = false;
    let unknownFound = false;
    let origArg;
    for (let arg of this.argv) {
      if (t.isPlainObject(arg)) {
        origArg = arg.origArg;
        arg = arg.arg;
      }
      if (unknownFound && this.options.stopAtFirstUnknown) {
        yield { event: "unknown_value", arg, name: "_unknown", value: void 0 };
        continue;
      }
      if (isOption(arg)) {
        def = definitions.get(arg, this.options.caseInsensitive);
        value = void 0;
        if (def) {
          value = def.isBoolean() ? true : null;
          event = "set";
        } else {
          event = "unknown_option";
        }
      } else if (isOptionEqualsNotation(arg)) {
        const matches = arg.match(re$1.optEquals);
        def = definitions.get(matches[1], this.options.caseInsensitive);
        if (def) {
          if (def.isBoolean()) {
            yield { event: "unknown_value", arg, name: "_unknown", value, def };
            event = "set";
            value = true;
          } else {
            event = "set";
            value = matches[2];
          }
        } else {
          event = "unknown_option";
        }
      } else if (isValue(arg)) {
        if (def) {
          value = arg;
          event = "set";
        } else {
          def = this.definitions.getDefault();
          if (def && !singularDefaultSet) {
            value = arg;
            event = "set";
          } else {
            event = "unknown_value";
            def = void 0;
          }
        }
      }
      name = def ? def.name : "_unknown";
      const argInfo = { event, arg, name, value, def };
      if (origArg) {
        argInfo.subArg = arg;
        argInfo.arg = origArg;
      }
      yield argInfo;
      if (name === "_unknown") unknownFound = true;
      if (def && def.defaultOption && !def.isMultiple() && event === "set") singularDefaultSet = true;
      if (def && def.isBoolean()) def = void 0;
      if (def && !def.multiple && t.isDefined(value) && value !== null) {
        def = void 0;
      }
      value = void 0;
      event = void 0;
      name = void 0;
      origArg = void 0;
    }
  }
};
__name(_ArgvParser, "ArgvParser");
let ArgvParser = _ArgvParser;
const _value$1 = /* @__PURE__ */ new WeakMap();
const _Option = class _Option {
  constructor(definition) {
    this.definition = new OptionDefinition(definition);
    this.state = null;
    this.resetToDefault();
  }
  get() {
    return _value$1.get(this);
  }
  set(val) {
    this._set(val, "set");
  }
  _set(val, state2) {
    const def = this.definition;
    if (def.isMultiple()) {
      if (val !== null && val !== void 0) {
        const arr = this.get();
        if (this.state === "default") arr.length = 0;
        arr.push(def.type(val));
        this.state = state2;
      }
    } else {
      if (!def.isMultiple() && this.state === "set") {
        const err2 = new Error(`Singular option already set [${this.definition.name}=${this.get()}]`);
        err2.name = "ALREADY_SET";
        err2.value = val;
        err2.optionName = def.name;
        throw err2;
      } else if (val === null || val === void 0) {
        _value$1.set(this, val);
      } else {
        _value$1.set(this, def.type(val));
        this.state = state2;
      }
    }
  }
  resetToDefault() {
    if (t.isDefined(this.definition.defaultValue)) {
      if (this.definition.isMultiple()) {
        _value$1.set(this, arrayify$5(this.definition.defaultValue).slice());
      } else {
        _value$1.set(this, this.definition.defaultValue);
      }
    } else {
      if (this.definition.isMultiple()) {
        _value$1.set(this, []);
      } else {
        _value$1.set(this, null);
      }
    }
    this.state = "default";
  }
  static create(definition) {
    definition = new OptionDefinition(definition);
    if (definition.isBoolean()) {
      return FlagOption.create(definition);
    } else {
      return new this(definition);
    }
  }
};
__name(_Option, "Option");
let Option = _Option;
const _FlagOption = class _FlagOption extends Option {
  set(val) {
    super.set(true);
  }
  static create(def) {
    return new this(def);
  }
};
__name(_FlagOption, "FlagOption");
let FlagOption = _FlagOption;
var lodash_camelcase;
var hasRequiredLodash_camelcase;
function requireLodash_camelcase() {
  if (hasRequiredLodash_camelcase) return lodash_camelcase;
  hasRequiredLodash_camelcase = 1;
  var symbolTag = "[object Symbol]";
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange = "\\u20d0-\\u20f0", rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
  var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")", rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
  var reApos = RegExp(rsApos, "g");
  var reComboMark = RegExp(rsCombo, "g");
  var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
    rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
    rsUpper + "+" + rsOptUpperContr,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  var deburredLetters = {
    // Latin-1 Supplement block.
    "À": "A",
    "Á": "A",
    "Â": "A",
    "Ã": "A",
    "Ä": "A",
    "Å": "A",
    "à": "a",
    "á": "a",
    "â": "a",
    "ã": "a",
    "ä": "a",
    "å": "a",
    "Ç": "C",
    "ç": "c",
    "Ð": "D",
    "ð": "d",
    "È": "E",
    "É": "E",
    "Ê": "E",
    "Ë": "E",
    "è": "e",
    "é": "e",
    "ê": "e",
    "ë": "e",
    "Ì": "I",
    "Í": "I",
    "Î": "I",
    "Ï": "I",
    "ì": "i",
    "í": "i",
    "î": "i",
    "ï": "i",
    "Ñ": "N",
    "ñ": "n",
    "Ò": "O",
    "Ó": "O",
    "Ô": "O",
    "Õ": "O",
    "Ö": "O",
    "Ø": "O",
    "ò": "o",
    "ó": "o",
    "ô": "o",
    "õ": "o",
    "ö": "o",
    "ø": "o",
    "Ù": "U",
    "Ú": "U",
    "Û": "U",
    "Ü": "U",
    "ù": "u",
    "ú": "u",
    "û": "u",
    "ü": "u",
    "Ý": "Y",
    "ý": "y",
    "ÿ": "y",
    "Æ": "Ae",
    "æ": "ae",
    "Þ": "Th",
    "þ": "th",
    "ß": "ss",
    // Latin Extended-A block.
    "Ā": "A",
    "Ă": "A",
    "Ą": "A",
    "ā": "a",
    "ă": "a",
    "ą": "a",
    "Ć": "C",
    "Ĉ": "C",
    "Ċ": "C",
    "Č": "C",
    "ć": "c",
    "ĉ": "c",
    "ċ": "c",
    "č": "c",
    "Ď": "D",
    "Đ": "D",
    "ď": "d",
    "đ": "d",
    "Ē": "E",
    "Ĕ": "E",
    "Ė": "E",
    "Ę": "E",
    "Ě": "E",
    "ē": "e",
    "ĕ": "e",
    "ė": "e",
    "ę": "e",
    "ě": "e",
    "Ĝ": "G",
    "Ğ": "G",
    "Ġ": "G",
    "Ģ": "G",
    "ĝ": "g",
    "ğ": "g",
    "ġ": "g",
    "ģ": "g",
    "Ĥ": "H",
    "Ħ": "H",
    "ĥ": "h",
    "ħ": "h",
    "Ĩ": "I",
    "Ī": "I",
    "Ĭ": "I",
    "Į": "I",
    "İ": "I",
    "ĩ": "i",
    "ī": "i",
    "ĭ": "i",
    "į": "i",
    "ı": "i",
    "Ĵ": "J",
    "ĵ": "j",
    "Ķ": "K",
    "ķ": "k",
    "ĸ": "k",
    "Ĺ": "L",
    "Ļ": "L",
    "Ľ": "L",
    "Ŀ": "L",
    "Ł": "L",
    "ĺ": "l",
    "ļ": "l",
    "ľ": "l",
    "ŀ": "l",
    "ł": "l",
    "Ń": "N",
    "Ņ": "N",
    "Ň": "N",
    "Ŋ": "N",
    "ń": "n",
    "ņ": "n",
    "ň": "n",
    "ŋ": "n",
    "Ō": "O",
    "Ŏ": "O",
    "Ő": "O",
    "ō": "o",
    "ŏ": "o",
    "ő": "o",
    "Ŕ": "R",
    "Ŗ": "R",
    "Ř": "R",
    "ŕ": "r",
    "ŗ": "r",
    "ř": "r",
    "Ś": "S",
    "Ŝ": "S",
    "Ş": "S",
    "Š": "S",
    "ś": "s",
    "ŝ": "s",
    "ş": "s",
    "š": "s",
    "Ţ": "T",
    "Ť": "T",
    "Ŧ": "T",
    "ţ": "t",
    "ť": "t",
    "ŧ": "t",
    "Ũ": "U",
    "Ū": "U",
    "Ŭ": "U",
    "Ů": "U",
    "Ű": "U",
    "Ų": "U",
    "ũ": "u",
    "ū": "u",
    "ŭ": "u",
    "ů": "u",
    "ű": "u",
    "ų": "u",
    "Ŵ": "W",
    "ŵ": "w",
    "Ŷ": "Y",
    "ŷ": "y",
    "Ÿ": "Y",
    "Ź": "Z",
    "Ż": "Z",
    "Ž": "Z",
    "ź": "z",
    "ż": "z",
    "ž": "z",
    "Ĳ": "IJ",
    "ĳ": "ij",
    "Œ": "Oe",
    "œ": "oe",
    "ŉ": "'n",
    "ſ": "ss"
  };
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayReduce(array2, iteratee, accumulator, initAccum) {
    var index = -1, length = array2 ? array2.length : 0;
    while (++index < length) {
      accumulator = iteratee(accumulator, array2[index], index, array2);
    }
    return accumulator;
  }
  __name(arrayReduce, "arrayReduce");
  function asciiToArray(string) {
    return string.split("");
  }
  __name(asciiToArray, "asciiToArray");
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }
  __name(asciiWords, "asciiWords");
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? void 0 : object[key];
    };
  }
  __name(basePropertyOf, "basePropertyOf");
  var deburrLetter = basePropertyOf(deburredLetters);
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }
  __name(hasUnicode, "hasUnicode");
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }
  __name(hasUnicodeWord, "hasUnicodeWord");
  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }
  __name(stringToArray, "stringToArray");
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }
  __name(unicodeToArray, "unicodeToArray");
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }
  __name(unicodeWords, "unicodeWords");
  var objectProto = Object.prototype;
  var objectToString2 = objectProto.toString;
  var Symbol2 = root.Symbol;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseSlice(array2, start, end) {
    var index = -1, length = array2.length;
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
      result[index] = array2[index + start];
    }
    return result;
  }
  __name(baseSlice, "baseSlice");
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  __name(baseToString, "baseToString");
  function castSlice(array2, start, end) {
    var length = array2.length;
    end = end === void 0 ? length : end;
    return !start && end >= length ? array2 : baseSlice(array2, start, end);
  }
  __name(castSlice, "castSlice");
  function createCaseFirst(methodName) {
    return function(string) {
      string = toString2(string);
      var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
      var chr = strSymbols ? strSymbols[0] : string.charAt(0);
      var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
      return chr[methodName]() + trailing;
    };
  }
  __name(createCaseFirst, "createCaseFirst");
  function createCompounder(callback) {
    return function(string) {
      return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
    };
  }
  __name(createCompounder, "createCompounder");
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  __name(isObjectLike, "isObjectLike");
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString2.call(value) == symbolTag;
  }
  __name(isSymbol, "isSymbol");
  function toString2(value) {
    return value == null ? "" : baseToString(value);
  }
  __name(toString2, "toString");
  var camelCase2 = createCompounder(function(result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize2(word) : word);
  });
  function capitalize2(string) {
    return upperFirst(toString2(string).toLowerCase());
  }
  __name(capitalize2, "capitalize");
  function deburr(string) {
    string = toString2(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
  }
  __name(deburr, "deburr");
  var upperFirst = createCaseFirst("toUpperCase");
  function words(string, pattern2, guard) {
    string = toString2(string);
    pattern2 = pattern2;
    if (pattern2 === void 0) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern2) || [];
  }
  __name(words, "words");
  lodash_camelcase = camelCase2;
  return lodash_camelcase;
}
__name(requireLodash_camelcase, "requireLodash_camelcase");
var lodash_camelcaseExports = requireLodash_camelcase();
const camelCase = /* @__PURE__ */ getDefaultExportFromCjs$1(lodash_camelcaseExports);
const _Output = class _Output extends Map {
  constructor(definitions) {
    super();
    this.definitions = Definitions.from(definitions);
    this.set("_unknown", Option.create({ name: "_unknown", multiple: true }));
    for (const def of this.definitions.whereDefaultValueSet()) {
      this.set(def.name, Option.create(def));
    }
  }
  toObject(options) {
    options = options || {};
    const output2 = {};
    for (const item of this) {
      const name = options.camelCase && item[0] !== "_unknown" ? camelCase(item[0]) : item[0];
      const option = item[1];
      if (name === "_unknown" && !option.get().length) continue;
      output2[name] = option.get();
    }
    if (options.skipUnknown) delete output2._unknown;
    return output2;
  }
};
__name(_Output, "Output");
let Output = _Output;
const _GroupedOutput = class _GroupedOutput extends Output {
  toObject(options) {
    const superOutputNoCamel = super.toObject({ skipUnknown: options.skipUnknown });
    const superOutput = super.toObject(options);
    const unknown = superOutput._unknown;
    delete superOutput._unknown;
    const grouped = {
      _all: superOutput
    };
    if (unknown && unknown.length) grouped._unknown = unknown;
    this.definitions.whereGrouped().forEach((def) => {
      const name = options.camelCase ? camelCase(def.name) : def.name;
      const outputValue = superOutputNoCamel[def.name];
      for (const groupName of arrayify$5(def.group)) {
        grouped[groupName] = grouped[groupName] || {};
        if (t.isDefined(outputValue)) {
          grouped[groupName][name] = outputValue;
        }
      }
    });
    this.definitions.whereNotGrouped().forEach((def) => {
      const name = options.camelCase ? camelCase(def.name) : def.name;
      const outputValue = superOutputNoCamel[def.name];
      if (t.isDefined(outputValue)) {
        if (!grouped._none) grouped._none = {};
        grouped._none[name] = outputValue;
      }
    });
    return grouped;
  }
};
__name(_GroupedOutput, "GroupedOutput");
let GroupedOutput = _GroupedOutput;
function commandLineArgs(optionDefinitions, options) {
  options = options || {};
  if (options.stopAtFirstUnknown) options.partial = true;
  optionDefinitions = Definitions.from(optionDefinitions, options.caseInsensitive);
  const parser = new ArgvParser(optionDefinitions, {
    argv: options.argv,
    stopAtFirstUnknown: options.stopAtFirstUnknown,
    caseInsensitive: options.caseInsensitive
  });
  const OutputClass = optionDefinitions.isGrouped() ? GroupedOutput : Output;
  const output2 = new OutputClass(optionDefinitions);
  for (const argInfo of parser) {
    const arg = argInfo.subArg || argInfo.arg;
    if (!options.partial) {
      if (argInfo.event === "unknown_value") {
        const err2 = new Error(`Unknown value: ${arg}`);
        err2.name = "UNKNOWN_VALUE";
        err2.value = arg;
        throw err2;
      } else if (argInfo.event === "unknown_option") {
        const err2 = new Error(`Unknown option: ${arg}`);
        err2.name = "UNKNOWN_OPTION";
        err2.optionName = arg;
        throw err2;
      }
    }
    let option;
    if (output2.has(argInfo.name)) {
      option = output2.get(argInfo.name);
    } else {
      option = Option.create(argInfo.def);
      output2.set(argInfo.name, option);
    }
    if (argInfo.name === "_unknown") {
      option.set(arg);
    } else {
      option.set(argInfo.value);
    }
  }
  return output2.toObject({ skipUnknown: !options.partial, camelCase: options.camelCase });
}
__name(commandLineArgs, "commandLineArgs");
var ansiStyles = { exports: {} };
var colorName;
var hasRequiredColorName;
function requireColorName() {
  if (hasRequiredColorName) return colorName;
  hasRequiredColorName = 1;
  colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  return colorName;
}
__name(requireColorName, "requireColorName");
var conversions;
var hasRequiredConversions;
function requireConversions() {
  if (hasRequiredConversions) return conversions;
  hasRequiredConversions = 1;
  const cssKeywords = requireColorName();
  const reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  const convert = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  conversions = convert;
  for (const model of Object.keys(convert)) {
    if (!("channels" in convert[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", { value: channels });
    Object.defineProperty(convert[model], "labels", { value: labels });
  }
  convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = /* @__PURE__ */ __name(function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    }, "diffc");
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  __name(comparativeDistance, "comparativeDistance");
  convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t2 = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t2, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t2];
      case 3:
        return [p, q, v];
      case 4:
        return [t2, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi2 = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi2 += 60;
    }
    return ansi2;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi2 = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi2;
  };
  convert.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
  return conversions;
}
__name(requireConversions, "requireConversions");
var route;
var hasRequiredRoute;
function requireRoute() {
  if (hasRequiredRoute) return route;
  hasRequiredRoute = 1;
  const conversions2 = requireConversions();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions2);
    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  __name(buildGraph, "buildGraph");
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue2 = [fromModel];
    graph[fromModel].distance = 0;
    while (queue2.length) {
      const current = queue2.pop();
      const adjacents = Object.keys(conversions2[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue2.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  __name(deriveBFS, "deriveBFS");
  function link2(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  __name(link2, "link");
  function wrapConversion(toModel, graph) {
    const path2 = [graph[toModel].parent, toModel];
    let fn = conversions2[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path2.unshift(graph[cur].parent);
      fn = link2(conversions2[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path2;
    return fn;
  }
  __name(wrapConversion, "wrapConversion");
  route = /* @__PURE__ */ __name(function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  }, "route");
  return route;
}
__name(requireRoute, "requireRoute");
var colorConvert;
var hasRequiredColorConvert;
function requireColorConvert() {
  if (hasRequiredColorConvert) return colorConvert;
  hasRequiredColorConvert = 1;
  const conversions2 = requireConversions();
  const route2 = requireRoute();
  const convert = {};
  const models = Object.keys(conversions2);
  function wrapRaw(fn) {
    const wrappedFn = /* @__PURE__ */ __name(function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    }, "wrappedFn");
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  __name(wrapRaw, "wrapRaw");
  function wrapRounded(fn) {
    const wrappedFn = /* @__PURE__ */ __name(function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    }, "wrappedFn");
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  __name(wrapRounded, "wrapRounded");
  models.forEach((fromModel) => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", { value: conversions2[fromModel].channels });
    Object.defineProperty(convert[fromModel], "labels", { value: conversions2[fromModel].labels });
    const routes = route2(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  colorConvert = convert;
  return colorConvert;
}
__name(requireColorConvert, "requireColorConvert");
ansiStyles.exports;
var hasRequiredAnsiStyles;
function requireAnsiStyles() {
  if (hasRequiredAnsiStyles) return ansiStyles.exports;
  hasRequiredAnsiStyles = 1;
  (function(module) {
    const wrapAnsi162 = /* @__PURE__ */ __name((fn, offset) => (...args) => {
      const code2 = fn(...args);
      return `\x1B[${code2 + offset}m`;
    }, "wrapAnsi16");
    const wrapAnsi2562 = /* @__PURE__ */ __name((fn, offset) => (...args) => {
      const code2 = fn(...args);
      return `\x1B[${38 + offset};5;${code2}m`;
    }, "wrapAnsi256");
    const wrapAnsi16m2 = /* @__PURE__ */ __name((fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    }, "wrapAnsi16m");
    const ansi2ansi = /* @__PURE__ */ __name((n) => n, "ansi2ansi");
    const rgb2rgb = /* @__PURE__ */ __name((r, g, b) => [r, g, b], "rgb2rgb");
    const setLazyProperty = /* @__PURE__ */ __name((object, property, get2) => {
      Object.defineProperty(object, property, {
        get: /* @__PURE__ */ __name(() => {
          const value = get2();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        }, "get"),
        enumerable: true,
        configurable: true
      });
    }, "setLazyProperty");
    let colorConvert2;
    const makeDynamicStyles = /* @__PURE__ */ __name((wrap2, targetSpace, identity, isBackground) => {
      if (colorConvert2 === void 0) {
        colorConvert2 = requireColorConvert();
      }
      const offset = isBackground ? 10 : 0;
      const styles2 = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert2)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles2[name] = wrap2(identity, offset);
        } else if (typeof suite === "object") {
          styles2[name] = wrap2(suite[targetSpace], offset);
        }
      }
      return styles2;
    }, "makeDynamicStyles");
    function assembleStyles2() {
      const codes = /* @__PURE__ */ new Map();
      const styles2 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles2.color.gray = styles2.color.blackBright;
      styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
      styles2.color.grey = styles2.color.blackBright;
      styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles2)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles2[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles2[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles2, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles2, "codes", {
        value: codes,
        enumerable: false
      });
      styles2.color.close = "\x1B[39m";
      styles2.bgColor.close = "\x1B[49m";
      setLazyProperty(styles2.color, "ansi", () => makeDynamicStyles(wrapAnsi162, "ansi16", ansi2ansi, false));
      setLazyProperty(styles2.color, "ansi256", () => makeDynamicStyles(wrapAnsi2562, "ansi256", ansi2ansi, false));
      setLazyProperty(styles2.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m2, "rgb", rgb2rgb, false));
      setLazyProperty(styles2.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi162, "ansi16", ansi2ansi, true));
      setLazyProperty(styles2.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi2562, "ansi256", ansi2ansi, true));
      setLazyProperty(styles2.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m2, "rgb", rgb2rgb, true));
      return styles2;
    }
    __name(assembleStyles2, "assembleStyles");
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles2
    });
  })(ansiStyles);
  return ansiStyles.exports;
}
__name(requireAnsiStyles, "requireAnsiStyles");
var browser$1;
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$1;
  hasRequiredBrowser$1 = 1;
  browser$1 = {
    stdout: false,
    stderr: false
  };
  return browser$1;
}
__name(requireBrowser$1, "requireBrowser$1");
var util;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  const stringReplaceAll2 = /* @__PURE__ */ __name((string, substring, replacer) => {
    let index = string.indexOf(substring);
    if (index === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
      endIndex = index + substringLength;
      index = string.indexOf(substring, endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  }, "stringReplaceAll");
  const stringEncaseCRLFWithFirstIndex2 = /* @__PURE__ */ __name((string, prefix, postfix, index) => {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index - 1] === "\r";
      returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index + 1;
      index = string.indexOf("\n", endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  }, "stringEncaseCRLFWithFirstIndex");
  util = {
    stringReplaceAll: stringReplaceAll2,
    stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex2
  };
  return util;
}
__name(requireUtil, "requireUtil");
var templates;
var hasRequiredTemplates;
function requireTemplates() {
  if (hasRequiredTemplates) return templates;
  hasRequiredTemplates = 1;
  const TEMPLATE_REGEX2 = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  const STYLE_REGEX2 = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  const STRING_REGEX2 = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  const ESCAPE_REGEX2 = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
  const ESCAPES2 = /* @__PURE__ */ new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function unescape2(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES2.get(c) || c;
  }
  __name(unescape2, "unescape");
  function parseArguments2(name, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number)) {
        results.push(number);
      } else if (matches = chunk.match(STRING_REGEX2)) {
        results.push(matches[2].replace(ESCAPE_REGEX2, (m, escape2, character) => escape2 ? unescape2(escape2) : character));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }
    return results;
  }
  __name(parseArguments2, "parseArguments");
  function parseStyle2(style) {
    STYLE_REGEX2.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX2.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args = parseArguments2(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }
    return results;
  }
  __name(parseStyle2, "parseStyle");
  function buildStyle2(chalk2, styles2) {
    const enabled = {};
    for (const layer2 of styles2) {
      for (const style of layer2.styles) {
        enabled[style[0]] = layer2.inverse ? null : style.slice(1);
      }
    }
    let current = chalk2;
    for (const [styleName, styles3] of Object.entries(enabled)) {
      if (!Array.isArray(styles3)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles3.length > 0 ? current[styleName](...styles3) : current[styleName];
    }
    return current;
  }
  __name(buildStyle2, "buildStyle");
  templates = /* @__PURE__ */ __name((chalk2, temporary) => {
    const styles2 = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(TEMPLATE_REGEX2, (m, escapeCharacter, inverse, style, close2, character) => {
      if (escapeCharacter) {
        chunk.push(unescape2(escapeCharacter));
      } else if (style) {
        const string = chunk.join("");
        chunk = [];
        chunks.push(styles2.length === 0 ? string : buildStyle2(chalk2, styles2)(string));
        styles2.push({ inverse, styles: parseStyle2(style) });
      } else if (close2) {
        if (styles2.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle2(chalk2, styles2)(chunk.join("")));
        chunk = [];
        styles2.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles2.length > 0) {
      const errMessage = `Chalk template literal is missing ${styles2.length} closing bracket${styles2.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMessage);
    }
    return chunks.join("");
  }, "templates");
  return templates;
}
__name(requireTemplates, "requireTemplates");
var source;
var hasRequiredSource;
function requireSource() {
  if (hasRequiredSource) return source;
  hasRequiredSource = 1;
  const ansiStyles2 = requireAnsiStyles();
  const { stdout: stdoutColor2, stderr: stderrColor2 } = requireBrowser$1();
  const {
    stringReplaceAll: stringReplaceAll2,
    stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex2
  } = requireUtil();
  const { isArray } = Array;
  const levelMapping2 = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  const styles2 = /* @__PURE__ */ Object.create(null);
  const applyOptions2 = /* @__PURE__ */ __name((object, options = {}) => {
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor2 ? stdoutColor2.level : 0;
    object.level = options.level === void 0 ? colorLevel : options.level;
  }, "applyOptions");
  const _ChalkClass = class _ChalkClass {
    constructor(options) {
      return chalkFactory2(options);
    }
  };
  __name(_ChalkClass, "ChalkClass");
  let ChalkClass = _ChalkClass;
  const chalkFactory2 = /* @__PURE__ */ __name((options) => {
    const chalk3 = {};
    applyOptions2(chalk3, options);
    chalk3.template = (...arguments_) => chalkTag(chalk3.template, ...arguments_);
    Object.setPrototypeOf(chalk3, Chalk.prototype);
    Object.setPrototypeOf(chalk3.template, chalk3);
    chalk3.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    };
    chalk3.template.Instance = ChalkClass;
    return chalk3.template;
  }, "chalkFactory");
  function Chalk(options) {
    return chalkFactory2(options);
  }
  __name(Chalk, "Chalk");
  for (const [styleName, style] of Object.entries(ansiStyles2)) {
    styles2[styleName] = {
      get() {
        const builder = createBuilder2(this, createStyler2(style.open, style.close, this._styler), this._isEmpty);
        Object.defineProperty(this, styleName, { value: builder });
        return builder;
      }
    };
  }
  styles2.visible = {
    get() {
      const builder = createBuilder2(this, this._styler, true);
      Object.defineProperty(this, "visible", { value: builder });
      return builder;
    }
  };
  const usedModels2 = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const model of usedModels2) {
    styles2[model] = {
      get() {
        const { level: level2 } = this;
        return function(...arguments_) {
          const styler = createStyler2(ansiStyles2.color[levelMapping2[level2]][model](...arguments_), ansiStyles2.color.close, this._styler);
          return createBuilder2(this, styler, this._isEmpty);
        };
      }
    };
  }
  for (const model of usedModels2) {
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles2[bgModel] = {
      get() {
        const { level: level2 } = this;
        return function(...arguments_) {
          const styler = createStyler2(ansiStyles2.bgColor[levelMapping2[level2]][model](...arguments_), ansiStyles2.bgColor.close, this._styler);
          return createBuilder2(this, styler, this._isEmpty);
        };
      }
    };
  }
  const proto2 = Object.defineProperties(() => {
  }, {
    ...styles2,
    level: {
      enumerable: true,
      get() {
        return this._generator.level;
      },
      set(level2) {
        this._generator.level = level2;
      }
    }
  });
  const createStyler2 = /* @__PURE__ */ __name((open2, close2, parent) => {
    let openAll;
    let closeAll;
    if (parent === void 0) {
      openAll = open2;
      closeAll = close2;
    } else {
      openAll = parent.openAll + open2;
      closeAll = close2 + parent.closeAll;
    }
    return {
      open: open2,
      close: close2,
      openAll,
      closeAll,
      parent
    };
  }, "createStyler");
  const createBuilder2 = /* @__PURE__ */ __name((self2, _styler, _isEmpty) => {
    const builder = /* @__PURE__ */ __name((...arguments_) => {
      if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
        return applyStyle2(builder, chalkTag(builder, ...arguments_));
      }
      return applyStyle2(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    }, "builder");
    Object.setPrototypeOf(builder, proto2);
    builder._generator = self2;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
  }, "createBuilder");
  const applyStyle2 = /* @__PURE__ */ __name((self2, string) => {
    if (self2.level <= 0 || !string) {
      return self2._isEmpty ? "" : string;
    }
    let styler = self2._styler;
    if (styler === void 0) {
      return string;
    }
    const { openAll, closeAll } = styler;
    if (string.indexOf("\x1B") !== -1) {
      while (styler !== void 0) {
        string = stringReplaceAll2(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex2(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  }, "applyStyle");
  let template2;
  const chalkTag = /* @__PURE__ */ __name((chalk3, ...strings2) => {
    const [firstString] = strings2;
    if (!isArray(firstString) || !isArray(firstString.raw)) {
      return strings2.join(" ");
    }
    const arguments_ = strings2.slice(1);
    const parts = [firstString.raw[0]];
    for (let i = 1; i < firstString.length; i++) {
      parts.push(
        String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
        String(firstString.raw[i])
      );
    }
    if (template2 === void 0) {
      template2 = requireTemplates();
    }
    return template2(chalk3, parts.join(""));
  }, "chalkTag");
  Object.defineProperties(Chalk.prototype, styles2);
  const chalk2 = Chalk();
  chalk2.supportsColor = stdoutColor2;
  chalk2.stderr = Chalk({ level: stderrColor2 ? stderrColor2.level : 0 });
  chalk2.stderr.supportsColor = stderrColor2;
  source = chalk2;
  return source;
}
__name(requireSource, "requireSource");
var sourceExports = requireSource();
const chalk = /* @__PURE__ */ getDefaultExportFromCjs$1(sourceExports);
const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.))|(?:{(~)?(#?[\w:]+(?:\([^)]*\))?(?:\.#?[\w:]+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(?:(?:(\w+)(?:\(([^)]*)\))?)|(?:#(?=[:a-fA-F\d]{2,})([a-fA-F\d]{6})?(?::([a-fA-F\d]{6}))?))/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
const ESCAPES = /* @__PURE__ */ new Map([
  ["n", "\n"],
  ["r", "\r"],
  ["t", "	"],
  ["b", "\b"],
  ["f", "\f"],
  ["v", "\v"],
  ["0", "\0"],
  ["\\", "\\"],
  ["e", "\x1B"],
  ["a", "\x07"]
]);
function unescape$1(c) {
  const u = c[0] === "u";
  const bracket = c[1] === "{";
  if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
    return String.fromCharCode(Number.parseInt(c.slice(1), 16));
  }
  if (u && bracket) {
    return String.fromCodePoint(Number.parseInt(c.slice(2, -1), 16));
  }
  return ESCAPES.get(c) || c;
}
__name(unescape$1, "unescape$1");
function parseArguments(name, arguments_) {
  const results = [];
  const chunks = arguments_.trim().split(/\s*,\s*/g);
  let matches;
  for (const chunk of chunks) {
    const number = Number(chunk);
    if (!Number.isNaN(number)) {
      results.push(number);
    } else if (matches = chunk.match(STRING_REGEX)) {
      results.push(matches[2].replace(ESCAPE_REGEX, (_, escape2, character) => escape2 ? unescape$1(escape2) : character));
    } else {
      throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
    }
  }
  return results;
}
__name(parseArguments, "parseArguments");
function parseHex(hex) {
  const n = Number.parseInt(hex, 16);
  return [
    // eslint-disable-next-line no-bitwise
    n >> 16 & 255,
    // eslint-disable-next-line no-bitwise
    n >> 8 & 255,
    // eslint-disable-next-line no-bitwise
    n & 255
  ];
}
__name(parseHex, "parseHex");
function parseStyle(style) {
  STYLE_REGEX.lastIndex = 0;
  const results = [];
  let matches;
  while ((matches = STYLE_REGEX.exec(style)) !== null) {
    const name = matches[1];
    if (matches[2]) {
      results.push([name, ...parseArguments(name, matches[2])]);
    } else if (matches[3] || matches[4]) {
      if (matches[3]) {
        results.push(["rgb", ...parseHex(matches[3])]);
      }
      if (matches[4]) {
        results.push(["bgRgb", ...parseHex(matches[4])]);
      }
    } else {
      results.push([name]);
    }
  }
  return results;
}
__name(parseStyle, "parseStyle");
function buildStyle(styles2) {
  const enabled = {};
  for (const layer2 of styles2) {
    for (const style of layer2.styles) {
      enabled[style[0]] = layer2.inverse ? null : style.slice(1);
    }
  }
  let current = chalk;
  for (const [styleName, styles3] of Object.entries(enabled)) {
    if (!Array.isArray(styles3)) {
      continue;
    }
    if (!(styleName in current)) {
      throw new Error(`Unknown Chalk style: ${styleName}`);
    }
    current = styles3.length > 0 ? current[styleName](...styles3) : current[styleName];
  }
  return current;
}
__name(buildStyle, "buildStyle");
function template$2(string) {
  const styles2 = [];
  const chunks = [];
  let chunk = [];
  string.replace(TEMPLATE_REGEX, (_, escapeCharacter, inverse, style, close2, character) => {
    if (escapeCharacter) {
      chunk.push(unescape$1(escapeCharacter));
    } else if (style) {
      const string2 = chunk.join("");
      chunk = [];
      chunks.push(styles2.length === 0 ? string2 : buildStyle(styles2)(string2));
      styles2.push({ inverse, styles: parseStyle(style) });
    } else if (close2) {
      if (styles2.length === 0) {
        throw new Error("Found extraneous } in Chalk template literal");
      }
      chunks.push(buildStyle(styles2)(chunk.join("")));
      chunk = [];
      styles2.pop();
    } else {
      chunk.push(character);
    }
  });
  chunks.push(chunk.join(""));
  if (styles2.length > 0) {
    throw new Error(`Chalk template literal is missing ${styles2.length} closing bracket${styles2.length === 1 ? "" : "s"} (\`}\`)`);
  }
  return chunks.join("");
}
__name(template$2, "template$2");
function chalkTemplate(firstString, ...arguments_) {
  if (!Array.isArray(firstString) || !Array.isArray(firstString.raw)) {
    throw new TypeError("A tagged template literal must be provided");
  }
  const parts = [firstString.raw[0]];
  for (let index = 1; index < firstString.raw.length; index++) {
    parts.push(
      String(arguments_[index - 1]).replace(/[{}\\]/g, "\\$&"),
      String(firstString.raw[index])
    );
  }
  return template$2(parts.join(""));
}
__name(chalkTemplate, "chalkTemplate");
function chalkFormat(str) {
  if (str) {
    str = str.replace(/`/g, "\\`");
    return chalkTemplate(Object.assign([], { raw: [str] }));
  } else {
    return "";
  }
}
__name(chalkFormat, "chalkFormat");
var browser = {};
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  browser.endianness = function() {
    return "LE";
  };
  browser.hostname = function() {
    if (typeof location !== "undefined") {
      return location.hostname;
    } else return "";
  };
  browser.loadavg = function() {
    return [];
  };
  browser.uptime = function() {
    return 0;
  };
  browser.freemem = function() {
    return Number.MAX_VALUE;
  };
  browser.totalmem = function() {
    return Number.MAX_VALUE;
  };
  browser.cpus = function() {
    return [];
  };
  browser.type = function() {
    return "Browser";
  };
  browser.release = function() {
    if (typeof navigator !== "undefined") {
      return navigator.appVersion;
    }
    return "";
  };
  browser.networkInterfaces = browser.getNetworkInterfaces = function() {
    return {};
  };
  browser.arch = function() {
    return "javascript";
  };
  browser.platform = function() {
    return "browser";
  };
  browser.tmpdir = browser.tmpDir = function() {
    return "/tmp";
  };
  browser.EOL = "\n";
  browser.homedir = function() {
    return "/";
  };
  return browser;
}
__name(requireBrowser, "requireBrowser");
var browserExports = requireBrowser();
const os = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);
const _Section = class _Section {
  constructor() {
    this.lines = [];
  }
  add(lines) {
    if (lines) {
      arrayify$5(lines).forEach((line3) => this.lines.push(line3));
    } else {
      this.lines.push("");
    }
  }
  toString() {
    return this.lines.join(os.EOL);
  }
  header(text) {
    if (text) {
      this.add(chalkFormat(`{bold ${text}}`));
      this.add();
    }
  }
};
__name(_Section, "Section");
let Section = _Section;
const _value = /* @__PURE__ */ new WeakMap();
const _column = /* @__PURE__ */ new WeakMap();
const _Cell = class _Cell {
  constructor(value, column) {
    this.value = value;
    _column.set(this, column);
  }
  set value(val) {
    _value.set(this, val);
  }
  /**
  * Must return a string or object with a `.toString()` method.
  * @returns {string}
  */
  get value() {
    let cellValue = _value.get(this);
    const column = _column.get(this);
    if (column.get) {
      cellValue = column.get(cellValue);
    }
    if (cellValue === void 0) {
      cellValue = "";
    } else {
      cellValue = String(cellValue);
    }
    return cellValue;
  }
};
__name(_Cell, "Cell");
let Cell = _Cell;
const _Rows = class _Rows {
  constructor(rows, columns) {
    this.list = [];
    this.load(rows, columns);
  }
  load(rows, columns) {
    for (const row of arrayify$5(rows)) {
      const map = new Map(columns.list.map((column) => [column, new Cell(row[column.name], column)]));
      this.list.push(map);
    }
  }
};
__name(_Rows, "Rows");
let Rows = _Rows;
const _Padding = class _Padding {
  constructor(padding) {
    this.left = padding.left;
    this.right = padding.right;
  }
  length() {
    return this.left.length + this.right.length;
  }
};
__name(_Padding, "Padding");
let Padding = _Padding;
const _padding = /* @__PURE__ */ new WeakMap();
const _Column = class _Column {
  constructor(column = {}) {
    this.name = column.name;
    this.width = column.width;
    this.maxWidth = column.maxWidth;
    this.minWidth = column.minWidth;
    this.noWrap = column.noWrap;
    this.break = column.break;
    this.contentWrappable = column.contentWrappable;
    this.contentWidth = column.contentWidth;
    this.minContentWidth = column.minContentWidth;
    this.padding = column.padding || { left: " ", right: " " };
    this.generatedWidth = null;
  }
  set padding(padding) {
    _padding.set(this, new Padding(padding));
  }
  get padding() {
    return _padding.get(this);
  }
  /**
   * The width of the content (excluding padding) after being wrapped
   */
  get wrappedContentWidth() {
    return Math.max(this.generatedWidth - this.padding.length(), 0);
  }
  isResizable() {
    return !this.isFixed();
  }
  isFixed() {
    return this.width !== void 0 || this.noWrap || !this.contentWrappable;
  }
  generateWidth() {
    this.generatedWidth = this.width || this.contentWidth + this.padding.length();
  }
  generateMinWidth() {
    this.minWidth = this.minContentWidth + this.padding.length();
  }
};
__name(_Column, "Column");
let Column = _Column;
const _maxWidth = /* @__PURE__ */ new WeakMap();
const _Columns = class _Columns {
  constructor(columns) {
    this.list = [];
    for (const column of arrayify$5(columns)) {
      this.add(column);
    }
  }
  /**
   * sum of all generatedWidth fields
   * @return {number}
   */
  totalWidth() {
    return this.list.length ? this.list.map((col) => col.generatedWidth).reduce((a, b) => a + b) : 0;
  }
  totalFixedWidth() {
    return this.getFixed().map((col) => col.generatedWidth).reduce((a, b) => a + b, 0);
  }
  get(columnName) {
    return this.list.find((column) => column.name === columnName);
  }
  getResizable() {
    return this.list.filter((column) => column.isResizable());
  }
  getFixed() {
    return this.list.filter((column) => column.isFixed());
  }
  add(column) {
    const col = column instanceof Column ? column : new Column(column);
    this.list.push(col);
    return col;
  }
  get maxWidth() {
    _maxWidth.get(this);
  }
  set maxWidth(val) {
    _maxWidth.set(this, val);
  }
  /**
   * sets `generatedWidth` for each column
   * @chainable
   */
  autoSize() {
    const maxWidth = _maxWidth.get(this);
    for (const column of this.list) {
      column.generateWidth();
      column.generateMinWidth();
    }
    for (const column of this.list) {
      if (column.maxWidth !== void 0 && column.generatedWidth > column.maxWidth) {
        column.generatedWidth = column.maxWidth;
      }
      if (column.minWidth !== void 0 && column.generatedWidth < column.minWidth) {
        column.generatedWidth = column.minWidth;
      }
    }
    const width = {
      total: this.totalWidth(),
      diff: this.totalWidth() - maxWidth,
      totalFixed: this.totalFixedWidth(),
      totalResizable: Math.max(maxWidth - this.totalFixedWidth(), 0)
    };
    if (width.diff > 0) {
      const resizableColumns = this.getResizable();
      for (const column of resizableColumns) {
        column.generatedWidth = Math.floor(width.totalResizable / resizableColumns.length);
      }
      const grownColumns = this.list.filter((column) => column.generatedWidth > column.contentWidth);
      const shrunkenColumns = this.list.filter((column) => column.generatedWidth < column.contentWidth);
      let salvagedSpace = 0;
      for (const column of grownColumns) {
        const currentGeneratedWidth = column.generatedWidth;
        column.generateWidth();
        salvagedSpace += currentGeneratedWidth - column.generatedWidth;
      }
      for (const column of shrunkenColumns) {
        column.generatedWidth += Math.floor(salvagedSpace / shrunkenColumns.length);
      }
    }
    return this;
  }
  /**
   * Factory method returning all distinct columns from input
   * @param  {object[]} - input recordset
   * @return {module:columns}
   */
  static getColumns(rows) {
    const columns = new _Columns();
    for (const row of arrayify$5(rows)) {
      for (const columnName in row) {
        let column = columns.get(columnName);
        if (!column) {
          column = columns.add({ name: columnName, contentWidth: 0, minContentWidth: 0 });
        }
      }
    }
    return columns;
  }
};
__name(_Columns, "Columns");
let Columns = _Columns;
const re = {
  chunk: /[^\s-]+?-\b|\S+|\s+|\r\n?|\n/g,
  ansiEscapeSequence: /\u001b.*?m/g
};
const _Wordwrap = class _Wordwrap {
  /**
   * @param {string} text - The input text to wrap.
   * @param {module:wordwrapjs~WordwrapOptions} [options]
   */
  constructor(text = "", options = {}) {
    this._lines = String(text).split(/\r\n|\n/g);
    this.options = {
      eol: "\n",
      width: 30,
      ...options
    };
  }
  lines() {
    return this._lines.map(trimLine, this).map((line3) => line3.match(re.chunk) || ["~~empty~~"]).map(
      (lineWords) => this.options.break ? lineWords.map(breakWord, this) : lineWords
    ).map((lineWords) => lineWords.flat()).map((lineWords) => {
      return lineWords.reduce((lines, word) => {
        const currentLine = lines[lines.length - 1];
        if (replaceAnsi(word).length + replaceAnsi(currentLine).length > this.options.width) {
          lines.push(word);
        } else {
          lines[lines.length - 1] += word;
        }
        return lines;
      }, [""]);
    }).flat().map(trimLine, this).filter((line3) => line3.trim()).map((line3) => line3.replace("~~empty~~", ""));
  }
  wrap() {
    return this.lines().join(this.options.eol);
  }
  toString() {
    return this.wrap();
  }
  /**
   * @param {string} text - the input text to wrap
   * @param {module:wordwrapjs~WordwrapOptions} [options]
   */
  static wrap(text, options) {
    const block = new this(text, options);
    return block.wrap();
  }
  /**
   * Wraps the input text, returning an array of strings (lines).
   * @param {string} text - input text
   * @param {module:wordwrapjs~WordwrapOptions} [options]
   */
  static lines(text, options) {
    const block = new this(text, options);
    return block.lines();
  }
  /**
   * Returns true if the input text would be wrapped if passed into `.wrap()`.
   * @param {string} text - input text
   * @return {boolean}
   */
  static isWrappable(text = "") {
    const matches = String(text).match(re.chunk);
    return matches ? matches.length > 1 : false;
  }
  /**
   * Splits the input text into an array of words and whitespace.
   * @param {string} text - input text
   * @returns {string[]}
   */
  static getChunks(text) {
    return text.match(re.chunk) || [];
  }
};
__name(_Wordwrap, "Wordwrap");
let Wordwrap = _Wordwrap;
function trimLine(line3) {
  return this.options.noTrim ? line3 : line3.trim();
}
__name(trimLine, "trimLine");
function replaceAnsi(string) {
  return string.replace(re.ansiEscapeSequence, "");
}
__name(replaceAnsi, "replaceAnsi");
function breakWord(word) {
  if (replaceAnsi(word).length > this.options.width) {
    const letters = word.split("");
    let piece;
    const pieces = [];
    while ((piece = letters.splice(0, this.options.width)).length) {
      pieces.push(piece.join(""));
    }
    return pieces;
  } else {
    return word;
  }
}
__name(breakWord, "breakWord");
const ansiEscapeSequence = /\u001b.*?m/g;
function remove(input) {
  return input.replace(ansiEscapeSequence, "");
}
__name(remove, "remove");
function has(input) {
  return ansiEscapeSequence.test(input);
}
__name(has, "has");
function getLongestArray(arrays) {
  const lengths = arrays.map((array2) => array2.length);
  return Math.max(...lengths);
}
__name(getLongestArray, "getLongestArray");
function padCell(cellValue, padding, width) {
  const ansiLength = cellValue.length - remove(cellValue).length;
  cellValue = cellValue || "";
  return (padding.left || "") + cellValue.padEnd(width - padding.length() + ansiLength) + (padding.right || "");
}
__name(padCell, "padCell");
function getLongestWord(line3) {
  const words = Wordwrap.getChunks(line3);
  return words.reduce((max, word) => Math.max(word.length, max), 0);
}
__name(getLongestWord, "getLongestWord");
function removeEmptyColumns(data) {
  const distinctColumnNames = data.reduce((columnNames, row) => {
    for (const key of Object.keys(row)) {
      if (!columnNames.includes(key)) {
        columnNames.push(key);
      }
    }
    return columnNames;
  }, []);
  const emptyColumns = distinctColumnNames.filter((columnName) => {
    const hasValue = data.some((row) => {
      const value = row[columnName];
      return value !== void 0 && typeof value !== "string" || typeof value === "string" && /\S+/.test(value);
    });
    return !hasValue;
  });
  return data.map((row) => {
    for (const emptyCol of emptyColumns) {
      delete row[emptyCol];
    }
    return row;
  });
}
__name(removeEmptyColumns, "removeEmptyColumns");
function applyDefaultValues(options = {}, defaults = {}) {
  const result = Object.assign({}, options);
  if (typeof result.padding === "object") {
    if (result.padding.left === void 0) result.padding.left = defaults.padding.left;
    if (result.padding.right === void 0) result.padding.right = defaults.padding.right;
  } else {
    result.padding = defaults.padding;
  }
  if (result.maxWidth === void 0) result.maxWidth = defaults.maxWidth;
  if (result.columns === void 0) result.columns = defaults.columns;
  if (result.eol === void 0) result.eol = defaults.eol;
  return result;
}
__name(applyDefaultValues, "applyDefaultValues");
const _Table = class _Table {
  /**
   * @param {object[]} - input data
   * @param [options] {object} - optional settings
   * @param [options.maxWidth] {number} - maximum width of layout
   * @param [options.noWrap] {boolean} - disable wrapping on all columns
   * @param [options.noTrim] {boolean} - disable line-trimming
   * @param [options.break] {boolean} - enable word-breaking on all columns
   * @param [options.columns] {module:table-layout~columnOption} - array of column-specific options
   * @param [options.ignoreEmptyColumns] {boolean} - If set, empty columns or columns containing only whitespace are not rendered.
   * @param [options.padding] {object} - Padding values to set on each column. Per-column overrides can be set in the `options.columns` array.
   * @param [options.padding.left] {string} - Defaults to a single space.
   * @param [options.padding.right] {string} - Defaults to a single space.
   * @param [options.eol] {string} - EOL character used. Defaults to `\n`.
   * @alias module:table-layout
   */
  constructor(data, options = {}) {
    const defaults = {
      padding: {
        left: " ",
        right: " "
      },
      maxWidth: 80,
      columns: [],
      eol: "\n"
    };
    this.options = applyDefaultValues(options, defaults);
    this.rows = null;
    this.columns = null;
    this.load(data);
  }
  /**
  * Set the input data to display. Must be an array of objects.
  * @param data {object[]}
  */
  load(data) {
    const options = this.options;
    if (options.ignoreEmptyColumns) {
      data = removeEmptyColumns(data);
    }
    this.columns = Columns.getColumns(data);
    this.columns.maxWidth = options.maxWidth;
    for (const column of this.columns.list) {
      column.padding = options.padding;
      column.noWrap = options.noWrap;
      column.break = options.break;
      if (options.break) {
        column.contentWrappable = true;
      }
    }
    for (const optionColumn of options.columns) {
      const column = this.columns.get(optionColumn.name);
      if (column) {
        if (optionColumn.padding) {
          column.padding.left = optionColumn.padding.left;
          column.padding.right = optionColumn.padding.right;
        }
        column.width = optionColumn.width;
        column.maxWidth = optionColumn.maxWidth;
        column.minWidth = optionColumn.minWidth;
        column.noWrap = optionColumn.noWrap;
        column.break = optionColumn.break;
        if (optionColumn.break) {
          column.contentWrappable = true;
        }
        column.get = optionColumn.get;
      }
    }
    for (const row of arrayify$5(data)) {
      for (const columnName in row) {
        const column = this.columns.get(columnName);
        const cell = new Cell(row[columnName], column);
        let cellValue = cell.value;
        if (has(cellValue)) {
          cellValue = remove(cellValue);
        }
        if (cellValue.length > column.contentWidth) {
          column.contentWidth = cellValue.length;
        }
        const longestWord = getLongestWord(cellValue);
        if (longestWord > column.minContentWidth) {
          column.minContentWidth = longestWord;
        }
        if (!column.contentWrappable) {
          column.contentWrappable = Wordwrap.isWrappable(cellValue);
        }
      }
    }
    this.columns.autoSize();
    this.rows = new Rows(data, this.columns);
    return this;
  }
  getWrapped() {
    this.columns.autoSize();
    return this.rows.list.map((row) => {
      const line3 = [];
      for (const [column, cell] of row.entries()) {
        if (column.noWrap) {
          line3.push(cell.value.split(/\r\n?|\n/));
        } else {
          line3.push(Wordwrap.lines(cell.value, {
            width: column.wrappedContentWidth,
            break: column.break,
            noTrim: this.options.noTrim
          }));
        }
      }
      return line3;
    });
  }
  getLines() {
    const wrappedLines = this.getWrapped();
    const lines = [];
    wrappedLines.forEach((wrapped) => {
      const mostLines = getLongestArray(wrapped);
      for (let i = 0; i < mostLines; i++) {
        const line3 = [];
        wrapped.forEach((cell) => {
          line3.push(cell[i] || "");
        });
        lines.push(line3);
      }
    });
    return lines;
  }
  /**
   * Identical to `.toString()` with the exception that the result will be an array of lines, rather than a single, multi-line string.
   * @returns {string[]}
   */
  renderLines() {
    const lines = this.getLines();
    return lines.map((line3) => {
      return line3.reduce((prev, cell, index) => {
        const column = this.columns.list[index];
        return prev + padCell(cell, column.padding, column.generatedWidth);
      }, "");
    });
  }
  /**
   * Returns the input data as a text table.
   * @returns {string}
   */
  toString() {
    return this.renderLines().join(this.options.eol) + this.options.eol;
  }
};
__name(_Table, "Table");
let Table = _Table;
const _OptionList = class _OptionList extends Section {
  constructor(data) {
    super();
    let definitions = arrayify$5(data.optionList);
    const hide = arrayify$5(data.hide);
    const groups = arrayify$5(data.group);
    if (hide.length) {
      definitions = definitions.filter((definition) => {
        return hide.indexOf(definition.name) === -1;
      });
    }
    if (data.header) this.header(data.header);
    if (groups.length) {
      definitions = definitions.filter((def) => {
        const noGroupMatch = groups.indexOf("_none") > -1 && def.group === void 0;
        const groupMatch = intersect(arrayify$5(def.group), groups);
        return noGroupMatch || groupMatch ? def : void 0;
      });
    }
    const rows = definitions.map((def) => {
      return {
        option: getOptionNames(def, data.reverseNameOrder),
        description: chalkFormat(def.description)
      };
    });
    const tableOptions = data.tableOptions || {
      padding: { left: "  ", right: " " },
      columns: [
        { name: "option", noWrap: true },
        { name: "description", maxWidth: 80 }
      ]
    };
    const table2 = new Table(rows, tableOptions);
    this.add(table2.renderLines());
    this.add();
  }
};
__name(_OptionList, "OptionList");
let OptionList = _OptionList;
function getOptionNames(definition, reverseNameOrder) {
  let type = definition.type ? definition.type.name.toLowerCase() : "string";
  const multiple = definition.multiple || definition.lazyMultiple ? "[]" : "";
  if (type) {
    type = type === "boolean" ? "" : `{underline ${type}${multiple}}`;
  }
  type = chalkFormat(definition.typeLabel || type);
  let result = "";
  if (definition.alias) {
    if (definition.name) {
      if (reverseNameOrder) {
        result = chalkFormat(`{bold --${definition.name}}, {bold -${definition.alias}} ${type}`);
      } else {
        result = chalkFormat(`{bold -${definition.alias}}, {bold --${definition.name}} ${type}`);
      }
    } else {
      if (reverseNameOrder) {
        result = chalkFormat(`{bold -${definition.alias}} ${type}`);
      } else {
        result = chalkFormat(`{bold -${definition.alias}} ${type}`);
      }
    }
  } else {
    result = chalkFormat(`{bold --${definition.name}} ${type}`);
  }
  return result;
}
__name(getOptionNames, "getOptionNames");
function intersect(arr1, arr2) {
  return arr1.some(function(item1) {
    return arr2.some(function(item2) {
      return item1 === item2;
    });
  });
}
__name(intersect, "intersect");
const _ContentSection = class _ContentSection extends Section {
  constructor(section) {
    super();
    this.header(section.header);
    if (section.content) {
      if (section.raw) {
        const content = arrayify$5(section.content).map((line3) => chalkFormat(line3));
        this.add(content);
      } else {
        this.add(getContentLines(section.content));
      }
      this.add();
    }
  }
};
__name(_ContentSection, "ContentSection");
let ContentSection = _ContentSection;
function getContentLines(content) {
  const defaultPadding = { left: "  ", right: " " };
  if (content) {
    if (t.isString(content)) {
      const table2 = new Table({ column: chalkFormat(content) }, {
        padding: defaultPadding,
        maxWidth: 80
      });
      return table2.renderLines();
    } else if (Array.isArray(content) && content.every(t.isString)) {
      const rows = content.map((string) => ({ column: chalkFormat(string) }));
      const table2 = new Table(rows, {
        padding: defaultPadding,
        maxWidth: 80
      });
      return table2.renderLines();
    } else if (Array.isArray(content) && content.every(t.isPlainObject)) {
      const table2 = new Table(content.map((row) => ansiFormatRow(row)), {
        padding: defaultPadding
      });
      return table2.renderLines();
    } else if (t.isPlainObject(content)) {
      if (!content.options || !content.data) {
        throw new Error('must have an "options" or "data" property\n' + JSON.stringify(content));
      }
      const options = Object.assign(
        { padding: defaultPadding },
        content.options
      );
      if (options.columns) {
        options.columns = options.columns.map((column) => {
          if (column.nowrap) {
            column.noWrap = column.nowrap;
            delete column.nowrap;
          }
          return column;
        });
      }
      const table2 = new Table(
        content.data.map((row) => ansiFormatRow(row)),
        options
      );
      return table2.renderLines();
    } else {
      const message = `invalid input - 'content' must be a string, array of strings, or array of plain objects:

${JSON.stringify(content)}`;
      throw new Error(message);
    }
  }
}
__name(getContentLines, "getContentLines");
function ansiFormatRow(row) {
  for (const key in row) {
    row[key] = chalkFormat(row[key]);
  }
  return row;
}
__name(ansiFormatRow, "ansiFormatRow");
function commandLineUsage(sections) {
  sections = arrayify$5(sections);
  if (sections.length) {
    const output2 = sections.map((section) => {
      if (section.optionList) {
        return new OptionList(section);
      } else {
        return new ContentSection(section);
      }
    });
    return "\n" + output2.join("\n");
  } else {
    return "";
  }
}
__name(commandLineUsage, "commandLineUsage");
const MAX_BITS$1 = 15;
const D_CODES = 30;
const BL_CODES = 19;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const HEAP_SIZE = 2 * L_CODES + 1;
const END_BLOCK = 256;
const MAX_BL_BITS = 7;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const Buf_size = 8 * 2;
const Z_DEFAULT_COMPRESSION = -1;
const Z_FILTERED = 1;
const Z_HUFFMAN_ONLY = 2;
const Z_DEFAULT_STRATEGY = 0;
const Z_NO_FLUSH$1 = 0;
const Z_PARTIAL_FLUSH = 1;
const Z_FULL_FLUSH = 3;
const Z_FINISH$1 = 4;
const Z_OK$1 = 0;
const Z_STREAM_END$1 = 1;
const Z_NEED_DICT$1 = 2;
const Z_STREAM_ERROR$1 = -2;
const Z_DATA_ERROR$1 = -3;
const Z_BUF_ERROR$1 = -5;
function extractArray(array2) {
  return flatArray(array2.map(([length, value]) => new Array(length).fill(value, 0, length)));
}
__name(extractArray, "extractArray");
function flatArray(array2) {
  return array2.reduce((a, b) => a.concat(Array.isArray(b) ? flatArray(b) : b), []);
}
__name(flatArray, "flatArray");
const _dist_code = [0, 1, 2, 3].concat(...extractArray([
  [2, 4],
  [2, 5],
  [4, 6],
  [4, 7],
  [8, 8],
  [8, 9],
  [16, 10],
  [16, 11],
  [32, 12],
  [32, 13],
  [64, 14],
  [64, 15],
  [2, 0],
  [1, 16],
  [1, 17],
  [2, 18],
  [2, 19],
  [4, 20],
  [4, 21],
  [8, 22],
  [8, 23],
  [16, 24],
  [16, 25],
  [32, 26],
  [32, 27],
  [64, 28],
  [64, 29]
]));
function Tree() {
  const that = this;
  function gen_bitlen2(s) {
    const tree = that.dyn_tree;
    const stree = that.stat_desc.static_tree;
    const extra = that.stat_desc.extra_bits;
    const base = that.stat_desc.extra_base;
    const max_length = that.stat_desc.max_length;
    let h;
    let n, m;
    let bits;
    let xbits;
    let f;
    let overflow = 0;
    for (bits = 0; bits <= MAX_BITS$1; bits++)
      s.bl_count[bits] = 0;
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > that.max_code)
        continue;
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base)
        xbits = extra[n - base];
      f = tree[n * 2];
      s.opt_len += f * (bits + xbits);
      if (stree)
        s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
    if (overflow === 0)
      return;
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0)
        bits--;
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > that.max_code)
          continue;
        if (tree[m * 2 + 1] != bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  }
  __name(gen_bitlen2, "gen_bitlen");
  function bi_reverse2(code2, len) {
    let res = 0;
    do {
      res |= code2 & 1;
      code2 >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  __name(bi_reverse2, "bi_reverse");
  function gen_codes2(tree, max_code, bl_count) {
    const next_code = [];
    let code2 = 0;
    let bits;
    let n;
    let len;
    for (bits = 1; bits <= MAX_BITS$1; bits++) {
      next_code[bits] = code2 = code2 + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      len = tree[n * 2 + 1];
      if (len === 0)
        continue;
      tree[n * 2] = bi_reverse2(next_code[len]++, len);
    }
  }
  __name(gen_codes2, "gen_codes");
  that.build_tree = function(s) {
    const tree = that.dyn_tree;
    const stree = that.stat_desc.static_tree;
    const elems = that.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (stree)
        s.static_len -= stree[node * 2 + 1];
    }
    that.max_code = max_code;
    for (n = Math.floor(s.heap_len / 2); n >= 1; n--)
      s.pqdownheap(tree, n);
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      s.pqdownheap(tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      s.pqdownheap(tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    gen_bitlen2(s);
    gen_codes2(tree, that.max_code, s.bl_count);
  };
}
__name(Tree, "Tree");
Tree._length_code = [0, 1, 2, 3, 4, 5, 6, 7].concat(...extractArray([
  [2, 8],
  [2, 9],
  [2, 10],
  [2, 11],
  [4, 12],
  [4, 13],
  [4, 14],
  [4, 15],
  [8, 16],
  [8, 17],
  [8, 18],
  [8, 19],
  [16, 20],
  [16, 21],
  [16, 22],
  [16, 23],
  [32, 24],
  [32, 25],
  [32, 26],
  [31, 27],
  [1, 28]
]));
Tree.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];
Tree.base_dist = [
  0,
  1,
  2,
  3,
  4,
  6,
  8,
  12,
  16,
  24,
  32,
  48,
  64,
  96,
  128,
  192,
  256,
  384,
  512,
  768,
  1024,
  1536,
  2048,
  3072,
  4096,
  6144,
  8192,
  12288,
  16384,
  24576
];
Tree.d_code = function(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
Tree.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
Tree.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
Tree.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
Tree.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {
  const that = this;
  that.static_tree = static_tree;
  that.extra_bits = extra_bits;
  that.extra_base = extra_base;
  that.elems = elems;
  that.max_length = max_length;
}
__name(StaticTree, "StaticTree");
const static_ltree2_first_part = [
  12,
  140,
  76,
  204,
  44,
  172,
  108,
  236,
  28,
  156,
  92,
  220,
  60,
  188,
  124,
  252,
  2,
  130,
  66,
  194,
  34,
  162,
  98,
  226,
  18,
  146,
  82,
  210,
  50,
  178,
  114,
  242,
  10,
  138,
  74,
  202,
  42,
  170,
  106,
  234,
  26,
  154,
  90,
  218,
  58,
  186,
  122,
  250,
  6,
  134,
  70,
  198,
  38,
  166,
  102,
  230,
  22,
  150,
  86,
  214,
  54,
  182,
  118,
  246,
  14,
  142,
  78,
  206,
  46,
  174,
  110,
  238,
  30,
  158,
  94,
  222,
  62,
  190,
  126,
  254,
  1,
  129,
  65,
  193,
  33,
  161,
  97,
  225,
  17,
  145,
  81,
  209,
  49,
  177,
  113,
  241,
  9,
  137,
  73,
  201,
  41,
  169,
  105,
  233,
  25,
  153,
  89,
  217,
  57,
  185,
  121,
  249,
  5,
  133,
  69,
  197,
  37,
  165,
  101,
  229,
  21,
  149,
  85,
  213,
  53,
  181,
  117,
  245,
  13,
  141,
  77,
  205,
  45,
  173,
  109,
  237,
  29,
  157,
  93,
  221,
  61,
  189,
  125,
  253,
  19,
  275,
  147,
  403,
  83,
  339,
  211,
  467,
  51,
  307,
  179,
  435,
  115,
  371,
  243,
  499,
  11,
  267,
  139,
  395,
  75,
  331,
  203,
  459,
  43,
  299,
  171,
  427,
  107,
  363,
  235,
  491,
  27,
  283,
  155,
  411,
  91,
  347,
  219,
  475,
  59,
  315,
  187,
  443,
  123,
  379,
  251,
  507,
  7,
  263,
  135,
  391,
  71,
  327,
  199,
  455,
  39,
  295,
  167,
  423,
  103,
  359,
  231,
  487,
  23,
  279,
  151,
  407,
  87,
  343,
  215,
  471,
  55,
  311,
  183,
  439,
  119,
  375,
  247,
  503,
  15,
  271,
  143,
  399,
  79,
  335,
  207,
  463,
  47,
  303,
  175,
  431,
  111,
  367,
  239,
  495,
  31,
  287,
  159,
  415,
  95,
  351,
  223,
  479,
  63,
  319,
  191,
  447,
  127,
  383,
  255,
  511,
  0,
  64,
  32,
  96,
  16,
  80,
  48,
  112,
  8,
  72,
  40,
  104,
  24,
  88,
  56,
  120,
  4,
  68,
  36,
  100,
  20,
  84,
  52,
  116,
  3,
  131,
  67,
  195,
  35,
  163,
  99,
  227
];
const static_ltree2_second_part = extractArray([[144, 8], [112, 9], [24, 7], [8, 8]]);
StaticTree.static_ltree = flatArray(static_ltree2_first_part.map((value, index) => [value, static_ltree2_second_part[index]]));
const static_dtree_first_part = [0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23];
const static_dtree_second_part = extractArray([[30, 5]]);
StaticTree.static_dtree = flatArray(static_dtree_first_part.map((value, index) => [value, static_dtree_second_part[index]]));
StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS$1);
StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS$1);
StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);
const MAX_MEM_LEVEL = 9;
const DEF_MEM_LEVEL = 8;
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  const that = this;
  that.good_length = good_length;
  that.max_lazy = max_lazy;
  that.nice_length = nice_length;
  that.max_chain = max_chain;
  that.func = func;
}
__name(Config, "Config");
const STORED$1 = 0;
const FAST = 1;
const SLOW = 2;
const config_table = [
  new Config(0, 0, 0, 0, STORED$1),
  new Config(4, 4, 8, 4, FAST),
  new Config(4, 5, 16, 8, FAST),
  new Config(4, 6, 32, 32, FAST),
  new Config(4, 4, 16, 16, SLOW),
  new Config(8, 16, 32, 32, SLOW),
  new Config(8, 16, 128, 128, SLOW),
  new Config(8, 32, 128, 256, SLOW),
  new Config(32, 128, 258, 1024, SLOW),
  new Config(32, 258, 258, 4096, SLOW)
];
const z_errmsg = [
  "need dictionary",
  // Z_NEED_DICT
  // 2
  "stream end",
  // Z_STREAM_END 1
  "",
  // Z_OK 0
  "",
  // Z_ERRNO (-1)
  "stream error",
  // Z_STREAM_ERROR (-2)
  "data error",
  // Z_DATA_ERROR (-3)
  "",
  // Z_MEM_ERROR (-4)
  "buffer error",
  // Z_BUF_ERROR (-5)
  "",
  // Z_VERSION_ERROR (-6)
  ""
];
const NeedMore = 0;
const BlockDone = 1;
const FinishStarted = 2;
const FinishDone = 3;
const PRESET_DICT$1 = 32;
const INIT_STATE = 42;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const Z_DEFLATED$1 = 8;
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
function smaller(tree, n, m, depth) {
  const tn2 = tree[n * 2];
  const tm2 = tree[m * 2];
  return tn2 < tm2 || tn2 == tm2 && depth[n] <= depth[m];
}
__name(smaller, "smaller");
function Deflate() {
  const that = this;
  let strm;
  let status;
  let pending_buf_size;
  let last_flush;
  let w_size;
  let w_bits;
  let w_mask;
  let win;
  let window_size;
  let prev;
  let head;
  let ins_h;
  let hash_size;
  let hash_bits;
  let hash_mask;
  let hash_shift;
  let block_start;
  let match_length;
  let prev_match;
  let match_available;
  let strstart;
  let match_start;
  let lookahead;
  let prev_length;
  let max_chain_length;
  let max_lazy_match;
  let level2;
  let strategy;
  let good_match;
  let nice_match;
  let dyn_ltree;
  let dyn_dtree;
  let bl_tree;
  const l_desc = new Tree();
  const d_desc = new Tree();
  const bl_desc = new Tree();
  that.depth = [];
  let lit_bufsize;
  let last_lit;
  let matches;
  let last_eob_len;
  let bi_buf;
  let bi_valid;
  that.bl_count = [];
  that.heap = [];
  dyn_ltree = [];
  dyn_dtree = [];
  bl_tree = [];
  function lm_init2() {
    window_size = 2 * w_size;
    head[hash_size - 1] = 0;
    for (let i = 0; i < hash_size - 1; i++) {
      head[i] = 0;
    }
    max_lazy_match = config_table[level2].max_lazy;
    good_match = config_table[level2].good_length;
    nice_match = config_table[level2].nice_length;
    max_chain_length = config_table[level2].max_chain;
    strstart = 0;
    block_start = 0;
    lookahead = 0;
    match_length = prev_length = MIN_MATCH - 1;
    match_available = 0;
    ins_h = 0;
  }
  __name(lm_init2, "lm_init");
  function init_block2() {
    let i;
    for (i = 0; i < L_CODES; i++)
      dyn_ltree[i * 2] = 0;
    for (i = 0; i < D_CODES; i++)
      dyn_dtree[i * 2] = 0;
    for (i = 0; i < BL_CODES; i++)
      bl_tree[i * 2] = 0;
    dyn_ltree[END_BLOCK * 2] = 1;
    that.opt_len = that.static_len = 0;
    last_lit = matches = 0;
  }
  __name(init_block2, "init_block");
  function tr_init() {
    l_desc.dyn_tree = dyn_ltree;
    l_desc.stat_desc = StaticTree.static_l_desc;
    d_desc.dyn_tree = dyn_dtree;
    d_desc.stat_desc = StaticTree.static_d_desc;
    bl_desc.dyn_tree = bl_tree;
    bl_desc.stat_desc = StaticTree.static_bl_desc;
    bi_buf = 0;
    bi_valid = 0;
    last_eob_len = 8;
    init_block2();
  }
  __name(tr_init, "tr_init");
  that.pqdownheap = function(tree, k) {
    const heap = that.heap;
    const v = heap[k];
    let j = k << 1;
    while (j <= that.heap_len) {
      if (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {
        j++;
      }
      if (smaller(tree, v, heap[j], that.depth))
        break;
      heap[k] = heap[j];
      k = j;
      j <<= 1;
    }
    heap[k] = v;
  };
  function scan_tree2(tree, max_code) {
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (let n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen == nextlen) {
        continue;
      } else if (count < min_count) {
        bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen != prevlen)
          bl_tree[curlen * 2]++;
        bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        bl_tree[REPZ_3_10 * 2]++;
      } else {
        bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen == nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  __name(scan_tree2, "scan_tree");
  function build_bl_tree2() {
    let max_blindex;
    scan_tree2(dyn_ltree, l_desc.max_code);
    scan_tree2(dyn_dtree, d_desc.max_code);
    bl_desc.build_tree(that);
    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)
        break;
    }
    that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  __name(build_bl_tree2, "build_bl_tree");
  function put_byte2(p) {
    that.pending_buf[that.pending++] = p;
  }
  __name(put_byte2, "put_byte");
  function put_short2(w) {
    put_byte2(w & 255);
    put_byte2(w >>> 8 & 255);
  }
  __name(put_short2, "put_short");
  function putShortMSB2(b) {
    put_byte2(b >> 8 & 255);
    put_byte2(b & 255 & 255);
  }
  __name(putShortMSB2, "putShortMSB");
  function send_bits2(value, length) {
    let val;
    const len = length;
    if (bi_valid > Buf_size - len) {
      val = value;
      bi_buf |= val << bi_valid & 65535;
      put_short2(bi_buf);
      bi_buf = val >>> Buf_size - bi_valid;
      bi_valid += len - Buf_size;
    } else {
      bi_buf |= value << bi_valid & 65535;
      bi_valid += len;
    }
  }
  __name(send_bits2, "send_bits");
  function send_code2(c, tree) {
    const c2 = c * 2;
    send_bits2(tree[c2] & 65535, tree[c2 + 1] & 65535);
  }
  __name(send_code2, "send_code");
  function send_tree2(tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen == nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code2(curlen, bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen != prevlen) {
          send_code2(curlen, bl_tree);
          count--;
        }
        send_code2(REP_3_6, bl_tree);
        send_bits2(count - 3, 2);
      } else if (count <= 10) {
        send_code2(REPZ_3_10, bl_tree);
        send_bits2(count - 3, 3);
      } else {
        send_code2(REPZ_11_138, bl_tree);
        send_bits2(count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen == nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  __name(send_tree2, "send_tree");
  function send_all_trees2(lcodes, dcodes, blcodes) {
    let rank2;
    send_bits2(lcodes - 257, 5);
    send_bits2(dcodes - 1, 5);
    send_bits2(blcodes - 4, 4);
    for (rank2 = 0; rank2 < blcodes; rank2++) {
      send_bits2(bl_tree[Tree.bl_order[rank2] * 2 + 1], 3);
    }
    send_tree2(dyn_ltree, lcodes - 1);
    send_tree2(dyn_dtree, dcodes - 1);
  }
  __name(send_all_trees2, "send_all_trees");
  function bi_flush2() {
    if (bi_valid == 16) {
      put_short2(bi_buf);
      bi_buf = 0;
      bi_valid = 0;
    } else if (bi_valid >= 8) {
      put_byte2(bi_buf & 255);
      bi_buf >>>= 8;
      bi_valid -= 8;
    }
  }
  __name(bi_flush2, "bi_flush");
  function _tr_align2() {
    send_bits2(STATIC_TREES << 1, 3);
    send_code2(END_BLOCK, StaticTree.static_ltree);
    bi_flush2();
    if (1 + last_eob_len + 10 - bi_valid < 9) {
      send_bits2(STATIC_TREES << 1, 3);
      send_code2(END_BLOCK, StaticTree.static_ltree);
      bi_flush2();
    }
    last_eob_len = 7;
  }
  __name(_tr_align2, "_tr_align");
  function _tr_tally2(dist, lc) {
    let out_length, in_length, dcode;
    that.dist_buf[last_lit] = dist;
    that.lc_buf[last_lit] = lc & 255;
    last_lit++;
    if (dist === 0) {
      dyn_ltree[lc * 2]++;
    } else {
      matches++;
      dist--;
      dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;
      dyn_dtree[Tree.d_code(dist) * 2]++;
    }
    if ((last_lit & 8191) === 0 && level2 > 2) {
      out_length = last_lit * 8;
      in_length = strstart - block_start;
      for (dcode = 0; dcode < D_CODES; dcode++) {
        out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);
      }
      out_length >>>= 3;
      if (matches < Math.floor(last_lit / 2) && out_length < Math.floor(in_length / 2))
        return true;
    }
    return last_lit == lit_bufsize - 1;
  }
  __name(_tr_tally2, "_tr_tally");
  function compress_block2(ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code2;
    let extra;
    if (last_lit !== 0) {
      do {
        dist = that.dist_buf[lx];
        lc = that.lc_buf[lx];
        lx++;
        if (dist === 0) {
          send_code2(lc, ltree);
        } else {
          code2 = Tree._length_code[lc];
          send_code2(code2 + LITERALS + 1, ltree);
          extra = Tree.extra_lbits[code2];
          if (extra !== 0) {
            lc -= Tree.base_length[code2];
            send_bits2(lc, extra);
          }
          dist--;
          code2 = Tree.d_code(dist);
          send_code2(code2, dtree);
          extra = Tree.extra_dbits[code2];
          if (extra !== 0) {
            dist -= Tree.base_dist[code2];
            send_bits2(dist, extra);
          }
        }
      } while (lx < last_lit);
    }
    send_code2(END_BLOCK, ltree);
    last_eob_len = ltree[END_BLOCK * 2 + 1];
  }
  __name(compress_block2, "compress_block");
  function bi_windup2() {
    if (bi_valid > 8) {
      put_short2(bi_buf);
    } else if (bi_valid > 0) {
      put_byte2(bi_buf & 255);
    }
    bi_buf = 0;
    bi_valid = 0;
  }
  __name(bi_windup2, "bi_windup");
  function copy_block(buf, len, header) {
    bi_windup2();
    last_eob_len = 8;
    {
      put_short2(len);
      put_short2(~len);
    }
    that.pending_buf.set(win.subarray(buf, buf + len), that.pending);
    that.pending += len;
  }
  __name(copy_block, "copy_block");
  function _tr_stored_block2(buf, stored_len, eof) {
    send_bits2((STORED_BLOCK << 1) + (eof ? 1 : 0), 3);
    copy_block(buf, stored_len);
  }
  __name(_tr_stored_block2, "_tr_stored_block");
  function _tr_flush_block2(buf, stored_len, eof) {
    let opt_lenb, static_lenb;
    let max_blindex = 0;
    if (level2 > 0) {
      l_desc.build_tree(that);
      d_desc.build_tree(that);
      max_blindex = build_bl_tree2();
      opt_lenb = that.opt_len + 3 + 7 >>> 3;
      static_lenb = that.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb)
        opt_lenb = static_lenb;
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf != -1) {
      _tr_stored_block2(buf, stored_len, eof);
    } else if (static_lenb == opt_lenb) {
      send_bits2((STATIC_TREES << 1) + (eof ? 1 : 0), 3);
      compress_block2(StaticTree.static_ltree, StaticTree.static_dtree);
    } else {
      send_bits2((DYN_TREES << 1) + (eof ? 1 : 0), 3);
      send_all_trees2(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
      compress_block2(dyn_ltree, dyn_dtree);
    }
    init_block2();
    if (eof) {
      bi_windup2();
    }
  }
  __name(_tr_flush_block2, "_tr_flush_block");
  function flush_block_only2(eof) {
    _tr_flush_block2(block_start >= 0 ? block_start : -1, strstart - block_start, eof);
    block_start = strstart;
    strm.flush_pending();
  }
  __name(flush_block_only2, "flush_block_only");
  function fill_window2() {
    let n, m;
    let p;
    let more;
    do {
      more = window_size - lookahead - strstart;
      if (more === 0 && strstart === 0 && lookahead === 0) {
        more = w_size;
      } else if (more == -1) {
        more--;
      } else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {
        win.set(win.subarray(w_size, w_size + w_size), 0);
        match_start -= w_size;
        strstart -= w_size;
        block_start -= w_size;
        n = hash_size;
        p = n;
        do {
          m = head[--p] & 65535;
          head[p] = m >= w_size ? m - w_size : 0;
        } while (--n !== 0);
        n = w_size;
        p = n;
        do {
          m = prev[--p] & 65535;
          prev[p] = m >= w_size ? m - w_size : 0;
        } while (--n !== 0);
        more += w_size;
      }
      if (strm.avail_in === 0)
        return;
      n = strm.read_buf(win, strstart + lookahead, more);
      lookahead += n;
      if (lookahead >= MIN_MATCH) {
        ins_h = win[strstart] & 255;
        ins_h = (ins_h << hash_shift ^ win[strstart + 1] & 255) & hash_mask;
      }
    } while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0);
  }
  __name(fill_window2, "fill_window");
  function deflate_stored2(flush) {
    let max_block_size = 65535;
    let max_start;
    if (max_block_size > pending_buf_size - 5) {
      max_block_size = pending_buf_size - 5;
    }
    while (true) {
      if (lookahead <= 1) {
        fill_window2();
        if (lookahead === 0 && flush == Z_NO_FLUSH$1)
          return NeedMore;
        if (lookahead === 0)
          break;
      }
      strstart += lookahead;
      lookahead = 0;
      max_start = block_start + max_block_size;
      if (strstart === 0 || strstart >= max_start) {
        lookahead = strstart - max_start;
        strstart = max_start;
        flush_block_only2(false);
        if (strm.avail_out === 0)
          return NeedMore;
      }
      if (strstart - block_start >= w_size - MIN_LOOKAHEAD) {
        flush_block_only2(false);
        if (strm.avail_out === 0)
          return NeedMore;
      }
    }
    flush_block_only2(flush == Z_FINISH$1);
    if (strm.avail_out === 0)
      return flush == Z_FINISH$1 ? FinishStarted : NeedMore;
    return flush == Z_FINISH$1 ? FinishDone : BlockDone;
  }
  __name(deflate_stored2, "deflate_stored");
  function longest_match2(cur_match) {
    let chain_length = max_chain_length;
    let scan = strstart;
    let match;
    let len;
    let best_len = prev_length;
    const limit = strstart > w_size - MIN_LOOKAHEAD ? strstart - (w_size - MIN_LOOKAHEAD) : 0;
    let _nice_match = nice_match;
    const wmask = w_mask;
    const strend = strstart + MAX_MATCH;
    let scan_end1 = win[scan + best_len - 1];
    let scan_end = win[scan + best_len];
    if (prev_length >= good_match) {
      chain_length >>= 2;
    }
    if (_nice_match > lookahead)
      _nice_match = lookahead;
    do {
      match = cur_match;
      if (win[match + best_len] != scan_end || win[match + best_len - 1] != scan_end1 || win[match] != win[scan] || win[++match] != win[scan + 1])
        continue;
      scan += 2;
      match++;
      do {
      } while (win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        match_start = cur_match;
        best_len = len;
        if (len >= _nice_match)
          break;
        scan_end1 = win[scan + best_len - 1];
        scan_end = win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask] & 65535) > limit && --chain_length !== 0);
    if (best_len <= lookahead)
      return best_len;
    return lookahead;
  }
  __name(longest_match2, "longest_match");
  function deflate_fast2(flush) {
    let hash_head = 0;
    let bflush;
    while (true) {
      if (lookahead < MIN_LOOKAHEAD) {
        fill_window2();
        if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH$1) {
          return NeedMore;
        }
        if (lookahead === 0)
          break;
      }
      if (lookahead >= MIN_MATCH) {
        ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
        hash_head = head[ins_h] & 65535;
        prev[strstart & w_mask] = head[ins_h];
        head[ins_h] = strstart;
      }
      if (hash_head !== 0 && (strstart - hash_head & 65535) <= w_size - MIN_LOOKAHEAD) {
        if (strategy != Z_HUFFMAN_ONLY) {
          match_length = longest_match2(hash_head);
        }
      }
      if (match_length >= MIN_MATCH) {
        bflush = _tr_tally2(strstart - match_start, match_length - MIN_MATCH);
        lookahead -= match_length;
        if (match_length <= max_lazy_match && lookahead >= MIN_MATCH) {
          match_length--;
          do {
            strstart++;
            ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
            hash_head = head[ins_h] & 65535;
            prev[strstart & w_mask] = head[ins_h];
            head[ins_h] = strstart;
          } while (--match_length !== 0);
          strstart++;
        } else {
          strstart += match_length;
          match_length = 0;
          ins_h = win[strstart] & 255;
          ins_h = (ins_h << hash_shift ^ win[strstart + 1] & 255) & hash_mask;
        }
      } else {
        bflush = _tr_tally2(0, win[strstart] & 255);
        lookahead--;
        strstart++;
      }
      if (bflush) {
        flush_block_only2(false);
        if (strm.avail_out === 0)
          return NeedMore;
      }
    }
    flush_block_only2(flush == Z_FINISH$1);
    if (strm.avail_out === 0) {
      if (flush == Z_FINISH$1)
        return FinishStarted;
      else
        return NeedMore;
    }
    return flush == Z_FINISH$1 ? FinishDone : BlockDone;
  }
  __name(deflate_fast2, "deflate_fast");
  function deflate_slow2(flush) {
    let hash_head = 0;
    let bflush;
    let max_insert;
    while (true) {
      if (lookahead < MIN_LOOKAHEAD) {
        fill_window2();
        if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH$1) {
          return NeedMore;
        }
        if (lookahead === 0)
          break;
      }
      if (lookahead >= MIN_MATCH) {
        ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
        hash_head = head[ins_h] & 65535;
        prev[strstart & w_mask] = head[ins_h];
        head[ins_h] = strstart;
      }
      prev_length = match_length;
      prev_match = match_start;
      match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && prev_length < max_lazy_match && (strstart - hash_head & 65535) <= w_size - MIN_LOOKAHEAD) {
        if (strategy != Z_HUFFMAN_ONLY) {
          match_length = longest_match2(hash_head);
        }
        if (match_length <= 5 && (strategy == Z_FILTERED || match_length == MIN_MATCH && strstart - match_start > 4096)) {
          match_length = MIN_MATCH - 1;
        }
      }
      if (prev_length >= MIN_MATCH && match_length <= prev_length) {
        max_insert = strstart + lookahead - MIN_MATCH;
        bflush = _tr_tally2(strstart - 1 - prev_match, prev_length - MIN_MATCH);
        lookahead -= prev_length - 1;
        prev_length -= 2;
        do {
          if (++strstart <= max_insert) {
            ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
            hash_head = head[ins_h] & 65535;
            prev[strstart & w_mask] = head[ins_h];
            head[ins_h] = strstart;
          }
        } while (--prev_length !== 0);
        match_available = 0;
        match_length = MIN_MATCH - 1;
        strstart++;
        if (bflush) {
          flush_block_only2(false);
          if (strm.avail_out === 0)
            return NeedMore;
        }
      } else if (match_available !== 0) {
        bflush = _tr_tally2(0, win[strstart - 1] & 255);
        if (bflush) {
          flush_block_only2(false);
        }
        strstart++;
        lookahead--;
        if (strm.avail_out === 0)
          return NeedMore;
      } else {
        match_available = 1;
        strstart++;
        lookahead--;
      }
    }
    if (match_available !== 0) {
      bflush = _tr_tally2(0, win[strstart - 1] & 255);
      match_available = 0;
    }
    flush_block_only2(flush == Z_FINISH$1);
    if (strm.avail_out === 0) {
      if (flush == Z_FINISH$1)
        return FinishStarted;
      else
        return NeedMore;
    }
    return flush == Z_FINISH$1 ? FinishDone : BlockDone;
  }
  __name(deflate_slow2, "deflate_slow");
  function deflateReset2(strm2) {
    strm2.total_in = strm2.total_out = 0;
    strm2.msg = null;
    that.pending = 0;
    that.pending_out = 0;
    status = BUSY_STATE;
    last_flush = Z_NO_FLUSH$1;
    tr_init();
    lm_init2();
    return Z_OK$1;
  }
  __name(deflateReset2, "deflateReset");
  that.deflateInit = function(strm2, _level, bits, _method, memLevel, _strategy) {
    if (!_method)
      _method = Z_DEFLATED$1;
    if (!memLevel)
      memLevel = DEF_MEM_LEVEL;
    if (!_strategy)
      _strategy = Z_DEFAULT_STRATEGY;
    strm2.msg = null;
    if (_level == Z_DEFAULT_COMPRESSION)
      _level = 6;
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED$1 || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
      return Z_STREAM_ERROR$1;
    }
    strm2.dstate = that;
    w_bits = bits;
    w_size = 1 << w_bits;
    w_mask = w_size - 1;
    hash_bits = memLevel + 7;
    hash_size = 1 << hash_bits;
    hash_mask = hash_size - 1;
    hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    win = new Uint8Array(w_size * 2);
    prev = [];
    head = [];
    lit_bufsize = 1 << memLevel + 6;
    that.pending_buf = new Uint8Array(lit_bufsize * 4);
    pending_buf_size = lit_bufsize * 4;
    that.dist_buf = new Uint16Array(lit_bufsize);
    that.lc_buf = new Uint8Array(lit_bufsize);
    level2 = _level;
    strategy = _strategy;
    return deflateReset2(strm2);
  };
  that.deflateEnd = function() {
    if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {
      return Z_STREAM_ERROR$1;
    }
    that.lc_buf = null;
    that.dist_buf = null;
    that.pending_buf = null;
    head = null;
    prev = null;
    win = null;
    that.dstate = null;
    return status == BUSY_STATE ? Z_DATA_ERROR$1 : Z_OK$1;
  };
  that.deflateParams = function(strm2, _level, _strategy) {
    let err2 = Z_OK$1;
    if (_level == Z_DEFAULT_COMPRESSION) {
      _level = 6;
    }
    if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
      return Z_STREAM_ERROR$1;
    }
    if (config_table[level2].func != config_table[_level].func && strm2.total_in !== 0) {
      err2 = strm2.deflate(Z_PARTIAL_FLUSH);
    }
    if (level2 != _level) {
      level2 = _level;
      max_lazy_match = config_table[level2].max_lazy;
      good_match = config_table[level2].good_length;
      nice_match = config_table[level2].nice_length;
      max_chain_length = config_table[level2].max_chain;
    }
    strategy = _strategy;
    return err2;
  };
  that.deflateSetDictionary = function(_strm, dictionary, dictLength) {
    let length = dictLength;
    let n, index = 0;
    if (!dictionary || status != INIT_STATE)
      return Z_STREAM_ERROR$1;
    if (length < MIN_MATCH)
      return Z_OK$1;
    if (length > w_size - MIN_LOOKAHEAD) {
      length = w_size - MIN_LOOKAHEAD;
      index = dictLength - length;
    }
    win.set(dictionary.subarray(index, index + length), 0);
    strstart = length;
    block_start = length;
    ins_h = win[0] & 255;
    ins_h = (ins_h << hash_shift ^ win[1] & 255) & hash_mask;
    for (n = 0; n <= length - MIN_MATCH; n++) {
      ins_h = (ins_h << hash_shift ^ win[n + (MIN_MATCH - 1)] & 255) & hash_mask;
      prev[n & w_mask] = head[ins_h];
      head[ins_h] = n;
    }
    return Z_OK$1;
  };
  that.deflate = function(_strm, flush) {
    let i, header, level_flags, old_flush, bstate;
    if (flush > Z_FINISH$1 || flush < 0) {
      return Z_STREAM_ERROR$1;
    }
    if (!_strm.next_out || !_strm.next_in && _strm.avail_in !== 0 || status == FINISH_STATE && flush != Z_FINISH$1) {
      _strm.msg = z_errmsg[Z_NEED_DICT$1 - Z_STREAM_ERROR$1];
      return Z_STREAM_ERROR$1;
    }
    if (_strm.avail_out === 0) {
      _strm.msg = z_errmsg[Z_NEED_DICT$1 - Z_BUF_ERROR$1];
      return Z_BUF_ERROR$1;
    }
    strm = _strm;
    old_flush = last_flush;
    last_flush = flush;
    if (status == INIT_STATE) {
      header = Z_DEFLATED$1 + (w_bits - 8 << 4) << 8;
      level_flags = (level2 - 1 & 255) >> 1;
      if (level_flags > 3)
        level_flags = 3;
      header |= level_flags << 6;
      if (strstart !== 0)
        header |= PRESET_DICT$1;
      header += 31 - header % 31;
      status = BUSY_STATE;
      putShortMSB2(header);
    }
    if (that.pending !== 0) {
      strm.flush_pending();
      if (strm.avail_out === 0) {
        last_flush = -1;
        return Z_OK$1;
      }
    } else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH$1) {
      strm.msg = z_errmsg[Z_NEED_DICT$1 - Z_BUF_ERROR$1];
      return Z_BUF_ERROR$1;
    }
    if (status == FINISH_STATE && strm.avail_in !== 0) {
      _strm.msg = z_errmsg[Z_NEED_DICT$1 - Z_BUF_ERROR$1];
      return Z_BUF_ERROR$1;
    }
    if (strm.avail_in !== 0 || lookahead !== 0 || flush != Z_NO_FLUSH$1 && status != FINISH_STATE) {
      bstate = -1;
      switch (config_table[level2].func) {
        case STORED$1:
          bstate = deflate_stored2(flush);
          break;
        case FAST:
          bstate = deflate_fast2(flush);
          break;
        case SLOW:
          bstate = deflate_slow2(flush);
          break;
      }
      if (bstate == FinishStarted || bstate == FinishDone) {
        status = FINISH_STATE;
      }
      if (bstate == NeedMore || bstate == FinishStarted) {
        if (strm.avail_out === 0) {
          last_flush = -1;
        }
        return Z_OK$1;
      }
      if (bstate == BlockDone) {
        if (flush == Z_PARTIAL_FLUSH) {
          _tr_align2();
        } else {
          _tr_stored_block2(0, 0, false);
          if (flush == Z_FULL_FLUSH) {
            for (i = 0; i < hash_size; i++)
              head[i] = 0;
          }
        }
        strm.flush_pending();
        if (strm.avail_out === 0) {
          last_flush = -1;
          return Z_OK$1;
        }
      }
    }
    if (flush != Z_FINISH$1)
      return Z_OK$1;
    return Z_STREAM_END$1;
  };
}
__name(Deflate, "Deflate");
function ZStream$1() {
  const that = this;
  that.next_in_index = 0;
  that.next_out_index = 0;
  that.avail_in = 0;
  that.total_in = 0;
  that.avail_out = 0;
  that.total_out = 0;
}
__name(ZStream$1, "ZStream$1");
ZStream$1.prototype = {
  deflateInit(level2, bits) {
    const that = this;
    that.dstate = new Deflate();
    if (!bits)
      bits = MAX_BITS$1;
    return that.dstate.deflateInit(that, level2, bits);
  },
  deflate(flush) {
    const that = this;
    if (!that.dstate) {
      return Z_STREAM_ERROR$1;
    }
    return that.dstate.deflate(that, flush);
  },
  deflateEnd() {
    const that = this;
    if (!that.dstate)
      return Z_STREAM_ERROR$1;
    const ret = that.dstate.deflateEnd();
    that.dstate = null;
    return ret;
  },
  deflateParams(level2, strategy) {
    const that = this;
    if (!that.dstate)
      return Z_STREAM_ERROR$1;
    return that.dstate.deflateParams(that, level2, strategy);
  },
  deflateSetDictionary(dictionary, dictLength) {
    const that = this;
    if (!that.dstate)
      return Z_STREAM_ERROR$1;
    return that.dstate.deflateSetDictionary(that, dictionary, dictLength);
  },
  // Read a new buffer from the current input stream, update the
  // total number of bytes read. All deflate() input goes through
  // this function so some applications may wish to modify it to avoid
  // allocating a large strm->next_in buffer and copying from it.
  // (See also flush_pending()).
  read_buf(buf, start, size) {
    const that = this;
    let len = that.avail_in;
    if (len > size)
      len = size;
    if (len === 0)
      return 0;
    that.avail_in -= len;
    buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);
    that.next_in_index += len;
    that.total_in += len;
    return len;
  },
  // Flush as much pending output as possible. All deflate() output goes
  // through this function so some applications may wish to modify it
  // to avoid allocating a large strm->next_out buffer and copying into it.
  // (See also read_buf()).
  flush_pending() {
    const that = this;
    let len = that.dstate.pending;
    if (len > that.avail_out)
      len = that.avail_out;
    if (len === 0)
      return;
    that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);
    that.next_out_index += len;
    that.dstate.pending_out += len;
    that.total_out += len;
    that.avail_out -= len;
    that.dstate.pending -= len;
    if (that.dstate.pending === 0) {
      that.dstate.pending_out = 0;
    }
  }
};
function ZipDeflate(options) {
  const that = this;
  const z = new ZStream$1();
  const bufsize = getMaximumCompressedSize$1(options && options.chunkSize ? options.chunkSize : 64 * 1024);
  const flush = Z_NO_FLUSH$1;
  const buf = new Uint8Array(bufsize);
  let level2 = options ? options.level : Z_DEFAULT_COMPRESSION;
  if (typeof level2 == "undefined")
    level2 = Z_DEFAULT_COMPRESSION;
  z.deflateInit(level2);
  z.next_out = buf;
  that.append = function(data, onprogress) {
    let err2, array2, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
    const buffers = [];
    if (!data.length)
      return;
    z.next_in_index = 0;
    z.next_in = data;
    z.avail_in = data.length;
    do {
      z.next_out_index = 0;
      z.avail_out = bufsize;
      err2 = z.deflate(flush);
      if (err2 != Z_OK$1)
        throw new Error("deflating: " + z.msg);
      if (z.next_out_index)
        if (z.next_out_index == bufsize)
          buffers.push(new Uint8Array(buf));
        else
          buffers.push(buf.subarray(0, z.next_out_index));
      bufferSize += z.next_out_index;
      if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
        onprogress(z.next_in_index);
        lastIndex = z.next_in_index;
      }
    } while (z.avail_in > 0 || z.avail_out === 0);
    if (buffers.length > 1) {
      array2 = new Uint8Array(bufferSize);
      buffers.forEach(function(chunk) {
        array2.set(chunk, bufferIndex);
        bufferIndex += chunk.length;
      });
    } else {
      array2 = buffers[0] ? new Uint8Array(buffers[0]) : new Uint8Array();
    }
    return array2;
  };
  that.flush = function() {
    let err2, array2, bufferIndex = 0, bufferSize = 0;
    const buffers = [];
    do {
      z.next_out_index = 0;
      z.avail_out = bufsize;
      err2 = z.deflate(Z_FINISH$1);
      if (err2 != Z_STREAM_END$1 && err2 != Z_OK$1)
        throw new Error("deflating: " + z.msg);
      if (bufsize - z.avail_out > 0)
        buffers.push(buf.slice(0, z.next_out_index));
      bufferSize += z.next_out_index;
    } while (z.avail_in > 0 || z.avail_out === 0);
    z.deflateEnd();
    array2 = new Uint8Array(bufferSize);
    buffers.forEach(function(chunk) {
      array2.set(chunk, bufferIndex);
      bufferIndex += chunk.length;
    });
    return array2;
  };
}
__name(ZipDeflate, "ZipDeflate");
function getMaximumCompressedSize$1(uncompressedSize) {
  return uncompressedSize + 5 * (Math.floor(uncompressedSize / 16383) + 1);
}
__name(getMaximumCompressedSize$1, "getMaximumCompressedSize$1");
const MAX_BITS = 15;
const Z_OK = 0;
const Z_STREAM_END = 1;
const Z_NEED_DICT = 2;
const Z_STREAM_ERROR = -2;
const Z_DATA_ERROR = -3;
const Z_MEM_ERROR = -4;
const Z_BUF_ERROR = -5;
const inflate_mask = [
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535
];
const MANY = 1440;
const Z_NO_FLUSH = 0;
const Z_FINISH = 4;
const fixed_bl = 9;
const fixed_bd = 5;
const fixed_tl = [
  96,
  7,
  256,
  0,
  8,
  80,
  0,
  8,
  16,
  84,
  8,
  115,
  82,
  7,
  31,
  0,
  8,
  112,
  0,
  8,
  48,
  0,
  9,
  192,
  80,
  7,
  10,
  0,
  8,
  96,
  0,
  8,
  32,
  0,
  9,
  160,
  0,
  8,
  0,
  0,
  8,
  128,
  0,
  8,
  64,
  0,
  9,
  224,
  80,
  7,
  6,
  0,
  8,
  88,
  0,
  8,
  24,
  0,
  9,
  144,
  83,
  7,
  59,
  0,
  8,
  120,
  0,
  8,
  56,
  0,
  9,
  208,
  81,
  7,
  17,
  0,
  8,
  104,
  0,
  8,
  40,
  0,
  9,
  176,
  0,
  8,
  8,
  0,
  8,
  136,
  0,
  8,
  72,
  0,
  9,
  240,
  80,
  7,
  4,
  0,
  8,
  84,
  0,
  8,
  20,
  85,
  8,
  227,
  83,
  7,
  43,
  0,
  8,
  116,
  0,
  8,
  52,
  0,
  9,
  200,
  81,
  7,
  13,
  0,
  8,
  100,
  0,
  8,
  36,
  0,
  9,
  168,
  0,
  8,
  4,
  0,
  8,
  132,
  0,
  8,
  68,
  0,
  9,
  232,
  80,
  7,
  8,
  0,
  8,
  92,
  0,
  8,
  28,
  0,
  9,
  152,
  84,
  7,
  83,
  0,
  8,
  124,
  0,
  8,
  60,
  0,
  9,
  216,
  82,
  7,
  23,
  0,
  8,
  108,
  0,
  8,
  44,
  0,
  9,
  184,
  0,
  8,
  12,
  0,
  8,
  140,
  0,
  8,
  76,
  0,
  9,
  248,
  80,
  7,
  3,
  0,
  8,
  82,
  0,
  8,
  18,
  85,
  8,
  163,
  83,
  7,
  35,
  0,
  8,
  114,
  0,
  8,
  50,
  0,
  9,
  196,
  81,
  7,
  11,
  0,
  8,
  98,
  0,
  8,
  34,
  0,
  9,
  164,
  0,
  8,
  2,
  0,
  8,
  130,
  0,
  8,
  66,
  0,
  9,
  228,
  80,
  7,
  7,
  0,
  8,
  90,
  0,
  8,
  26,
  0,
  9,
  148,
  84,
  7,
  67,
  0,
  8,
  122,
  0,
  8,
  58,
  0,
  9,
  212,
  82,
  7,
  19,
  0,
  8,
  106,
  0,
  8,
  42,
  0,
  9,
  180,
  0,
  8,
  10,
  0,
  8,
  138,
  0,
  8,
  74,
  0,
  9,
  244,
  80,
  7,
  5,
  0,
  8,
  86,
  0,
  8,
  22,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  118,
  0,
  8,
  54,
  0,
  9,
  204,
  81,
  7,
  15,
  0,
  8,
  102,
  0,
  8,
  38,
  0,
  9,
  172,
  0,
  8,
  6,
  0,
  8,
  134,
  0,
  8,
  70,
  0,
  9,
  236,
  80,
  7,
  9,
  0,
  8,
  94,
  0,
  8,
  30,
  0,
  9,
  156,
  84,
  7,
  99,
  0,
  8,
  126,
  0,
  8,
  62,
  0,
  9,
  220,
  82,
  7,
  27,
  0,
  8,
  110,
  0,
  8,
  46,
  0,
  9,
  188,
  0,
  8,
  14,
  0,
  8,
  142,
  0,
  8,
  78,
  0,
  9,
  252,
  96,
  7,
  256,
  0,
  8,
  81,
  0,
  8,
  17,
  85,
  8,
  131,
  82,
  7,
  31,
  0,
  8,
  113,
  0,
  8,
  49,
  0,
  9,
  194,
  80,
  7,
  10,
  0,
  8,
  97,
  0,
  8,
  33,
  0,
  9,
  162,
  0,
  8,
  1,
  0,
  8,
  129,
  0,
  8,
  65,
  0,
  9,
  226,
  80,
  7,
  6,
  0,
  8,
  89,
  0,
  8,
  25,
  0,
  9,
  146,
  83,
  7,
  59,
  0,
  8,
  121,
  0,
  8,
  57,
  0,
  9,
  210,
  81,
  7,
  17,
  0,
  8,
  105,
  0,
  8,
  41,
  0,
  9,
  178,
  0,
  8,
  9,
  0,
  8,
  137,
  0,
  8,
  73,
  0,
  9,
  242,
  80,
  7,
  4,
  0,
  8,
  85,
  0,
  8,
  21,
  80,
  8,
  258,
  83,
  7,
  43,
  0,
  8,
  117,
  0,
  8,
  53,
  0,
  9,
  202,
  81,
  7,
  13,
  0,
  8,
  101,
  0,
  8,
  37,
  0,
  9,
  170,
  0,
  8,
  5,
  0,
  8,
  133,
  0,
  8,
  69,
  0,
  9,
  234,
  80,
  7,
  8,
  0,
  8,
  93,
  0,
  8,
  29,
  0,
  9,
  154,
  84,
  7,
  83,
  0,
  8,
  125,
  0,
  8,
  61,
  0,
  9,
  218,
  82,
  7,
  23,
  0,
  8,
  109,
  0,
  8,
  45,
  0,
  9,
  186,
  0,
  8,
  13,
  0,
  8,
  141,
  0,
  8,
  77,
  0,
  9,
  250,
  80,
  7,
  3,
  0,
  8,
  83,
  0,
  8,
  19,
  85,
  8,
  195,
  83,
  7,
  35,
  0,
  8,
  115,
  0,
  8,
  51,
  0,
  9,
  198,
  81,
  7,
  11,
  0,
  8,
  99,
  0,
  8,
  35,
  0,
  9,
  166,
  0,
  8,
  3,
  0,
  8,
  131,
  0,
  8,
  67,
  0,
  9,
  230,
  80,
  7,
  7,
  0,
  8,
  91,
  0,
  8,
  27,
  0,
  9,
  150,
  84,
  7,
  67,
  0,
  8,
  123,
  0,
  8,
  59,
  0,
  9,
  214,
  82,
  7,
  19,
  0,
  8,
  107,
  0,
  8,
  43,
  0,
  9,
  182,
  0,
  8,
  11,
  0,
  8,
  139,
  0,
  8,
  75,
  0,
  9,
  246,
  80,
  7,
  5,
  0,
  8,
  87,
  0,
  8,
  23,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  119,
  0,
  8,
  55,
  0,
  9,
  206,
  81,
  7,
  15,
  0,
  8,
  103,
  0,
  8,
  39,
  0,
  9,
  174,
  0,
  8,
  7,
  0,
  8,
  135,
  0,
  8,
  71,
  0,
  9,
  238,
  80,
  7,
  9,
  0,
  8,
  95,
  0,
  8,
  31,
  0,
  9,
  158,
  84,
  7,
  99,
  0,
  8,
  127,
  0,
  8,
  63,
  0,
  9,
  222,
  82,
  7,
  27,
  0,
  8,
  111,
  0,
  8,
  47,
  0,
  9,
  190,
  0,
  8,
  15,
  0,
  8,
  143,
  0,
  8,
  79,
  0,
  9,
  254,
  96,
  7,
  256,
  0,
  8,
  80,
  0,
  8,
  16,
  84,
  8,
  115,
  82,
  7,
  31,
  0,
  8,
  112,
  0,
  8,
  48,
  0,
  9,
  193,
  80,
  7,
  10,
  0,
  8,
  96,
  0,
  8,
  32,
  0,
  9,
  161,
  0,
  8,
  0,
  0,
  8,
  128,
  0,
  8,
  64,
  0,
  9,
  225,
  80,
  7,
  6,
  0,
  8,
  88,
  0,
  8,
  24,
  0,
  9,
  145,
  83,
  7,
  59,
  0,
  8,
  120,
  0,
  8,
  56,
  0,
  9,
  209,
  81,
  7,
  17,
  0,
  8,
  104,
  0,
  8,
  40,
  0,
  9,
  177,
  0,
  8,
  8,
  0,
  8,
  136,
  0,
  8,
  72,
  0,
  9,
  241,
  80,
  7,
  4,
  0,
  8,
  84,
  0,
  8,
  20,
  85,
  8,
  227,
  83,
  7,
  43,
  0,
  8,
  116,
  0,
  8,
  52,
  0,
  9,
  201,
  81,
  7,
  13,
  0,
  8,
  100,
  0,
  8,
  36,
  0,
  9,
  169,
  0,
  8,
  4,
  0,
  8,
  132,
  0,
  8,
  68,
  0,
  9,
  233,
  80,
  7,
  8,
  0,
  8,
  92,
  0,
  8,
  28,
  0,
  9,
  153,
  84,
  7,
  83,
  0,
  8,
  124,
  0,
  8,
  60,
  0,
  9,
  217,
  82,
  7,
  23,
  0,
  8,
  108,
  0,
  8,
  44,
  0,
  9,
  185,
  0,
  8,
  12,
  0,
  8,
  140,
  0,
  8,
  76,
  0,
  9,
  249,
  80,
  7,
  3,
  0,
  8,
  82,
  0,
  8,
  18,
  85,
  8,
  163,
  83,
  7,
  35,
  0,
  8,
  114,
  0,
  8,
  50,
  0,
  9,
  197,
  81,
  7,
  11,
  0,
  8,
  98,
  0,
  8,
  34,
  0,
  9,
  165,
  0,
  8,
  2,
  0,
  8,
  130,
  0,
  8,
  66,
  0,
  9,
  229,
  80,
  7,
  7,
  0,
  8,
  90,
  0,
  8,
  26,
  0,
  9,
  149,
  84,
  7,
  67,
  0,
  8,
  122,
  0,
  8,
  58,
  0,
  9,
  213,
  82,
  7,
  19,
  0,
  8,
  106,
  0,
  8,
  42,
  0,
  9,
  181,
  0,
  8,
  10,
  0,
  8,
  138,
  0,
  8,
  74,
  0,
  9,
  245,
  80,
  7,
  5,
  0,
  8,
  86,
  0,
  8,
  22,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  118,
  0,
  8,
  54,
  0,
  9,
  205,
  81,
  7,
  15,
  0,
  8,
  102,
  0,
  8,
  38,
  0,
  9,
  173,
  0,
  8,
  6,
  0,
  8,
  134,
  0,
  8,
  70,
  0,
  9,
  237,
  80,
  7,
  9,
  0,
  8,
  94,
  0,
  8,
  30,
  0,
  9,
  157,
  84,
  7,
  99,
  0,
  8,
  126,
  0,
  8,
  62,
  0,
  9,
  221,
  82,
  7,
  27,
  0,
  8,
  110,
  0,
  8,
  46,
  0,
  9,
  189,
  0,
  8,
  14,
  0,
  8,
  142,
  0,
  8,
  78,
  0,
  9,
  253,
  96,
  7,
  256,
  0,
  8,
  81,
  0,
  8,
  17,
  85,
  8,
  131,
  82,
  7,
  31,
  0,
  8,
  113,
  0,
  8,
  49,
  0,
  9,
  195,
  80,
  7,
  10,
  0,
  8,
  97,
  0,
  8,
  33,
  0,
  9,
  163,
  0,
  8,
  1,
  0,
  8,
  129,
  0,
  8,
  65,
  0,
  9,
  227,
  80,
  7,
  6,
  0,
  8,
  89,
  0,
  8,
  25,
  0,
  9,
  147,
  83,
  7,
  59,
  0,
  8,
  121,
  0,
  8,
  57,
  0,
  9,
  211,
  81,
  7,
  17,
  0,
  8,
  105,
  0,
  8,
  41,
  0,
  9,
  179,
  0,
  8,
  9,
  0,
  8,
  137,
  0,
  8,
  73,
  0,
  9,
  243,
  80,
  7,
  4,
  0,
  8,
  85,
  0,
  8,
  21,
  80,
  8,
  258,
  83,
  7,
  43,
  0,
  8,
  117,
  0,
  8,
  53,
  0,
  9,
  203,
  81,
  7,
  13,
  0,
  8,
  101,
  0,
  8,
  37,
  0,
  9,
  171,
  0,
  8,
  5,
  0,
  8,
  133,
  0,
  8,
  69,
  0,
  9,
  235,
  80,
  7,
  8,
  0,
  8,
  93,
  0,
  8,
  29,
  0,
  9,
  155,
  84,
  7,
  83,
  0,
  8,
  125,
  0,
  8,
  61,
  0,
  9,
  219,
  82,
  7,
  23,
  0,
  8,
  109,
  0,
  8,
  45,
  0,
  9,
  187,
  0,
  8,
  13,
  0,
  8,
  141,
  0,
  8,
  77,
  0,
  9,
  251,
  80,
  7,
  3,
  0,
  8,
  83,
  0,
  8,
  19,
  85,
  8,
  195,
  83,
  7,
  35,
  0,
  8,
  115,
  0,
  8,
  51,
  0,
  9,
  199,
  81,
  7,
  11,
  0,
  8,
  99,
  0,
  8,
  35,
  0,
  9,
  167,
  0,
  8,
  3,
  0,
  8,
  131,
  0,
  8,
  67,
  0,
  9,
  231,
  80,
  7,
  7,
  0,
  8,
  91,
  0,
  8,
  27,
  0,
  9,
  151,
  84,
  7,
  67,
  0,
  8,
  123,
  0,
  8,
  59,
  0,
  9,
  215,
  82,
  7,
  19,
  0,
  8,
  107,
  0,
  8,
  43,
  0,
  9,
  183,
  0,
  8,
  11,
  0,
  8,
  139,
  0,
  8,
  75,
  0,
  9,
  247,
  80,
  7,
  5,
  0,
  8,
  87,
  0,
  8,
  23,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  119,
  0,
  8,
  55,
  0,
  9,
  207,
  81,
  7,
  15,
  0,
  8,
  103,
  0,
  8,
  39,
  0,
  9,
  175,
  0,
  8,
  7,
  0,
  8,
  135,
  0,
  8,
  71,
  0,
  9,
  239,
  80,
  7,
  9,
  0,
  8,
  95,
  0,
  8,
  31,
  0,
  9,
  159,
  84,
  7,
  99,
  0,
  8,
  127,
  0,
  8,
  63,
  0,
  9,
  223,
  82,
  7,
  27,
  0,
  8,
  111,
  0,
  8,
  47,
  0,
  9,
  191,
  0,
  8,
  15,
  0,
  8,
  143,
  0,
  8,
  79,
  0,
  9,
  255
];
const fixed_td = [
  80,
  5,
  1,
  87,
  5,
  257,
  83,
  5,
  17,
  91,
  5,
  4097,
  81,
  5,
  5,
  89,
  5,
  1025,
  85,
  5,
  65,
  93,
  5,
  16385,
  80,
  5,
  3,
  88,
  5,
  513,
  84,
  5,
  33,
  92,
  5,
  8193,
  82,
  5,
  9,
  90,
  5,
  2049,
  86,
  5,
  129,
  192,
  5,
  24577,
  80,
  5,
  2,
  87,
  5,
  385,
  83,
  5,
  25,
  91,
  5,
  6145,
  81,
  5,
  7,
  89,
  5,
  1537,
  85,
  5,
  97,
  93,
  5,
  24577,
  80,
  5,
  4,
  88,
  5,
  769,
  84,
  5,
  49,
  92,
  5,
  12289,
  82,
  5,
  13,
  90,
  5,
  3073,
  86,
  5,
  193,
  192,
  5,
  24577
];
const cplens = [
  // Copy lengths for literal codes 257..285
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
const cplext = [
  // Extra bits for literal codes 257..285
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  112,
  112
  // 112==invalid
];
const cpdist = [
  // Copy offsets for distance codes 0..29
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577
];
const cpdext = [
  // Extra bits for distance codes
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13
];
const BMAX = 15;
function InfTree() {
  const that = this;
  let hn;
  let v;
  let c;
  let r;
  let u;
  let x;
  function huft_build(b, bindex, n, s, d, e2, t2, m, hp, hn2, v2) {
    let a;
    let f;
    let g;
    let h;
    let i;
    let j;
    let k;
    let l;
    let mask;
    let p;
    let q;
    let w;
    let xp;
    let y;
    let z;
    p = 0;
    i = n;
    do {
      c[b[bindex + p]]++;
      p++;
      i--;
    } while (i !== 0);
    if (c[0] == n) {
      t2[0] = -1;
      m[0] = 0;
      return Z_OK;
    }
    l = m[0];
    for (j = 1; j <= BMAX; j++)
      if (c[j] !== 0)
        break;
    k = j;
    if (l < j) {
      l = j;
    }
    for (i = BMAX; i !== 0; i--) {
      if (c[i] !== 0)
        break;
    }
    g = i;
    if (l > i) {
      l = i;
    }
    m[0] = l;
    for (y = 1 << j; j < i; j++, y <<= 1) {
      if ((y -= c[j]) < 0) {
        return Z_DATA_ERROR;
      }
    }
    if ((y -= c[i]) < 0) {
      return Z_DATA_ERROR;
    }
    c[i] += y;
    x[1] = j = 0;
    p = 1;
    xp = 2;
    while (--i !== 0) {
      x[xp] = j += c[p];
      xp++;
      p++;
    }
    i = 0;
    p = 0;
    do {
      if ((j = b[bindex + p]) !== 0) {
        v2[x[j]++] = i;
      }
      p++;
    } while (++i < n);
    n = x[g];
    x[0] = i = 0;
    p = 0;
    h = -1;
    w = -l;
    u[0] = 0;
    q = 0;
    z = 0;
    for (; k <= g; k++) {
      a = c[k];
      while (a-- !== 0) {
        while (k > w + l) {
          h++;
          w += l;
          z = g - w;
          z = z > l ? l : z;
          if ((f = 1 << (j = k - w)) > a + 1) {
            f -= a + 1;
            xp = k;
            if (j < z) {
              while (++j < z) {
                if ((f <<= 1) <= c[++xp])
                  break;
                f -= c[xp];
              }
            }
          }
          z = 1 << j;
          if (hn2[0] + z > MANY) {
            return Z_DATA_ERROR;
          }
          u[h] = q = /* hp+ */
          hn2[0];
          hn2[0] += z;
          if (h !== 0) {
            x[h] = i;
            r[0] = /* (byte) */
            j;
            r[1] = /* (byte) */
            l;
            j = i >>> w - l;
            r[2] = /* (int) */
            q - u[h - 1] - j;
            hp.set(r, (u[h - 1] + j) * 3);
          } else {
            t2[0] = q;
          }
        }
        r[1] = /* (byte) */
        k - w;
        if (p >= n) {
          r[0] = 128 + 64;
        } else if (v2[p] < s) {
          r[0] = /* (byte) */
          v2[p] < 256 ? 0 : 32 + 64;
          r[2] = v2[p++];
        } else {
          r[0] = /* (byte) */
          e2[v2[p] - s] + 16 + 64;
          r[2] = d[v2[p++] - s];
        }
        f = 1 << k - w;
        for (j = i >>> w; j < z; j += f) {
          hp.set(r, (q + j) * 3);
        }
        for (j = 1 << k - 1; (i & j) !== 0; j >>>= 1) {
          i ^= j;
        }
        i ^= j;
        mask = (1 << w) - 1;
        while ((i & mask) != x[h]) {
          h--;
          w -= l;
          mask = (1 << w) - 1;
        }
      }
    }
    return y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
  }
  __name(huft_build, "huft_build");
  function initWorkArea(vsize) {
    let i;
    if (!hn) {
      hn = [];
      v = [];
      c = new Int32Array(BMAX + 1);
      r = [];
      u = new Int32Array(BMAX);
      x = new Int32Array(BMAX + 1);
    }
    if (v.length < vsize) {
      v = [];
    }
    for (i = 0; i < vsize; i++) {
      v[i] = 0;
    }
    for (i = 0; i < BMAX + 1; i++) {
      c[i] = 0;
    }
    for (i = 0; i < 3; i++) {
      r[i] = 0;
    }
    u.set(c.subarray(0, BMAX), 0);
    x.set(c.subarray(0, BMAX + 1), 0);
  }
  __name(initWorkArea, "initWorkArea");
  that.inflate_trees_bits = function(c2, bb, tb, hp, z) {
    let result;
    initWorkArea(19);
    hn[0] = 0;
    result = huft_build(c2, 0, 19, 19, null, null, tb, bb, hp, hn, v);
    if (result == Z_DATA_ERROR) {
      z.msg = "oversubscribed dynamic bit lengths tree";
    } else if (result == Z_BUF_ERROR || bb[0] === 0) {
      z.msg = "incomplete dynamic bit lengths tree";
      result = Z_DATA_ERROR;
    }
    return result;
  };
  that.inflate_trees_dynamic = function(nl, nd, c2, bl, bd, tl, td, hp, z) {
    let result;
    initWorkArea(288);
    hn[0] = 0;
    result = huft_build(c2, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);
    if (result != Z_OK || bl[0] === 0) {
      if (result == Z_DATA_ERROR) {
        z.msg = "oversubscribed literal/length tree";
      } else if (result != Z_MEM_ERROR) {
        z.msg = "incomplete literal/length tree";
        result = Z_DATA_ERROR;
      }
      return result;
    }
    initWorkArea(288);
    result = huft_build(c2, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);
    if (result != Z_OK || bd[0] === 0 && nl > 257) {
      if (result == Z_DATA_ERROR) {
        z.msg = "oversubscribed distance tree";
      } else if (result == Z_BUF_ERROR) {
        z.msg = "incomplete distance tree";
        result = Z_DATA_ERROR;
      } else if (result != Z_MEM_ERROR) {
        z.msg = "empty distance tree with lengths";
        result = Z_DATA_ERROR;
      }
      return result;
    }
    return Z_OK;
  };
}
__name(InfTree, "InfTree");
InfTree.inflate_trees_fixed = function(bl, bd, tl, td) {
  bl[0] = fixed_bl;
  bd[0] = fixed_bd;
  tl[0] = fixed_tl;
  td[0] = fixed_td;
  return Z_OK;
};
const START = 0;
const LEN = 1;
const LENEXT = 2;
const DIST = 3;
const DISTEXT = 4;
const COPY = 5;
const LIT = 6;
const WASH = 7;
const END = 8;
const BADCODE = 9;
function InfCodes() {
  const that = this;
  let mode2;
  let len = 0;
  let tree;
  let tree_index = 0;
  let need = 0;
  let lit = 0;
  let get2 = 0;
  let dist = 0;
  let lbits = 0;
  let dbits = 0;
  let ltree;
  let ltree_index = 0;
  let dtree;
  let dtree_index = 0;
  function inflate_fast2(bl, bd, tl, tl_index, td, td_index, s, z) {
    let t2;
    let tp;
    let tp_index;
    let e2;
    let b;
    let k;
    let p;
    let n;
    let q;
    let m;
    let ml;
    let md;
    let c;
    let d;
    let r;
    let tp_index_t_3;
    p = z.next_in_index;
    n = z.avail_in;
    b = s.bitb;
    k = s.bitk;
    q = s.write;
    m = q < s.read ? s.read - q - 1 : s.end - q;
    ml = inflate_mask[bl];
    md = inflate_mask[bd];
    do {
      while (k < 20) {
        n--;
        b |= (z.read_byte(p++) & 255) << k;
        k += 8;
      }
      t2 = b & ml;
      tp = tl;
      tp_index = tl_index;
      tp_index_t_3 = (tp_index + t2) * 3;
      if ((e2 = tp[tp_index_t_3]) === 0) {
        b >>= tp[tp_index_t_3 + 1];
        k -= tp[tp_index_t_3 + 1];
        s.win[q++] = /* (byte) */
        tp[tp_index_t_3 + 2];
        m--;
        continue;
      }
      do {
        b >>= tp[tp_index_t_3 + 1];
        k -= tp[tp_index_t_3 + 1];
        if ((e2 & 16) !== 0) {
          e2 &= 15;
          c = tp[tp_index_t_3 + 2] + /* (int) */
          (b & inflate_mask[e2]);
          b >>= e2;
          k -= e2;
          while (k < 15) {
            n--;
            b |= (z.read_byte(p++) & 255) << k;
            k += 8;
          }
          t2 = b & md;
          tp = td;
          tp_index = td_index;
          tp_index_t_3 = (tp_index + t2) * 3;
          e2 = tp[tp_index_t_3];
          do {
            b >>= tp[tp_index_t_3 + 1];
            k -= tp[tp_index_t_3 + 1];
            if ((e2 & 16) !== 0) {
              e2 &= 15;
              while (k < e2) {
                n--;
                b |= (z.read_byte(p++) & 255) << k;
                k += 8;
              }
              d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e2]);
              b >>= e2;
              k -= e2;
              m -= c;
              if (q >= d) {
                r = q - d;
                if (q - r > 0 && 2 > q - r) {
                  s.win[q++] = s.win[r++];
                  s.win[q++] = s.win[r++];
                  c -= 2;
                } else {
                  s.win.set(s.win.subarray(r, r + 2), q);
                  q += 2;
                  r += 2;
                  c -= 2;
                }
              } else {
                r = q - d;
                do {
                  r += s.end;
                } while (r < 0);
                e2 = s.end - r;
                if (c > e2) {
                  c -= e2;
                  if (q - r > 0 && e2 > q - r) {
                    do {
                      s.win[q++] = s.win[r++];
                    } while (--e2 !== 0);
                  } else {
                    s.win.set(s.win.subarray(r, r + e2), q);
                    q += e2;
                    r += e2;
                    e2 = 0;
                  }
                  r = 0;
                }
              }
              if (q - r > 0 && c > q - r) {
                do {
                  s.win[q++] = s.win[r++];
                } while (--c !== 0);
              } else {
                s.win.set(s.win.subarray(r, r + c), q);
                q += c;
                r += c;
                c = 0;
              }
              break;
            } else if ((e2 & 64) === 0) {
              t2 += tp[tp_index_t_3 + 2];
              t2 += b & inflate_mask[e2];
              tp_index_t_3 = (tp_index + t2) * 3;
              e2 = tp[tp_index_t_3];
            } else {
              z.msg = "invalid distance code";
              c = z.avail_in - n;
              c = k >> 3 < c ? k >> 3 : c;
              n += c;
              p -= c;
              k -= c << 3;
              s.bitb = b;
              s.bitk = k;
              z.avail_in = n;
              z.total_in += p - z.next_in_index;
              z.next_in_index = p;
              s.write = q;
              return Z_DATA_ERROR;
            }
          } while (true);
          break;
        }
        if ((e2 & 64) === 0) {
          t2 += tp[tp_index_t_3 + 2];
          t2 += b & inflate_mask[e2];
          tp_index_t_3 = (tp_index + t2) * 3;
          if ((e2 = tp[tp_index_t_3]) === 0) {
            b >>= tp[tp_index_t_3 + 1];
            k -= tp[tp_index_t_3 + 1];
            s.win[q++] = /* (byte) */
            tp[tp_index_t_3 + 2];
            m--;
            break;
          }
        } else if ((e2 & 32) !== 0) {
          c = z.avail_in - n;
          c = k >> 3 < c ? k >> 3 : c;
          n += c;
          p -= c;
          k -= c << 3;
          s.bitb = b;
          s.bitk = k;
          z.avail_in = n;
          z.total_in += p - z.next_in_index;
          z.next_in_index = p;
          s.write = q;
          return Z_STREAM_END;
        } else {
          z.msg = "invalid literal/length code";
          c = z.avail_in - n;
          c = k >> 3 < c ? k >> 3 : c;
          n += c;
          p -= c;
          k -= c << 3;
          s.bitb = b;
          s.bitk = k;
          z.avail_in = n;
          z.total_in += p - z.next_in_index;
          z.next_in_index = p;
          s.write = q;
          return Z_DATA_ERROR;
        }
      } while (true);
    } while (m >= 258 && n >= 10);
    c = z.avail_in - n;
    c = k >> 3 < c ? k >> 3 : c;
    n += c;
    p -= c;
    k -= c << 3;
    s.bitb = b;
    s.bitk = k;
    z.avail_in = n;
    z.total_in += p - z.next_in_index;
    z.next_in_index = p;
    s.write = q;
    return Z_OK;
  }
  __name(inflate_fast2, "inflate_fast");
  that.init = function(bl, bd, tl, tl_index, td, td_index) {
    mode2 = START;
    lbits = /* (byte) */
    bl;
    dbits = /* (byte) */
    bd;
    ltree = tl;
    ltree_index = tl_index;
    dtree = td;
    dtree_index = td_index;
    tree = null;
  };
  that.proc = function(s, z, r) {
    let j;
    let tindex;
    let e2;
    let b = 0;
    let k = 0;
    let p = 0;
    let n;
    let q;
    let m;
    let f;
    p = z.next_in_index;
    n = z.avail_in;
    b = s.bitb;
    k = s.bitk;
    q = s.write;
    m = q < s.read ? s.read - q - 1 : s.end - q;
    while (true) {
      switch (mode2) {
        // waiting for "i:"=input, "o:"=output, "x:"=nothing
        case START:
          if (m >= 258 && n >= 10) {
            s.bitb = b;
            s.bitk = k;
            z.avail_in = n;
            z.total_in += p - z.next_in_index;
            z.next_in_index = p;
            s.write = q;
            r = inflate_fast2(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);
            p = z.next_in_index;
            n = z.avail_in;
            b = s.bitb;
            k = s.bitk;
            q = s.write;
            m = q < s.read ? s.read - q - 1 : s.end - q;
            if (r != Z_OK) {
              mode2 = r == Z_STREAM_END ? WASH : BADCODE;
              break;
            }
          }
          need = lbits;
          tree = ltree;
          tree_index = ltree_index;
          mode2 = LEN;
        /* falls through */
        case LEN:
          j = need;
          while (k < j) {
            if (n !== 0)
              r = Z_OK;
            else {
              s.bitb = b;
              s.bitk = k;
              z.avail_in = n;
              z.total_in += p - z.next_in_index;
              z.next_in_index = p;
              s.write = q;
              return s.inflate_flush(z, r);
            }
            n--;
            b |= (z.read_byte(p++) & 255) << k;
            k += 8;
          }
          tindex = (tree_index + (b & inflate_mask[j])) * 3;
          b >>>= tree[tindex + 1];
          k -= tree[tindex + 1];
          e2 = tree[tindex];
          if (e2 === 0) {
            lit = tree[tindex + 2];
            mode2 = LIT;
            break;
          }
          if ((e2 & 16) !== 0) {
            get2 = e2 & 15;
            len = tree[tindex + 2];
            mode2 = LENEXT;
            break;
          }
          if ((e2 & 64) === 0) {
            need = e2;
            tree_index = tindex / 3 + tree[tindex + 2];
            break;
          }
          if ((e2 & 32) !== 0) {
            mode2 = WASH;
            break;
          }
          mode2 = BADCODE;
          z.msg = "invalid literal/length code";
          r = Z_DATA_ERROR;
          s.bitb = b;
          s.bitk = k;
          z.avail_in = n;
          z.total_in += p - z.next_in_index;
          z.next_in_index = p;
          s.write = q;
          return s.inflate_flush(z, r);
        case LENEXT:
          j = get2;
          while (k < j) {
            if (n !== 0)
              r = Z_OK;
            else {
              s.bitb = b;
              s.bitk = k;
              z.avail_in = n;
              z.total_in += p - z.next_in_index;
              z.next_in_index = p;
              s.write = q;
              return s.inflate_flush(z, r);
            }
            n--;
            b |= (z.read_byte(p++) & 255) << k;
            k += 8;
          }
          len += b & inflate_mask[j];
          b >>= j;
          k -= j;
          need = dbits;
          tree = dtree;
          tree_index = dtree_index;
          mode2 = DIST;
        /* falls through */
        case DIST:
          j = need;
          while (k < j) {
            if (n !== 0)
              r = Z_OK;
            else {
              s.bitb = b;
              s.bitk = k;
              z.avail_in = n;
              z.total_in += p - z.next_in_index;
              z.next_in_index = p;
              s.write = q;
              return s.inflate_flush(z, r);
            }
            n--;
            b |= (z.read_byte(p++) & 255) << k;
            k += 8;
          }
          tindex = (tree_index + (b & inflate_mask[j])) * 3;
          b >>= tree[tindex + 1];
          k -= tree[tindex + 1];
          e2 = tree[tindex];
          if ((e2 & 16) !== 0) {
            get2 = e2 & 15;
            dist = tree[tindex + 2];
            mode2 = DISTEXT;
            break;
          }
          if ((e2 & 64) === 0) {
            need = e2;
            tree_index = tindex / 3 + tree[tindex + 2];
            break;
          }
          mode2 = BADCODE;
          z.msg = "invalid distance code";
          r = Z_DATA_ERROR;
          s.bitb = b;
          s.bitk = k;
          z.avail_in = n;
          z.total_in += p - z.next_in_index;
          z.next_in_index = p;
          s.write = q;
          return s.inflate_flush(z, r);
        case DISTEXT:
          j = get2;
          while (k < j) {
            if (n !== 0)
              r = Z_OK;
            else {
              s.bitb = b;
              s.bitk = k;
              z.avail_in = n;
              z.total_in += p - z.next_in_index;
              z.next_in_index = p;
              s.write = q;
              return s.inflate_flush(z, r);
            }
            n--;
            b |= (z.read_byte(p++) & 255) << k;
            k += 8;
          }
          dist += b & inflate_mask[j];
          b >>= j;
          k -= j;
          mode2 = COPY;
        /* falls through */
        case COPY:
          f = q - dist;
          while (f < 0) {
            f += s.end;
          }
          while (len !== 0) {
            if (m === 0) {
              if (q == s.end && s.read !== 0) {
                q = 0;
                m = q < s.read ? s.read - q - 1 : s.end - q;
              }
              if (m === 0) {
                s.write = q;
                r = s.inflate_flush(z, r);
                q = s.write;
                m = q < s.read ? s.read - q - 1 : s.end - q;
                if (q == s.end && s.read !== 0) {
                  q = 0;
                  m = q < s.read ? s.read - q - 1 : s.end - q;
                }
                if (m === 0) {
                  s.bitb = b;
                  s.bitk = k;
                  z.avail_in = n;
                  z.total_in += p - z.next_in_index;
                  z.next_in_index = p;
                  s.write = q;
                  return s.inflate_flush(z, r);
                }
              }
            }
            s.win[q++] = s.win[f++];
            m--;
            if (f == s.end)
              f = 0;
            len--;
          }
          mode2 = START;
          break;
        case LIT:
          if (m === 0) {
            if (q == s.end && s.read !== 0) {
              q = 0;
              m = q < s.read ? s.read - q - 1 : s.end - q;
            }
            if (m === 0) {
              s.write = q;
              r = s.inflate_flush(z, r);
              q = s.write;
              m = q < s.read ? s.read - q - 1 : s.end - q;
              if (q == s.end && s.read !== 0) {
                q = 0;
                m = q < s.read ? s.read - q - 1 : s.end - q;
              }
              if (m === 0) {
                s.bitb = b;
                s.bitk = k;
                z.avail_in = n;
                z.total_in += p - z.next_in_index;
                z.next_in_index = p;
                s.write = q;
                return s.inflate_flush(z, r);
              }
            }
          }
          r = Z_OK;
          s.win[q++] = /* (byte) */
          lit;
          m--;
          mode2 = START;
          break;
        case WASH:
          if (k > 7) {
            k -= 8;
            n++;
            p--;
          }
          s.write = q;
          r = s.inflate_flush(z, r);
          q = s.write;
          m = q < s.read ? s.read - q - 1 : s.end - q;
          if (s.read != s.write) {
            s.bitb = b;
            s.bitk = k;
            z.avail_in = n;
            z.total_in += p - z.next_in_index;
            z.next_in_index = p;
            s.write = q;
            return s.inflate_flush(z, r);
          }
          mode2 = END;
        /* falls through */
        case END:
          r = Z_STREAM_END;
          s.bitb = b;
          s.bitk = k;
          z.avail_in = n;
          z.total_in += p - z.next_in_index;
          z.next_in_index = p;
          s.write = q;
          return s.inflate_flush(z, r);
        case BADCODE:
          r = Z_DATA_ERROR;
          s.bitb = b;
          s.bitk = k;
          z.avail_in = n;
          z.total_in += p - z.next_in_index;
          z.next_in_index = p;
          s.write = q;
          return s.inflate_flush(z, r);
        default:
          r = Z_STREAM_ERROR;
          s.bitb = b;
          s.bitk = k;
          z.avail_in = n;
          z.total_in += p - z.next_in_index;
          z.next_in_index = p;
          s.write = q;
          return s.inflate_flush(z, r);
      }
    }
  };
  that.free = function() {
  };
}
__name(InfCodes, "InfCodes");
const border = [
  // Order of the bit length code lengths
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15
];
const TYPE = 0;
const LENS = 1;
const STORED = 2;
const TABLE = 3;
const BTREE = 4;
const DTREE = 5;
const CODES = 6;
const DRY = 7;
const DONELOCKS = 8;
const BADBLOCKS = 9;
function InfBlocks(z, w) {
  const that = this;
  let mode2 = TYPE;
  let left = 0;
  let table2 = 0;
  let index = 0;
  let blens;
  const bb = [0];
  const tb = [0];
  const codes = new InfCodes();
  let last = 0;
  let hufts = new Int32Array(MANY * 3);
  const check = 0;
  const inftree = new InfTree();
  that.bitk = 0;
  that.bitb = 0;
  that.win = new Uint8Array(w);
  that.end = w;
  that.read = 0;
  that.write = 0;
  that.reset = function(z2, c) {
    if (c)
      c[0] = check;
    if (mode2 == CODES) {
      codes.free(z2);
    }
    mode2 = TYPE;
    that.bitk = 0;
    that.bitb = 0;
    that.read = that.write = 0;
  };
  that.reset(z, null);
  that.inflate_flush = function(z2, r) {
    let n;
    let p;
    let q;
    p = z2.next_out_index;
    q = that.read;
    n = /* (int) */
    (q <= that.write ? that.write : that.end) - q;
    if (n > z2.avail_out)
      n = z2.avail_out;
    if (n !== 0 && r == Z_BUF_ERROR)
      r = Z_OK;
    z2.avail_out -= n;
    z2.total_out += n;
    z2.next_out.set(that.win.subarray(q, q + n), p);
    p += n;
    q += n;
    if (q == that.end) {
      q = 0;
      if (that.write == that.end)
        that.write = 0;
      n = that.write - q;
      if (n > z2.avail_out)
        n = z2.avail_out;
      if (n !== 0 && r == Z_BUF_ERROR)
        r = Z_OK;
      z2.avail_out -= n;
      z2.total_out += n;
      z2.next_out.set(that.win.subarray(q, q + n), p);
      p += n;
      q += n;
    }
    z2.next_out_index = p;
    that.read = q;
    return r;
  };
  that.proc = function(z2, r) {
    let t2;
    let b;
    let k;
    let p;
    let n;
    let q;
    let m;
    let i;
    p = z2.next_in_index;
    n = z2.avail_in;
    b = that.bitb;
    k = that.bitk;
    q = that.write;
    m = /* (int) */
    q < that.read ? that.read - q - 1 : that.end - q;
    while (true) {
      let bl, bd, tl, td, bl_, bd_, tl_, td_;
      switch (mode2) {
        case TYPE:
          while (k < 3) {
            if (n !== 0) {
              r = Z_OK;
            } else {
              that.bitb = b;
              that.bitk = k;
              z2.avail_in = n;
              z2.total_in += p - z2.next_in_index;
              z2.next_in_index = p;
              that.write = q;
              return that.inflate_flush(z2, r);
            }
            n--;
            b |= (z2.read_byte(p++) & 255) << k;
            k += 8;
          }
          t2 = /* (int) */
          b & 7;
          last = t2 & 1;
          switch (t2 >>> 1) {
            case 0:
              b >>>= 3;
              k -= 3;
              t2 = k & 7;
              b >>>= t2;
              k -= t2;
              mode2 = LENS;
              break;
            case 1:
              bl = [];
              bd = [];
              tl = [[]];
              td = [[]];
              InfTree.inflate_trees_fixed(bl, bd, tl, td);
              codes.init(bl[0], bd[0], tl[0], 0, td[0], 0);
              b >>>= 3;
              k -= 3;
              mode2 = CODES;
              break;
            case 2:
              b >>>= 3;
              k -= 3;
              mode2 = TABLE;
              break;
            case 3:
              b >>>= 3;
              k -= 3;
              mode2 = BADBLOCKS;
              z2.msg = "invalid block type";
              r = Z_DATA_ERROR;
              that.bitb = b;
              that.bitk = k;
              z2.avail_in = n;
              z2.total_in += p - z2.next_in_index;
              z2.next_in_index = p;
              that.write = q;
              return that.inflate_flush(z2, r);
          }
          break;
        case LENS:
          while (k < 32) {
            if (n !== 0) {
              r = Z_OK;
            } else {
              that.bitb = b;
              that.bitk = k;
              z2.avail_in = n;
              z2.total_in += p - z2.next_in_index;
              z2.next_in_index = p;
              that.write = q;
              return that.inflate_flush(z2, r);
            }
            n--;
            b |= (z2.read_byte(p++) & 255) << k;
            k += 8;
          }
          if ((~b >>> 16 & 65535) != (b & 65535)) {
            mode2 = BADBLOCKS;
            z2.msg = "invalid stored block lengths";
            r = Z_DATA_ERROR;
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
          }
          left = b & 65535;
          b = k = 0;
          mode2 = left !== 0 ? STORED : last !== 0 ? DRY : TYPE;
          break;
        case STORED:
          if (n === 0) {
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
          }
          if (m === 0) {
            if (q == that.end && that.read !== 0) {
              q = 0;
              m = /* (int) */
              q < that.read ? that.read - q - 1 : that.end - q;
            }
            if (m === 0) {
              that.write = q;
              r = that.inflate_flush(z2, r);
              q = that.write;
              m = /* (int) */
              q < that.read ? that.read - q - 1 : that.end - q;
              if (q == that.end && that.read !== 0) {
                q = 0;
                m = /* (int) */
                q < that.read ? that.read - q - 1 : that.end - q;
              }
              if (m === 0) {
                that.bitb = b;
                that.bitk = k;
                z2.avail_in = n;
                z2.total_in += p - z2.next_in_index;
                z2.next_in_index = p;
                that.write = q;
                return that.inflate_flush(z2, r);
              }
            }
          }
          r = Z_OK;
          t2 = left;
          if (t2 > n)
            t2 = n;
          if (t2 > m)
            t2 = m;
          that.win.set(z2.read_buf(p, t2), q);
          p += t2;
          n -= t2;
          q += t2;
          m -= t2;
          if ((left -= t2) !== 0)
            break;
          mode2 = last !== 0 ? DRY : TYPE;
          break;
        case TABLE:
          while (k < 14) {
            if (n !== 0) {
              r = Z_OK;
            } else {
              that.bitb = b;
              that.bitk = k;
              z2.avail_in = n;
              z2.total_in += p - z2.next_in_index;
              z2.next_in_index = p;
              that.write = q;
              return that.inflate_flush(z2, r);
            }
            n--;
            b |= (z2.read_byte(p++) & 255) << k;
            k += 8;
          }
          table2 = t2 = b & 16383;
          if ((t2 & 31) > 29 || (t2 >> 5 & 31) > 29) {
            mode2 = BADBLOCKS;
            z2.msg = "too many length or distance symbols";
            r = Z_DATA_ERROR;
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
          }
          t2 = 258 + (t2 & 31) + (t2 >> 5 & 31);
          if (!blens || blens.length < t2) {
            blens = [];
          } else {
            for (i = 0; i < t2; i++) {
              blens[i] = 0;
            }
          }
          b >>>= 14;
          k -= 14;
          index = 0;
          mode2 = BTREE;
        /* falls through */
        case BTREE:
          while (index < 4 + (table2 >>> 10)) {
            while (k < 3) {
              if (n !== 0) {
                r = Z_OK;
              } else {
                that.bitb = b;
                that.bitk = k;
                z2.avail_in = n;
                z2.total_in += p - z2.next_in_index;
                z2.next_in_index = p;
                that.write = q;
                return that.inflate_flush(z2, r);
              }
              n--;
              b |= (z2.read_byte(p++) & 255) << k;
              k += 8;
            }
            blens[border[index++]] = b & 7;
            b >>>= 3;
            k -= 3;
          }
          while (index < 19) {
            blens[border[index++]] = 0;
          }
          bb[0] = 7;
          t2 = inftree.inflate_trees_bits(blens, bb, tb, hufts, z2);
          if (t2 != Z_OK) {
            r = t2;
            if (r == Z_DATA_ERROR) {
              blens = null;
              mode2 = BADBLOCKS;
            }
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
          }
          index = 0;
          mode2 = DTREE;
        /* falls through */
        case DTREE:
          while (true) {
            t2 = table2;
            if (index >= 258 + (t2 & 31) + (t2 >> 5 & 31)) {
              break;
            }
            let j, c;
            t2 = bb[0];
            while (k < t2) {
              if (n !== 0) {
                r = Z_OK;
              } else {
                that.bitb = b;
                that.bitk = k;
                z2.avail_in = n;
                z2.total_in += p - z2.next_in_index;
                z2.next_in_index = p;
                that.write = q;
                return that.inflate_flush(z2, r);
              }
              n--;
              b |= (z2.read_byte(p++) & 255) << k;
              k += 8;
            }
            t2 = hufts[(tb[0] + (b & inflate_mask[t2])) * 3 + 1];
            c = hufts[(tb[0] + (b & inflate_mask[t2])) * 3 + 2];
            if (c < 16) {
              b >>>= t2;
              k -= t2;
              blens[index++] = c;
            } else {
              i = c == 18 ? 7 : c - 14;
              j = c == 18 ? 11 : 3;
              while (k < t2 + i) {
                if (n !== 0) {
                  r = Z_OK;
                } else {
                  that.bitb = b;
                  that.bitk = k;
                  z2.avail_in = n;
                  z2.total_in += p - z2.next_in_index;
                  z2.next_in_index = p;
                  that.write = q;
                  return that.inflate_flush(z2, r);
                }
                n--;
                b |= (z2.read_byte(p++) & 255) << k;
                k += 8;
              }
              b >>>= t2;
              k -= t2;
              j += b & inflate_mask[i];
              b >>>= i;
              k -= i;
              i = index;
              t2 = table2;
              if (i + j > 258 + (t2 & 31) + (t2 >> 5 & 31) || c == 16 && i < 1) {
                blens = null;
                mode2 = BADBLOCKS;
                z2.msg = "invalid bit length repeat";
                r = Z_DATA_ERROR;
                that.bitb = b;
                that.bitk = k;
                z2.avail_in = n;
                z2.total_in += p - z2.next_in_index;
                z2.next_in_index = p;
                that.write = q;
                return that.inflate_flush(z2, r);
              }
              c = c == 16 ? blens[i - 1] : 0;
              do {
                blens[i++] = c;
              } while (--j !== 0);
              index = i;
            }
          }
          tb[0] = -1;
          bl_ = [];
          bd_ = [];
          tl_ = [];
          td_ = [];
          bl_[0] = 9;
          bd_[0] = 6;
          t2 = table2;
          t2 = inftree.inflate_trees_dynamic(257 + (t2 & 31), 1 + (t2 >> 5 & 31), blens, bl_, bd_, tl_, td_, hufts, z2);
          if (t2 != Z_OK) {
            if (t2 == Z_DATA_ERROR) {
              blens = null;
              mode2 = BADBLOCKS;
            }
            r = t2;
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
          }
          codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);
          mode2 = CODES;
        /* falls through */
        case CODES:
          that.bitb = b;
          that.bitk = k;
          z2.avail_in = n;
          z2.total_in += p - z2.next_in_index;
          z2.next_in_index = p;
          that.write = q;
          if ((r = codes.proc(that, z2, r)) != Z_STREAM_END) {
            return that.inflate_flush(z2, r);
          }
          r = Z_OK;
          codes.free(z2);
          p = z2.next_in_index;
          n = z2.avail_in;
          b = that.bitb;
          k = that.bitk;
          q = that.write;
          m = /* (int) */
          q < that.read ? that.read - q - 1 : that.end - q;
          if (last === 0) {
            mode2 = TYPE;
            break;
          }
          mode2 = DRY;
        /* falls through */
        case DRY:
          that.write = q;
          r = that.inflate_flush(z2, r);
          q = that.write;
          m = /* (int) */
          q < that.read ? that.read - q - 1 : that.end - q;
          if (that.read != that.write) {
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
          }
          mode2 = DONELOCKS;
        /* falls through */
        case DONELOCKS:
          r = Z_STREAM_END;
          that.bitb = b;
          that.bitk = k;
          z2.avail_in = n;
          z2.total_in += p - z2.next_in_index;
          z2.next_in_index = p;
          that.write = q;
          return that.inflate_flush(z2, r);
        case BADBLOCKS:
          r = Z_DATA_ERROR;
          that.bitb = b;
          that.bitk = k;
          z2.avail_in = n;
          z2.total_in += p - z2.next_in_index;
          z2.next_in_index = p;
          that.write = q;
          return that.inflate_flush(z2, r);
        default:
          r = Z_STREAM_ERROR;
          that.bitb = b;
          that.bitk = k;
          z2.avail_in = n;
          z2.total_in += p - z2.next_in_index;
          z2.next_in_index = p;
          that.write = q;
          return that.inflate_flush(z2, r);
      }
    }
  };
  that.free = function(z2) {
    that.reset(z2, null);
    that.win = null;
    hufts = null;
  };
  that.set_dictionary = function(d, start, n) {
    that.win.set(d.subarray(start, start + n), 0);
    that.read = that.write = n;
  };
  that.sync_point = function() {
    return mode2 == LENS ? 1 : 0;
  };
}
__name(InfBlocks, "InfBlocks");
const PRESET_DICT = 32;
const Z_DEFLATED = 8;
const METHOD = 0;
const FLAG = 1;
const DICT4 = 2;
const DICT3 = 3;
const DICT2 = 4;
const DICT1 = 5;
const DICT0 = 6;
const BLOCKS = 7;
const DONE = 12;
const BAD = 13;
const mark = [0, 0, 255, 255];
function Inflate() {
  const that = this;
  that.mode = 0;
  that.method = 0;
  that.was = [0];
  that.need = 0;
  that.marker = 0;
  that.wbits = 0;
  function inflateReset3(z) {
    if (!z || !z.istate)
      return Z_STREAM_ERROR;
    z.total_in = z.total_out = 0;
    z.msg = null;
    z.istate.mode = BLOCKS;
    z.istate.blocks.reset(z, null);
    return Z_OK;
  }
  __name(inflateReset3, "inflateReset");
  that.inflateEnd = function(z) {
    if (that.blocks)
      that.blocks.free(z);
    that.blocks = null;
    return Z_OK;
  };
  that.inflateInit = function(z, w) {
    z.msg = null;
    that.blocks = null;
    if (w < 8 || w > 15) {
      that.inflateEnd(z);
      return Z_STREAM_ERROR;
    }
    that.wbits = w;
    z.istate.blocks = new InfBlocks(z, 1 << w);
    inflateReset3(z);
    return Z_OK;
  };
  that.inflate = function(z, f) {
    let r;
    let b;
    if (!z || !z.istate || !z.next_in)
      return Z_STREAM_ERROR;
    const istate = z.istate;
    f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
    r = Z_BUF_ERROR;
    while (true) {
      switch (istate.mode) {
        case METHOD:
          if (z.avail_in === 0)
            return r;
          r = f;
          z.avail_in--;
          z.total_in++;
          if (((istate.method = z.read_byte(z.next_in_index++)) & 15) != Z_DEFLATED) {
            istate.mode = BAD;
            z.msg = "unknown compression method";
            istate.marker = 5;
            break;
          }
          if ((istate.method >> 4) + 8 > istate.wbits) {
            istate.mode = BAD;
            z.msg = "invalid win size";
            istate.marker = 5;
            break;
          }
          istate.mode = FLAG;
        /* falls through */
        case FLAG:
          if (z.avail_in === 0)
            return r;
          r = f;
          z.avail_in--;
          z.total_in++;
          b = z.read_byte(z.next_in_index++) & 255;
          if (((istate.method << 8) + b) % 31 !== 0) {
            istate.mode = BAD;
            z.msg = "incorrect header check";
            istate.marker = 5;
            break;
          }
          if ((b & PRESET_DICT) === 0) {
            istate.mode = BLOCKS;
            break;
          }
          istate.mode = DICT4;
        /* falls through */
        case DICT4:
          if (z.avail_in === 0)
            return r;
          r = f;
          z.avail_in--;
          z.total_in++;
          istate.need = (z.read_byte(z.next_in_index++) & 255) << 24 & 4278190080;
          istate.mode = DICT3;
        /* falls through */
        case DICT3:
          if (z.avail_in === 0)
            return r;
          r = f;
          z.avail_in--;
          z.total_in++;
          istate.need += (z.read_byte(z.next_in_index++) & 255) << 16 & 16711680;
          istate.mode = DICT2;
        /* falls through */
        case DICT2:
          if (z.avail_in === 0)
            return r;
          r = f;
          z.avail_in--;
          z.total_in++;
          istate.need += (z.read_byte(z.next_in_index++) & 255) << 8 & 65280;
          istate.mode = DICT1;
        /* falls through */
        case DICT1:
          if (z.avail_in === 0)
            return r;
          r = f;
          z.avail_in--;
          z.total_in++;
          istate.need += z.read_byte(z.next_in_index++) & 255;
          istate.mode = DICT0;
          return Z_NEED_DICT;
        case DICT0:
          istate.mode = BAD;
          z.msg = "need dictionary";
          istate.marker = 0;
          return Z_STREAM_ERROR;
        case BLOCKS:
          r = istate.blocks.proc(z, r);
          if (r == Z_DATA_ERROR) {
            istate.mode = BAD;
            istate.marker = 0;
            break;
          }
          if (r == Z_OK) {
            r = f;
          }
          if (r != Z_STREAM_END) {
            return r;
          }
          r = f;
          istate.blocks.reset(z, istate.was);
          istate.mode = DONE;
        /* falls through */
        case DONE:
          z.avail_in = 0;
          return Z_STREAM_END;
        case BAD:
          return Z_DATA_ERROR;
        default:
          return Z_STREAM_ERROR;
      }
    }
  };
  that.inflateSetDictionary = function(z, dictionary, dictLength) {
    let index = 0, length = dictLength;
    if (!z || !z.istate || z.istate.mode != DICT0)
      return Z_STREAM_ERROR;
    const istate = z.istate;
    if (length >= 1 << istate.wbits) {
      length = (1 << istate.wbits) - 1;
      index = dictLength - length;
    }
    istate.blocks.set_dictionary(dictionary, index, length);
    istate.mode = BLOCKS;
    return Z_OK;
  };
  that.inflateSync = function(z) {
    let n;
    let p;
    let m;
    let r, w;
    if (!z || !z.istate)
      return Z_STREAM_ERROR;
    const istate = z.istate;
    if (istate.mode != BAD) {
      istate.mode = BAD;
      istate.marker = 0;
    }
    if ((n = z.avail_in) === 0)
      return Z_BUF_ERROR;
    p = z.next_in_index;
    m = istate.marker;
    while (n !== 0 && m < 4) {
      if (z.read_byte(p) == mark[m]) {
        m++;
      } else if (z.read_byte(p) !== 0) {
        m = 0;
      } else {
        m = 4 - m;
      }
      p++;
      n--;
    }
    z.total_in += p - z.next_in_index;
    z.next_in_index = p;
    z.avail_in = n;
    istate.marker = m;
    if (m != 4) {
      return Z_DATA_ERROR;
    }
    r = z.total_in;
    w = z.total_out;
    inflateReset3(z);
    z.total_in = r;
    z.total_out = w;
    istate.mode = BLOCKS;
    return Z_OK;
  };
  that.inflateSyncPoint = function(z) {
    if (!z || !z.istate || !z.istate.blocks)
      return Z_STREAM_ERROR;
    return z.istate.blocks.sync_point();
  };
}
__name(Inflate, "Inflate");
function ZStream() {
}
__name(ZStream, "ZStream");
ZStream.prototype = {
  inflateInit(bits) {
    const that = this;
    that.istate = new Inflate();
    if (!bits)
      bits = MAX_BITS;
    return that.istate.inflateInit(that, bits);
  },
  inflate(f) {
    const that = this;
    if (!that.istate)
      return Z_STREAM_ERROR;
    return that.istate.inflate(that, f);
  },
  inflateEnd() {
    const that = this;
    if (!that.istate)
      return Z_STREAM_ERROR;
    const ret = that.istate.inflateEnd(that);
    that.istate = null;
    return ret;
  },
  inflateSync() {
    const that = this;
    if (!that.istate)
      return Z_STREAM_ERROR;
    return that.istate.inflateSync(that);
  },
  inflateSetDictionary(dictionary, dictLength) {
    const that = this;
    if (!that.istate)
      return Z_STREAM_ERROR;
    return that.istate.inflateSetDictionary(that, dictionary, dictLength);
  },
  read_byte(start) {
    const that = this;
    return that.next_in[start];
  },
  read_buf(start, size) {
    const that = this;
    return that.next_in.subarray(start, start + size);
  }
};
function ZipInflate(options) {
  const that = this;
  const z = new ZStream();
  const bufsize = options && options.chunkSize ? Math.floor(options.chunkSize * 2) : 128 * 1024;
  const flush = Z_NO_FLUSH;
  const buf = new Uint8Array(bufsize);
  let nomoreinput = false;
  z.inflateInit();
  z.next_out = buf;
  that.append = function(data, onprogress) {
    const buffers = [];
    let err2, array2, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
    if (data.length === 0)
      return;
    z.next_in_index = 0;
    z.next_in = data;
    z.avail_in = data.length;
    do {
      z.next_out_index = 0;
      z.avail_out = bufsize;
      if (z.avail_in === 0 && !nomoreinput) {
        z.next_in_index = 0;
        nomoreinput = true;
      }
      err2 = z.inflate(flush);
      if (nomoreinput && err2 === Z_BUF_ERROR) {
        if (z.avail_in !== 0)
          throw new Error("inflating: bad input");
      } else if (err2 !== Z_OK && err2 !== Z_STREAM_END)
        throw new Error("inflating: " + z.msg);
      if ((nomoreinput || err2 === Z_STREAM_END) && z.avail_in === data.length)
        throw new Error("inflating: bad input");
      if (z.next_out_index)
        if (z.next_out_index === bufsize)
          buffers.push(new Uint8Array(buf));
        else
          buffers.push(buf.subarray(0, z.next_out_index));
      bufferSize += z.next_out_index;
      if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
        onprogress(z.next_in_index);
        lastIndex = z.next_in_index;
      }
    } while (z.avail_in > 0 || z.avail_out === 0);
    if (buffers.length > 1) {
      array2 = new Uint8Array(bufferSize);
      buffers.forEach(function(chunk) {
        array2.set(chunk, bufferIndex);
        bufferIndex += chunk.length;
      });
    } else {
      array2 = buffers[0] ? new Uint8Array(buffers[0]) : new Uint8Array();
    }
    return array2;
  };
  that.flush = function() {
    z.inflateEnd();
  };
}
__name(ZipInflate, "ZipInflate");
const MAX_32_BITS = 4294967295;
const MAX_16_BITS = 65535;
const COMPRESSION_METHOD_DEFLATE = 8;
const COMPRESSION_METHOD_STORE = 0;
const COMPRESSION_METHOD_AES = 99;
const LOCAL_FILE_HEADER_SIGNATURE = 67324752;
const SPLIT_ZIP_FILE_SIGNATURE = 134695760;
const DATA_DESCRIPTOR_RECORD_SIGNATURE = SPLIT_ZIP_FILE_SIGNATURE;
const CENTRAL_FILE_HEADER_SIGNATURE = 33639248;
const END_OF_CENTRAL_DIR_SIGNATURE = 101010256;
const ZIP64_END_OF_CENTRAL_DIR_SIGNATURE = 101075792;
const ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE = 117853008;
const END_OF_CENTRAL_DIR_LENGTH = 22;
const ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH = 20;
const ZIP64_END_OF_CENTRAL_DIR_LENGTH = 56;
const ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH = END_OF_CENTRAL_DIR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LENGTH;
const EXTRAFIELD_TYPE_ZIP64 = 1;
const EXTRAFIELD_TYPE_AES = 39169;
const EXTRAFIELD_TYPE_NTFS = 10;
const EXTRAFIELD_TYPE_NTFS_TAG1 = 1;
const EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP = 21589;
const EXTRAFIELD_TYPE_UNICODE_PATH = 28789;
const EXTRAFIELD_TYPE_UNICODE_COMMENT = 25461;
const EXTRAFIELD_TYPE_USDZ = 6534;
const BITFLAG_ENCRYPTED = 1;
const BITFLAG_LEVEL = 6;
const BITFLAG_DATA_DESCRIPTOR = 8;
const BITFLAG_LANG_ENCODING_FLAG = 2048;
const FILE_ATTR_MSDOS_DIR_MASK = 16;
const VERSION_DEFLATE = 20;
const VERSION_ZIP64 = 45;
const VERSION_AES = 51;
const DIRECTORY_SIGNATURE = "/";
const MAX_DATE = new Date(2107, 11, 31);
const MIN_DATE = new Date(1980, 0, 1);
const UNDEFINED_VALUE = void 0;
const UNDEFINED_TYPE = "undefined";
const FUNCTION_TYPE = "function";
const _StreamAdapter = class _StreamAdapter {
  constructor(Codec) {
    return class extends TransformStream {
      constructor(_format2, options) {
        const codec2 = new Codec(options);
        super({
          transform(chunk, controller) {
            controller.enqueue(codec2.append(chunk));
          },
          flush(controller) {
            const chunk = codec2.flush();
            if (chunk) {
              controller.enqueue(chunk);
            }
          }
        });
      }
    };
  }
};
__name(_StreamAdapter, "StreamAdapter");
let StreamAdapter = _StreamAdapter;
const MINIMUM_CHUNK_SIZE = 64;
let maxWorkers = 2;
try {
  if (typeof navigator != UNDEFINED_TYPE && navigator.hardwareConcurrency) {
    maxWorkers = navigator.hardwareConcurrency;
  }
} catch (_error) {
}
const DEFAULT_CONFIGURATION = {
  chunkSize: 512 * 1024,
  maxWorkers,
  terminateWorkerTimeout: 5e3,
  useWebWorkers: true,
  useCompressionStream: true,
  workerScripts: UNDEFINED_VALUE,
  CompressionStreamNative: typeof CompressionStream != UNDEFINED_TYPE && CompressionStream,
  DecompressionStreamNative: typeof DecompressionStream != UNDEFINED_TYPE && DecompressionStream
};
const config = Object.assign({}, DEFAULT_CONFIGURATION);
function getConfiguration() {
  return config;
}
__name(getConfiguration, "getConfiguration");
function getChunkSize(config2) {
  return Math.max(config2.chunkSize, MINIMUM_CHUNK_SIZE);
}
__name(getChunkSize, "getChunkSize");
function configure(configuration) {
  const {
    baseURL: baseURL2,
    chunkSize,
    maxWorkers: maxWorkers2,
    terminateWorkerTimeout,
    useCompressionStream,
    useWebWorkers,
    Deflate: Deflate2,
    Inflate: Inflate2,
    CompressionStream: CompressionStream2,
    DecompressionStream: DecompressionStream2,
    workerScripts
  } = configuration;
  setIfDefined("baseURL", baseURL2);
  setIfDefined("chunkSize", chunkSize);
  setIfDefined("maxWorkers", maxWorkers2);
  setIfDefined("terminateWorkerTimeout", terminateWorkerTimeout);
  setIfDefined("useCompressionStream", useCompressionStream);
  setIfDefined("useWebWorkers", useWebWorkers);
  if (Deflate2) {
    config.CompressionStream = new StreamAdapter(Deflate2);
  }
  if (Inflate2) {
    config.DecompressionStream = new StreamAdapter(Inflate2);
  }
  setIfDefined("CompressionStream", CompressionStream2);
  setIfDefined("DecompressionStream", DecompressionStream2);
  if (workerScripts !== UNDEFINED_VALUE) {
    const { deflate: deflate2, inflate: inflate2 } = workerScripts;
    if (deflate2 || inflate2) {
      if (!config.workerScripts) {
        config.workerScripts = {};
      }
    }
    if (deflate2) {
      if (!Array.isArray(deflate2)) {
        throw new Error("workerScripts.deflate must be an array");
      }
      config.workerScripts.deflate = deflate2;
    }
    if (inflate2) {
      if (!Array.isArray(inflate2)) {
        throw new Error("workerScripts.inflate must be an array");
      }
      config.workerScripts.inflate = inflate2;
    }
  }
}
__name(configure, "configure");
function setIfDefined(propertyName, propertyValue) {
  if (propertyValue !== UNDEFINED_VALUE) {
    config[propertyName] = propertyValue;
  }
}
__name(setIfDefined, "setIfDefined");
const table$1 = {
  "application": {
    "andrew-inset": "ez",
    "annodex": "anx",
    "atom+xml": "atom",
    "atomcat+xml": "atomcat",
    "atomserv+xml": "atomsrv",
    "bbolin": "lin",
    "cu-seeme": "cu",
    "davmount+xml": "davmount",
    "dsptype": "tsp",
    "ecmascript": [
      "es",
      "ecma"
    ],
    "futuresplash": "spl",
    "hta": "hta",
    "java-archive": "jar",
    "java-serialized-object": "ser",
    "java-vm": "class",
    "m3g": "m3g",
    "mac-binhex40": "hqx",
    "mathematica": [
      "nb",
      "ma",
      "mb"
    ],
    "msaccess": "mdb",
    "msword": [
      "doc",
      "dot",
      "wiz"
    ],
    "mxf": "mxf",
    "oda": "oda",
    "ogg": "ogx",
    "pdf": "pdf",
    "pgp-keys": "key",
    "pgp-signature": [
      "asc",
      "sig"
    ],
    "pics-rules": "prf",
    "postscript": [
      "ps",
      "ai",
      "eps",
      "epsi",
      "epsf",
      "eps2",
      "eps3"
    ],
    "rar": "rar",
    "rdf+xml": "rdf",
    "rss+xml": "rss",
    "rtf": "rtf",
    "xhtml+xml": [
      "xhtml",
      "xht"
    ],
    "xml": [
      "xml",
      "xsl",
      "xsd",
      "xpdl"
    ],
    "xspf+xml": "xspf",
    "zip": "zip",
    "vnd.android.package-archive": "apk",
    "vnd.cinderella": "cdy",
    "vnd.google-earth.kml+xml": "kml",
    "vnd.google-earth.kmz": "kmz",
    "vnd.mozilla.xul+xml": "xul",
    "vnd.ms-excel": [
      "xls",
      "xlb",
      "xlt",
      "xlm",
      "xla",
      "xlc",
      "xlw"
    ],
    "vnd.ms-pki.seccat": "cat",
    "vnd.ms-pki.stl": "stl",
    "vnd.ms-powerpoint": [
      "ppt",
      "pps",
      "pot",
      "ppa",
      "pwz"
    ],
    "vnd.oasis.opendocument.chart": "odc",
    "vnd.oasis.opendocument.database": "odb",
    "vnd.oasis.opendocument.formula": "odf",
    "vnd.oasis.opendocument.graphics": "odg",
    "vnd.oasis.opendocument.graphics-template": "otg",
    "vnd.oasis.opendocument.image": "odi",
    "vnd.oasis.opendocument.presentation": "odp",
    "vnd.oasis.opendocument.presentation-template": "otp",
    "vnd.oasis.opendocument.spreadsheet": "ods",
    "vnd.oasis.opendocument.spreadsheet-template": "ots",
    "vnd.oasis.opendocument.text": "odt",
    "vnd.oasis.opendocument.text-master": [
      "odm",
      "otm"
    ],
    "vnd.oasis.opendocument.text-template": "ott",
    "vnd.oasis.opendocument.text-web": "oth",
    "vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
    "vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
    "vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
    "vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
    "vnd.openxmlformats-officedocument.presentationml.template": "potx",
    "vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
    "vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
    "vnd.smaf": "mmf",
    "vnd.stardivision.calc": "sdc",
    "vnd.stardivision.chart": "sds",
    "vnd.stardivision.draw": "sda",
    "vnd.stardivision.impress": "sdd",
    "vnd.stardivision.math": [
      "sdf",
      "smf"
    ],
    "vnd.stardivision.writer": [
      "sdw",
      "vor"
    ],
    "vnd.stardivision.writer-global": "sgl",
    "vnd.sun.xml.calc": "sxc",
    "vnd.sun.xml.calc.template": "stc",
    "vnd.sun.xml.draw": "sxd",
    "vnd.sun.xml.draw.template": "std",
    "vnd.sun.xml.impress": "sxi",
    "vnd.sun.xml.impress.template": "sti",
    "vnd.sun.xml.math": "sxm",
    "vnd.sun.xml.writer": "sxw",
    "vnd.sun.xml.writer.global": "sxg",
    "vnd.sun.xml.writer.template": "stw",
    "vnd.symbian.install": [
      "sis",
      "sisx"
    ],
    "vnd.visio": [
      "vsd",
      "vst",
      "vss",
      "vsw",
      "vsdx",
      "vssx",
      "vstx",
      "vssm",
      "vstm"
    ],
    "vnd.wap.wbxml": "wbxml",
    "vnd.wap.wmlc": "wmlc",
    "vnd.wap.wmlscriptc": "wmlsc",
    "vnd.wordperfect": "wpd",
    "vnd.wordperfect5.1": "wp5",
    "x-123": "wk",
    "x-7z-compressed": "7z",
    "x-abiword": "abw",
    "x-apple-diskimage": "dmg",
    "x-bcpio": "bcpio",
    "x-bittorrent": "torrent",
    "x-cbr": [
      "cbr",
      "cba",
      "cbt",
      "cb7"
    ],
    "x-cbz": "cbz",
    "x-cdf": [
      "cdf",
      "cda"
    ],
    "x-cdlink": "vcd",
    "x-chess-pgn": "pgn",
    "x-cpio": "cpio",
    "x-csh": "csh",
    "x-director": [
      "dir",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ],
    "x-dms": "dms",
    "x-doom": "wad",
    "x-dvi": "dvi",
    "x-httpd-eruby": "rhtml",
    "x-font": "pcf.Z",
    "x-freemind": "mm",
    "x-gnumeric": "gnumeric",
    "x-go-sgf": "sgf",
    "x-graphing-calculator": "gcf",
    "x-gtar": [
      "gtar",
      "taz"
    ],
    "x-hdf": "hdf",
    "x-httpd-php": [
      "phtml",
      "pht",
      "php"
    ],
    "x-httpd-php-source": "phps",
    "x-httpd-php3": "php3",
    "x-httpd-php3-preprocessed": "php3p",
    "x-httpd-php4": "php4",
    "x-httpd-php5": "php5",
    "x-ica": "ica",
    "x-info": "info",
    "x-internet-signup": [
      "ins",
      "isp"
    ],
    "x-iphone": "iii",
    "x-iso9660-image": "iso",
    "x-java-jnlp-file": "jnlp",
    "x-jmol": "jmz",
    "x-killustrator": "kil",
    "x-latex": "latex",
    "x-lyx": "lyx",
    "x-lzx": "lzx",
    "x-maker": [
      "frm",
      "fb",
      "fbdoc"
    ],
    "x-ms-wmd": "wmd",
    "x-msdos-program": [
      "com",
      "exe",
      "bat",
      "dll"
    ],
    "x-netcdf": [
      "nc"
    ],
    "x-ns-proxy-autoconfig": [
      "pac",
      "dat"
    ],
    "x-nwc": "nwc",
    "x-object": "o",
    "x-oz-application": "oza",
    "x-pkcs7-certreqresp": "p7r",
    "x-python-code": [
      "pyc",
      "pyo"
    ],
    "x-qgis": [
      "qgs",
      "shp",
      "shx"
    ],
    "x-quicktimeplayer": "qtl",
    "x-redhat-package-manager": [
      "rpm",
      "rpa"
    ],
    "x-ruby": "rb",
    "x-sh": "sh",
    "x-shar": "shar",
    "x-shockwave-flash": [
      "swf",
      "swfl"
    ],
    "x-silverlight": "scr",
    "x-stuffit": "sit",
    "x-sv4cpio": "sv4cpio",
    "x-sv4crc": "sv4crc",
    "x-tar": "tar",
    "x-tex-gf": "gf",
    "x-tex-pk": "pk",
    "x-texinfo": [
      "texinfo",
      "texi"
    ],
    "x-trash": [
      "~",
      "%",
      "bak",
      "old",
      "sik"
    ],
    "x-ustar": "ustar",
    "x-wais-source": "src",
    "x-wingz": "wz",
    "x-x509-ca-cert": [
      "crt",
      "der",
      "cer"
    ],
    "x-xcf": "xcf",
    "x-xfig": "fig",
    "x-xpinstall": "xpi",
    "applixware": "aw",
    "atomsvc+xml": "atomsvc",
    "ccxml+xml": "ccxml",
    "cdmi-capability": "cdmia",
    "cdmi-container": "cdmic",
    "cdmi-domain": "cdmid",
    "cdmi-object": "cdmio",
    "cdmi-queue": "cdmiq",
    "docbook+xml": "dbk",
    "dssc+der": "dssc",
    "dssc+xml": "xdssc",
    "emma+xml": "emma",
    "epub+zip": "epub",
    "exi": "exi",
    "font-tdpfr": "pfr",
    "gml+xml": "gml",
    "gpx+xml": "gpx",
    "gxf": "gxf",
    "hyperstudio": "stk",
    "inkml+xml": [
      "ink",
      "inkml"
    ],
    "ipfix": "ipfix",
    "jsonml+json": "jsonml",
    "lost+xml": "lostxml",
    "mads+xml": "mads",
    "marc": "mrc",
    "marcxml+xml": "mrcx",
    "mathml+xml": [
      "mathml",
      "mml"
    ],
    "mbox": "mbox",
    "mediaservercontrol+xml": "mscml",
    "metalink+xml": "metalink",
    "metalink4+xml": "meta4",
    "mets+xml": "mets",
    "mods+xml": "mods",
    "mp21": [
      "m21",
      "mp21"
    ],
    "mp4": "mp4s",
    "oebps-package+xml": "opf",
    "omdoc+xml": "omdoc",
    "onenote": [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ],
    "oxps": "oxps",
    "patch-ops-error+xml": "xer",
    "pgp-encrypted": "pgp",
    "pkcs10": "p10",
    "pkcs7-mime": [
      "p7m",
      "p7c"
    ],
    "pkcs7-signature": "p7s",
    "pkcs8": "p8",
    "pkix-attr-cert": "ac",
    "pkix-crl": "crl",
    "pkix-pkipath": "pkipath",
    "pkixcmp": "pki",
    "pls+xml": "pls",
    "prs.cww": "cww",
    "pskc+xml": "pskcxml",
    "reginfo+xml": "rif",
    "relax-ng-compact-syntax": "rnc",
    "resource-lists+xml": "rl",
    "resource-lists-diff+xml": "rld",
    "rls-services+xml": "rs",
    "rpki-ghostbusters": "gbr",
    "rpki-manifest": "mft",
    "rpki-roa": "roa",
    "rsd+xml": "rsd",
    "sbml+xml": "sbml",
    "scvp-cv-request": "scq",
    "scvp-cv-response": "scs",
    "scvp-vp-request": "spq",
    "scvp-vp-response": "spp",
    "sdp": "sdp",
    "set-payment-initiation": "setpay",
    "set-registration-initiation": "setreg",
    "shf+xml": "shf",
    "sparql-query": "rq",
    "sparql-results+xml": "srx",
    "srgs": "gram",
    "srgs+xml": "grxml",
    "sru+xml": "sru",
    "ssdl+xml": "ssdl",
    "ssml+xml": "ssml",
    "tei+xml": [
      "tei",
      "teicorpus"
    ],
    "thraud+xml": "tfi",
    "timestamped-data": "tsd",
    "vnd.3gpp.pic-bw-large": "plb",
    "vnd.3gpp.pic-bw-small": "psb",
    "vnd.3gpp.pic-bw-var": "pvb",
    "vnd.3gpp2.tcap": "tcap",
    "vnd.3m.post-it-notes": "pwn",
    "vnd.accpac.simply.aso": "aso",
    "vnd.accpac.simply.imp": "imp",
    "vnd.acucobol": "acu",
    "vnd.acucorp": [
      "atc",
      "acutc"
    ],
    "vnd.adobe.air-application-installer-package+zip": "air",
    "vnd.adobe.formscentral.fcdt": "fcdt",
    "vnd.adobe.fxp": [
      "fxp",
      "fxpl"
    ],
    "vnd.adobe.xdp+xml": "xdp",
    "vnd.adobe.xfdf": "xfdf",
    "vnd.ahead.space": "ahead",
    "vnd.airzip.filesecure.azf": "azf",
    "vnd.airzip.filesecure.azs": "azs",
    "vnd.amazon.ebook": "azw",
    "vnd.americandynamics.acc": "acc",
    "vnd.amiga.ami": "ami",
    "vnd.anser-web-certificate-issue-initiation": "cii",
    "vnd.anser-web-funds-transfer-initiation": "fti",
    "vnd.antix.game-component": "atx",
    "vnd.apple.installer+xml": "mpkg",
    "vnd.apple.mpegurl": "m3u8",
    "vnd.aristanetworks.swi": "swi",
    "vnd.astraea-software.iota": "iota",
    "vnd.audiograph": "aep",
    "vnd.blueice.multipass": "mpm",
    "vnd.bmi": "bmi",
    "vnd.businessobjects": "rep",
    "vnd.chemdraw+xml": "cdxml",
    "vnd.chipnuts.karaoke-mmd": "mmd",
    "vnd.claymore": "cla",
    "vnd.cloanto.rp9": "rp9",
    "vnd.clonk.c4group": [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ],
    "vnd.cluetrust.cartomobile-config": "c11amc",
    "vnd.cluetrust.cartomobile-config-pkg": "c11amz",
    "vnd.commonspace": "csp",
    "vnd.contact.cmsg": "cdbcmsg",
    "vnd.cosmocaller": "cmc",
    "vnd.crick.clicker": "clkx",
    "vnd.crick.clicker.keyboard": "clkk",
    "vnd.crick.clicker.palette": "clkp",
    "vnd.crick.clicker.template": "clkt",
    "vnd.crick.clicker.wordbank": "clkw",
    "vnd.criticaltools.wbs+xml": "wbs",
    "vnd.ctc-posml": "pml",
    "vnd.cups-ppd": "ppd",
    "vnd.curl.car": "car",
    "vnd.curl.pcurl": "pcurl",
    "vnd.dart": "dart",
    "vnd.data-vision.rdz": "rdz",
    "vnd.dece.data": [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ],
    "vnd.dece.ttml+xml": [
      "uvt",
      "uvvt"
    ],
    "vnd.dece.unspecified": [
      "uvx",
      "uvvx"
    ],
    "vnd.dece.zip": [
      "uvz",
      "uvvz"
    ],
    "vnd.denovo.fcselayout-link": "fe_launch",
    "vnd.dna": "dna",
    "vnd.dolby.mlp": "mlp",
    "vnd.dpgraph": "dpg",
    "vnd.dreamfactory": "dfac",
    "vnd.ds-keypoint": "kpxx",
    "vnd.dvb.ait": "ait",
    "vnd.dvb.service": "svc",
    "vnd.dynageo": "geo",
    "vnd.ecowin.chart": "mag",
    "vnd.enliven": "nml",
    "vnd.epson.esf": "esf",
    "vnd.epson.msf": "msf",
    "vnd.epson.quickanime": "qam",
    "vnd.epson.salt": "slt",
    "vnd.epson.ssf": "ssf",
    "vnd.eszigno3+xml": [
      "es3",
      "et3"
    ],
    "vnd.ezpix-album": "ez2",
    "vnd.ezpix-package": "ez3",
    "vnd.fdf": "fdf",
    "vnd.fdsn.mseed": "mseed",
    "vnd.fdsn.seed": [
      "seed",
      "dataless"
    ],
    "vnd.flographit": "gph",
    "vnd.fluxtime.clip": "ftc",
    "vnd.framemaker": [
      "fm",
      "frame",
      "maker",
      "book"
    ],
    "vnd.frogans.fnc": "fnc",
    "vnd.frogans.ltf": "ltf",
    "vnd.fsc.weblaunch": "fsc",
    "vnd.fujitsu.oasys": "oas",
    "vnd.fujitsu.oasys2": "oa2",
    "vnd.fujitsu.oasys3": "oa3",
    "vnd.fujitsu.oasysgp": "fg5",
    "vnd.fujitsu.oasysprs": "bh2",
    "vnd.fujixerox.ddd": "ddd",
    "vnd.fujixerox.docuworks": "xdw",
    "vnd.fujixerox.docuworks.binder": "xbd",
    "vnd.fuzzysheet": "fzs",
    "vnd.genomatix.tuxedo": "txd",
    "vnd.geogebra.file": "ggb",
    "vnd.geogebra.tool": "ggt",
    "vnd.geometry-explorer": [
      "gex",
      "gre"
    ],
    "vnd.geonext": "gxt",
    "vnd.geoplan": "g2w",
    "vnd.geospace": "g3w",
    "vnd.gmx": "gmx",
    "vnd.grafeq": [
      "gqf",
      "gqs"
    ],
    "vnd.groove-account": "gac",
    "vnd.groove-help": "ghf",
    "vnd.groove-identity-message": "gim",
    "vnd.groove-injector": "grv",
    "vnd.groove-tool-message": "gtm",
    "vnd.groove-tool-template": "tpl",
    "vnd.groove-vcard": "vcg",
    "vnd.hal+xml": "hal",
    "vnd.handheld-entertainment+xml": "zmm",
    "vnd.hbci": "hbci",
    "vnd.hhe.lesson-player": "les",
    "vnd.hp-hpgl": "hpgl",
    "vnd.hp-hpid": "hpid",
    "vnd.hp-hps": "hps",
    "vnd.hp-jlyt": "jlt",
    "vnd.hp-pcl": "pcl",
    "vnd.hp-pclxl": "pclxl",
    "vnd.hydrostatix.sof-data": "sfd-hdstx",
    "vnd.ibm.minipay": "mpy",
    "vnd.ibm.modcap": [
      "afp",
      "listafp",
      "list3820"
    ],
    "vnd.ibm.rights-management": "irm",
    "vnd.ibm.secure-container": "sc",
    "vnd.iccprofile": [
      "icc",
      "icm"
    ],
    "vnd.igloader": "igl",
    "vnd.immervision-ivp": "ivp",
    "vnd.immervision-ivu": "ivu",
    "vnd.insors.igm": "igm",
    "vnd.intercon.formnet": [
      "xpw",
      "xpx"
    ],
    "vnd.intergeo": "i2g",
    "vnd.intu.qbo": "qbo",
    "vnd.intu.qfx": "qfx",
    "vnd.ipunplugged.rcprofile": "rcprofile",
    "vnd.irepository.package+xml": "irp",
    "vnd.is-xpr": "xpr",
    "vnd.isac.fcs": "fcs",
    "vnd.jam": "jam",
    "vnd.jcp.javame.midlet-rms": "rms",
    "vnd.jisp": "jisp",
    "vnd.joost.joda-archive": "joda",
    "vnd.kahootz": [
      "ktz",
      "ktr"
    ],
    "vnd.kde.karbon": "karbon",
    "vnd.kde.kchart": "chrt",
    "vnd.kde.kformula": "kfo",
    "vnd.kde.kivio": "flw",
    "vnd.kde.kontour": "kon",
    "vnd.kde.kpresenter": [
      "kpr",
      "kpt"
    ],
    "vnd.kde.kspread": "ksp",
    "vnd.kde.kword": [
      "kwd",
      "kwt"
    ],
    "vnd.kenameaapp": "htke",
    "vnd.kidspiration": "kia",
    "vnd.kinar": [
      "kne",
      "knp"
    ],
    "vnd.koan": [
      "skp",
      "skd",
      "skt",
      "skm"
    ],
    "vnd.kodak-descriptor": "sse",
    "vnd.las.las+xml": "lasxml",
    "vnd.llamagraphics.life-balance.desktop": "lbd",
    "vnd.llamagraphics.life-balance.exchange+xml": "lbe",
    "vnd.lotus-1-2-3": "123",
    "vnd.lotus-approach": "apr",
    "vnd.lotus-freelance": "pre",
    "vnd.lotus-notes": "nsf",
    "vnd.lotus-organizer": "org",
    "vnd.lotus-screencam": "scm",
    "vnd.lotus-wordpro": "lwp",
    "vnd.macports.portpkg": "portpkg",
    "vnd.mcd": "mcd",
    "vnd.medcalcdata": "mc1",
    "vnd.mediastation.cdkey": "cdkey",
    "vnd.mfer": "mwf",
    "vnd.mfmp": "mfm",
    "vnd.micrografx.flo": "flo",
    "vnd.micrografx.igx": "igx",
    "vnd.mif": "mif",
    "vnd.mobius.daf": "daf",
    "vnd.mobius.dis": "dis",
    "vnd.mobius.mbk": "mbk",
    "vnd.mobius.mqy": "mqy",
    "vnd.mobius.msl": "msl",
    "vnd.mobius.plc": "plc",
    "vnd.mobius.txf": "txf",
    "vnd.mophun.application": "mpn",
    "vnd.mophun.certificate": "mpc",
    "vnd.ms-artgalry": "cil",
    "vnd.ms-cab-compressed": "cab",
    "vnd.ms-excel.addin.macroenabled.12": "xlam",
    "vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
    "vnd.ms-excel.sheet.macroenabled.12": "xlsm",
    "vnd.ms-excel.template.macroenabled.12": "xltm",
    "vnd.ms-fontobject": "eot",
    "vnd.ms-htmlhelp": "chm",
    "vnd.ms-ims": "ims",
    "vnd.ms-lrm": "lrm",
    "vnd.ms-officetheme": "thmx",
    "vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
    "vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
    "vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
    "vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
    "vnd.ms-powerpoint.template.macroenabled.12": "potm",
    "vnd.ms-project": [
      "mpp",
      "mpt"
    ],
    "vnd.ms-word.document.macroenabled.12": "docm",
    "vnd.ms-word.template.macroenabled.12": "dotm",
    "vnd.ms-works": [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ],
    "vnd.ms-wpl": "wpl",
    "vnd.ms-xpsdocument": "xps",
    "vnd.mseq": "mseq",
    "vnd.musician": "mus",
    "vnd.muvee.style": "msty",
    "vnd.mynfc": "taglet",
    "vnd.neurolanguage.nlu": "nlu",
    "vnd.nitf": [
      "ntf",
      "nitf"
    ],
    "vnd.noblenet-directory": "nnd",
    "vnd.noblenet-sealer": "nns",
    "vnd.noblenet-web": "nnw",
    "vnd.nokia.n-gage.data": "ngdat",
    "vnd.nokia.n-gage.symbian.install": "n-gage",
    "vnd.nokia.radio-preset": "rpst",
    "vnd.nokia.radio-presets": "rpss",
    "vnd.novadigm.edm": "edm",
    "vnd.novadigm.edx": "edx",
    "vnd.novadigm.ext": "ext",
    "vnd.oasis.opendocument.chart-template": "otc",
    "vnd.oasis.opendocument.formula-template": "odft",
    "vnd.oasis.opendocument.image-template": "oti",
    "vnd.olpc-sugar": "xo",
    "vnd.oma.dd2+xml": "dd2",
    "vnd.openofficeorg.extension": "oxt",
    "vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
    "vnd.osgeo.mapguide.package": "mgp",
    "vnd.osgi.dp": "dp",
    "vnd.osgi.subsystem": "esa",
    "vnd.palm": [
      "pdb",
      "pqa",
      "oprc"
    ],
    "vnd.pawaafile": "paw",
    "vnd.pg.format": "str",
    "vnd.pg.osasli": "ei6",
    "vnd.picsel": "efif",
    "vnd.pmi.widget": "wg",
    "vnd.pocketlearn": "plf",
    "vnd.powerbuilder6": "pbd",
    "vnd.previewsystems.box": "box",
    "vnd.proteus.magazine": "mgz",
    "vnd.publishare-delta-tree": "qps",
    "vnd.pvi.ptid1": "ptid",
    "vnd.quark.quarkxpress": [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ],
    "vnd.realvnc.bed": "bed",
    "vnd.recordare.musicxml": "mxl",
    "vnd.recordare.musicxml+xml": "musicxml",
    "vnd.rig.cryptonote": "cryptonote",
    "vnd.rn-realmedia": "rm",
    "vnd.rn-realmedia-vbr": "rmvb",
    "vnd.route66.link66+xml": "link66",
    "vnd.sailingtracker.track": "st",
    "vnd.seemail": "see",
    "vnd.sema": "sema",
    "vnd.semd": "semd",
    "vnd.semf": "semf",
    "vnd.shana.informed.formdata": "ifm",
    "vnd.shana.informed.formtemplate": "itp",
    "vnd.shana.informed.interchange": "iif",
    "vnd.shana.informed.package": "ipk",
    "vnd.simtech-mindmapper": [
      "twd",
      "twds"
    ],
    "vnd.smart.teacher": "teacher",
    "vnd.solent.sdkm+xml": [
      "sdkm",
      "sdkd"
    ],
    "vnd.spotfire.dxp": "dxp",
    "vnd.spotfire.sfs": "sfs",
    "vnd.stepmania.package": "smzip",
    "vnd.stepmania.stepchart": "sm",
    "vnd.sus-calendar": [
      "sus",
      "susp"
    ],
    "vnd.svd": "svd",
    "vnd.syncml+xml": "xsm",
    "vnd.syncml.dm+wbxml": "bdm",
    "vnd.syncml.dm+xml": "xdm",
    "vnd.tao.intent-module-archive": "tao",
    "vnd.tcpdump.pcap": [
      "pcap",
      "cap",
      "dmp"
    ],
    "vnd.tmobile-livetv": "tmo",
    "vnd.trid.tpt": "tpt",
    "vnd.triscape.mxs": "mxs",
    "vnd.trueapp": "tra",
    "vnd.ufdl": [
      "ufd",
      "ufdl"
    ],
    "vnd.uiq.theme": "utz",
    "vnd.umajin": "umj",
    "vnd.unity": "unityweb",
    "vnd.uoml+xml": "uoml",
    "vnd.vcx": "vcx",
    "vnd.visionary": "vis",
    "vnd.vsf": "vsf",
    "vnd.webturbo": "wtb",
    "vnd.wolfram.player": "nbp",
    "vnd.wqd": "wqd",
    "vnd.wt.stf": "stf",
    "vnd.xara": "xar",
    "vnd.xfdl": "xfdl",
    "vnd.yamaha.hv-dic": "hvd",
    "vnd.yamaha.hv-script": "hvs",
    "vnd.yamaha.hv-voice": "hvp",
    "vnd.yamaha.openscoreformat": "osf",
    "vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
    "vnd.yamaha.smaf-audio": "saf",
    "vnd.yamaha.smaf-phrase": "spf",
    "vnd.yellowriver-custom-menu": "cmp",
    "vnd.zul": [
      "zir",
      "zirz"
    ],
    "vnd.zzazz.deck+xml": "zaz",
    "voicexml+xml": "vxml",
    "widget": "wgt",
    "winhlp": "hlp",
    "wsdl+xml": "wsdl",
    "wspolicy+xml": "wspolicy",
    "x-ace-compressed": "ace",
    "x-authorware-bin": [
      "aab",
      "x32",
      "u32",
      "vox"
    ],
    "x-authorware-map": "aam",
    "x-authorware-seg": "aas",
    "x-blorb": [
      "blb",
      "blorb"
    ],
    "x-bzip": "bz",
    "x-bzip2": [
      "bz2",
      "boz"
    ],
    "x-cfs-compressed": "cfs",
    "x-chat": "chat",
    "x-conference": "nsc",
    "x-dgc-compressed": "dgc",
    "x-dtbncx+xml": "ncx",
    "x-dtbook+xml": "dtb",
    "x-dtbresource+xml": "res",
    "x-eva": "eva",
    "x-font-bdf": "bdf",
    "x-font-ghostscript": "gsf",
    "x-font-linux-psf": "psf",
    "x-font-pcf": "pcf",
    "x-font-snf": "snf",
    "x-font-ttf": [
      "ttf",
      "ttc"
    ],
    "x-font-type1": [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ],
    "x-freearc": "arc",
    "x-gca-compressed": "gca",
    "x-glulx": "ulx",
    "x-gramps-xml": "gramps",
    "x-install-instructions": "install",
    "x-lzh-compressed": [
      "lzh",
      "lha"
    ],
    "x-mie": "mie",
    "x-mobipocket-ebook": [
      "prc",
      "mobi"
    ],
    "x-ms-application": "application",
    "x-ms-shortcut": "lnk",
    "x-ms-xbap": "xbap",
    "x-msbinder": "obd",
    "x-mscardfile": "crd",
    "x-msclip": "clp",
    "application/x-ms-installer": "msi",
    "x-msmediaview": [
      "mvb",
      "m13",
      "m14"
    ],
    "x-msmetafile": [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ],
    "x-msmoney": "mny",
    "x-mspublisher": "pub",
    "x-msschedule": "scd",
    "x-msterminal": "trm",
    "x-mswrite": "wri",
    "x-nzb": "nzb",
    "x-pkcs12": [
      "p12",
      "pfx"
    ],
    "x-pkcs7-certificates": [
      "p7b",
      "spc"
    ],
    "x-research-info-systems": "ris",
    "x-silverlight-app": "xap",
    "x-sql": "sql",
    "x-stuffitx": "sitx",
    "x-subrip": "srt",
    "x-t3vm-image": "t3",
    "x-tex-tfm": "tfm",
    "x-tgif": "obj",
    "x-xliff+xml": "xlf",
    "x-xz": "xz",
    "x-zmachine": [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ],
    "xaml+xml": "xaml",
    "xcap-diff+xml": "xdf",
    "xenc+xml": "xenc",
    "xml-dtd": "dtd",
    "xop+xml": "xop",
    "xproc+xml": "xpl",
    "xslt+xml": "xslt",
    "xv+xml": [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ],
    "yang": "yang",
    "yin+xml": "yin",
    "envoy": "evy",
    "fractals": "fif",
    "internet-property-stream": "acx",
    "olescript": "axs",
    "vnd.ms-outlook": "msg",
    "vnd.ms-pkicertstore": "sst",
    "x-compress": "z",
    "x-perfmon": [
      "pma",
      "pmc",
      "pmr",
      "pmw"
    ],
    "ynd.ms-pkipko": "pko",
    "gzip": [
      "gz",
      "tgz"
    ],
    "smil+xml": [
      "smi",
      "smil"
    ],
    "vnd.debian.binary-package": [
      "deb",
      "udeb"
    ],
    "vnd.hzn-3d-crossword": "x3d",
    "vnd.sqlite3": [
      "db",
      "sqlite",
      "sqlite3",
      "db-wal",
      "sqlite-wal",
      "db-shm",
      "sqlite-shm"
    ],
    "vnd.wap.sic": "sic",
    "vnd.wap.slc": "slc",
    "x-krita": [
      "kra",
      "krz"
    ],
    "x-perl": [
      "pm",
      "pl"
    ],
    "yaml": [
      "yaml",
      "yml"
    ]
  },
  "audio": {
    "amr": "amr",
    "amr-wb": "awb",
    "annodex": "axa",
    "basic": [
      "au",
      "snd"
    ],
    "flac": "flac",
    "midi": [
      "mid",
      "midi",
      "kar",
      "rmi"
    ],
    "mpeg": [
      "mpga",
      "mpega",
      "mp3",
      "m4a",
      "mp2a",
      "m2a",
      "m3a"
    ],
    "mpegurl": "m3u",
    "ogg": [
      "oga",
      "ogg",
      "spx"
    ],
    "prs.sid": "sid",
    "x-aiff": "aifc",
    "x-gsm": "gsm",
    "x-ms-wma": "wma",
    "x-ms-wax": "wax",
    "x-pn-realaudio": "ram",
    "x-realaudio": "ra",
    "x-sd2": "sd2",
    "adpcm": "adp",
    "mp4": "mp4a",
    "s3m": "s3m",
    "silk": "sil",
    "vnd.dece.audio": [
      "uva",
      "uvva"
    ],
    "vnd.digital-winds": "eol",
    "vnd.dra": "dra",
    "vnd.dts": "dts",
    "vnd.dts.hd": "dtshd",
    "vnd.lucent.voice": "lvp",
    "vnd.ms-playready.media.pya": "pya",
    "vnd.nuera.ecelp4800": "ecelp4800",
    "vnd.nuera.ecelp7470": "ecelp7470",
    "vnd.nuera.ecelp9600": "ecelp9600",
    "vnd.rip": "rip",
    "webm": "weba",
    "x-caf": "caf",
    "x-matroska": "mka",
    "x-pn-realaudio-plugin": "rmp",
    "xm": "xm",
    "aac": "aac",
    "aiff": [
      "aiff",
      "aif",
      "aff"
    ],
    "opus": "opus",
    "wav": "wav"
  },
  "chemical": {
    "x-alchemy": "alc",
    "x-cache": [
      "cac",
      "cache"
    ],
    "x-cache-csf": "csf",
    "x-cactvs-binary": [
      "cbin",
      "cascii",
      "ctab"
    ],
    "x-cdx": "cdx",
    "x-chem3d": "c3d",
    "x-cif": "cif",
    "x-cmdf": "cmdf",
    "x-cml": "cml",
    "x-compass": "cpa",
    "x-crossfire": "bsd",
    "x-csml": [
      "csml",
      "csm"
    ],
    "x-ctx": "ctx",
    "x-cxf": [
      "cxf",
      "cef"
    ],
    "x-embl-dl-nucleotide": [
      "emb",
      "embl"
    ],
    "x-gamess-input": [
      "inp",
      "gam",
      "gamin"
    ],
    "x-gaussian-checkpoint": [
      "fch",
      "fchk"
    ],
    "x-gaussian-cube": "cub",
    "x-gaussian-input": [
      "gau",
      "gjc",
      "gjf"
    ],
    "x-gaussian-log": "gal",
    "x-gcg8-sequence": "gcg",
    "x-genbank": "gen",
    "x-hin": "hin",
    "x-isostar": [
      "istr",
      "ist"
    ],
    "x-jcamp-dx": [
      "jdx",
      "dx"
    ],
    "x-kinemage": "kin",
    "x-macmolecule": "mcm",
    "x-macromodel-input": "mmod",
    "x-mdl-molfile": "mol",
    "x-mdl-rdfile": "rd",
    "x-mdl-rxnfile": "rxn",
    "x-mdl-sdfile": "sd",
    "x-mdl-tgf": "tgf",
    "x-mmcif": "mcif",
    "x-mol2": "mol2",
    "x-molconn-Z": "b",
    "x-mopac-graph": "gpt",
    "x-mopac-input": [
      "mop",
      "mopcrt",
      "zmt"
    ],
    "x-mopac-out": "moo",
    "x-ncbi-asn1": "asn",
    "x-ncbi-asn1-ascii": [
      "prt",
      "ent"
    ],
    "x-ncbi-asn1-binary": "val",
    "x-rosdal": "ros",
    "x-swissprot": "sw",
    "x-vamas-iso14976": "vms",
    "x-vmd": "vmd",
    "x-xtel": "xtel",
    "x-xyz": "xyz"
  },
  "font": {
    "otf": "otf",
    "woff": "woff",
    "woff2": "woff2"
  },
  "image": {
    "gif": "gif",
    "ief": "ief",
    "jpeg": [
      "jpeg",
      "jpg",
      "jpe",
      "jfif",
      "jfif-tbnl",
      "jif"
    ],
    "pcx": "pcx",
    "png": "png",
    "svg+xml": [
      "svg",
      "svgz"
    ],
    "tiff": [
      "tiff",
      "tif"
    ],
    "vnd.djvu": [
      "djvu",
      "djv"
    ],
    "vnd.wap.wbmp": "wbmp",
    "x-canon-cr2": "cr2",
    "x-canon-crw": "crw",
    "x-cmu-raster": "ras",
    "x-coreldraw": "cdr",
    "x-coreldrawpattern": "pat",
    "x-coreldrawtemplate": "cdt",
    "x-corelphotopaint": "cpt",
    "x-epson-erf": "erf",
    "x-icon": "ico",
    "x-jg": "art",
    "x-jng": "jng",
    "x-nikon-nef": "nef",
    "x-olympus-orf": "orf",
    "x-portable-anymap": "pnm",
    "x-portable-bitmap": "pbm",
    "x-portable-graymap": "pgm",
    "x-portable-pixmap": "ppm",
    "x-rgb": "rgb",
    "x-xbitmap": "xbm",
    "x-xpixmap": "xpm",
    "x-xwindowdump": "xwd",
    "bmp": "bmp",
    "cgm": "cgm",
    "g3fax": "g3",
    "ktx": "ktx",
    "prs.btif": "btif",
    "sgi": "sgi",
    "vnd.dece.graphic": [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ],
    "vnd.dwg": "dwg",
    "vnd.dxf": "dxf",
    "vnd.fastbidsheet": "fbs",
    "vnd.fpx": "fpx",
    "vnd.fst": "fst",
    "vnd.fujixerox.edmics-mmr": "mmr",
    "vnd.fujixerox.edmics-rlc": "rlc",
    "vnd.ms-modi": "mdi",
    "vnd.ms-photo": "wdp",
    "vnd.net-fpx": "npx",
    "vnd.xiff": "xif",
    "webp": "webp",
    "x-3ds": "3ds",
    "x-cmx": "cmx",
    "x-freehand": [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ],
    "x-pict": [
      "pic",
      "pct"
    ],
    "x-tga": "tga",
    "cis-cod": "cod",
    "avif": "avifs",
    "heic": [
      "heif",
      "heic"
    ],
    "pjpeg": [
      "pjpg"
    ],
    "vnd.adobe.photoshop": "psd",
    "x-adobe-dng": "dng",
    "x-fuji-raf": "raf",
    "x-icns": "icns",
    "x-kodak-dcr": "dcr",
    "x-kodak-k25": "k25",
    "x-kodak-kdc": "kdc",
    "x-minolta-mrw": "mrw",
    "x-panasonic-raw": [
      "raw",
      "rw2",
      "rwl"
    ],
    "x-pentax-pef": [
      "pef",
      "ptx"
    ],
    "x-sigma-x3f": "x3f",
    "x-sony-arw": "arw",
    "x-sony-sr2": "sr2",
    "x-sony-srf": "srf"
  },
  "message": {
    "rfc822": [
      "eml",
      "mime",
      "mht",
      "mhtml",
      "nws"
    ]
  },
  "model": {
    "iges": [
      "igs",
      "iges"
    ],
    "mesh": [
      "msh",
      "mesh",
      "silo"
    ],
    "vrml": [
      "wrl",
      "vrml"
    ],
    "x3d+vrml": [
      "x3dv",
      "x3dvz"
    ],
    "x3d+xml": "x3dz",
    "x3d+binary": [
      "x3db",
      "x3dbz"
    ],
    "vnd.collada+xml": "dae",
    "vnd.dwf": "dwf",
    "vnd.gdl": "gdl",
    "vnd.gtw": "gtw",
    "vnd.mts": "mts",
    "vnd.usdz+zip": "usdz",
    "vnd.vtu": "vtu"
  },
  "text": {
    "cache-manifest": [
      "manifest",
      "appcache"
    ],
    "calendar": [
      "ics",
      "icz",
      "ifb"
    ],
    "css": "css",
    "csv": "csv",
    "h323": "323",
    "html": [
      "html",
      "htm",
      "shtml",
      "stm"
    ],
    "iuls": "uls",
    "plain": [
      "txt",
      "text",
      "brf",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "bas",
      "diff",
      "ksh"
    ],
    "richtext": "rtx",
    "scriptlet": [
      "sct",
      "wsc"
    ],
    "texmacs": "tm",
    "tab-separated-values": "tsv",
    "vnd.sun.j2me.app-descriptor": "jad",
    "vnd.wap.wml": "wml",
    "vnd.wap.wmlscript": "wmls",
    "x-bibtex": "bib",
    "x-boo": "boo",
    "x-c++hdr": [
      "h++",
      "hpp",
      "hxx",
      "hh"
    ],
    "x-c++src": [
      "c++",
      "cpp",
      "cxx",
      "cc"
    ],
    "x-component": "htc",
    "x-dsrc": "d",
    "x-diff": "patch",
    "x-haskell": "hs",
    "x-java": "java",
    "x-literate-haskell": "lhs",
    "x-moc": "moc",
    "x-pascal": [
      "p",
      "pas",
      "pp",
      "inc"
    ],
    "x-pcs-gcd": "gcd",
    "x-python": "py",
    "x-scala": "scala",
    "x-setext": "etx",
    "x-tcl": [
      "tcl",
      "tk"
    ],
    "x-tex": [
      "tex",
      "ltx",
      "sty",
      "cls"
    ],
    "x-vcalendar": "vcs",
    "x-vcard": "vcf",
    "n3": "n3",
    "prs.lines.tag": "dsc",
    "sgml": [
      "sgml",
      "sgm"
    ],
    "troff": [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ],
    "turtle": "ttl",
    "uri-list": [
      "uri",
      "uris",
      "urls"
    ],
    "vcard": "vcard",
    "vnd.curl": "curl",
    "vnd.curl.dcurl": "dcurl",
    "vnd.curl.scurl": "scurl",
    "vnd.curl.mcurl": "mcurl",
    "vnd.dvb.subtitle": "sub",
    "vnd.fly": "fly",
    "vnd.fmi.flexstor": "flx",
    "vnd.graphviz": "gv",
    "vnd.in3d.3dml": "3dml",
    "vnd.in3d.spot": "spot",
    "x-asm": [
      "s",
      "asm"
    ],
    "x-c": [
      "c",
      "h",
      "dic"
    ],
    "x-fortran": [
      "f",
      "for",
      "f77",
      "f90"
    ],
    "x-opml": "opml",
    "x-nfo": "nfo",
    "x-sfv": "sfv",
    "x-uuencode": "uu",
    "webviewhtml": "htt",
    "javascript": "js",
    "json": "json",
    "markdown": [
      "md",
      "markdown",
      "mdown",
      "markdn"
    ],
    "vnd.wap.si": "si",
    "vnd.wap.sl": "sl"
  },
  "video": {
    "avif": "avif",
    "3gpp": "3gp",
    "annodex": "axv",
    "dl": "dl",
    "dv": [
      "dif",
      "dv"
    ],
    "fli": "fli",
    "gl": "gl",
    "mpeg": [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v",
      "mp2",
      "mpa",
      "mpv2"
    ],
    "mp4": [
      "mp4",
      "mp4v",
      "mpg4"
    ],
    "quicktime": [
      "qt",
      "mov"
    ],
    "ogg": "ogv",
    "vnd.mpegurl": [
      "mxu",
      "m4u"
    ],
    "x-flv": "flv",
    "x-la-asf": [
      "lsf",
      "lsx"
    ],
    "x-mng": "mng",
    "x-ms-asf": [
      "asf",
      "asx",
      "asr"
    ],
    "x-ms-wm": "wm",
    "x-ms-wmv": "wmv",
    "x-ms-wmx": "wmx",
    "x-ms-wvx": "wvx",
    "x-msvideo": "avi",
    "x-sgi-movie": "movie",
    "x-matroska": [
      "mpv",
      "mkv",
      "mk3d",
      "mks"
    ],
    "3gpp2": "3g2",
    "h261": "h261",
    "h263": "h263",
    "h264": "h264",
    "jpeg": "jpgv",
    "jpm": [
      "jpm",
      "jpgm"
    ],
    "mj2": [
      "mj2",
      "mjp2"
    ],
    "vnd.dece.hd": [
      "uvh",
      "uvvh"
    ],
    "vnd.dece.mobile": [
      "uvm",
      "uvvm"
    ],
    "vnd.dece.pd": [
      "uvp",
      "uvvp"
    ],
    "vnd.dece.sd": [
      "uvs",
      "uvvs"
    ],
    "vnd.dece.video": [
      "uvv",
      "uvvv"
    ],
    "vnd.dvb.file": "dvb",
    "vnd.fvt": "fvt",
    "vnd.ms-playready.media.pyv": "pyv",
    "vnd.uvvu.mp4": [
      "uvu",
      "uvvu"
    ],
    "vnd.vivo": "viv",
    "webm": "webm",
    "x-f4v": "f4v",
    "x-m4v": "m4v",
    "x-ms-vob": "vob",
    "x-smv": "smv",
    "mp2t": "ts"
  },
  "x-conference": {
    "x-cooltalk": "ice"
  },
  "x-world": {
    "x-vrml": [
      "vrm",
      "flr",
      "wrz",
      "xaf",
      "xof"
    ]
  }
};
(() => {
  const mimeTypes = {};
  for (const type of Object.keys(table$1)) {
    for (const subtype of Object.keys(table$1[type])) {
      const value = table$1[type][subtype];
      if (typeof value == "string") {
        mimeTypes[value] = type + "/" + subtype;
      } else {
        for (let indexMimeType = 0; indexMimeType < value.length; indexMimeType++) {
          mimeTypes[value[indexMimeType]] = type + "/" + subtype;
        }
      }
    }
  }
  return mimeTypes;
})();
const table = [];
for (let i = 0; i < 256; i++) {
  let t2 = i;
  for (let j = 0; j < 8; j++) {
    if (t2 & 1) {
      t2 = t2 >>> 1 ^ 3988292384;
    } else {
      t2 = t2 >>> 1;
    }
  }
  table[i] = t2;
}
const _Crc32 = class _Crc32 {
  constructor(crc) {
    this.crc = crc || -1;
  }
  append(data) {
    let crc = this.crc | 0;
    for (let offset = 0, length = data.length | 0; offset < length; offset++) {
      crc = crc >>> 8 ^ table[(crc ^ data[offset]) & 255];
    }
    this.crc = crc;
  }
  get() {
    return ~this.crc;
  }
};
__name(_Crc32, "Crc32");
let Crc32 = _Crc32;
const _Crc32Stream = class _Crc32Stream extends TransformStream {
  constructor() {
    let stream2;
    const crc322 = new Crc32();
    super({
      transform(chunk, controller) {
        crc322.append(chunk);
        controller.enqueue(chunk);
      },
      flush() {
        const value = new Uint8Array(4);
        const dataView = new DataView(value.buffer);
        dataView.setUint32(0, crc322.get());
        stream2.value = value;
      }
    });
    stream2 = this;
  }
};
__name(_Crc32Stream, "Crc32Stream");
let Crc32Stream = _Crc32Stream;
function encodeText(value) {
  if (typeof TextEncoder == UNDEFINED_TYPE) {
    value = unescape(encodeURIComponent(value));
    const result = new Uint8Array(value.length);
    for (let i = 0; i < result.length; i++) {
      result[i] = value.charCodeAt(i);
    }
    return result;
  } else {
    return new TextEncoder().encode(value);
  }
}
__name(encodeText, "encodeText");
const bitArray = {
  /**
   * Concatenate two bit arrays.
   * @param {bitArray} a1 The first array.
   * @param {bitArray} a2 The second array.
   * @return {bitArray} The concatenation of a1 and a2.
   */
  concat(a1, a2) {
    if (a1.length === 0 || a2.length === 0) {
      return a1.concat(a2);
    }
    const last = a1[a1.length - 1], shift = bitArray.getPartial(last);
    if (shift === 32) {
      return a1.concat(a2);
    } else {
      return bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));
    }
  },
  /**
   * Find the length of an array of bits.
   * @param {bitArray} a The array.
   * @return {Number} The length of a, in bits.
   */
  bitLength(a) {
    const l = a.length;
    if (l === 0) {
      return 0;
    }
    const x = a[l - 1];
    return (l - 1) * 32 + bitArray.getPartial(x);
  },
  /**
   * Truncate an array.
   * @param {bitArray} a The array.
   * @param {Number} len The length to truncate to, in bits.
   * @return {bitArray} A new array, truncated to len bits.
   */
  clamp(a, len) {
    if (a.length * 32 < len) {
      return a;
    }
    a = a.slice(0, Math.ceil(len / 32));
    const l = a.length;
    len = len & 31;
    if (l > 0 && len) {
      a[l - 1] = bitArray.partial(len, a[l - 1] & 2147483648 >> len - 1, 1);
    }
    return a;
  },
  /**
   * Make a partial word for a bit array.
   * @param {Number} len The number of bits in the word.
   * @param {Number} x The bits.
   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.
   * @return {Number} The partial word.
   */
  partial(len, x, _end) {
    if (len === 32) {
      return x;
    }
    return (_end ? x | 0 : x << 32 - len) + len * 1099511627776;
  },
  /**
   * Get the number of bits used by a partial word.
   * @param {Number} x The partial word.
   * @return {Number} The number of bits used by the partial word.
   */
  getPartial(x) {
    return Math.round(x / 1099511627776) || 32;
  },
  /** Shift an array right.
   * @param {bitArray} a The array to shift.
   * @param {Number} shift The number of bits to shift.
   * @param {Number} [carry=0] A byte to carry in
   * @param {bitArray} [out=[]] An array to prepend to the output.
   * @private
   */
  _shiftRight(a, shift, carry, out) {
    if (out === void 0) {
      out = [];
    }
    for (; shift >= 32; shift -= 32) {
      out.push(carry);
      carry = 0;
    }
    if (shift === 0) {
      return out.concat(a);
    }
    for (let i = 0; i < a.length; i++) {
      out.push(carry | a[i] >>> shift);
      carry = a[i] << 32 - shift;
    }
    const last2 = a.length ? a[a.length - 1] : 0;
    const shift2 = bitArray.getPartial(last2);
    out.push(bitArray.partial(shift + shift2 & 31, shift + shift2 > 32 ? carry : out.pop(), 1));
    return out;
  }
};
const codec = {
  bytes: {
    /** Convert from a bitArray to an array of bytes. */
    fromBits(arr) {
      const bl = bitArray.bitLength(arr);
      const byteLength2 = bl / 8;
      const out = new Uint8Array(byteLength2);
      let tmp;
      for (let i = 0; i < byteLength2; i++) {
        if ((i & 3) === 0) {
          tmp = arr[i / 4];
        }
        out[i] = tmp >>> 24;
        tmp <<= 8;
      }
      return out;
    },
    /** Convert from an array of bytes to a bitArray. */
    toBits(bytes) {
      const out = [];
      let i;
      let tmp = 0;
      for (i = 0; i < bytes.length; i++) {
        tmp = tmp << 8 | bytes[i];
        if ((i & 3) === 3) {
          out.push(tmp);
          tmp = 0;
        }
      }
      if (i & 3) {
        out.push(bitArray.partial(8 * (i & 3), tmp));
      }
      return out;
    }
  }
};
const hash = {};
hash.sha1 = class {
  constructor(hash2) {
    const sha1 = this;
    sha1.blockSize = 512;
    sha1._init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    sha1._key = [1518500249, 1859775393, 2400959708, 3395469782];
    if (hash2) {
      sha1._h = hash2._h.slice(0);
      sha1._buffer = hash2._buffer.slice(0);
      sha1._length = hash2._length;
    } else {
      sha1.reset();
    }
  }
  /**
   * Reset the hash state.
   * @return this
   */
  reset() {
    const sha1 = this;
    sha1._h = sha1._init.slice(0);
    sha1._buffer = [];
    sha1._length = 0;
    return sha1;
  }
  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update(data) {
    const sha1 = this;
    if (typeof data === "string") {
      data = codec.utf8String.toBits(data);
    }
    const b = sha1._buffer = bitArray.concat(sha1._buffer, data);
    const ol = sha1._length;
    const nl = sha1._length = ol + bitArray.bitLength(data);
    if (nl > 9007199254740991) {
      throw new Error("Cannot hash more than 2^53 - 1 bits");
    }
    const c = new Uint32Array(b);
    let j = 0;
    for (let i = sha1.blockSize + ol - (sha1.blockSize + ol & sha1.blockSize - 1); i <= nl; i += sha1.blockSize) {
      sha1._block(c.subarray(16 * j, 16 * (j + 1)));
      j += 1;
    }
    b.splice(0, 16 * j);
    return sha1;
  }
  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO
   */
  finalize() {
    const sha1 = this;
    let b = sha1._buffer;
    const h = sha1._h;
    b = bitArray.concat(b, [bitArray.partial(1, 1)]);
    for (let i = b.length + 2; i & 15; i++) {
      b.push(0);
    }
    b.push(Math.floor(sha1._length / 4294967296));
    b.push(sha1._length | 0);
    while (b.length) {
      sha1._block(b.splice(0, 16));
    }
    sha1.reset();
    return h;
  }
  /**
   * The SHA-1 logical functions f(0), f(1), ..., f(79).
   * @private
   */
  _f(t2, b, c, d) {
    if (t2 <= 19) {
      return b & c | ~b & d;
    } else if (t2 <= 39) {
      return b ^ c ^ d;
    } else if (t2 <= 59) {
      return b & c | b & d | c & d;
    } else if (t2 <= 79) {
      return b ^ c ^ d;
    }
  }
  /**
   * Circular left-shift operator.
   * @private
   */
  _S(n, x) {
    return x << n | x >>> 32 - n;
  }
  /**
   * Perform one cycle of SHA-1.
   * @param {Uint32Array|bitArray} words one block of words.
   * @private
   */
  _block(words) {
    const sha1 = this;
    const h = sha1._h;
    const w = Array(80);
    for (let j = 0; j < 16; j++) {
      w[j] = words[j];
    }
    let a = h[0];
    let b = h[1];
    let c = h[2];
    let d = h[3];
    let e2 = h[4];
    for (let t2 = 0; t2 <= 79; t2++) {
      if (t2 >= 16) {
        w[t2] = sha1._S(1, w[t2 - 3] ^ w[t2 - 8] ^ w[t2 - 14] ^ w[t2 - 16]);
      }
      const tmp = sha1._S(5, a) + sha1._f(t2, b, c, d) + e2 + w[t2] + sha1._key[Math.floor(t2 / 20)] | 0;
      e2 = d;
      d = c;
      c = sha1._S(30, b);
      b = a;
      a = tmp;
    }
    h[0] = h[0] + a | 0;
    h[1] = h[1] + b | 0;
    h[2] = h[2] + c | 0;
    h[3] = h[3] + d | 0;
    h[4] = h[4] + e2 | 0;
  }
};
const cipher = {};
cipher.aes = class {
  constructor(key) {
    const aes = this;
    aes._tables = [[[], [], [], [], []], [[], [], [], [], []]];
    if (!aes._tables[0][0][0]) {
      aes._precompute();
    }
    const sbox = aes._tables[0][4];
    const decTable = aes._tables[1];
    const keyLen = key.length;
    let i, encKey, decKey, rcon = 1;
    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
      throw new Error("invalid aes key size");
    }
    aes._key = [encKey = key.slice(0), decKey = []];
    for (i = keyLen; i < 4 * keyLen + 28; i++) {
      let tmp = encKey[i - 1];
      if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
        tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
        if (i % keyLen === 0) {
          tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
          rcon = rcon << 1 ^ (rcon >> 7) * 283;
        }
      }
      encKey[i] = encKey[i - keyLen] ^ tmp;
    }
    for (let j = 0; i; j++, i--) {
      const tmp = encKey[j & 3 ? i : i - 4];
      if (i <= 4 || j < 4) {
        decKey[j] = tmp;
      } else {
        decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
      }
    }
  }
  // public
  /* Something like this might appear here eventually
  name: "AES",
  blockSize: 4,
  keySizes: [4,6,8],
  */
  /**
   * Encrypt an array of 4 big-endian words.
   * @param {Array} data The plaintext.
   * @return {Array} The ciphertext.
   */
  encrypt(data) {
    return this._crypt(data, 0);
  }
  /**
   * Decrypt an array of 4 big-endian words.
   * @param {Array} data The ciphertext.
   * @return {Array} The plaintext.
   */
  decrypt(data) {
    return this._crypt(data, 1);
  }
  /**
   * Expand the S-box tables.
   *
   * @private
   */
  _precompute() {
    const encTable = this._tables[0];
    const decTable = this._tables[1];
    const sbox = encTable[4];
    const sboxInv = decTable[4];
    const d = [];
    const th = [];
    let xInv, x2, x4, x8;
    for (let i = 0; i < 256; i++) {
      th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
    }
    for (let x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
      let s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
      s = s >> 8 ^ s & 255 ^ 99;
      sbox[x] = s;
      sboxInv[s] = x;
      x8 = d[x4 = d[x2 = d[x]]];
      let tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
      let tEnc = d[s] * 257 ^ s * 16843008;
      for (let i = 0; i < 4; i++) {
        encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
        decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
      }
    }
    for (let i = 0; i < 5; i++) {
      encTable[i] = encTable[i].slice(0);
      decTable[i] = decTable[i].slice(0);
    }
  }
  /**
   * Encryption and decryption core.
   * @param {Array} input Four words to be encrypted or decrypted.
   * @param dir The direction, 0 for encrypt and 1 for decrypt.
   * @return {Array} The four encrypted or decrypted words.
   * @private
   */
  _crypt(input, dir) {
    if (input.length !== 4) {
      throw new Error("invalid aes block size");
    }
    const key = this._key[dir];
    const nInnerRounds = key.length / 4 - 2;
    const out = [0, 0, 0, 0];
    const table2 = this._tables[dir];
    const t0 = table2[0];
    const t1 = table2[1];
    const t2 = table2[2];
    const t3 = table2[3];
    const sbox = table2[4];
    let a = input[0] ^ key[0];
    let b = input[dir ? 3 : 1] ^ key[1];
    let c = input[2] ^ key[2];
    let d = input[dir ? 1 : 3] ^ key[3];
    let kIndex = 4;
    let a2, b2, c2;
    for (let i = 0; i < nInnerRounds; i++) {
      a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];
      b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
      c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
      d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
      kIndex += 4;
      a = a2;
      b = b2;
      c = c2;
    }
    for (let i = 0; i < 4; i++) {
      out[dir ? 3 & -i : i] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
      a2 = a;
      a = b;
      b = c;
      c = d;
      d = a2;
    }
    return out;
  }
};
const random = {
  /** 
   * Generate random words with pure js, cryptographically not as strong & safe as native implementation.
   * @param {TypedArray} typedArray The array to fill.
   * @return {TypedArray} The random values.
   */
  getRandomValues(typedArray) {
    const words = new Uint32Array(typedArray.buffer);
    const r = /* @__PURE__ */ __name((m_w) => {
      let m_z = 987654321;
      const mask = 4294967295;
      return function() {
        m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;
        m_w = 18e3 * (m_w & 65535) + (m_w >> 16) & mask;
        const result = ((m_z << 16) + m_w & mask) / 4294967296 + 0.5;
        return result * (Math.random() > 0.5 ? 1 : -1);
      };
    }, "r");
    for (let i = 0, rcache; i < typedArray.length; i += 4) {
      const _r = r((rcache || Math.random()) * 4294967296);
      rcache = _r() * 987654071;
      words[i / 4] = _r() * 4294967296 | 0;
    }
    return typedArray;
  }
};
const mode = {};
mode.ctrGladman = class {
  constructor(prf, iv) {
    this._prf = prf;
    this._initIv = iv;
    this._iv = iv;
  }
  reset() {
    this._iv = this._initIv;
  }
  /** Input some data to calculate.
   * @param {bitArray} data the data to process, it must be intergral multiple of 128 bits unless it's the last.
   */
  update(data) {
    return this.calculate(this._prf, data, this._iv);
  }
  incWord(word) {
    if ((word >> 24 & 255) === 255) {
      let b1 = word >> 16 & 255;
      let b2 = word >> 8 & 255;
      let b3 = word & 255;
      if (b1 === 255) {
        b1 = 0;
        if (b2 === 255) {
          b2 = 0;
          if (b3 === 255) {
            b3 = 0;
          } else {
            ++b3;
          }
        } else {
          ++b2;
        }
      } else {
        ++b1;
      }
      word = 0;
      word += b1 << 16;
      word += b2 << 8;
      word += b3;
    } else {
      word += 1 << 24;
    }
    return word;
  }
  incCounter(counter) {
    if ((counter[0] = this.incWord(counter[0])) === 0) {
      counter[1] = this.incWord(counter[1]);
    }
  }
  calculate(prf, data, iv) {
    let l;
    if (!(l = data.length)) {
      return [];
    }
    const bl = bitArray.bitLength(data);
    for (let i = 0; i < l; i += 4) {
      this.incCounter(iv);
      const e2 = prf.encrypt(iv);
      data[i] ^= e2[0];
      data[i + 1] ^= e2[1];
      data[i + 2] ^= e2[2];
      data[i + 3] ^= e2[3];
    }
    return bitArray.clamp(data, bl);
  }
};
const misc = {
  importKey(password) {
    return new misc.hmacSha1(codec.bytes.toBits(password));
  },
  pbkdf2(prf, salt, count, length) {
    count = count || 1e4;
    if (length < 0 || count < 0) {
      throw new Error("invalid params to pbkdf2");
    }
    const byteLength2 = (length >> 5) + 1 << 2;
    let u, ui, i, j, k;
    const arrayBuffer = new ArrayBuffer(byteLength2);
    const out = new DataView(arrayBuffer);
    let outLength = 0;
    const b = bitArray;
    salt = codec.bytes.toBits(salt);
    for (k = 1; outLength < (byteLength2 || 1); k++) {
      u = ui = prf.encrypt(b.concat(salt, [k]));
      for (i = 1; i < count; i++) {
        ui = prf.encrypt(ui);
        for (j = 0; j < ui.length; j++) {
          u[j] ^= ui[j];
        }
      }
      for (i = 0; outLength < (byteLength2 || 1) && i < u.length; i++) {
        out.setInt32(outLength, u[i]);
        outLength += 4;
      }
    }
    return arrayBuffer.slice(0, length / 8);
  }
};
misc.hmacSha1 = class {
  constructor(key) {
    const hmac = this;
    const Hash = hmac._hash = hash.sha1;
    const exKey = [[], []];
    hmac._baseHash = [new Hash(), new Hash()];
    const bs = hmac._baseHash[0].blockSize / 32;
    if (key.length > bs) {
      key = new Hash().update(key).finalize();
    }
    for (let i = 0; i < bs; i++) {
      exKey[0][i] = key[i] ^ 909522486;
      exKey[1][i] = key[i] ^ 1549556828;
    }
    hmac._baseHash[0].update(exKey[0]);
    hmac._baseHash[1].update(exKey[1]);
    hmac._resultHash = new Hash(hmac._baseHash[0]);
  }
  reset() {
    const hmac = this;
    hmac._resultHash = new hmac._hash(hmac._baseHash[0]);
    hmac._updated = false;
  }
  update(data) {
    const hmac = this;
    hmac._updated = true;
    hmac._resultHash.update(data);
  }
  digest() {
    const hmac = this;
    const w = hmac._resultHash.finalize();
    const result = new hmac._hash(hmac._baseHash[1]).update(w).finalize();
    hmac.reset();
    return result;
  }
  encrypt(data) {
    if (!this._updated) {
      this.update(data);
      return this.digest(data);
    } else {
      throw new Error("encrypt on already updated hmac called!");
    }
  }
};
const GET_RANDOM_VALUES_SUPPORTED = typeof crypto != UNDEFINED_TYPE && typeof crypto.getRandomValues == FUNCTION_TYPE;
const ERR_INVALID_PASSWORD = "Invalid password";
const ERR_INVALID_SIGNATURE = "Invalid signature";
const ERR_ABORT_CHECK_PASSWORD = "zipjs-abort-check-password";
function getRandomValues(array2) {
  if (GET_RANDOM_VALUES_SUPPORTED) {
    return crypto.getRandomValues(array2);
  } else {
    return random.getRandomValues(array2);
  }
}
__name(getRandomValues, "getRandomValues");
const BLOCK_LENGTH = 16;
const RAW_FORMAT = "raw";
const PBKDF2_ALGORITHM = { name: "PBKDF2" };
const HASH_ALGORITHM = { name: "HMAC" };
const HASH_FUNCTION = "SHA-1";
const BASE_KEY_ALGORITHM = Object.assign({ hash: HASH_ALGORITHM }, PBKDF2_ALGORITHM);
const DERIVED_BITS_ALGORITHM = Object.assign({ iterations: 1e3, hash: { name: HASH_FUNCTION } }, PBKDF2_ALGORITHM);
const DERIVED_BITS_USAGE = ["deriveBits"];
const SALT_LENGTH = [8, 12, 16];
const KEY_LENGTH = [16, 24, 32];
const SIGNATURE_LENGTH = 10;
const COUNTER_DEFAULT_VALUE = [0, 0, 0, 0];
const CRYPTO_API_SUPPORTED = typeof crypto != UNDEFINED_TYPE;
const subtle = CRYPTO_API_SUPPORTED && crypto.subtle;
const SUBTLE_API_SUPPORTED = CRYPTO_API_SUPPORTED && typeof subtle != UNDEFINED_TYPE;
const codecBytes = codec.bytes;
const Aes = cipher.aes;
const CtrGladman = mode.ctrGladman;
const HmacSha1 = misc.hmacSha1;
let IMPORT_KEY_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.importKey == FUNCTION_TYPE;
let DERIVE_BITS_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.deriveBits == FUNCTION_TYPE;
const _AESDecryptionStream = class _AESDecryptionStream extends TransformStream {
  constructor({ password, rawPassword, signed, encryptionStrength, checkPasswordOnly }) {
    super({
      start() {
        Object.assign(this, {
          ready: new Promise((resolve2) => this.resolveReady = resolve2),
          password: encodePassword(password, rawPassword),
          signed,
          strength: encryptionStrength - 1,
          pending: new Uint8Array()
        });
      },
      async transform(chunk, controller) {
        const aesCrypto = this;
        const {
          password: password2,
          strength,
          resolveReady,
          ready
        } = aesCrypto;
        if (password2) {
          await createDecryptionKeys(aesCrypto, strength, password2, subarray(chunk, 0, SALT_LENGTH[strength] + 2));
          chunk = subarray(chunk, SALT_LENGTH[strength] + 2);
          if (checkPasswordOnly) {
            controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));
          } else {
            resolveReady();
          }
        } else {
          await ready;
        }
        const output2 = new Uint8Array(chunk.length - SIGNATURE_LENGTH - (chunk.length - SIGNATURE_LENGTH) % BLOCK_LENGTH);
        controller.enqueue(append(aesCrypto, chunk, output2, 0, SIGNATURE_LENGTH, true));
      },
      async flush(controller) {
        const {
          signed: signed2,
          ctr,
          hmac,
          pending,
          ready
        } = this;
        if (hmac && ctr) {
          await ready;
          const chunkToDecrypt = subarray(pending, 0, pending.length - SIGNATURE_LENGTH);
          const originalSignature = subarray(pending, pending.length - SIGNATURE_LENGTH);
          let decryptedChunkArray = new Uint8Array();
          if (chunkToDecrypt.length) {
            const encryptedChunk = toBits(codecBytes, chunkToDecrypt);
            hmac.update(encryptedChunk);
            const decryptedChunk = ctr.update(encryptedChunk);
            decryptedChunkArray = fromBits(codecBytes, decryptedChunk);
          }
          if (signed2) {
            const signature = subarray(fromBits(codecBytes, hmac.digest()), 0, SIGNATURE_LENGTH);
            for (let indexSignature = 0; indexSignature < SIGNATURE_LENGTH; indexSignature++) {
              if (signature[indexSignature] != originalSignature[indexSignature]) {
                throw new Error(ERR_INVALID_SIGNATURE);
              }
            }
          }
          controller.enqueue(decryptedChunkArray);
        }
      }
    });
  }
};
__name(_AESDecryptionStream, "AESDecryptionStream");
let AESDecryptionStream = _AESDecryptionStream;
const _AESEncryptionStream = class _AESEncryptionStream extends TransformStream {
  constructor({ password, rawPassword, encryptionStrength }) {
    let stream2;
    super({
      start() {
        Object.assign(this, {
          ready: new Promise((resolve2) => this.resolveReady = resolve2),
          password: encodePassword(password, rawPassword),
          strength: encryptionStrength - 1,
          pending: new Uint8Array()
        });
      },
      async transform(chunk, controller) {
        const aesCrypto = this;
        const {
          password: password2,
          strength,
          resolveReady,
          ready
        } = aesCrypto;
        let preamble = new Uint8Array();
        if (password2) {
          preamble = await createEncryptionKeys(aesCrypto, strength, password2);
          resolveReady();
        } else {
          await ready;
        }
        const output2 = new Uint8Array(preamble.length + chunk.length - chunk.length % BLOCK_LENGTH);
        output2.set(preamble, 0);
        controller.enqueue(append(aesCrypto, chunk, output2, preamble.length, 0));
      },
      async flush(controller) {
        const {
          ctr,
          hmac,
          pending,
          ready
        } = this;
        if (hmac && ctr) {
          await ready;
          let encryptedChunkArray = new Uint8Array();
          if (pending.length) {
            const encryptedChunk = ctr.update(toBits(codecBytes, pending));
            hmac.update(encryptedChunk);
            encryptedChunkArray = fromBits(codecBytes, encryptedChunk);
          }
          stream2.signature = fromBits(codecBytes, hmac.digest()).slice(0, SIGNATURE_LENGTH);
          controller.enqueue(concat(encryptedChunkArray, stream2.signature));
        }
      }
    });
    stream2 = this;
  }
};
__name(_AESEncryptionStream, "AESEncryptionStream");
let AESEncryptionStream = _AESEncryptionStream;
function append(aesCrypto, input, output2, paddingStart, paddingEnd, verifySignature) {
  const {
    ctr,
    hmac,
    pending
  } = aesCrypto;
  const inputLength = input.length - paddingEnd;
  if (pending.length) {
    input = concat(pending, input);
    output2 = expand(output2, inputLength - inputLength % BLOCK_LENGTH);
  }
  let offset;
  for (offset = 0; offset <= inputLength - BLOCK_LENGTH; offset += BLOCK_LENGTH) {
    const inputChunk = toBits(codecBytes, subarray(input, offset, offset + BLOCK_LENGTH));
    if (verifySignature) {
      hmac.update(inputChunk);
    }
    const outputChunk = ctr.update(inputChunk);
    if (!verifySignature) {
      hmac.update(outputChunk);
    }
    output2.set(fromBits(codecBytes, outputChunk), offset + paddingStart);
  }
  aesCrypto.pending = subarray(input, offset);
  return output2;
}
__name(append, "append");
async function createDecryptionKeys(decrypt2, strength, password, preamble) {
  const passwordVerificationKey = await createKeys$1(decrypt2, strength, password, subarray(preamble, 0, SALT_LENGTH[strength]));
  const passwordVerification = subarray(preamble, SALT_LENGTH[strength]);
  if (passwordVerificationKey[0] != passwordVerification[0] || passwordVerificationKey[1] != passwordVerification[1]) {
    throw new Error(ERR_INVALID_PASSWORD);
  }
}
__name(createDecryptionKeys, "createDecryptionKeys");
async function createEncryptionKeys(encrypt2, strength, password) {
  const salt = getRandomValues(new Uint8Array(SALT_LENGTH[strength]));
  const passwordVerification = await createKeys$1(encrypt2, strength, password, salt);
  return concat(salt, passwordVerification);
}
__name(createEncryptionKeys, "createEncryptionKeys");
async function createKeys$1(aesCrypto, strength, password, salt) {
  aesCrypto.password = null;
  const baseKey = await importKey(RAW_FORMAT, password, BASE_KEY_ALGORITHM, false, DERIVED_BITS_USAGE);
  const derivedBits = await deriveBits(Object.assign({ salt }, DERIVED_BITS_ALGORITHM), baseKey, 8 * (KEY_LENGTH[strength] * 2 + 2));
  const compositeKey = new Uint8Array(derivedBits);
  const key = toBits(codecBytes, subarray(compositeKey, 0, KEY_LENGTH[strength]));
  const authentication = toBits(codecBytes, subarray(compositeKey, KEY_LENGTH[strength], KEY_LENGTH[strength] * 2));
  const passwordVerification = subarray(compositeKey, KEY_LENGTH[strength] * 2);
  Object.assign(aesCrypto, {
    keys: {
      key,
      authentication,
      passwordVerification
    },
    ctr: new CtrGladman(new Aes(key), Array.from(COUNTER_DEFAULT_VALUE)),
    hmac: new HmacSha1(authentication)
  });
  return passwordVerification;
}
__name(createKeys$1, "createKeys$1");
async function importKey(format2, password, algorithm, extractable, keyUsages) {
  if (IMPORT_KEY_SUPPORTED) {
    try {
      return await subtle.importKey(format2, password, algorithm, extractable, keyUsages);
    } catch (_error) {
      IMPORT_KEY_SUPPORTED = false;
      return misc.importKey(password);
    }
  } else {
    return misc.importKey(password);
  }
}
__name(importKey, "importKey");
async function deriveBits(algorithm, baseKey, length) {
  if (DERIVE_BITS_SUPPORTED) {
    try {
      return await subtle.deriveBits(algorithm, baseKey, length);
    } catch (_error) {
      DERIVE_BITS_SUPPORTED = false;
      return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
    }
  } else {
    return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
  }
}
__name(deriveBits, "deriveBits");
function encodePassword(password, rawPassword) {
  if (rawPassword === UNDEFINED_VALUE) {
    return encodeText(password);
  } else {
    return rawPassword;
  }
}
__name(encodePassword, "encodePassword");
function concat(leftArray, rightArray) {
  let array2 = leftArray;
  if (leftArray.length + rightArray.length) {
    array2 = new Uint8Array(leftArray.length + rightArray.length);
    array2.set(leftArray, 0);
    array2.set(rightArray, leftArray.length);
  }
  return array2;
}
__name(concat, "concat");
function expand(inputArray, length) {
  if (length && length > inputArray.length) {
    const array2 = inputArray;
    inputArray = new Uint8Array(length);
    inputArray.set(array2, 0);
  }
  return inputArray;
}
__name(expand, "expand");
function subarray(array2, begin, end) {
  return array2.subarray(begin, end);
}
__name(subarray, "subarray");
function fromBits(codecBytes2, chunk) {
  return codecBytes2.fromBits(chunk);
}
__name(fromBits, "fromBits");
function toBits(codecBytes2, chunk) {
  return codecBytes2.toBits(chunk);
}
__name(toBits, "toBits");
const HEADER_LENGTH = 12;
const _ZipCryptoDecryptionStream = class _ZipCryptoDecryptionStream extends TransformStream {
  constructor({ password, passwordVerification, checkPasswordOnly }) {
    super({
      start() {
        Object.assign(this, {
          password,
          passwordVerification
        });
        createKeys(this, password);
      },
      transform(chunk, controller) {
        const zipCrypto = this;
        if (zipCrypto.password) {
          const decryptedHeader = decrypt(zipCrypto, chunk.subarray(0, HEADER_LENGTH));
          zipCrypto.password = null;
          if (decryptedHeader[HEADER_LENGTH - 1] != zipCrypto.passwordVerification) {
            throw new Error(ERR_INVALID_PASSWORD);
          }
          chunk = chunk.subarray(HEADER_LENGTH);
        }
        if (checkPasswordOnly) {
          controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));
        } else {
          controller.enqueue(decrypt(zipCrypto, chunk));
        }
      }
    });
  }
};
__name(_ZipCryptoDecryptionStream, "ZipCryptoDecryptionStream");
let ZipCryptoDecryptionStream = _ZipCryptoDecryptionStream;
const _ZipCryptoEncryptionStream = class _ZipCryptoEncryptionStream extends TransformStream {
  constructor({ password, passwordVerification }) {
    super({
      start() {
        Object.assign(this, {
          password,
          passwordVerification
        });
        createKeys(this, password);
      },
      transform(chunk, controller) {
        const zipCrypto = this;
        let output2;
        let offset;
        if (zipCrypto.password) {
          zipCrypto.password = null;
          const header = getRandomValues(new Uint8Array(HEADER_LENGTH));
          header[HEADER_LENGTH - 1] = zipCrypto.passwordVerification;
          output2 = new Uint8Array(chunk.length + header.length);
          output2.set(encrypt(zipCrypto, header), 0);
          offset = HEADER_LENGTH;
        } else {
          output2 = new Uint8Array(chunk.length);
          offset = 0;
        }
        output2.set(encrypt(zipCrypto, chunk), offset);
        controller.enqueue(output2);
      }
    });
  }
};
__name(_ZipCryptoEncryptionStream, "ZipCryptoEncryptionStream");
let ZipCryptoEncryptionStream = _ZipCryptoEncryptionStream;
function decrypt(target, input) {
  const output2 = new Uint8Array(input.length);
  for (let index = 0; index < input.length; index++) {
    output2[index] = getByte(target) ^ input[index];
    updateKeys(target, output2[index]);
  }
  return output2;
}
__name(decrypt, "decrypt");
function encrypt(target, input) {
  const output2 = new Uint8Array(input.length);
  for (let index = 0; index < input.length; index++) {
    output2[index] = getByte(target) ^ input[index];
    updateKeys(target, input[index]);
  }
  return output2;
}
__name(encrypt, "encrypt");
function createKeys(target, password) {
  const keys = [305419896, 591751049, 878082192];
  Object.assign(target, {
    keys,
    crcKey0: new Crc32(keys[0]),
    crcKey2: new Crc32(keys[2])
  });
  for (let index = 0; index < password.length; index++) {
    updateKeys(target, password.charCodeAt(index));
  }
}
__name(createKeys, "createKeys");
function updateKeys(target, byte) {
  let [key0, key1, key2] = target.keys;
  target.crcKey0.append([byte]);
  key0 = ~target.crcKey0.get();
  key1 = getInt32(Math.imul(getInt32(key1 + getInt8(key0)), 134775813) + 1);
  target.crcKey2.append([key1 >>> 24]);
  key2 = ~target.crcKey2.get();
  target.keys = [key0, key1, key2];
}
__name(updateKeys, "updateKeys");
function getByte(target) {
  const temp = target.keys[2] | 2;
  return getInt8(Math.imul(temp, temp ^ 1) >>> 8);
}
__name(getByte, "getByte");
function getInt8(number) {
  return number & 255;
}
__name(getInt8, "getInt8");
function getInt32(number) {
  return number & 4294967295;
}
__name(getInt32, "getInt32");
const COMPRESSION_FORMAT = "deflate-raw";
const _DeflateStream = class _DeflateStream extends TransformStream {
  constructor(options, { chunkSize, CompressionStream: CompressionStream2, CompressionStreamNative }) {
    super({});
    const { compressed, encrypted, useCompressionStream, zipCrypto, signed, level: level2 } = options;
    const stream2 = this;
    let crc32Stream, encryptionStream;
    let readable2 = filterEmptyChunks(super.readable);
    if ((!encrypted || zipCrypto) && signed) {
      crc32Stream = new Crc32Stream();
      readable2 = pipeThrough(readable2, crc32Stream);
    }
    if (compressed) {
      readable2 = pipeThroughCommpressionStream(readable2, useCompressionStream, { level: level2, chunkSize }, CompressionStreamNative, CompressionStream2);
    }
    if (encrypted) {
      if (zipCrypto) {
        readable2 = pipeThrough(readable2, new ZipCryptoEncryptionStream(options));
      } else {
        encryptionStream = new AESEncryptionStream(options);
        readable2 = pipeThrough(readable2, encryptionStream);
      }
    }
    setReadable(stream2, readable2, () => {
      let signature;
      if (encrypted && !zipCrypto) {
        signature = encryptionStream.signature;
      }
      if ((!encrypted || zipCrypto) && signed) {
        signature = new DataView(crc32Stream.value.buffer).getUint32(0);
      }
      stream2.signature = signature;
    });
  }
};
__name(_DeflateStream, "DeflateStream");
let DeflateStream = _DeflateStream;
const _InflateStream = class _InflateStream extends TransformStream {
  constructor(options, { chunkSize, DecompressionStream: DecompressionStream2, DecompressionStreamNative }) {
    super({});
    const { zipCrypto, encrypted, signed, signature, compressed, useCompressionStream } = options;
    let crc32Stream, decryptionStream;
    let readable2 = filterEmptyChunks(super.readable);
    if (encrypted) {
      if (zipCrypto) {
        readable2 = pipeThrough(readable2, new ZipCryptoDecryptionStream(options));
      } else {
        decryptionStream = new AESDecryptionStream(options);
        readable2 = pipeThrough(readable2, decryptionStream);
      }
    }
    if (compressed) {
      readable2 = pipeThroughCommpressionStream(readable2, useCompressionStream, { chunkSize }, DecompressionStreamNative, DecompressionStream2);
    }
    if ((!encrypted || zipCrypto) && signed) {
      crc32Stream = new Crc32Stream();
      readable2 = pipeThrough(readable2, crc32Stream);
    }
    setReadable(this, readable2, () => {
      if ((!encrypted || zipCrypto) && signed) {
        const dataViewSignature = new DataView(crc32Stream.value.buffer);
        if (signature != dataViewSignature.getUint32(0, false)) {
          throw new Error(ERR_INVALID_SIGNATURE);
        }
      }
    });
  }
};
__name(_InflateStream, "InflateStream");
let InflateStream = _InflateStream;
function filterEmptyChunks(readable2) {
  return pipeThrough(readable2, new TransformStream({
    transform(chunk, controller) {
      if (chunk && chunk.length) {
        controller.enqueue(chunk);
      }
    }
  }));
}
__name(filterEmptyChunks, "filterEmptyChunks");
function setReadable(stream2, readable2, flush) {
  readable2 = pipeThrough(readable2, new TransformStream({ flush }));
  Object.defineProperty(stream2, "readable", {
    get() {
      return readable2;
    }
  });
}
__name(setReadable, "setReadable");
function pipeThroughCommpressionStream(readable2, useCompressionStream, options, CodecStreamNative, CodecStream2) {
  try {
    const CompressionStream2 = useCompressionStream && CodecStreamNative ? CodecStreamNative : CodecStream2;
    readable2 = pipeThrough(readable2, new CompressionStream2(COMPRESSION_FORMAT, options));
  } catch (error) {
    if (useCompressionStream) {
      try {
        readable2 = pipeThrough(readable2, new CodecStream2(COMPRESSION_FORMAT, options));
      } catch (error2) {
        return readable2;
      }
    } else {
      return readable2;
    }
  }
  return readable2;
}
__name(pipeThroughCommpressionStream, "pipeThroughCommpressionStream");
function pipeThrough(readable2, transformStream) {
  return readable2.pipeThrough(transformStream);
}
__name(pipeThrough, "pipeThrough");
const MESSAGE_EVENT_TYPE = "message";
const MESSAGE_START = "start";
const MESSAGE_PULL = "pull";
const MESSAGE_DATA = "data";
const MESSAGE_ACK_DATA = "ack";
const MESSAGE_CLOSE = "close";
const CODEC_DEFLATE = "deflate";
const CODEC_INFLATE = "inflate";
const _CodecStream = class _CodecStream extends TransformStream {
  constructor(options, config2) {
    super({});
    const codec2 = this;
    const { codecType } = options;
    let Stream2;
    if (codecType.startsWith(CODEC_DEFLATE)) {
      Stream2 = DeflateStream;
    } else if (codecType.startsWith(CODEC_INFLATE)) {
      Stream2 = InflateStream;
    }
    let outputSize = 0;
    let inputSize = 0;
    const stream2 = new Stream2(options, config2);
    const readable2 = super.readable;
    const inputSizeStream = new TransformStream({
      transform(chunk, controller) {
        if (chunk && chunk.length) {
          inputSize += chunk.length;
          controller.enqueue(chunk);
        }
      },
      flush() {
        Object.assign(codec2, {
          inputSize
        });
      }
    });
    const outputSizeStream = new TransformStream({
      transform(chunk, controller) {
        if (chunk && chunk.length) {
          outputSize += chunk.length;
          controller.enqueue(chunk);
        }
      },
      flush() {
        const { signature } = stream2;
        Object.assign(codec2, {
          signature,
          outputSize,
          inputSize
        });
      }
    });
    Object.defineProperty(codec2, "readable", {
      get() {
        return readable2.pipeThrough(inputSizeStream).pipeThrough(stream2).pipeThrough(outputSizeStream);
      }
    });
  }
};
__name(_CodecStream, "CodecStream");
let CodecStream = _CodecStream;
const _ChunkStream = class _ChunkStream extends TransformStream {
  constructor(chunkSize) {
    let pendingChunk;
    super({
      transform: transform2,
      flush(controller) {
        if (pendingChunk && pendingChunk.length) {
          controller.enqueue(pendingChunk);
        }
      }
    });
    function transform2(chunk, controller) {
      if (pendingChunk) {
        const newChunk = new Uint8Array(pendingChunk.length + chunk.length);
        newChunk.set(pendingChunk);
        newChunk.set(chunk, pendingChunk.length);
        chunk = newChunk;
        pendingChunk = null;
      }
      if (chunk.length > chunkSize) {
        controller.enqueue(chunk.slice(0, chunkSize));
        transform2(chunk.slice(chunkSize), controller);
      } else {
        pendingChunk = chunk;
      }
    }
    __name(transform2, "transform");
  }
};
__name(_ChunkStream, "ChunkStream");
let ChunkStream = _ChunkStream;
let WEB_WORKERS_SUPPORTED = typeof Worker != UNDEFINED_TYPE;
const _CodecWorker = class _CodecWorker {
  constructor(workerData, { readable: readable2, writable: writable2 }, { options, config: config2, streamOptions, useWebWorkers, transferStreams, scripts }, onTaskFinished) {
    const { signal } = streamOptions;
    Object.assign(workerData, {
      busy: true,
      readable: readable2.pipeThrough(new ChunkStream(config2.chunkSize)).pipeThrough(new ProgressWatcherStream(readable2, streamOptions), { signal }),
      writable: writable2,
      options: Object.assign({}, options),
      scripts,
      transferStreams,
      terminate() {
        return new Promise((resolve2) => {
          const { worker, busy } = workerData;
          if (worker) {
            if (busy) {
              workerData.resolveTerminated = resolve2;
            } else {
              worker.terminate();
              resolve2();
            }
            workerData.interface = null;
          } else {
            resolve2();
          }
        });
      },
      onTaskFinished() {
        const { resolveTerminated } = workerData;
        if (resolveTerminated) {
          workerData.resolveTerminated = null;
          workerData.terminated = true;
          workerData.worker.terminate();
          resolveTerminated();
        }
        workerData.busy = false;
        onTaskFinished(workerData);
      }
    });
    return (useWebWorkers && WEB_WORKERS_SUPPORTED ? createWebWorkerInterface : createWorkerInterface)(workerData, config2);
  }
};
__name(_CodecWorker, "CodecWorker");
let CodecWorker = _CodecWorker;
const _ProgressWatcherStream = class _ProgressWatcherStream extends TransformStream {
  constructor(readableSource, { onstart, onprogress, size, onend }) {
    let chunkOffset = 0;
    super({
      async start() {
        if (onstart) {
          await callHandler(onstart, size);
        }
      },
      async transform(chunk, controller) {
        chunkOffset += chunk.length;
        if (onprogress) {
          await callHandler(onprogress, chunkOffset, size);
        }
        controller.enqueue(chunk);
      },
      async flush() {
        readableSource.size = chunkOffset;
        if (onend) {
          await callHandler(onend, chunkOffset);
        }
      }
    });
  }
};
__name(_ProgressWatcherStream, "ProgressWatcherStream");
let ProgressWatcherStream = _ProgressWatcherStream;
async function callHandler(handler, ...parameters) {
  try {
    await handler(...parameters);
  } catch (_error) {
  }
}
__name(callHandler, "callHandler");
function createWorkerInterface(workerData, config2) {
  return {
    run: /* @__PURE__ */ __name(() => runWorker$1(workerData, config2), "run")
  };
}
__name(createWorkerInterface, "createWorkerInterface");
function createWebWorkerInterface(workerData, config2) {
  const { baseURL: baseURL2, chunkSize } = config2;
  if (!workerData.interface) {
    let worker;
    try {
      worker = getWebWorker(workerData.scripts[0], baseURL2, workerData);
    } catch (error) {
      WEB_WORKERS_SUPPORTED = false;
      return createWorkerInterface(workerData, config2);
    }
    Object.assign(workerData, {
      worker,
      interface: {
        run: /* @__PURE__ */ __name(() => runWebWorker(workerData, { chunkSize }), "run")
      }
    });
  }
  return workerData.interface;
}
__name(createWebWorkerInterface, "createWebWorkerInterface");
async function runWorker$1({ options, readable: readable2, writable: writable2, onTaskFinished }, config2) {
  try {
    const codecStream = new CodecStream(options, config2);
    await readable2.pipeThrough(codecStream).pipeTo(writable2, { preventClose: true, preventAbort: true });
    const {
      signature,
      inputSize,
      outputSize
    } = codecStream;
    return {
      signature,
      inputSize,
      outputSize
    };
  } finally {
    onTaskFinished();
  }
}
__name(runWorker$1, "runWorker$1");
async function runWebWorker(workerData, config2) {
  let resolveResult, rejectResult;
  const result = new Promise((resolve2, reject) => {
    resolveResult = resolve2;
    rejectResult = reject;
  });
  Object.assign(workerData, {
    reader: null,
    writer: null,
    resolveResult,
    rejectResult,
    result
  });
  const { readable: readable2, options, scripts } = workerData;
  const { writable: writable2, closed } = watchClosedStream(workerData.writable);
  const streamsTransferred = sendMessage({
    type: MESSAGE_START,
    scripts: scripts.slice(1),
    options,
    config: config2,
    readable: readable2,
    writable: writable2
  }, workerData);
  if (!streamsTransferred) {
    Object.assign(workerData, {
      reader: readable2.getReader(),
      writer: writable2.getWriter()
    });
  }
  const resultValue = await result;
  if (!streamsTransferred) {
    await writable2.getWriter().close();
  }
  await closed;
  return resultValue;
}
__name(runWebWorker, "runWebWorker");
function watchClosedStream(writableSource) {
  let resolveStreamClosed;
  const closed = new Promise((resolve2) => resolveStreamClosed = resolve2);
  const writable2 = new WritableStream({
    async write(chunk) {
      const writer = writableSource.getWriter();
      await writer.ready;
      await writer.write(chunk);
      writer.releaseLock();
    },
    close() {
      resolveStreamClosed();
    },
    abort(reason) {
      const writer = writableSource.getWriter();
      return writer.abort(reason);
    }
  });
  return { writable: writable2, closed };
}
__name(watchClosedStream, "watchClosedStream");
let classicWorkersSupported = true;
let transferStreamsSupported = true;
function getWebWorker(url, baseURL2, workerData) {
  const workerOptions = { type: "module" };
  let scriptUrl, worker;
  if (typeof url == FUNCTION_TYPE) {
    url = url();
  }
  try {
    scriptUrl = new URL(url, baseURL2);
  } catch (_error) {
    scriptUrl = url;
  }
  if (classicWorkersSupported) {
    try {
      worker = new Worker(scriptUrl);
    } catch (_error) {
      classicWorkersSupported = false;
      worker = new Worker(scriptUrl, workerOptions);
    }
  } else {
    worker = new Worker(scriptUrl, workerOptions);
  }
  worker.addEventListener(MESSAGE_EVENT_TYPE, (event) => onMessage(event, workerData));
  return worker;
}
__name(getWebWorker, "getWebWorker");
function sendMessage(message, { worker, writer, onTaskFinished, transferStreams }) {
  try {
    let { value, readable: readable2, writable: writable2 } = message;
    const transferables = [];
    if (value) {
      if (value.byteLength < value.buffer.byteLength) {
        message.value = value.buffer.slice(0, value.byteLength);
      } else {
        message.value = value.buffer;
      }
      transferables.push(message.value);
    }
    if (transferStreams && transferStreamsSupported) {
      if (readable2) {
        transferables.push(readable2);
      }
      if (writable2) {
        transferables.push(writable2);
      }
    } else {
      message.readable = message.writable = null;
    }
    if (transferables.length) {
      try {
        worker.postMessage(message, transferables);
        return true;
      } catch (_error) {
        transferStreamsSupported = false;
        message.readable = message.writable = null;
        worker.postMessage(message);
      }
    } else {
      worker.postMessage(message);
    }
  } catch (error) {
    if (writer) {
      writer.releaseLock();
    }
    onTaskFinished();
    throw error;
  }
}
__name(sendMessage, "sendMessage");
async function onMessage({ data }, workerData) {
  const { type, value, messageId, result, error } = data;
  const { reader, writer, resolveResult, rejectResult, onTaskFinished } = workerData;
  try {
    if (error) {
      const { message, stack, code: code2, name } = error;
      const responseError = new Error(message);
      Object.assign(responseError, { stack, code: code2, name });
      close2(responseError);
    } else {
      if (type == MESSAGE_PULL) {
        const { value: value2, done } = await reader.read();
        sendMessage({ type: MESSAGE_DATA, value: value2, done, messageId }, workerData);
      }
      if (type == MESSAGE_DATA) {
        await writer.ready;
        await writer.write(new Uint8Array(value));
        sendMessage({ type: MESSAGE_ACK_DATA, messageId }, workerData);
      }
      if (type == MESSAGE_CLOSE) {
        close2(null, result);
      }
    }
  } catch (error2) {
    sendMessage({ type: MESSAGE_CLOSE, messageId }, workerData);
    close2(error2);
  }
  function close2(error2, result2) {
    if (error2) {
      rejectResult(error2);
    } else {
      resolveResult(result2);
    }
    if (writer) {
      writer.releaseLock();
    }
    onTaskFinished();
  }
  __name(close2, "close");
}
__name(onMessage, "onMessage");
let pool = [];
const pendingRequests = [];
let indexWorker = 0;
async function runWorker(stream2, workerOptions) {
  const { options, config: config2 } = workerOptions;
  const { transferStreams, useWebWorkers, useCompressionStream, codecType, compressed, signed, encrypted } = options;
  const { workerScripts, maxWorkers: maxWorkers2 } = config2;
  workerOptions.transferStreams = transferStreams || transferStreams === UNDEFINED_VALUE;
  const streamCopy = !compressed && !signed && !encrypted && !workerOptions.transferStreams;
  workerOptions.useWebWorkers = !streamCopy && (useWebWorkers || useWebWorkers === UNDEFINED_VALUE && config2.useWebWorkers);
  workerOptions.scripts = workerOptions.useWebWorkers && workerScripts ? workerScripts[codecType] : [];
  options.useCompressionStream = useCompressionStream || useCompressionStream === UNDEFINED_VALUE && config2.useCompressionStream;
  return (await getWorker()).run();
  async function getWorker() {
    const workerData = pool.find((workerData2) => !workerData2.busy);
    if (workerData) {
      clearTerminateTimeout(workerData);
      return new CodecWorker(workerData, stream2, workerOptions, onTaskFinished);
    } else if (pool.length < maxWorkers2) {
      const workerData2 = { indexWorker };
      indexWorker++;
      pool.push(workerData2);
      return new CodecWorker(workerData2, stream2, workerOptions, onTaskFinished);
    } else {
      return new Promise((resolve2) => pendingRequests.push({ resolve: resolve2, stream: stream2, workerOptions }));
    }
  }
  __name(getWorker, "getWorker");
  function onTaskFinished(workerData) {
    if (pendingRequests.length) {
      const [{ resolve: resolve2, stream: stream3, workerOptions: workerOptions2 }] = pendingRequests.splice(0, 1);
      resolve2(new CodecWorker(workerData, stream3, workerOptions2, onTaskFinished));
    } else if (workerData.worker) {
      clearTerminateTimeout(workerData);
      terminateWorker(workerData, workerOptions);
    } else {
      pool = pool.filter((data) => data != workerData);
    }
  }
  __name(onTaskFinished, "onTaskFinished");
}
__name(runWorker, "runWorker");
function terminateWorker(workerData, workerOptions) {
  const { config: config2 } = workerOptions;
  const { terminateWorkerTimeout } = config2;
  if (Number.isFinite(terminateWorkerTimeout) && terminateWorkerTimeout >= 0) {
    if (workerData.terminated) {
      workerData.terminated = false;
    } else {
      workerData.terminateTimeout = setTimeout(async () => {
        pool = pool.filter((data) => data != workerData);
        try {
          await workerData.terminate();
        } catch (_error) {
        }
      }, terminateWorkerTimeout);
    }
  }
}
__name(terminateWorker, "terminateWorker");
function clearTerminateTimeout(workerData) {
  const { terminateTimeout } = workerData;
  if (terminateTimeout) {
    clearTimeout(terminateTimeout);
    workerData.terminateTimeout = null;
  }
}
__name(clearTerminateTimeout, "clearTerminateTimeout");
function e(e2, t2 = {}) {
  const n = 'const{Array:e,Object:t,Number:n,Math:r,Error:s,Uint8Array:i,Uint16Array:o,Uint32Array:c,Int32Array:f,Map:a,DataView:l,Promise:u,TextEncoder:w,crypto:h,postMessage:d,TransformStream:p,ReadableStream:y,WritableStream:m,CompressionStream:b,DecompressionStream:g}=self,k=void 0,v="undefined",S="function";class z{constructor(e){return class extends p{constructor(t,n){const r=new e(n);super({transform(e,t){t.enqueue(r.append(e))},flush(e){const t=r.flush();t&&e.enqueue(t)}})}}}}const C=[];for(let e=0;256>e;e++){let t=e;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;C[e]=t}class x{constructor(e){this.t=e||-1}append(e){let t=0|this.t;for(let n=0,r=0|e.length;r>n;n++)t=t>>>8^C[255&(t^e[n])];this.t=t}get(){return~this.t}}class A extends p{constructor(){let e;const t=new x;super({transform(e,n){t.append(e),n.enqueue(e)},flush(){const n=new i(4);new l(n.buffer).setUint32(0,t.get()),e.value=n}}),e=this}}const _={concat(e,t){if(0===e.length||0===t.length)return e.concat(t);const n=e[e.length-1],r=_.i(n);return 32===r?e.concat(t):_.o(t,r,0|n,e.slice(0,e.length-1))},l(e){const t=e.length;if(0===t)return 0;const n=e[t-1];return 32*(t-1)+_.i(n)},u(e,t){if(32*e.length<t)return e;const n=(e=e.slice(0,r.ceil(t/32))).length;return t&=31,n>0&&t&&(e[n-1]=_.h(t,e[n-1]&2147483648>>t-1,1)),e},h:(e,t,n)=>32===e?t:(n?0|t:t<<32-e)+1099511627776*e,i:e=>r.round(e/1099511627776)||32,o(e,t,n,r){for(void 0===r&&(r=[]);t>=32;t-=32)r.push(n),n=0;if(0===t)return r.concat(e);for(let s=0;s<e.length;s++)r.push(n|e[s]>>>t),n=e[s]<<32-t;const s=e.length?e[e.length-1]:0,i=_.i(s);return r.push(_.h(t+i&31,t+i>32?n:r.pop(),1)),r}},I={p:{m(e){const t=_.l(e)/8,n=new i(t);let r;for(let s=0;t>s;s++)3&s||(r=e[s/4]),n[s]=r>>>24,r<<=8;return n},k(e){const t=[];let n,r=0;for(n=0;n<e.length;n++)r=r<<8|e[n],3&~n||(t.push(r),r=0);return 3&n&&t.push(_.h(8*(3&n),r)),t}}},P=class{constructor(e){const t=this;t.blockSize=512,t.v=[1732584193,4023233417,2562383102,271733878,3285377520],t.S=[1518500249,1859775393,2400959708,3395469782],e?(t.C=e.C.slice(0),t.A=e.A.slice(0),t._=e._):t.reset()}reset(){const e=this;return e.C=e.v.slice(0),e.A=[],e._=0,e}update(e){const t=this;"string"==typeof e&&(e=I.I.k(e));const n=t.A=_.concat(t.A,e),r=t._,i=t._=r+_.l(e);if(i>9007199254740991)throw new s("Cannot hash more than 2^53 - 1 bits");const o=new c(n);let f=0;for(let e=t.blockSize+r-(t.blockSize+r&t.blockSize-1);i>=e;e+=t.blockSize)t.P(o.subarray(16*f,16*(f+1))),f+=1;return n.splice(0,16*f),t}D(){const e=this;let t=e.A;const n=e.C;t=_.concat(t,[_.h(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(r.floor(e._/4294967296)),t.push(0|e._);t.length;)e.P(t.splice(0,16));return e.reset(),n}V(e,t,n,r){return e>19?e>39?e>59?e>79?void 0:t^n^r:t&n|t&r|n&r:t^n^r:t&n|~t&r}R(e,t){return t<<e|t>>>32-e}P(t){const n=this,s=n.C,i=e(80);for(let e=0;16>e;e++)i[e]=t[e];let o=s[0],c=s[1],f=s[2],a=s[3],l=s[4];for(let e=0;79>=e;e++){16>e||(i[e]=n.R(1,i[e-3]^i[e-8]^i[e-14]^i[e-16]));const t=n.R(5,o)+n.V(e,c,f,a)+l+i[e]+n.S[r.floor(e/20)]|0;l=a,a=f,f=n.R(30,c),c=o,o=t}s[0]=s[0]+o|0,s[1]=s[1]+c|0,s[2]=s[2]+f|0,s[3]=s[3]+a|0,s[4]=s[4]+l|0}},D={getRandomValues(e){const t=new c(e.buffer),n=e=>{let t=987654321;const n=4294967295;return()=>(t=36969*(65535&t)+(t>>16)&n,(((t<<16)+(e=18e3*(65535&e)+(e>>16)&n)&n)/4294967296+.5)*(r.random()>.5?1:-1))};for(let s,i=0;i<e.length;i+=4){const e=n(4294967296*(s||r.random()));s=987654071*e(),t[i/4]=4294967296*e()|0}return e}},V={importKey:e=>new V.B(I.p.k(e)),M(e,t,n,r){if(n=n||1e4,0>r||0>n)throw new s("invalid params to pbkdf2");const i=1+(r>>5)<<2;let o,c,f,a,u;const w=new ArrayBuffer(i),h=new l(w);let d=0;const p=_;for(t=I.p.k(t),u=1;(i||1)>d;u++){for(o=c=e.encrypt(p.concat(t,[u])),f=1;n>f;f++)for(c=e.encrypt(c),a=0;a<c.length;a++)o[a]^=c[a];for(f=0;(i||1)>d&&f<o.length;f++)h.setInt32(d,o[f]),d+=4}return w.slice(0,r/8)},B:class{constructor(e){const t=this,n=t.U=P,r=[[],[]];t.K=[new n,new n];const s=t.K[0].blockSize/32;e.length>s&&(e=(new n).update(e).D());for(let t=0;s>t;t++)r[0][t]=909522486^e[t],r[1][t]=1549556828^e[t];t.K[0].update(r[0]),t.K[1].update(r[1]),t.N=new n(t.K[0])}reset(){const e=this;e.N=new e.U(e.K[0]),e.O=!1}update(e){this.O=!0,this.N.update(e)}digest(){const e=this,t=e.N.D(),n=new e.U(e.K[1]).update(t).D();return e.reset(),n}encrypt(e){if(this.O)throw new s("encrypt on already updated hmac called!");return this.update(e),this.digest(e)}}},R=typeof h!=v&&typeof h.getRandomValues==S,B="Invalid password",E="Invalid signature",M="zipjs-abort-check-password";function U(e){return R?h.getRandomValues(e):D.getRandomValues(e)}const K=16,N={name:"PBKDF2"},O=t.assign({hash:{name:"HMAC"}},N),T=t.assign({iterations:1e3,hash:{name:"SHA-1"}},N),W=["deriveBits"],j=[8,12,16],H=[16,24,32],L=10,F=[0,0,0,0],q=typeof h!=v,G=q&&h.subtle,J=q&&typeof G!=v,Q=I.p,X=class{constructor(e){const t=this;t.T=[[[],[],[],[],[]],[[],[],[],[],[]]],t.T[0][0][0]||t.W();const n=t.T[0][4],r=t.T[1],i=e.length;let o,c,f,a=1;if(4!==i&&6!==i&&8!==i)throw new s("invalid aes key size");for(t.S=[c=e.slice(0),f=[]],o=i;4*i+28>o;o++){let e=c[o-1];(o%i==0||8===i&&o%i==4)&&(e=n[e>>>24]<<24^n[e>>16&255]<<16^n[e>>8&255]<<8^n[255&e],o%i==0&&(e=e<<8^e>>>24^a<<24,a=a<<1^283*(a>>7))),c[o]=c[o-i]^e}for(let e=0;o;e++,o--){const t=c[3&e?o:o-4];f[e]=4>=o||4>e?t:r[0][n[t>>>24]]^r[1][n[t>>16&255]]^r[2][n[t>>8&255]]^r[3][n[255&t]]}}encrypt(e){return this.j(e,0)}decrypt(e){return this.j(e,1)}W(){const e=this.T[0],t=this.T[1],n=e[4],r=t[4],s=[],i=[];let o,c,f,a;for(let e=0;256>e;e++)i[(s[e]=e<<1^283*(e>>7))^e]=e;for(let l=o=0;!n[l];l^=c||1,o=i[o]||1){let i=o^o<<1^o<<2^o<<3^o<<4;i=i>>8^255&i^99,n[l]=i,r[i]=l,a=s[f=s[c=s[l]]];let u=16843009*a^65537*f^257*c^16843008*l,w=257*s[i]^16843008*i;for(let n=0;4>n;n++)e[n][l]=w=w<<24^w>>>8,t[n][i]=u=u<<24^u>>>8}for(let n=0;5>n;n++)e[n]=e[n].slice(0),t[n]=t[n].slice(0)}j(e,t){if(4!==e.length)throw new s("invalid aes block size");const n=this.S[t],r=n.length/4-2,i=[0,0,0,0],o=this.T[t],c=o[0],f=o[1],a=o[2],l=o[3],u=o[4];let w,h,d,p=e[0]^n[0],y=e[t?3:1]^n[1],m=e[2]^n[2],b=e[t?1:3]^n[3],g=4;for(let e=0;r>e;e++)w=c[p>>>24]^f[y>>16&255]^a[m>>8&255]^l[255&b]^n[g],h=c[y>>>24]^f[m>>16&255]^a[b>>8&255]^l[255&p]^n[g+1],d=c[m>>>24]^f[b>>16&255]^a[p>>8&255]^l[255&y]^n[g+2],b=c[b>>>24]^f[p>>16&255]^a[y>>8&255]^l[255&m]^n[g+3],g+=4,p=w,y=h,m=d;for(let e=0;4>e;e++)i[t?3&-e:e]=u[p>>>24]<<24^u[y>>16&255]<<16^u[m>>8&255]<<8^u[255&b]^n[g++],w=p,p=y,y=m,m=b,b=w;return i}},Y=class{constructor(e,t){this.H=e,this.L=t,this.F=t}reset(){this.F=this.L}update(e){return this.q(this.H,e,this.F)}G(e){if(255&~(e>>24))e+=1<<24;else{let t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}return e}J(e){0===(e[0]=this.G(e[0]))&&(e[1]=this.G(e[1]))}q(e,t,n){let r;if(!(r=t.length))return[];const s=_.l(t);for(let s=0;r>s;s+=4){this.J(n);const r=e.encrypt(n);t[s]^=r[0],t[s+1]^=r[1],t[s+2]^=r[2],t[s+3]^=r[3]}return _.u(t,s)}},Z=V.B;let $=q&&J&&typeof G.importKey==S,ee=q&&J&&typeof G.deriveBits==S;class te extends p{constructor({password:e,rawPassword:n,signed:r,encryptionStrength:o,checkPasswordOnly:c}){super({start(){t.assign(this,{ready:new u((e=>this.X=e)),password:ie(e,n),signed:r,Y:o-1,pending:new i})},async transform(e,t){const n=this,{password:r,Y:o,X:f,ready:a}=n;r?(await(async(e,t,n,r)=>{const i=await se(e,t,n,ce(r,0,j[t])),o=ce(r,j[t]);if(i[0]!=o[0]||i[1]!=o[1])throw new s(B)})(n,o,r,ce(e,0,j[o]+2)),e=ce(e,j[o]+2),c?t.error(new s(M)):f()):await a;const l=new i(e.length-L-(e.length-L)%K);t.enqueue(re(n,e,l,0,L,!0))},async flush(e){const{signed:t,Z:n,$:r,pending:o,ready:c}=this;if(r&&n){await c;const f=ce(o,0,o.length-L),a=ce(o,o.length-L);let l=new i;if(f.length){const e=ae(Q,f);r.update(e);const t=n.update(e);l=fe(Q,t)}if(t){const e=ce(fe(Q,r.digest()),0,L);for(let t=0;L>t;t++)if(e[t]!=a[t])throw new s(E)}e.enqueue(l)}}})}}class ne extends p{constructor({password:e,rawPassword:n,encryptionStrength:r}){let s;super({start(){t.assign(this,{ready:new u((e=>this.X=e)),password:ie(e,n),Y:r-1,pending:new i})},async transform(e,t){const n=this,{password:r,Y:s,X:o,ready:c}=n;let f=new i;r?(f=await(async(e,t,n)=>{const r=U(new i(j[t]));return oe(r,await se(e,t,n,r))})(n,s,r),o()):await c;const a=new i(f.length+e.length-e.length%K);a.set(f,0),t.enqueue(re(n,e,a,f.length,0))},async flush(e){const{Z:t,$:n,pending:r,ready:o}=this;if(n&&t){await o;let c=new i;if(r.length){const e=t.update(ae(Q,r));n.update(e),c=fe(Q,e)}s.signature=fe(Q,n.digest()).slice(0,L),e.enqueue(oe(c,s.signature))}}}),s=this}}function re(e,t,n,r,s,o){const{Z:c,$:f,pending:a}=e,l=t.length-s;let u;for(a.length&&(t=oe(a,t),n=((e,t)=>{if(t&&t>e.length){const n=e;(e=new i(t)).set(n,0)}return e})(n,l-l%K)),u=0;l-K>=u;u+=K){const e=ae(Q,ce(t,u,u+K));o&&f.update(e);const s=c.update(e);o||f.update(s),n.set(fe(Q,s),u+r)}return e.pending=ce(t,u),n}async function se(n,r,s,o){n.password=null;const c=await(async(e,t,n,r,s)=>{if(!$)return V.importKey(t);try{return await G.importKey("raw",t,n,!1,s)}catch(e){return $=!1,V.importKey(t)}})(0,s,O,0,W),f=await(async(e,t,n)=>{if(!ee)return V.M(t,e.salt,T.iterations,n);try{return await G.deriveBits(e,t,n)}catch(r){return ee=!1,V.M(t,e.salt,T.iterations,n)}})(t.assign({salt:o},T),c,8*(2*H[r]+2)),a=new i(f),l=ae(Q,ce(a,0,H[r])),u=ae(Q,ce(a,H[r],2*H[r])),w=ce(a,2*H[r]);return t.assign(n,{keys:{key:l,ee:u,passwordVerification:w},Z:new Y(new X(l),e.from(F)),$:new Z(u)}),w}function ie(e,t){return t===k?(e=>{if(typeof w==v){const t=new i((e=unescape(encodeURIComponent(e))).length);for(let n=0;n<t.length;n++)t[n]=e.charCodeAt(n);return t}return(new w).encode(e)})(e):t}function oe(e,t){let n=e;return e.length+t.length&&(n=new i(e.length+t.length),n.set(e,0),n.set(t,e.length)),n}function ce(e,t,n){return e.subarray(t,n)}function fe(e,t){return e.m(t)}function ae(e,t){return e.k(t)}class le extends p{constructor({password:e,passwordVerification:n,checkPasswordOnly:r}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;if(n.password){const t=we(n,e.subarray(0,12));if(n.password=null,t[11]!=n.passwordVerification)throw new s(B);e=e.subarray(12)}r?t.error(new s(M)):t.enqueue(we(n,e))}})}}class ue extends p{constructor({password:e,passwordVerification:n}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;let r,s;if(n.password){n.password=null;const t=U(new i(12));t[11]=n.passwordVerification,r=new i(e.length+t.length),r.set(he(n,t),0),s=12}else r=new i(e.length),s=0;r.set(he(n,e),s),t.enqueue(r)}})}}function we(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,n[r]);return n}function he(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,t[r]);return n}function de(e,n){const r=[305419896,591751049,878082192];t.assign(e,{keys:r,te:new x(r[0]),ne:new x(r[2])});for(let t=0;t<n.length;t++)pe(e,n.charCodeAt(t))}function pe(e,t){let[n,s,i]=e.keys;e.te.append([t]),n=~e.te.get(),s=be(r.imul(be(s+me(n)),134775813)+1),e.ne.append([s>>>24]),i=~e.ne.get(),e.keys=[n,s,i]}function ye(e){const t=2|e.keys[2];return me(r.imul(t,1^t)>>>8)}function me(e){return 255&e}function be(e){return 4294967295&e}const ge="deflate-raw";class ke extends p{constructor(e,{chunkSize:t,CompressionStream:n,CompressionStreamNative:r}){super({});const{compressed:s,encrypted:i,useCompressionStream:o,zipCrypto:c,signed:f,level:a}=e,u=this;let w,h,d=Se(super.readable);i&&!c||!f||(w=new A,d=xe(d,w)),s&&(d=Ce(d,o,{level:a,chunkSize:t},r,n)),i&&(c?d=xe(d,new ue(e)):(h=new ne(e),d=xe(d,h))),ze(u,d,(()=>{let e;i&&!c&&(e=h.signature),i&&!c||!f||(e=new l(w.value.buffer).getUint32(0)),u.signature=e}))}}class ve extends p{constructor(e,{chunkSize:t,DecompressionStream:n,DecompressionStreamNative:r}){super({});const{zipCrypto:i,encrypted:o,signed:c,signature:f,compressed:a,useCompressionStream:u}=e;let w,h,d=Se(super.readable);o&&(i?d=xe(d,new le(e)):(h=new te(e),d=xe(d,h))),a&&(d=Ce(d,u,{chunkSize:t},r,n)),o&&!i||!c||(w=new A,d=xe(d,w)),ze(this,d,(()=>{if((!o||i)&&c){const e=new l(w.value.buffer);if(f!=e.getUint32(0,!1))throw new s(E)}}))}}function Se(e){return xe(e,new p({transform(e,t){e&&e.length&&t.enqueue(e)}}))}function ze(e,n,r){n=xe(n,new p({flush:r})),t.defineProperty(e,"readable",{get:()=>n})}function Ce(e,t,n,r,s){try{e=xe(e,new(t&&r?r:s)(ge,n))}catch(r){if(!t)return e;try{e=xe(e,new s(ge,n))}catch(t){return e}}return e}function xe(e,t){return e.pipeThrough(t)}const Ae="data",_e="close";class Ie extends p{constructor(e,n){super({});const r=this,{codecType:s}=e;let i;s.startsWith("deflate")?i=ke:s.startsWith("inflate")&&(i=ve);let o=0,c=0;const f=new i(e,n),a=super.readable,l=new p({transform(e,t){e&&e.length&&(c+=e.length,t.enqueue(e))},flush(){t.assign(r,{inputSize:c})}}),u=new p({transform(e,t){e&&e.length&&(o+=e.length,t.enqueue(e))},flush(){const{signature:e}=f;t.assign(r,{signature:e,outputSize:o,inputSize:c})}});t.defineProperty(r,"readable",{get:()=>a.pipeThrough(l).pipeThrough(f).pipeThrough(u)})}}class Pe extends p{constructor(e){let t;super({transform:function n(r,s){if(t){const e=new i(t.length+r.length);e.set(t),e.set(r,t.length),r=e,t=null}r.length>e?(s.enqueue(r.slice(0,e)),n(r.slice(e),s)):t=r},flush(e){t&&t.length&&e.enqueue(t)}})}}const De=new a,Ve=new a;let Re,Be=0,Ee=!0;async function Me(e){try{const{options:t,scripts:r,config:s}=e;if(r&&r.length)try{Ee?importScripts.apply(k,r):await Ue(r)}catch(e){Ee=!1,await Ue(r)}self.initCodec&&self.initCodec(),s.CompressionStreamNative=self.CompressionStream,s.DecompressionStreamNative=self.DecompressionStream,self.Deflate&&(s.CompressionStream=new z(self.Deflate)),self.Inflate&&(s.DecompressionStream=new z(self.Inflate));const i={highWaterMark:1},o=e.readable||new y({async pull(e){const t=new u((e=>De.set(Be,e)));Ke({type:"pull",messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER;const{value:r,done:s}=await t;e.enqueue(r),s&&e.close()}},i),c=e.writable||new m({async write(e){let t;const r=new u((e=>t=e));Ve.set(Be,t),Ke({type:Ae,value:e,messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER,await r}},i),f=new Ie(t,s);Re=new AbortController;const{signal:a}=Re;await o.pipeThrough(f).pipeThrough(new Pe(s.chunkSize)).pipeTo(c,{signal:a,preventClose:!0,preventAbort:!0}),await c.getWriter().close();const{signature:l,inputSize:w,outputSize:h}=f;Ke({type:_e,result:{signature:l,inputSize:w,outputSize:h}})}catch(e){Ne(e)}}async function Ue(e){for(const t of e)await import(t)}function Ke(e){let{value:t}=e;if(t)if(t.length)try{t=new i(t),e.value=t.buffer,d(e,[e.value])}catch(t){d(e)}else d(e);else d(e)}function Ne(e=new s("Unknown error")){const{message:t,stack:n,code:r,name:i}=e;d({error:{message:t,stack:n,code:r,name:i}})}addEventListener("message",(({data:e})=>{const{type:t,messageId:n,value:r,done:s}=e;try{if("start"==t&&Me(e),t==Ae){const e=De.get(n);De.delete(n),e({value:new i(r),done:s})}if("ack"==t){const e=Ve.get(n);Ve.delete(n),e()}t==_e&&Re.abort()}catch(e){Ne(e)}}));const Oe=-2;function Te(t){return We(t.map((([t,n])=>new e(t).fill(n,0,t))))}function We(t){return t.reduce(((t,n)=>t.concat(e.isArray(n)?We(n):n)),[])}const je=[0,1,2,3].concat(...Te([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function He(){const e=this;function t(e,t){let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1}e.re=n=>{const s=e.se,i=e.oe.ie,o=e.oe.ce;let c,f,a,l=-1;for(n.fe=0,n.ae=573,c=0;o>c;c++)0!==s[2*c]?(n.le[++n.fe]=l=c,n.ue[c]=0):s[2*c+1]=0;for(;2>n.fe;)a=n.le[++n.fe]=2>l?++l:0,s[2*a]=1,n.ue[a]=0,n.we--,i&&(n.he-=i[2*a+1]);for(e.de=l,c=r.floor(n.fe/2);c>=1;c--)n.pe(s,c);a=o;do{c=n.le[1],n.le[1]=n.le[n.fe--],n.pe(s,1),f=n.le[1],n.le[--n.ae]=c,n.le[--n.ae]=f,s[2*a]=s[2*c]+s[2*f],n.ue[a]=r.max(n.ue[c],n.ue[f])+1,s[2*c+1]=s[2*f+1]=a,n.le[1]=a++,n.pe(s,1)}while(n.fe>=2);n.le[--n.ae]=n.le[1],(t=>{const n=e.se,r=e.oe.ie,s=e.oe.ye,i=e.oe.me,o=e.oe.be;let c,f,a,l,u,w,h=0;for(l=0;15>=l;l++)t.ge[l]=0;for(n[2*t.le[t.ae]+1]=0,c=t.ae+1;573>c;c++)f=t.le[c],l=n[2*n[2*f+1]+1]+1,l>o&&(l=o,h++),n[2*f+1]=l,f>e.de||(t.ge[l]++,u=0,i>f||(u=s[f-i]),w=n[2*f],t.we+=w*(l+u),r&&(t.he+=w*(r[2*f+1]+u)));if(0!==h){do{for(l=o-1;0===t.ge[l];)l--;t.ge[l]--,t.ge[l+1]+=2,t.ge[o]--,h-=2}while(h>0);for(l=o;0!==l;l--)for(f=t.ge[l];0!==f;)a=t.le[--c],a>e.de||(n[2*a+1]!=l&&(t.we+=(l-n[2*a+1])*n[2*a],n[2*a+1]=l),f--)}})(n),((e,n,r)=>{const s=[];let i,o,c,f=0;for(i=1;15>=i;i++)s[i]=f=f+r[i-1]<<1;for(o=0;n>=o;o++)c=e[2*o+1],0!==c&&(e[2*o]=t(s[c]++,c))})(s,e.de,n.ge)}}function Le(e,t,n,r,s){const i=this;i.ie=e,i.ye=t,i.me=n,i.ce=r,i.be=s}He.ke=[0,1,2,3,4,5,6,7].concat(...Te([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),He.ve=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],He.Se=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],He.ze=e=>256>e?je[e]:je[256+(e>>>7)],He.Ce=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],He.xe=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],He.Ae=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],He._e=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];const Fe=Te([[144,8],[112,9],[24,7],[8,8]]);Le.Ie=We([12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254,1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241,9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249,5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245,13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253,19,275,147,403,83,339,211,467,51,307,179,435,115,371,243,499,11,267,139,395,75,331,203,459,43,299,171,427,107,363,235,491,27,283,155,411,91,347,219,475,59,315,187,443,123,379,251,507,7,263,135,391,71,327,199,455,39,295,167,423,103,359,231,487,23,279,151,407,87,343,215,471,55,311,183,439,119,375,247,503,15,271,143,399,79,335,207,463,47,303,175,431,111,367,239,495,31,287,159,415,95,351,223,479,63,319,191,447,127,383,255,511,0,64,32,96,16,80,48,112,8,72,40,104,24,88,56,120,4,68,36,100,20,84,52,116,3,131,67,195,35,163,99,227].map(((e,t)=>[e,Fe[t]])));const qe=Te([[30,5]]);function Ge(e,t,n,r,s){const i=this;i.Pe=e,i.De=t,i.Ve=n,i.Re=r,i.Be=s}Le.Ee=We([0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,30,1,17,9,25,5,21,13,29,3,19,11,27,7,23].map(((e,t)=>[e,qe[t]]))),Le.Me=new Le(Le.Ie,He.Ce,257,286,15),Le.Ue=new Le(Le.Ee,He.xe,0,30,15),Le.Ke=new Le(null,He.Ae,0,19,7);const Je=[new Ge(0,0,0,0,0),new Ge(4,4,8,4,1),new Ge(4,5,16,8,1),new Ge(4,6,32,32,1),new Ge(4,4,16,16,2),new Ge(8,16,32,32,2),new Ge(8,16,128,128,2),new Ge(8,32,128,256,2),new Ge(32,128,258,1024,2),new Ge(32,258,258,4096,2)],Qe=["need dictionary","stream end","","","stream error","data error","","buffer error","",""],Xe=113,Ye=666,Ze=262;function $e(e,t,n,r){const s=e[2*t],i=e[2*n];return i>s||s==i&&r[t]<=r[n]}function et(){const e=this;let t,n,s,c,f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z,C,x,A,_,I,P,D,V,R,B,E,M,U;const K=new He,N=new He,O=new He;let T,W,j,H,L,F;function q(){let t;for(t=0;286>t;t++)E[2*t]=0;for(t=0;30>t;t++)M[2*t]=0;for(t=0;19>t;t++)U[2*t]=0;E[512]=1,e.we=e.he=0,W=j=0}function G(e,t){let n,r=-1,s=e[1],i=0,o=7,c=4;0===s&&(o=138,c=3),e[2*(t+1)+1]=65535;for(let f=0;t>=f;f++)n=s,s=e[2*(f+1)+1],++i<o&&n==s||(c>i?U[2*n]+=i:0!==n?(n!=r&&U[2*n]++,U[32]++):i>10?U[36]++:U[34]++,i=0,r=n,0===s?(o=138,c=3):n==s?(o=6,c=3):(o=7,c=4))}function J(t){e.Ne[e.pending++]=t}function Q(e){J(255&e),J(e>>>8&255)}function X(e,t){let n;const r=t;F>16-r?(n=e,L|=n<<F&65535,Q(L),L=n>>>16-F,F+=r-16):(L|=e<<F&65535,F+=r)}function Y(e,t){const n=2*e;X(65535&t[n],65535&t[n+1])}function Z(e,t){let n,r,s=-1,i=e[1],o=0,c=7,f=4;for(0===i&&(c=138,f=3),n=0;t>=n;n++)if(r=i,i=e[2*(n+1)+1],++o>=c||r!=i){if(f>o)do{Y(r,U)}while(0!=--o);else 0!==r?(r!=s&&(Y(r,U),o--),Y(16,U),X(o-3,2)):o>10?(Y(18,U),X(o-11,7)):(Y(17,U),X(o-3,3));o=0,s=r,0===i?(c=138,f=3):r==i?(c=6,f=3):(c=7,f=4)}}function $(){16==F?(Q(L),L=0,F=0):8>F||(J(255&L),L>>>=8,F-=8)}function ee(t,n){let s,i,o;if(e.Oe[W]=t,e.Te[W]=255&n,W++,0===t?E[2*n]++:(j++,t--,E[2*(He.ke[n]+256+1)]++,M[2*He.ze(t)]++),!(8191&W)&&D>2){for(s=8*W,i=C-k,o=0;30>o;o++)s+=M[2*o]*(5+He.xe[o]);if(s>>>=3,j<r.floor(W/2)&&s<r.floor(i/2))return!0}return W==T-1}function te(t,n){let r,s,i,o,c=0;if(0!==W)do{r=e.Oe[c],s=e.Te[c],c++,0===r?Y(s,t):(i=He.ke[s],Y(i+256+1,t),o=He.Ce[i],0!==o&&(s-=He.ve[i],X(s,o)),r--,i=He.ze(r),Y(i,n),o=He.xe[i],0!==o&&(r-=He.Se[i],X(r,o)))}while(W>c);Y(256,t),H=t[513]}function ne(){F>8?Q(L):F>0&&J(255&L),L=0,F=0}function re(t,n,r){X(0+(r?1:0),3),((t,n)=>{ne(),H=8,Q(n),Q(~n),e.Ne.set(u.subarray(t,t+n),e.pending),e.pending+=n})(t,n)}function se(n){((t,n,r)=>{let s,i,o=0;D>0?(K.re(e),N.re(e),o=(()=>{let t;for(G(E,K.de),G(M,N.de),O.re(e),t=18;t>=3&&0===U[2*He._e[t]+1];t--);return e.we+=14+3*(t+1),t})(),s=e.we+3+7>>>3,i=e.he+3+7>>>3,i>s||(s=i)):s=i=n+5,n+4>s||-1==t?i==s?(X(2+(r?1:0),3),te(Le.Ie,Le.Ee)):(X(4+(r?1:0),3),((e,t,n)=>{let r;for(X(e-257,5),X(t-1,5),X(n-4,4),r=0;n>r;r++)X(U[2*He._e[r]+1],3);Z(E,e-1),Z(M,t-1)})(K.de+1,N.de+1,o+1),te(E,M)):re(t,n,r),q(),r&&ne()})(0>k?-1:k,C-k,n),k=C,t.We()}function ie(){let e,n,r,s;do{if(s=w-A-C,0===s&&0===C&&0===A)s=f;else if(-1==s)s--;else if(C>=f+f-Ze){u.set(u.subarray(f,f+f),0),x-=f,C-=f,k-=f,e=y,r=e;do{n=65535&d[--r],d[r]=f>n?0:n-f}while(0!=--e);e=f,r=e;do{n=65535&h[--r],h[r]=f>n?0:n-f}while(0!=--e);s+=f}if(0===t.je)return;e=t.He(u,C+A,s),A+=e,3>A||(p=255&u[C],p=(p<<g^255&u[C+1])&b)}while(Ze>A&&0!==t.je)}function oe(e){let t,n,r=I,s=C,i=_;const o=C>f-Ze?C-(f-Ze):0;let c=B;const a=l,w=C+258;let d=u[s+i-1],p=u[s+i];R>_||(r>>=2),c>A&&(c=A);do{if(t=e,u[t+i]==p&&u[t+i-1]==d&&u[t]==u[s]&&u[++t]==u[s+1]){s+=2,t++;do{}while(u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&w>s);if(n=258-(w-s),s=w-258,n>i){if(x=e,i=n,n>=c)break;d=u[s+i-1],p=u[s+i]}}}while((e=65535&h[e&a])>o&&0!=--r);return i>A?A:i}e.ue=[],e.ge=[],e.le=[],E=[],M=[],U=[],e.pe=(t,n)=>{const r=e.le,s=r[n];let i=n<<1;for(;i<=e.fe&&(i<e.fe&&$e(t,r[i+1],r[i],e.ue)&&i++,!$e(t,s,r[i],e.ue));)r[n]=r[i],n=i,i<<=1;r[n]=s},e.Le=(t,S,x,W,j,G)=>(W||(W=8),j||(j=8),G||(G=0),t.Fe=null,-1==S&&(S=6),1>j||j>9||8!=W||9>x||x>15||0>S||S>9||0>G||G>2?Oe:(t.qe=e,a=x,f=1<<a,l=f-1,m=j+7,y=1<<m,b=y-1,g=r.floor((m+3-1)/3),u=new i(2*f),h=[],d=[],T=1<<j+6,e.Ne=new i(4*T),s=4*T,e.Oe=new o(T),e.Te=new i(T),D=S,V=G,(t=>(t.Ge=t.Je=0,t.Fe=null,e.pending=0,e.Qe=0,n=Xe,c=0,K.se=E,K.oe=Le.Me,N.se=M,N.oe=Le.Ue,O.se=U,O.oe=Le.Ke,L=0,F=0,H=8,q(),(()=>{w=2*f,d[y-1]=0;for(let e=0;y-1>e;e++)d[e]=0;P=Je[D].De,R=Je[D].Pe,B=Je[D].Ve,I=Je[D].Re,C=0,k=0,A=0,v=_=2,z=0,p=0})(),0))(t))),e.Xe=()=>42!=n&&n!=Xe&&n!=Ye?Oe:(e.Te=null,e.Oe=null,e.Ne=null,d=null,h=null,u=null,e.qe=null,n==Xe?-3:0),e.Ye=(e,t,n)=>{let r=0;return-1==t&&(t=6),0>t||t>9||0>n||n>2?Oe:(Je[D].Be!=Je[t].Be&&0!==e.Ge&&(r=e.Ze(1)),D!=t&&(D=t,P=Je[D].De,R=Je[D].Pe,B=Je[D].Ve,I=Je[D].Re),V=n,r)},e.$e=(e,t,r)=>{let s,i=r,o=0;if(!t||42!=n)return Oe;if(3>i)return 0;for(i>f-Ze&&(i=f-Ze,o=r-i),u.set(t.subarray(o,o+i),0),C=i,k=i,p=255&u[0],p=(p<<g^255&u[1])&b,s=0;i-3>=s;s++)p=(p<<g^255&u[s+2])&b,h[s&l]=d[p],d[p]=s;return 0},e.Ze=(r,i)=>{let o,w,m,I,R;if(i>4||0>i)return Oe;if(!r.et||!r.tt&&0!==r.je||n==Ye&&4!=i)return r.Fe=Qe[4],Oe;if(0===r.nt)return r.Fe=Qe[7],-5;var B;if(t=r,I=c,c=i,42==n&&(w=8+(a-8<<4)<<8,m=(D-1&255)>>1,m>3&&(m=3),w|=m<<6,0!==C&&(w|=32),w+=31-w%31,n=Xe,J((B=w)>>8&255),J(255&B)),0!==e.pending){if(t.We(),0===t.nt)return c=-1,0}else if(0===t.je&&I>=i&&4!=i)return t.Fe=Qe[7],-5;if(n==Ye&&0!==t.je)return r.Fe=Qe[7],-5;if(0!==t.je||0!==A||0!=i&&n!=Ye){switch(R=-1,Je[D].Be){case 0:R=(e=>{let n,r=65535;for(r>s-5&&(r=s-5);;){if(1>=A){if(ie(),0===A&&0==e)return 0;if(0===A)break}if(C+=A,A=0,n=k+r,(0===C||C>=n)&&(A=C-n,C=n,se(!1),0===t.nt))return 0;if(C-k>=f-Ze&&(se(!1),0===t.nt))return 0}return se(4==e),0===t.nt?4==e?2:0:4==e?3:1})(i);break;case 1:R=(e=>{let n,r=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C),0===r||(C-r&65535)>f-Ze||2!=V&&(v=oe(r)),3>v)n=ee(0,255&u[C]),A--,C++;else if(n=ee(C-x,v-3),A-=v,v>P||3>A)C+=v,v=0,p=255&u[C],p=(p<<g^255&u[C+1])&b;else{v--;do{C++,p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C}while(0!=--v);C++}if(n&&(se(!1),0===t.nt))return 0}return se(4==e),0===t.nt?4==e?2:0:4==e?3:1})(i);break;case 2:R=(e=>{let n,r,s=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C),_=v,S=x,v=2,0!==s&&P>_&&f-Ze>=(C-s&65535)&&(2!=V&&(v=oe(s)),5>=v&&(1==V||3==v&&C-x>4096)&&(v=2)),3>_||v>_)if(0!==z){if(n=ee(0,255&u[C-1]),n&&se(!1),C++,A--,0===t.nt)return 0}else z=1,C++,A--;else{r=C+A-3,n=ee(C-1-S,_-3),A-=_-1,_-=2;do{++C>r||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C)}while(0!=--_);if(z=0,v=2,C++,n&&(se(!1),0===t.nt))return 0}}return 0!==z&&(n=ee(0,255&u[C-1]),z=0),se(4==e),0===t.nt?4==e?2:0:4==e?3:1})(i)}if(2!=R&&3!=R||(n=Ye),0==R||2==R)return 0===t.nt&&(c=-1),0;if(1==R){if(1==i)X(2,3),Y(256,Le.Ie),$(),9>1+H+10-F&&(X(2,3),Y(256,Le.Ie),$()),H=7;else if(re(0,0,!1),3==i)for(o=0;y>o;o++)d[o]=0;if(t.We(),0===t.nt)return c=-1,0}}return 4!=i?0:1}}function tt(){const e=this;e.rt=0,e.st=0,e.je=0,e.Ge=0,e.nt=0,e.Je=0}function nt(e){const t=new tt,n=(o=e&&e.chunkSize?e.chunkSize:65536)+5*(r.floor(o/16383)+1);var o;const c=new i(n);let f=e?e.level:-1;void 0===f&&(f=-1),t.Le(f),t.et=c,this.append=(e,r)=>{let o,f,a=0,l=0,u=0;const w=[];if(e.length){t.rt=0,t.tt=e,t.je=e.length;do{if(t.st=0,t.nt=n,o=t.Ze(0),0!=o)throw new s("deflating: "+t.Fe);t.st&&(t.st==n?w.push(new i(c)):w.push(c.subarray(0,t.st))),u+=t.st,r&&t.rt>0&&t.rt!=a&&(r(t.rt),a=t.rt)}while(t.je>0||0===t.nt);return w.length>1?(f=new i(u),w.forEach((e=>{f.set(e,l),l+=e.length}))):f=w[0]?new i(w[0]):new i,f}},this.flush=()=>{let e,r,o=0,f=0;const a=[];do{if(t.st=0,t.nt=n,e=t.Ze(4),1!=e&&0!=e)throw new s("deflating: "+t.Fe);n-t.nt>0&&a.push(c.slice(0,t.st)),f+=t.st}while(t.je>0||0===t.nt);return t.Xe(),r=new i(f),a.forEach((e=>{r.set(e,o),o+=e.length})),r}}tt.prototype={Le(e,t){const n=this;return n.qe=new et,t||(t=15),n.qe.Le(n,e,t)},Ze(e){const t=this;return t.qe?t.qe.Ze(t,e):Oe},Xe(){const e=this;if(!e.qe)return Oe;const t=e.qe.Xe();return e.qe=null,t},Ye(e,t){const n=this;return n.qe?n.qe.Ye(n,e,t):Oe},$e(e,t){const n=this;return n.qe?n.qe.$e(n,e,t):Oe},He(e,t,n){const r=this;let s=r.je;return s>n&&(s=n),0===s?0:(r.je-=s,e.set(r.tt.subarray(r.rt,r.rt+s),t),r.rt+=s,r.Ge+=s,s)},We(){const e=this;let t=e.qe.pending;t>e.nt&&(t=e.nt),0!==t&&(e.et.set(e.qe.Ne.subarray(e.qe.Qe,e.qe.Qe+t),e.st),e.st+=t,e.qe.Qe+=t,e.Je+=t,e.nt-=t,e.qe.pending-=t,0===e.qe.pending&&(e.qe.Qe=0))}};const rt=-2,st=-3,it=-5,ot=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],ct=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],ft=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],at=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],lt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],ut=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],wt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function ht(){let e,t,n,r,s,i;function o(e,t,o,c,f,a,l,u,w,h,d){let p,y,m,b,g,k,v,S,z,C,x,A,_,I,P;C=0,g=o;do{n[e[t+C]]++,C++,g--}while(0!==g);if(n[0]==o)return l[0]=-1,u[0]=0,0;for(S=u[0],k=1;15>=k&&0===n[k];k++);for(v=k,k>S&&(S=k),g=15;0!==g&&0===n[g];g--);for(m=g,S>g&&(S=g),u[0]=S,I=1<<k;g>k;k++,I<<=1)if(0>(I-=n[k]))return st;if(0>(I-=n[g]))return st;for(n[g]+=I,i[1]=k=0,C=1,_=2;0!=--g;)i[_]=k+=n[C],_++,C++;g=0,C=0;do{0!==(k=e[t+C])&&(d[i[k]++]=g),C++}while(++g<o);for(o=i[m],i[0]=g=0,C=0,b=-1,A=-S,s[0]=0,x=0,P=0;m>=v;v++)for(p=n[v];0!=p--;){for(;v>A+S;){if(b++,A+=S,P=m-A,P=P>S?S:P,(y=1<<(k=v-A))>p+1&&(y-=p+1,_=v,P>k))for(;++k<P&&(y<<=1)>n[++_];)y-=n[_];if(P=1<<k,h[0]+P>1440)return st;s[b]=x=h[0],h[0]+=P,0!==b?(i[b]=g,r[0]=k,r[1]=S,k=g>>>A-S,r[2]=x-s[b-1]-k,w.set(r,3*(s[b-1]+k))):l[0]=x}for(r[1]=v-A,o>C?d[C]<c?(r[0]=256>d[C]?0:96,r[2]=d[C++]):(r[0]=a[d[C]-c]+16+64,r[2]=f[d[C++]-c]):r[0]=192,y=1<<v-A,k=g>>>A;P>k;k+=y)w.set(r,3*(x+k));for(k=1<<v-1;g&k;k>>>=1)g^=k;for(g^=k,z=(1<<A)-1;(g&z)!=i[b];)b--,A-=S,z=(1<<A)-1}return 0!==I&&1!=m?it:0}function c(o){let c;for(e||(e=[],t=[],n=new f(16),r=[],s=new f(15),i=new f(16)),t.length<o&&(t=[]),c=0;o>c;c++)t[c]=0;for(c=0;16>c;c++)n[c]=0;for(c=0;3>c;c++)r[c]=0;s.set(n.subarray(0,15),0),i.set(n.subarray(0,16),0)}this.it=(n,r,s,i,f)=>{let a;return c(19),e[0]=0,a=o(n,0,19,19,null,null,s,r,i,e,t),a==st?f.Fe="oversubscribed dynamic bit lengths tree":a!=it&&0!==r[0]||(f.Fe="incomplete dynamic bit lengths tree",a=st),a},this.ot=(n,r,s,i,f,a,l,u,w)=>{let h;return c(288),e[0]=0,h=o(s,0,n,257,at,lt,a,i,u,e,t),0!=h||0===i[0]?(h==st?w.Fe="oversubscribed literal/length tree":-4!=h&&(w.Fe="incomplete literal/length tree",h=st),h):(c(288),h=o(s,n,r,0,ut,wt,l,f,u,e,t),0!=h||0===f[0]&&n>257?(h==st?w.Fe="oversubscribed distance tree":h==it?(w.Fe="incomplete distance tree",h=st):-4!=h&&(w.Fe="empty distance tree with lengths",h=st),h):0)}}function dt(){const e=this;let t,n,r,s,i=0,o=0,c=0,f=0,a=0,l=0,u=0,w=0,h=0,d=0;function p(e,t,n,r,s,i,o,c){let f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z;d=c.rt,p=c.je,w=o.ct,h=o.ft,y=o.write,m=y<o.read?o.read-y-1:o.end-y,b=ot[e],g=ot[t];do{for(;20>h;)p--,w|=(255&c.lt(d++))<<h,h+=8;if(f=w&b,a=n,l=r,z=3*(l+f),0!==(u=a[z]))for(;;){if(w>>=a[z+1],h-=a[z+1],16&u){for(u&=15,k=a[z+2]+(w&ot[u]),w>>=u,h-=u;15>h;)p--,w|=(255&c.lt(d++))<<h,h+=8;for(f=w&g,a=s,l=i,z=3*(l+f),u=a[z];;){if(w>>=a[z+1],h-=a[z+1],16&u){for(u&=15;u>h;)p--,w|=(255&c.lt(d++))<<h,h+=8;if(v=a[z+2]+(w&ot[u]),w>>=u,h-=u,m-=k,v>y){S=y-v;do{S+=o.end}while(0>S);if(u=o.end-S,k>u){if(k-=u,y-S>0&&u>y-S)do{o.ut[y++]=o.ut[S++]}while(0!=--u);else o.ut.set(o.ut.subarray(S,S+u),y),y+=u,S+=u,u=0;S=0}}else S=y-v,y-S>0&&2>y-S?(o.ut[y++]=o.ut[S++],o.ut[y++]=o.ut[S++],k-=2):(o.ut.set(o.ut.subarray(S,S+2),y),y+=2,S+=2,k-=2);if(y-S>0&&k>y-S)do{o.ut[y++]=o.ut[S++]}while(0!=--k);else o.ut.set(o.ut.subarray(S,S+k),y),y+=k,S+=k,k=0;break}if(64&u)return c.Fe="invalid distance code",k=c.je-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ct=w,o.ft=h,c.je=p,c.Ge+=d-c.rt,c.rt=d,o.write=y,st;f+=a[z+2],f+=w&ot[u],z=3*(l+f),u=a[z]}break}if(64&u)return 32&u?(k=c.je-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ct=w,o.ft=h,c.je=p,c.Ge+=d-c.rt,c.rt=d,o.write=y,1):(c.Fe="invalid literal/length code",k=c.je-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ct=w,o.ft=h,c.je=p,c.Ge+=d-c.rt,c.rt=d,o.write=y,st);if(f+=a[z+2],f+=w&ot[u],z=3*(l+f),0===(u=a[z])){w>>=a[z+1],h-=a[z+1],o.ut[y++]=a[z+2],m--;break}}else w>>=a[z+1],h-=a[z+1],o.ut[y++]=a[z+2],m--}while(m>=258&&p>=10);return k=c.je-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ct=w,o.ft=h,c.je=p,c.Ge+=d-c.rt,c.rt=d,o.write=y,0}e.init=(e,i,o,c,f,a)=>{t=0,u=e,w=i,r=o,h=c,s=f,d=a,n=null},e.wt=(e,y,m)=>{let b,g,k,v,S,z,C,x=0,A=0,_=0;for(_=y.rt,v=y.je,x=e.ct,A=e.ft,S=e.write,z=S<e.read?e.read-S-1:e.end-S;;)switch(t){case 0:if(z>=258&&v>=10&&(e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,m=p(u,w,r,h,s,d,e,y),_=y.rt,v=y.je,x=e.ct,A=e.ft,S=e.write,z=S<e.read?e.read-S-1:e.end-S,0!=m)){t=1==m?7:9;break}c=u,n=r,o=h,t=1;case 1:for(b=c;b>A;){if(0===v)return e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);m=0,v--,x|=(255&y.lt(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>>=n[g+1],A-=n[g+1],k=n[g],0===k){f=n[g+2],t=6;break}if(16&k){a=15&k,i=n[g+2],t=2;break}if(!(64&k)){c=k,o=g/3+n[g+2];break}if(32&k){t=7;break}return t=9,y.Fe="invalid literal/length code",m=st,e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);case 2:for(b=a;b>A;){if(0===v)return e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);m=0,v--,x|=(255&y.lt(_++))<<A,A+=8}i+=x&ot[b],x>>=b,A-=b,c=w,n=s,o=d,t=3;case 3:for(b=c;b>A;){if(0===v)return e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);m=0,v--,x|=(255&y.lt(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>=n[g+1],A-=n[g+1],k=n[g],16&k){a=15&k,l=n[g+2],t=4;break}if(!(64&k)){c=k,o=g/3+n[g+2];break}return t=9,y.Fe="invalid distance code",m=st,e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);case 4:for(b=a;b>A;){if(0===v)return e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);m=0,v--,x|=(255&y.lt(_++))<<A,A+=8}l+=x&ot[b],x>>=b,A-=b,t=5;case 5:for(C=S-l;0>C;)C+=e.end;for(;0!==i;){if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.ht(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);e.ut[S++]=e.ut[C++],z--,C==e.end&&(C=0),i--}t=0;break;case 6:if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.ht(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);m=0,e.ut[S++]=f,z--,t=0;break;case 7:if(A>7&&(A-=8,v++,_--),e.write=S,m=e.ht(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,e.read!=e.write)return e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);t=8;case 8:return m=1,e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);case 9:return m=st,e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);default:return m=rt,e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m)}},e.dt=()=>{}}ht.yt=(e,t,n,r)=>(e[0]=9,t[0]=5,n[0]=ct,r[0]=ft,0);const pt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function yt(e,t){const n=this;let r,s=0,o=0,c=0,a=0;const l=[0],u=[0],w=new dt;let h=0,d=new f(4320);const p=new ht;n.ft=0,n.ct=0,n.ut=new i(t),n.end=t,n.read=0,n.write=0,n.reset=(e,t)=>{t&&(t[0]=0),6==s&&w.dt(e),s=0,n.ft=0,n.ct=0,n.read=n.write=0},n.reset(e,null),n.ht=(e,t)=>{let r,s,i;return s=e.st,i=n.read,r=(i>n.write?n.end:n.write)-i,r>e.nt&&(r=e.nt),0!==r&&t==it&&(t=0),e.nt-=r,e.Je+=r,e.et.set(n.ut.subarray(i,i+r),s),s+=r,i+=r,i==n.end&&(i=0,n.write==n.end&&(n.write=0),r=n.write-i,r>e.nt&&(r=e.nt),0!==r&&t==it&&(t=0),e.nt-=r,e.Je+=r,e.et.set(n.ut.subarray(i,i+r),s),s+=r,i+=r),e.st=s,n.read=i,t},n.wt=(e,t)=>{let i,f,y,m,b,g,k,v;for(m=e.rt,b=e.je,f=n.ct,y=n.ft,g=n.write,k=g<n.read?n.read-g-1:n.end-g;;){let S,z,C,x,A,_,I,P;switch(s){case 0:for(;3>y;){if(0===b)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);t=0,b--,f|=(255&e.lt(m++))<<y,y+=8}switch(i=7&f,h=1&i,i>>>1){case 0:f>>>=3,y-=3,i=7&y,f>>>=i,y-=i,s=1;break;case 1:S=[],z=[],C=[[]],x=[[]],ht.yt(S,z,C,x),w.init(S[0],z[0],C[0],0,x[0],0),f>>>=3,y-=3,s=6;break;case 2:f>>>=3,y-=3,s=3;break;case 3:return f>>>=3,y-=3,s=9,e.Fe="invalid block type",t=st,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t)}break;case 1:for(;32>y;){if(0===b)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);t=0,b--,f|=(255&e.lt(m++))<<y,y+=8}if((~f>>>16&65535)!=(65535&f))return s=9,e.Fe="invalid stored block lengths",t=st,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);o=65535&f,f=y=0,s=0!==o?2:0!==h?7:0;break;case 2:if(0===b)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);if(0===k&&(g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k&&(n.write=g,t=n.ht(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k)))return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);if(t=0,i=o,i>b&&(i=b),i>k&&(i=k),n.ut.set(e.He(m,i),g),m+=i,b-=i,g+=i,k-=i,0!=(o-=i))break;s=0!==h?7:0;break;case 3:for(;14>y;){if(0===b)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);t=0,b--,f|=(255&e.lt(m++))<<y,y+=8}if(c=i=16383&f,(31&i)>29||(i>>5&31)>29)return s=9,e.Fe="too many length or distance symbols",t=st,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);if(i=258+(31&i)+(i>>5&31),!r||r.length<i)r=[];else for(v=0;i>v;v++)r[v]=0;f>>>=14,y-=14,a=0,s=4;case 4:for(;4+(c>>>10)>a;){for(;3>y;){if(0===b)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);t=0,b--,f|=(255&e.lt(m++))<<y,y+=8}r[pt[a++]]=7&f,f>>>=3,y-=3}for(;19>a;)r[pt[a++]]=0;if(l[0]=7,i=p.it(r,l,u,d,e),0!=i)return(t=i)==st&&(r=null,s=9),n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);a=0,s=5;case 5:for(;i=c,258+(31&i)+(i>>5&31)>a;){let o,w;for(i=l[0];i>y;){if(0===b)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);t=0,b--,f|=(255&e.lt(m++))<<y,y+=8}if(i=d[3*(u[0]+(f&ot[i]))+1],w=d[3*(u[0]+(f&ot[i]))+2],16>w)f>>>=i,y-=i,r[a++]=w;else{for(v=18==w?7:w-14,o=18==w?11:3;i+v>y;){if(0===b)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);t=0,b--,f|=(255&e.lt(m++))<<y,y+=8}if(f>>>=i,y-=i,o+=f&ot[v],f>>>=v,y-=v,v=a,i=c,v+o>258+(31&i)+(i>>5&31)||16==w&&1>v)return r=null,s=9,e.Fe="invalid bit length repeat",t=st,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);w=16==w?r[v-1]:0;do{r[v++]=w}while(0!=--o);a=v}}if(u[0]=-1,A=[],_=[],I=[],P=[],A[0]=9,_[0]=6,i=c,i=p.ot(257+(31&i),1+(i>>5&31),r,A,_,I,P,d,e),0!=i)return i==st&&(r=null,s=9),t=i,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);w.init(A[0],_[0],d,I[0],d,P[0]),s=6;case 6:if(n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,1!=(t=w.wt(n,e,t)))return n.ht(e,t);if(t=0,w.dt(e),m=e.rt,b=e.je,f=n.ct,y=n.ft,g=n.write,k=g<n.read?n.read-g-1:n.end-g,0===h){s=0;break}s=7;case 7:if(n.write=g,t=n.ht(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);s=8;case 8:return t=1,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);case 9:return t=st,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);default:return t=rt,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t)}}},n.dt=e=>{n.reset(e,null),n.ut=null,d=null},n.bt=(e,t,r)=>{n.ut.set(e.subarray(t,t+r),0),n.read=n.write=r},n.gt=()=>1==s?1:0}const mt=13,bt=[0,0,255,255];function gt(){const e=this;function t(e){return e&&e.kt?(e.Ge=e.Je=0,e.Fe=null,e.kt.mode=7,e.kt.vt.reset(e,null),0):rt}e.mode=0,e.method=0,e.St=[0],e.zt=0,e.marker=0,e.Ct=0,e.xt=t=>(e.vt&&e.vt.dt(t),e.vt=null,0),e.At=(n,r)=>(n.Fe=null,e.vt=null,8>r||r>15?(e.xt(n),rt):(e.Ct=r,n.kt.vt=new yt(n,1<<r),t(n),0)),e._t=(e,t)=>{let n,r;if(!e||!e.kt||!e.tt)return rt;const s=e.kt;for(t=4==t?it:0,n=it;;)switch(s.mode){case 0:if(0===e.je)return n;if(n=t,e.je--,e.Ge++,8!=(15&(s.method=e.lt(e.rt++)))){s.mode=mt,e.Fe="unknown compression method",s.marker=5;break}if(8+(s.method>>4)>s.Ct){s.mode=mt,e.Fe="invalid win size",s.marker=5;break}s.mode=1;case 1:if(0===e.je)return n;if(n=t,e.je--,e.Ge++,r=255&e.lt(e.rt++),((s.method<<8)+r)%31!=0){s.mode=mt,e.Fe="incorrect header check",s.marker=5;break}if(!(32&r)){s.mode=7;break}s.mode=2;case 2:if(0===e.je)return n;n=t,e.je--,e.Ge++,s.zt=(255&e.lt(e.rt++))<<24&4278190080,s.mode=3;case 3:if(0===e.je)return n;n=t,e.je--,e.Ge++,s.zt+=(255&e.lt(e.rt++))<<16&16711680,s.mode=4;case 4:if(0===e.je)return n;n=t,e.je--,e.Ge++,s.zt+=(255&e.lt(e.rt++))<<8&65280,s.mode=5;case 5:return 0===e.je?n:(n=t,e.je--,e.Ge++,s.zt+=255&e.lt(e.rt++),s.mode=6,2);case 6:return s.mode=mt,e.Fe="need dictionary",s.marker=0,rt;case 7:if(n=s.vt.wt(e,n),n==st){s.mode=mt,s.marker=0;break}if(0==n&&(n=t),1!=n)return n;n=t,s.vt.reset(e,s.St),s.mode=12;case 12:return e.je=0,1;case mt:return st;default:return rt}},e.It=(e,t,n)=>{let r=0,s=n;if(!e||!e.kt||6!=e.kt.mode)return rt;const i=e.kt;return s<1<<i.Ct||(s=(1<<i.Ct)-1,r=n-s),i.vt.bt(t,r,s),i.mode=7,0},e.Pt=e=>{let n,r,s,i,o;if(!e||!e.kt)return rt;const c=e.kt;if(c.mode!=mt&&(c.mode=mt,c.marker=0),0===(n=e.je))return it;for(r=e.rt,s=c.marker;0!==n&&4>s;)e.lt(r)==bt[s]?s++:s=0!==e.lt(r)?0:4-s,r++,n--;return e.Ge+=r-e.rt,e.rt=r,e.je=n,c.marker=s,4!=s?st:(i=e.Ge,o=e.Je,t(e),e.Ge=i,e.Je=o,c.mode=7,0)},e.Dt=e=>e&&e.kt&&e.kt.vt?e.kt.vt.gt():rt}function kt(){}function vt(e){const t=new kt,n=e&&e.chunkSize?r.floor(2*e.chunkSize):131072,o=new i(n);let c=!1;t.At(),t.et=o,this.append=(e,r)=>{const f=[];let a,l,u=0,w=0,h=0;if(0!==e.length){t.rt=0,t.tt=e,t.je=e.length;do{if(t.st=0,t.nt=n,0!==t.je||c||(t.rt=0,c=!0),a=t._t(0),c&&a===it){if(0!==t.je)throw new s("inflating: bad input")}else if(0!==a&&1!==a)throw new s("inflating: "+t.Fe);if((c||1===a)&&t.je===e.length)throw new s("inflating: bad input");t.st&&(t.st===n?f.push(new i(o)):f.push(o.subarray(0,t.st))),h+=t.st,r&&t.rt>0&&t.rt!=u&&(r(t.rt),u=t.rt)}while(t.je>0||0===t.nt);return f.length>1?(l=new i(h),f.forEach((e=>{l.set(e,w),w+=e.length}))):l=f[0]?new i(f[0]):new i,l}},this.flush=()=>{t.xt()}}kt.prototype={At(e){const t=this;return t.kt=new gt,e||(e=15),t.kt.At(t,e)},_t(e){const t=this;return t.kt?t.kt._t(t,e):rt},xt(){const e=this;if(!e.kt)return rt;const t=e.kt.xt(e);return e.kt=null,t},Pt(){const e=this;return e.kt?e.kt.Pt(e):rt},It(e,t){const n=this;return n.kt?n.kt.It(n,e,t):rt},lt(e){return this.tt[e]},He(e,t){return this.tt.subarray(e,e+t)}},self.initCodec=()=>{self.Deflate=nt,self.Inflate=vt};\n', r = /* @__PURE__ */ __name(() => t2.useDataURI ? "data:text/javascript," + encodeURIComponent(n) : URL.createObjectURL(new Blob([n], { type: "text/javascript" })), "r");
  e2({ workerScripts: { inflate: [r], deflate: [r] } });
}
__name(e, "e");
const ERR_ITERATOR_COMPLETED_TOO_SOON = "Writer iterator completed too soon";
const HTTP_HEADER_CONTENT_TYPE = "Content-Type";
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const PROPERTY_NAME_WRITABLE = "writable";
const _Stream = class _Stream {
  constructor() {
    this.size = 0;
  }
  init() {
    this.initialized = true;
  }
};
__name(_Stream, "Stream");
let Stream = _Stream;
const _Reader = class _Reader extends Stream {
  get readable() {
    const reader = this;
    const { chunkSize = DEFAULT_CHUNK_SIZE } = reader;
    const readable2 = new ReadableStream({
      start() {
        this.chunkOffset = 0;
      },
      async pull(controller) {
        const { offset = 0, size, diskNumberStart } = readable2;
        const { chunkOffset } = this;
        controller.enqueue(await readUint8Array(reader, offset + chunkOffset, Math.min(chunkSize, size - chunkOffset), diskNumberStart));
        if (chunkOffset + chunkSize > size) {
          controller.close();
        } else {
          this.chunkOffset += chunkSize;
        }
      }
    });
    return readable2;
  }
};
__name(_Reader, "Reader");
let Reader = _Reader;
const _Writer = class _Writer extends Stream {
  constructor() {
    super();
    const writer = this;
    const writable2 = new WritableStream({
      write(chunk) {
        return writer.writeUint8Array(chunk);
      }
    });
    Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
      get() {
        return writable2;
      }
    });
  }
  writeUint8Array() {
  }
};
__name(_Writer, "Writer");
let Writer = _Writer;
const _BlobReader = class _BlobReader extends Reader {
  constructor(blob) {
    super();
    Object.assign(this, {
      blob,
      size: blob.size
    });
  }
  async readUint8Array(offset, length) {
    const reader = this;
    const offsetEnd = offset + length;
    const blob = offset || offsetEnd < reader.size ? reader.blob.slice(offset, offsetEnd) : reader.blob;
    let arrayBuffer = await blob.arrayBuffer();
    if (arrayBuffer.byteLength > length) {
      arrayBuffer = arrayBuffer.slice(offset, offsetEnd);
    }
    return new Uint8Array(arrayBuffer);
  }
};
__name(_BlobReader, "BlobReader");
let BlobReader = _BlobReader;
const _BlobWriter = class _BlobWriter extends Stream {
  constructor(contentType) {
    super();
    const writer = this;
    const transformStream = new TransformStream();
    const headers = [];
    if (contentType) {
      headers.push([HTTP_HEADER_CONTENT_TYPE, contentType]);
    }
    Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
      get() {
        return transformStream.writable;
      }
    });
    writer.blob = new Response(transformStream.readable, { headers }).blob();
  }
  getData() {
    return this.blob;
  }
};
__name(_BlobWriter, "BlobWriter");
let BlobWriter = _BlobWriter;
const _Uint8ArrayReader = class _Uint8ArrayReader extends Reader {
  constructor(array2) {
    super();
    Object.assign(this, {
      array: array2,
      size: array2.length
    });
  }
  readUint8Array(index, length) {
    return this.array.slice(index, index + length);
  }
};
__name(_Uint8ArrayReader, "Uint8ArrayReader");
let Uint8ArrayReader = _Uint8ArrayReader;
const _Uint8ArrayWriter = class _Uint8ArrayWriter extends Writer {
  init(initSize = 0) {
    Object.assign(this, {
      offset: 0,
      array: new Uint8Array(initSize)
    });
    super.init();
  }
  writeUint8Array(array2) {
    const writer = this;
    if (writer.offset + array2.length > writer.array.length) {
      const previousArray = writer.array;
      writer.array = new Uint8Array(previousArray.length + array2.length);
      writer.array.set(previousArray);
    }
    writer.array.set(array2, writer.offset);
    writer.offset += array2.length;
  }
  getData() {
    return this.array;
  }
};
__name(_Uint8ArrayWriter, "Uint8ArrayWriter");
let Uint8ArrayWriter = _Uint8ArrayWriter;
const _SplitDataReader = class _SplitDataReader extends Reader {
  constructor(readers) {
    super();
    this.readers = readers;
  }
  async init() {
    const reader = this;
    const { readers } = reader;
    reader.lastDiskNumber = 0;
    reader.lastDiskOffset = 0;
    await Promise.all(readers.map(async (diskReader, indexDiskReader) => {
      await diskReader.init();
      if (indexDiskReader != readers.length - 1) {
        reader.lastDiskOffset += diskReader.size;
      }
      reader.size += diskReader.size;
    }));
    super.init();
  }
  async readUint8Array(offset, length, diskNumber = 0) {
    const reader = this;
    const { readers } = this;
    let result;
    let currentDiskNumber = diskNumber;
    if (currentDiskNumber == -1) {
      currentDiskNumber = readers.length - 1;
    }
    let currentReaderOffset = offset;
    while (currentReaderOffset >= readers[currentDiskNumber].size) {
      currentReaderOffset -= readers[currentDiskNumber].size;
      currentDiskNumber++;
    }
    const currentReader = readers[currentDiskNumber];
    const currentReaderSize = currentReader.size;
    if (currentReaderOffset + length <= currentReaderSize) {
      result = await readUint8Array(currentReader, currentReaderOffset, length);
    } else {
      const chunkLength = currentReaderSize - currentReaderOffset;
      result = new Uint8Array(length);
      result.set(await readUint8Array(currentReader, currentReaderOffset, chunkLength));
      result.set(await reader.readUint8Array(offset + chunkLength, length - chunkLength, diskNumber), chunkLength);
    }
    reader.lastDiskNumber = Math.max(currentDiskNumber, reader.lastDiskNumber);
    return result;
  }
};
__name(_SplitDataReader, "SplitDataReader");
let SplitDataReader = _SplitDataReader;
const _SplitDataWriter = class _SplitDataWriter extends Stream {
  constructor(writerGenerator, maxSize = 4294967295) {
    super();
    const writer = this;
    Object.assign(writer, {
      diskNumber: 0,
      diskOffset: 0,
      size: 0,
      maxSize,
      availableSize: maxSize
    });
    let diskSourceWriter, diskWritable, diskWriter;
    const writable2 = new WritableStream({
      async write(chunk) {
        const { availableSize } = writer;
        if (!diskWriter) {
          const { value, done } = await writerGenerator.next();
          if (done && !value) {
            throw new Error(ERR_ITERATOR_COMPLETED_TOO_SOON);
          } else {
            diskSourceWriter = value;
            diskSourceWriter.size = 0;
            if (diskSourceWriter.maxSize) {
              writer.maxSize = diskSourceWriter.maxSize;
            }
            writer.availableSize = writer.maxSize;
            await initStream(diskSourceWriter);
            diskWritable = value.writable;
            diskWriter = diskWritable.getWriter();
          }
          await this.write(chunk);
        } else if (chunk.length >= availableSize) {
          await writeChunk(chunk.slice(0, availableSize));
          await closeDisk();
          writer.diskOffset += diskSourceWriter.size;
          writer.diskNumber++;
          diskWriter = null;
          await this.write(chunk.slice(availableSize));
        } else {
          await writeChunk(chunk);
        }
      },
      async close() {
        await diskWriter.ready;
        await closeDisk();
      }
    });
    Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
      get() {
        return writable2;
      }
    });
    async function writeChunk(chunk) {
      const chunkLength = chunk.length;
      if (chunkLength) {
        await diskWriter.ready;
        await diskWriter.write(chunk);
        diskSourceWriter.size += chunkLength;
        writer.size += chunkLength;
        writer.availableSize -= chunkLength;
      }
    }
    __name(writeChunk, "writeChunk");
    async function closeDisk() {
      diskWritable.size = diskSourceWriter.size;
      await diskWriter.close();
    }
    __name(closeDisk, "closeDisk");
  }
};
__name(_SplitDataWriter, "SplitDataWriter");
let SplitDataWriter = _SplitDataWriter;
async function initStream(stream2, initSize) {
  if (stream2.init && !stream2.initialized) {
    await stream2.init(initSize);
  } else {
    return Promise.resolve();
  }
}
__name(initStream, "initStream");
function initReader(reader) {
  if (Array.isArray(reader)) {
    reader = new SplitDataReader(reader);
  }
  if (reader instanceof ReadableStream) {
    reader = {
      readable: reader
    };
  }
  return reader;
}
__name(initReader, "initReader");
function initWriter(writer) {
  if (writer.writable === UNDEFINED_VALUE && typeof writer.next == FUNCTION_TYPE) {
    writer = new SplitDataWriter(writer);
  }
  if (writer instanceof WritableStream) {
    writer = {
      writable: writer
    };
  }
  const { writable: writable2 } = writer;
  if (writable2.size === UNDEFINED_VALUE) {
    writable2.size = 0;
  }
  if (!(writer instanceof SplitDataWriter)) {
    Object.assign(writer, {
      diskNumber: 0,
      diskOffset: 0,
      availableSize: Infinity,
      maxSize: Infinity
    });
  }
  return writer;
}
__name(initWriter, "initWriter");
function readUint8Array(reader, offset, size, diskNumber) {
  return reader.readUint8Array(offset, size, diskNumber);
}
__name(readUint8Array, "readUint8Array");
const CP437 = "\0☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ".split("");
const VALID_CP437 = CP437.length == 256;
function decodeCP437(stringValue) {
  if (VALID_CP437) {
    let result = "";
    for (let indexCharacter = 0; indexCharacter < stringValue.length; indexCharacter++) {
      result += CP437[stringValue[indexCharacter]];
    }
    return result;
  } else {
    return new TextDecoder().decode(stringValue);
  }
}
__name(decodeCP437, "decodeCP437");
function decodeText(value, encoding) {
  if (encoding && encoding.trim().toLowerCase() == "cp437") {
    return decodeCP437(value);
  } else {
    return new TextDecoder(encoding).decode(value);
  }
}
__name(decodeText, "decodeText");
const PROPERTY_NAME_FILENAME = "filename";
const PROPERTY_NAME_RAW_FILENAME = "rawFilename";
const PROPERTY_NAME_COMMENT = "comment";
const PROPERTY_NAME_RAW_COMMENT = "rawComment";
const PROPERTY_NAME_UNCOMPPRESSED_SIZE = "uncompressedSize";
const PROPERTY_NAME_COMPPRESSED_SIZE = "compressedSize";
const PROPERTY_NAME_OFFSET = "offset";
const PROPERTY_NAME_DISK_NUMBER_START = "diskNumberStart";
const PROPERTY_NAME_LAST_MODIFICATION_DATE = "lastModDate";
const PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE = "rawLastModDate";
const PROPERTY_NAME_LAST_ACCESS_DATE = "lastAccessDate";
const PROPERTY_NAME_RAW_LAST_ACCESS_DATE = "rawLastAccessDate";
const PROPERTY_NAME_CREATION_DATE = "creationDate";
const PROPERTY_NAME_RAW_CREATION_DATE = "rawCreationDate";
const PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE = "internalFileAttribute";
const PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE = "externalFileAttribute";
const PROPERTY_NAME_MS_DOS_COMPATIBLE = "msDosCompatible";
const PROPERTY_NAME_ZIP64 = "zip64";
const PROPERTY_NAME_ENCRYPTED = "encrypted";
const PROPERTY_NAME_VERSION = "version";
const PROPERTY_NAME_VERSION_MADE_BY = "versionMadeBy";
const PROPERTY_NAME_ZIPCRYPTO = "zipCrypto";
const PROPERTY_NAMES = [
  PROPERTY_NAME_FILENAME,
  PROPERTY_NAME_RAW_FILENAME,
  PROPERTY_NAME_COMPPRESSED_SIZE,
  PROPERTY_NAME_UNCOMPPRESSED_SIZE,
  PROPERTY_NAME_LAST_MODIFICATION_DATE,
  PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE,
  PROPERTY_NAME_COMMENT,
  PROPERTY_NAME_RAW_COMMENT,
  PROPERTY_NAME_LAST_ACCESS_DATE,
  PROPERTY_NAME_CREATION_DATE,
  PROPERTY_NAME_OFFSET,
  PROPERTY_NAME_DISK_NUMBER_START,
  PROPERTY_NAME_DISK_NUMBER_START,
  PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE,
  PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE,
  PROPERTY_NAME_MS_DOS_COMPATIBLE,
  PROPERTY_NAME_ZIP64,
  PROPERTY_NAME_ENCRYPTED,
  PROPERTY_NAME_VERSION,
  PROPERTY_NAME_VERSION_MADE_BY,
  PROPERTY_NAME_ZIPCRYPTO,
  "directory",
  "bitFlag",
  "signature",
  "filenameUTF8",
  "commentUTF8",
  "compressionMethod",
  "extraField",
  "rawExtraField",
  "extraFieldZip64",
  "extraFieldUnicodePath",
  "extraFieldUnicodeComment",
  "extraFieldAES",
  "extraFieldNTFS",
  "extraFieldExtendedTimestamp"
];
const _Entry = class _Entry {
  constructor(data) {
    PROPERTY_NAMES.forEach((name) => this[name] = data[name]);
  }
};
__name(_Entry, "Entry");
let Entry = _Entry;
const ERR_BAD_FORMAT = "File format is not recognized";
const ERR_EOCDR_NOT_FOUND = "End of central directory not found";
const ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = "End of Zip64 central directory locator not found";
const ERR_CENTRAL_DIRECTORY_NOT_FOUND = "Central directory header not found";
const ERR_LOCAL_FILE_HEADER_NOT_FOUND = "Local file header not found";
const ERR_EXTRAFIELD_ZIP64_NOT_FOUND = "Zip64 extra field not found";
const ERR_ENCRYPTED = "File contains encrypted entry";
const ERR_UNSUPPORTED_ENCRYPTION = "Encryption method not supported";
const ERR_UNSUPPORTED_COMPRESSION = "Compression method not supported";
const ERR_SPLIT_ZIP_FILE = "Split zip file";
const CHARSET_UTF8 = "utf-8";
const CHARSET_CP437 = "cp437";
const ZIP64_PROPERTIES = [
  [PROPERTY_NAME_UNCOMPPRESSED_SIZE, MAX_32_BITS],
  [PROPERTY_NAME_COMPPRESSED_SIZE, MAX_32_BITS],
  [PROPERTY_NAME_OFFSET, MAX_32_BITS],
  [PROPERTY_NAME_DISK_NUMBER_START, MAX_16_BITS]
];
const ZIP64_EXTRACTION = {
  [MAX_16_BITS]: {
    getValue: getUint32,
    bytes: 4
  },
  [MAX_32_BITS]: {
    getValue: getBigUint64,
    bytes: 8
  }
};
const _ZipReader = class _ZipReader {
  constructor(reader, options = {}) {
    Object.assign(this, {
      reader: initReader(reader),
      options,
      config: getConfiguration()
    });
  }
  async *getEntriesGenerator(options = {}) {
    const zipReader = this;
    let { reader } = zipReader;
    const { config: config2 } = zipReader;
    await initStream(reader);
    if (reader.size === UNDEFINED_VALUE || !reader.readUint8Array) {
      reader = new BlobReader(await new Response(reader.readable).blob());
      await initStream(reader);
    }
    if (reader.size < END_OF_CENTRAL_DIR_LENGTH) {
      throw new Error(ERR_BAD_FORMAT);
    }
    reader.chunkSize = getChunkSize(config2);
    const endOfDirectoryInfo = await seekSignature(reader, END_OF_CENTRAL_DIR_SIGNATURE, reader.size, END_OF_CENTRAL_DIR_LENGTH, MAX_16_BITS * 16);
    if (!endOfDirectoryInfo) {
      const signatureArray = await readUint8Array(reader, 0, 4);
      const signatureView = getDataView$1(signatureArray);
      if (getUint32(signatureView) == SPLIT_ZIP_FILE_SIGNATURE) {
        throw new Error(ERR_SPLIT_ZIP_FILE);
      } else {
        throw new Error(ERR_EOCDR_NOT_FOUND);
      }
    }
    const endOfDirectoryView = getDataView$1(endOfDirectoryInfo);
    let directoryDataLength = getUint32(endOfDirectoryView, 12);
    let directoryDataOffset = getUint32(endOfDirectoryView, 16);
    const commentOffset = endOfDirectoryInfo.offset;
    const commentLength = getUint16(endOfDirectoryView, 20);
    const appendedDataOffset = commentOffset + END_OF_CENTRAL_DIR_LENGTH + commentLength;
    let lastDiskNumber = getUint16(endOfDirectoryView, 4);
    const expectedLastDiskNumber = reader.lastDiskNumber || 0;
    let diskNumber = getUint16(endOfDirectoryView, 6);
    let filesLength = getUint16(endOfDirectoryView, 8);
    let prependedDataLength = 0;
    let startOffset = 0;
    if (directoryDataOffset == MAX_32_BITS || directoryDataLength == MAX_32_BITS || filesLength == MAX_16_BITS || diskNumber == MAX_16_BITS) {
      const endOfDirectoryLocatorArray = await readUint8Array(reader, endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH);
      const endOfDirectoryLocatorView = getDataView$1(endOfDirectoryLocatorArray);
      if (getUint32(endOfDirectoryLocatorView, 0) == ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE) {
        directoryDataOffset = getBigUint64(endOfDirectoryLocatorView, 8);
        let endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH, -1);
        let endOfDirectoryView2 = getDataView$1(endOfDirectoryArray);
        const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH - ZIP64_END_OF_CENTRAL_DIR_LENGTH;
        if (getUint32(endOfDirectoryView2, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {
          const originalDirectoryDataOffset = directoryDataOffset;
          directoryDataOffset = expectedDirectoryDataOffset;
          prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
          endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH, -1);
          endOfDirectoryView2 = getDataView$1(endOfDirectoryArray);
        }
        if (getUint32(endOfDirectoryView2, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE) {
          throw new Error(ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND);
        }
        if (lastDiskNumber == MAX_16_BITS) {
          lastDiskNumber = getUint32(endOfDirectoryView2, 16);
        }
        if (diskNumber == MAX_16_BITS) {
          diskNumber = getUint32(endOfDirectoryView2, 20);
        }
        if (filesLength == MAX_16_BITS) {
          filesLength = getBigUint64(endOfDirectoryView2, 32);
        }
        if (directoryDataLength == MAX_32_BITS) {
          directoryDataLength = getBigUint64(endOfDirectoryView2, 40);
        }
        directoryDataOffset -= directoryDataLength;
      }
    }
    if (directoryDataOffset >= reader.size) {
      prependedDataLength = reader.size - directoryDataOffset - directoryDataLength - END_OF_CENTRAL_DIR_LENGTH;
      directoryDataOffset = reader.size - directoryDataLength - END_OF_CENTRAL_DIR_LENGTH;
    }
    if (expectedLastDiskNumber != lastDiskNumber) {
      throw new Error(ERR_SPLIT_ZIP_FILE);
    }
    if (directoryDataOffset < 0) {
      throw new Error(ERR_BAD_FORMAT);
    }
    let offset = 0;
    let directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
    let directoryView = getDataView$1(directoryArray);
    if (directoryDataLength) {
      const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - directoryDataLength;
      if (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {
        const originalDirectoryDataOffset = directoryDataOffset;
        directoryDataOffset = expectedDirectoryDataOffset;
        prependedDataLength += directoryDataOffset - originalDirectoryDataOffset;
        directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
        directoryView = getDataView$1(directoryArray);
      }
    }
    const expectedDirectoryDataLength = endOfDirectoryInfo.offset - directoryDataOffset - (reader.lastDiskOffset || 0);
    if (directoryDataLength != expectedDirectoryDataLength && expectedDirectoryDataLength >= 0) {
      directoryDataLength = expectedDirectoryDataLength;
      directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
      directoryView = getDataView$1(directoryArray);
    }
    if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
      throw new Error(ERR_BAD_FORMAT);
    }
    const filenameEncoding = getOptionValue$1(zipReader, options, "filenameEncoding");
    const commentEncoding = getOptionValue$1(zipReader, options, "commentEncoding");
    for (let indexFile = 0; indexFile < filesLength; indexFile++) {
      const fileEntry = new ZipEntry(reader, config2, zipReader.options);
      if (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE) {
        throw new Error(ERR_CENTRAL_DIRECTORY_NOT_FOUND);
      }
      readCommonHeader(fileEntry, directoryView, offset + 6);
      const languageEncodingFlag = Boolean(fileEntry.bitFlag.languageEncodingFlag);
      const filenameOffset = offset + 46;
      const extraFieldOffset = filenameOffset + fileEntry.filenameLength;
      const commentOffset2 = extraFieldOffset + fileEntry.extraFieldLength;
      const versionMadeBy = getUint16(directoryView, offset + 4);
      const msDosCompatible = (versionMadeBy & 0) == 0;
      const rawFilename = directoryArray.subarray(filenameOffset, extraFieldOffset);
      const commentLength2 = getUint16(directoryView, offset + 32);
      const endOffset = commentOffset2 + commentLength2;
      const rawComment = directoryArray.subarray(commentOffset2, endOffset);
      const filenameUTF8 = languageEncodingFlag;
      const commentUTF8 = languageEncodingFlag;
      const directory = msDosCompatible && (getUint8(directoryView, offset + 38) & FILE_ATTR_MSDOS_DIR_MASK) == FILE_ATTR_MSDOS_DIR_MASK;
      const offsetFileEntry = getUint32(directoryView, offset + 42) + prependedDataLength;
      Object.assign(fileEntry, {
        versionMadeBy,
        msDosCompatible,
        compressedSize: 0,
        uncompressedSize: 0,
        commentLength: commentLength2,
        directory,
        offset: offsetFileEntry,
        diskNumberStart: getUint16(directoryView, offset + 34),
        internalFileAttribute: getUint16(directoryView, offset + 36),
        externalFileAttribute: getUint32(directoryView, offset + 38),
        rawFilename,
        filenameUTF8,
        commentUTF8,
        rawExtraField: directoryArray.subarray(extraFieldOffset, commentOffset2)
      });
      const decode = getOptionValue$1(zipReader, options, "decodeText") || decodeText;
      const rawFilenameEncoding = filenameUTF8 ? CHARSET_UTF8 : filenameEncoding || CHARSET_CP437;
      const rawCommentEncoding = commentUTF8 ? CHARSET_UTF8 : commentEncoding || CHARSET_CP437;
      let filename = decode(rawFilename, rawFilenameEncoding);
      if (filename === UNDEFINED_VALUE) {
        filename = decodeText(rawFilename, rawFilenameEncoding);
      }
      let comment = decode(rawComment, rawCommentEncoding);
      if (comment === UNDEFINED_VALUE) {
        comment = decodeText(rawComment, rawCommentEncoding);
      }
      Object.assign(fileEntry, {
        rawComment,
        filename,
        comment,
        directory: directory || filename.endsWith(DIRECTORY_SIGNATURE)
      });
      startOffset = Math.max(offsetFileEntry, startOffset);
      await readCommonFooter(fileEntry, fileEntry, directoryView, offset + 6);
      fileEntry.zipCrypto = fileEntry.encrypted && !fileEntry.extraFieldAES;
      const entry = new Entry(fileEntry);
      entry.getData = (writer, options2) => fileEntry.getData(writer, entry, options2);
      offset = endOffset;
      const { onprogress } = options;
      if (onprogress) {
        try {
          await onprogress(indexFile + 1, filesLength, new Entry(fileEntry));
        } catch (_error) {
        }
      }
      yield entry;
    }
    const extractPrependedData = getOptionValue$1(zipReader, options, "extractPrependedData");
    const extractAppendedData = getOptionValue$1(zipReader, options, "extractAppendedData");
    if (extractPrependedData) {
      zipReader.prependedData = startOffset > 0 ? await readUint8Array(reader, 0, startOffset) : new Uint8Array();
    }
    zipReader.comment = commentLength ? await readUint8Array(reader, commentOffset + END_OF_CENTRAL_DIR_LENGTH, commentLength) : new Uint8Array();
    if (extractAppendedData) {
      zipReader.appendedData = appendedDataOffset < reader.size ? await readUint8Array(reader, appendedDataOffset, reader.size - appendedDataOffset) : new Uint8Array();
    }
    return true;
  }
  async getEntries(options = {}) {
    const entries2 = [];
    for await (const entry of this.getEntriesGenerator(options)) {
      entries2.push(entry);
    }
    return entries2;
  }
  async close() {
  }
};
__name(_ZipReader, "ZipReader");
let ZipReader = _ZipReader;
const _ZipEntry = class _ZipEntry {
  constructor(reader, config2, options) {
    Object.assign(this, {
      reader,
      config: config2,
      options
    });
  }
  async getData(writer, fileEntry, options = {}) {
    const zipEntry = this;
    const {
      reader,
      offset,
      diskNumberStart,
      extraFieldAES,
      compressionMethod,
      config: config2,
      bitFlag,
      signature,
      rawLastModDate,
      uncompressedSize,
      compressedSize
    } = zipEntry;
    const localDirectory = fileEntry.localDirectory = {};
    const dataArray = await readUint8Array(reader, offset, 30, diskNumberStart);
    const dataView = getDataView$1(dataArray);
    let password = getOptionValue$1(zipEntry, options, "password");
    let rawPassword = getOptionValue$1(zipEntry, options, "rawPassword");
    const passThrough = getOptionValue$1(zipEntry, options, "passThrough");
    password = password && password.length && password;
    rawPassword = rawPassword && rawPassword.length && rawPassword;
    if (extraFieldAES) {
      if (extraFieldAES.originalCompressionMethod != COMPRESSION_METHOD_AES) {
        throw new Error(ERR_UNSUPPORTED_COMPRESSION);
      }
    }
    if (compressionMethod != COMPRESSION_METHOD_STORE && compressionMethod != COMPRESSION_METHOD_DEFLATE && !passThrough) {
      throw new Error(ERR_UNSUPPORTED_COMPRESSION);
    }
    if (getUint32(dataView, 0) != LOCAL_FILE_HEADER_SIGNATURE) {
      throw new Error(ERR_LOCAL_FILE_HEADER_NOT_FOUND);
    }
    readCommonHeader(localDirectory, dataView, 4);
    localDirectory.rawExtraField = localDirectory.extraFieldLength ? await readUint8Array(reader, offset + 30 + localDirectory.filenameLength, localDirectory.extraFieldLength, diskNumberStart) : new Uint8Array();
    await readCommonFooter(zipEntry, localDirectory, dataView, 4, true);
    Object.assign(fileEntry, {
      lastAccessDate: localDirectory.lastAccessDate,
      creationDate: localDirectory.creationDate
    });
    const encrypted = zipEntry.encrypted && localDirectory.encrypted && !passThrough;
    const zipCrypto = encrypted && !extraFieldAES;
    if (!passThrough) {
      fileEntry.zipCrypto = zipCrypto;
    }
    if (encrypted) {
      if (!zipCrypto && extraFieldAES.strength === UNDEFINED_VALUE) {
        throw new Error(ERR_UNSUPPORTED_ENCRYPTION);
      } else if (!password && !rawPassword) {
        throw new Error(ERR_ENCRYPTED);
      }
    }
    const dataOffset = offset + 30 + localDirectory.filenameLength + localDirectory.extraFieldLength;
    const size = compressedSize;
    const readable2 = reader.readable;
    Object.assign(readable2, {
      diskNumberStart,
      offset: dataOffset,
      size
    });
    const signal = getOptionValue$1(zipEntry, options, "signal");
    const checkPasswordOnly = getOptionValue$1(zipEntry, options, "checkPasswordOnly");
    if (checkPasswordOnly) {
      writer = new WritableStream();
    }
    writer = initWriter(writer);
    await initStream(writer, passThrough ? compressedSize : uncompressedSize);
    const { writable: writable2 } = writer;
    const { onstart, onprogress, onend } = options;
    const workerOptions = {
      options: {
        codecType: CODEC_INFLATE,
        password,
        rawPassword,
        zipCrypto,
        encryptionStrength: extraFieldAES && extraFieldAES.strength,
        signed: getOptionValue$1(zipEntry, options, "checkSignature") && !passThrough,
        passwordVerification: zipCrypto && (bitFlag.dataDescriptor ? rawLastModDate >>> 8 & 255 : signature >>> 24 & 255),
        signature,
        compressed: compressionMethod != 0 && !passThrough,
        encrypted: zipEntry.encrypted && !passThrough,
        useWebWorkers: getOptionValue$1(zipEntry, options, "useWebWorkers"),
        useCompressionStream: getOptionValue$1(zipEntry, options, "useCompressionStream"),
        transferStreams: getOptionValue$1(zipEntry, options, "transferStreams"),
        checkPasswordOnly
      },
      config: config2,
      streamOptions: { signal, size, onstart, onprogress, onend }
    };
    let outputSize = 0;
    try {
      ({ outputSize } = await runWorker({ readable: readable2, writable: writable2 }, workerOptions));
    } catch (error) {
      if (!checkPasswordOnly || error.message != ERR_ABORT_CHECK_PASSWORD) {
        throw error;
      }
    } finally {
      const preventClose = getOptionValue$1(zipEntry, options, "preventClose");
      writable2.size += outputSize;
      if (!preventClose && !writable2.locked) {
        await writable2.getWriter().close();
      }
    }
    return checkPasswordOnly ? UNDEFINED_VALUE : writer.getData ? writer.getData() : writable2;
  }
};
__name(_ZipEntry, "ZipEntry");
let ZipEntry = _ZipEntry;
function readCommonHeader(directory, dataView, offset) {
  const rawBitFlag = directory.rawBitFlag = getUint16(dataView, offset + 2);
  const encrypted = (rawBitFlag & BITFLAG_ENCRYPTED) == BITFLAG_ENCRYPTED;
  const rawLastModDate = getUint32(dataView, offset + 6);
  Object.assign(directory, {
    encrypted,
    version: getUint16(dataView, offset),
    bitFlag: {
      level: (rawBitFlag & BITFLAG_LEVEL) >> 1,
      dataDescriptor: (rawBitFlag & BITFLAG_DATA_DESCRIPTOR) == BITFLAG_DATA_DESCRIPTOR,
      languageEncodingFlag: (rawBitFlag & BITFLAG_LANG_ENCODING_FLAG) == BITFLAG_LANG_ENCODING_FLAG
    },
    rawLastModDate,
    lastModDate: getDate(rawLastModDate),
    filenameLength: getUint16(dataView, offset + 22),
    extraFieldLength: getUint16(dataView, offset + 24)
  });
}
__name(readCommonHeader, "readCommonHeader");
async function readCommonFooter(fileEntry, directory, dataView, offset, localDirectory) {
  const { rawExtraField } = directory;
  const extraField = directory.extraField = /* @__PURE__ */ new Map();
  const rawExtraFieldView = getDataView$1(new Uint8Array(rawExtraField));
  let offsetExtraField = 0;
  try {
    while (offsetExtraField < rawExtraField.length) {
      const type = getUint16(rawExtraFieldView, offsetExtraField);
      const size = getUint16(rawExtraFieldView, offsetExtraField + 2);
      extraField.set(type, {
        type,
        data: rawExtraField.slice(offsetExtraField + 4, offsetExtraField + 4 + size)
      });
      offsetExtraField += 4 + size;
    }
  } catch (_error) {
  }
  const compressionMethod = getUint16(dataView, offset + 4);
  Object.assign(directory, {
    signature: getUint32(dataView, offset + 10),
    uncompressedSize: getUint32(dataView, offset + 18),
    compressedSize: getUint32(dataView, offset + 14)
  });
  const extraFieldZip64 = extraField.get(EXTRAFIELD_TYPE_ZIP64);
  if (extraFieldZip64) {
    readExtraFieldZip64(extraFieldZip64, directory);
    directory.extraFieldZip64 = extraFieldZip64;
  }
  const extraFieldUnicodePath = extraField.get(EXTRAFIELD_TYPE_UNICODE_PATH);
  if (extraFieldUnicodePath) {
    await readExtraFieldUnicode(extraFieldUnicodePath, PROPERTY_NAME_FILENAME, PROPERTY_NAME_RAW_FILENAME, directory, fileEntry);
    directory.extraFieldUnicodePath = extraFieldUnicodePath;
  }
  const extraFieldUnicodeComment = extraField.get(EXTRAFIELD_TYPE_UNICODE_COMMENT);
  if (extraFieldUnicodeComment) {
    await readExtraFieldUnicode(extraFieldUnicodeComment, PROPERTY_NAME_COMMENT, PROPERTY_NAME_RAW_COMMENT, directory, fileEntry);
    directory.extraFieldUnicodeComment = extraFieldUnicodeComment;
  }
  const extraFieldAES = extraField.get(EXTRAFIELD_TYPE_AES);
  if (extraFieldAES) {
    readExtraFieldAES(extraFieldAES, directory, compressionMethod);
    directory.extraFieldAES = extraFieldAES;
  } else {
    directory.compressionMethod = compressionMethod;
  }
  const extraFieldNTFS = extraField.get(EXTRAFIELD_TYPE_NTFS);
  if (extraFieldNTFS) {
    readExtraFieldNTFS(extraFieldNTFS, directory);
    directory.extraFieldNTFS = extraFieldNTFS;
  }
  const extraFieldExtendedTimestamp = extraField.get(EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);
  if (extraFieldExtendedTimestamp) {
    readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory, localDirectory);
    directory.extraFieldExtendedTimestamp = extraFieldExtendedTimestamp;
  }
  const extraFieldUSDZ = extraField.get(EXTRAFIELD_TYPE_USDZ);
  if (extraFieldUSDZ) {
    directory.extraFieldUSDZ = extraFieldUSDZ;
  }
}
__name(readCommonFooter, "readCommonFooter");
function readExtraFieldZip64(extraFieldZip64, directory) {
  directory.zip64 = true;
  const extraFieldView = getDataView$1(extraFieldZip64.data);
  const missingProperties = ZIP64_PROPERTIES.filter(([propertyName, max]) => directory[propertyName] == max);
  for (let indexMissingProperty = 0, offset = 0; indexMissingProperty < missingProperties.length; indexMissingProperty++) {
    const [propertyName, max] = missingProperties[indexMissingProperty];
    if (directory[propertyName] == max) {
      const extraction = ZIP64_EXTRACTION[max];
      directory[propertyName] = extraFieldZip64[propertyName] = extraction.getValue(extraFieldView, offset);
      offset += extraction.bytes;
    } else if (extraFieldZip64[propertyName]) {
      throw new Error(ERR_EXTRAFIELD_ZIP64_NOT_FOUND);
    }
  }
}
__name(readExtraFieldZip64, "readExtraFieldZip64");
async function readExtraFieldUnicode(extraFieldUnicode, propertyName, rawPropertyName, directory, fileEntry) {
  const extraFieldView = getDataView$1(extraFieldUnicode.data);
  const crc322 = new Crc32();
  crc322.append(fileEntry[rawPropertyName]);
  const dataViewSignature = getDataView$1(new Uint8Array(4));
  dataViewSignature.setUint32(0, crc322.get(), true);
  const signature = getUint32(extraFieldView, 1);
  Object.assign(extraFieldUnicode, {
    version: getUint8(extraFieldView, 0),
    [propertyName]: decodeText(extraFieldUnicode.data.subarray(5)),
    valid: !fileEntry.bitFlag.languageEncodingFlag && signature == getUint32(dataViewSignature, 0)
  });
  if (extraFieldUnicode.valid) {
    directory[propertyName] = extraFieldUnicode[propertyName];
    directory[propertyName + "UTF8"] = true;
  }
}
__name(readExtraFieldUnicode, "readExtraFieldUnicode");
function readExtraFieldAES(extraFieldAES, directory, compressionMethod) {
  const extraFieldView = getDataView$1(extraFieldAES.data);
  const strength = getUint8(extraFieldView, 4);
  Object.assign(extraFieldAES, {
    vendorVersion: getUint8(extraFieldView, 0),
    vendorId: getUint8(extraFieldView, 2),
    strength,
    originalCompressionMethod: compressionMethod,
    compressionMethod: getUint16(extraFieldView, 5)
  });
  directory.compressionMethod = extraFieldAES.compressionMethod;
}
__name(readExtraFieldAES, "readExtraFieldAES");
function readExtraFieldNTFS(extraFieldNTFS, directory) {
  const extraFieldView = getDataView$1(extraFieldNTFS.data);
  let offsetExtraField = 4;
  let tag1Data;
  try {
    while (offsetExtraField < extraFieldNTFS.data.length && !tag1Data) {
      const tagValue = getUint16(extraFieldView, offsetExtraField);
      const attributeSize = getUint16(extraFieldView, offsetExtraField + 2);
      if (tagValue == EXTRAFIELD_TYPE_NTFS_TAG1) {
        tag1Data = extraFieldNTFS.data.slice(offsetExtraField + 4, offsetExtraField + 4 + attributeSize);
      }
      offsetExtraField += 4 + attributeSize;
    }
  } catch (_error) {
  }
  try {
    if (tag1Data && tag1Data.length == 24) {
      const tag1View = getDataView$1(tag1Data);
      const rawLastModDate = tag1View.getBigUint64(0, true);
      const rawLastAccessDate = tag1View.getBigUint64(8, true);
      const rawCreationDate = tag1View.getBigUint64(16, true);
      Object.assign(extraFieldNTFS, {
        rawLastModDate,
        rawLastAccessDate,
        rawCreationDate
      });
      const lastModDate = getDateNTFS(rawLastModDate);
      const lastAccessDate = getDateNTFS(rawLastAccessDate);
      const creationDate = getDateNTFS(rawCreationDate);
      const extraFieldData = { lastModDate, lastAccessDate, creationDate };
      Object.assign(extraFieldNTFS, extraFieldData);
      Object.assign(directory, extraFieldData);
    }
  } catch (_error) {
  }
}
__name(readExtraFieldNTFS, "readExtraFieldNTFS");
function readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory, localDirectory) {
  const extraFieldView = getDataView$1(extraFieldExtendedTimestamp.data);
  const flags = getUint8(extraFieldView, 0);
  const timeProperties = [];
  const timeRawProperties = [];
  if (localDirectory) {
    if ((flags & 1) == 1) {
      timeProperties.push(PROPERTY_NAME_LAST_MODIFICATION_DATE);
      timeRawProperties.push(PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE);
    }
    if ((flags & 2) == 2) {
      timeProperties.push(PROPERTY_NAME_LAST_ACCESS_DATE);
      timeRawProperties.push(PROPERTY_NAME_RAW_LAST_ACCESS_DATE);
    }
    if ((flags & 4) == 4) {
      timeProperties.push(PROPERTY_NAME_CREATION_DATE);
      timeRawProperties.push(PROPERTY_NAME_RAW_CREATION_DATE);
    }
  } else if (extraFieldExtendedTimestamp.data.length >= 5) {
    timeProperties.push(PROPERTY_NAME_LAST_MODIFICATION_DATE);
    timeRawProperties.push(PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE);
  }
  let offset = 1;
  timeProperties.forEach((propertyName, indexProperty) => {
    if (extraFieldExtendedTimestamp.data.length >= offset + 4) {
      const time = getUint32(extraFieldView, offset);
      directory[propertyName] = extraFieldExtendedTimestamp[propertyName] = new Date(time * 1e3);
      const rawPropertyName = timeRawProperties[indexProperty];
      extraFieldExtendedTimestamp[rawPropertyName] = time;
    }
    offset += 4;
  });
}
__name(readExtraFieldExtendedTimestamp, "readExtraFieldExtendedTimestamp");
async function seekSignature(reader, signature, startOffset, minimumBytes, maximumLength) {
  const signatureArray = new Uint8Array(4);
  const signatureView = getDataView$1(signatureArray);
  setUint32$1(signatureView, 0, signature);
  const maximumBytes = minimumBytes + maximumLength;
  return await seek(minimumBytes) || await seek(Math.min(maximumBytes, startOffset));
  async function seek(length) {
    const offset = startOffset - length;
    const bytes = await readUint8Array(reader, offset, length);
    for (let indexByte = bytes.length - minimumBytes; indexByte >= 0; indexByte--) {
      if (bytes[indexByte] == signatureArray[0] && bytes[indexByte + 1] == signatureArray[1] && bytes[indexByte + 2] == signatureArray[2] && bytes[indexByte + 3] == signatureArray[3]) {
        return {
          offset: offset + indexByte,
          buffer: bytes.slice(indexByte, indexByte + minimumBytes).buffer
        };
      }
    }
  }
  __name(seek, "seek");
}
__name(seekSignature, "seekSignature");
function getOptionValue$1(zipReader, options, name) {
  return options[name] === UNDEFINED_VALUE ? zipReader.options[name] : options[name];
}
__name(getOptionValue$1, "getOptionValue$1");
function getDate(timeRaw) {
  const date = (timeRaw & 4294901760) >> 16, time = timeRaw & 65535;
  try {
    return new Date(1980 + ((date & 65024) >> 9), ((date & 480) >> 5) - 1, date & 31, (time & 63488) >> 11, (time & 2016) >> 5, (time & 31) * 2, 0);
  } catch (_error) {
  }
}
__name(getDate, "getDate");
function getDateNTFS(timeRaw) {
  return new Date(Number(timeRaw / BigInt(1e4) - BigInt(116444736e5)));
}
__name(getDateNTFS, "getDateNTFS");
function getUint8(view2, offset) {
  return view2.getUint8(offset);
}
__name(getUint8, "getUint8");
function getUint16(view2, offset) {
  return view2.getUint16(offset, true);
}
__name(getUint16, "getUint16");
function getUint32(view2, offset) {
  return view2.getUint32(offset, true);
}
__name(getUint32, "getUint32");
function getBigUint64(view2, offset) {
  return Number(view2.getBigUint64(offset, true));
}
__name(getBigUint64, "getBigUint64");
function setUint32$1(view2, offset, value) {
  view2.setUint32(offset, value, true);
}
__name(setUint32$1, "setUint32$1");
function getDataView$1(array2) {
  return new DataView(array2.buffer);
}
__name(getDataView$1, "getDataView$1");
const ERR_DUPLICATED_NAME = "File already exists";
const ERR_INVALID_COMMENT = "Zip file comment exceeds 64KB";
const ERR_INVALID_ENTRY_COMMENT = "File entry comment exceeds 64KB";
const ERR_INVALID_ENTRY_NAME = "File entry name exceeds 64KB";
const ERR_INVALID_VERSION = "Version exceeds 65535";
const ERR_INVALID_ENCRYPTION_STRENGTH = "The strength must equal 1, 2, or 3";
const ERR_INVALID_EXTRAFIELD_TYPE = "Extra field type exceeds 65535";
const ERR_INVALID_EXTRAFIELD_DATA = "Extra field data exceeds 64KB";
const ERR_UNSUPPORTED_FORMAT = "Zip64 is not supported (make sure 'keepOrder' is set to 'true')";
const ERR_UNDEFINED_UNCOMPRESSED_SIZE = "Undefined uncompressed size";
const EXTRAFIELD_DATA_AES = new Uint8Array([7, 0, 2, 0, 65, 69, 3, 0, 0]);
let workers = 0;
const pendingEntries = [];
const _ZipWriter = class _ZipWriter {
  constructor(writer, options = {}) {
    writer = initWriter(writer);
    const addSplitZipSignature = writer.availableSize !== UNDEFINED_VALUE && writer.availableSize > 0 && writer.availableSize !== Infinity && writer.maxSize !== UNDEFINED_VALUE && writer.maxSize > 0 && writer.maxSize !== Infinity;
    Object.assign(this, {
      writer,
      addSplitZipSignature,
      options,
      config: getConfiguration(),
      files: /* @__PURE__ */ new Map(),
      filenames: /* @__PURE__ */ new Set(),
      offset: options.offset === UNDEFINED_VALUE ? writer.writable.size : options.offset,
      pendingEntriesSize: 0,
      pendingAddFileCalls: /* @__PURE__ */ new Set(),
      bufferedWrites: 0
    });
  }
  async add(name = "", reader, options = {}) {
    const zipWriter = this;
    const {
      pendingAddFileCalls,
      config: config2
    } = zipWriter;
    if (workers < config2.maxWorkers) {
      workers++;
    } else {
      await new Promise((resolve2) => pendingEntries.push(resolve2));
    }
    let promiseAddFile;
    try {
      name = name.trim();
      if (zipWriter.filenames.has(name)) {
        throw new Error(ERR_DUPLICATED_NAME);
      }
      zipWriter.filenames.add(name);
      promiseAddFile = addFile(zipWriter, name, reader, options);
      pendingAddFileCalls.add(promiseAddFile);
      return await promiseAddFile;
    } catch (error) {
      zipWriter.filenames.delete(name);
      throw error;
    } finally {
      pendingAddFileCalls.delete(promiseAddFile);
      const pendingEntry = pendingEntries.shift();
      if (pendingEntry) {
        pendingEntry();
      } else {
        workers--;
      }
    }
  }
  async close(comment = new Uint8Array(), options = {}) {
    const zipWriter = this;
    const { pendingAddFileCalls, writer } = this;
    const { writable: writable2 } = writer;
    while (pendingAddFileCalls.size) {
      await Promise.allSettled(Array.from(pendingAddFileCalls));
    }
    await closeFile(this, comment, options);
    const preventClose = getOptionValue(zipWriter, options, "preventClose");
    if (!preventClose) {
      await writable2.getWriter().close();
    }
    return writer.getData ? writer.getData() : writable2;
  }
};
__name(_ZipWriter, "ZipWriter");
let ZipWriter = _ZipWriter;
async function addFile(zipWriter, name, reader, options) {
  name = name.trim();
  if (options.directory && !name.endsWith(DIRECTORY_SIGNATURE)) {
    name += DIRECTORY_SIGNATURE;
  } else {
    options.directory = name.endsWith(DIRECTORY_SIGNATURE);
  }
  const encode = getOptionValue(zipWriter, options, "encodeText", encodeText);
  let rawFilename = encode(name);
  if (rawFilename === UNDEFINED_VALUE) {
    rawFilename = encodeText(name);
  }
  if (getLength(rawFilename) > MAX_16_BITS) {
    throw new Error(ERR_INVALID_ENTRY_NAME);
  }
  const comment = options.comment || "";
  let rawComment = encode(comment);
  if (rawComment === UNDEFINED_VALUE) {
    rawComment = encodeText(comment);
  }
  if (getLength(rawComment) > MAX_16_BITS) {
    throw new Error(ERR_INVALID_ENTRY_COMMENT);
  }
  const version2 = getOptionValue(zipWriter, options, PROPERTY_NAME_VERSION, VERSION_DEFLATE);
  if (version2 > MAX_16_BITS) {
    throw new Error(ERR_INVALID_VERSION);
  }
  const versionMadeBy = getOptionValue(zipWriter, options, PROPERTY_NAME_VERSION_MADE_BY, 20);
  if (versionMadeBy > MAX_16_BITS) {
    throw new Error(ERR_INVALID_VERSION);
  }
  const lastModDate = getOptionValue(zipWriter, options, PROPERTY_NAME_LAST_MODIFICATION_DATE, /* @__PURE__ */ new Date());
  const lastAccessDate = getOptionValue(zipWriter, options, PROPERTY_NAME_LAST_ACCESS_DATE);
  const creationDate = getOptionValue(zipWriter, options, PROPERTY_NAME_CREATION_DATE);
  const msDosCompatible = getOptionValue(zipWriter, options, PROPERTY_NAME_MS_DOS_COMPATIBLE, true);
  const internalFileAttribute = getOptionValue(zipWriter, options, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE, 0);
  const externalFileAttribute = getOptionValue(zipWriter, options, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE, 0);
  const passThrough = getOptionValue(zipWriter, options, "passThrough");
  let password, rawPassword;
  if (!passThrough) {
    password = getOptionValue(zipWriter, options, "password");
    rawPassword = getOptionValue(zipWriter, options, "rawPassword");
  }
  const encryptionStrength = getOptionValue(zipWriter, options, "encryptionStrength", 3);
  const zipCrypto = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIPCRYPTO);
  const extendedTimestamp = getOptionValue(zipWriter, options, "extendedTimestamp", true);
  const keepOrder = getOptionValue(zipWriter, options, "keepOrder", true);
  const level2 = getOptionValue(zipWriter, options, "level");
  const useWebWorkers = getOptionValue(zipWriter, options, "useWebWorkers");
  const bufferedWrite = getOptionValue(zipWriter, options, "bufferedWrite");
  const dataDescriptorSignature = getOptionValue(zipWriter, options, "dataDescriptorSignature", false);
  const signal = getOptionValue(zipWriter, options, "signal");
  const useUnicodeFileNames = getOptionValue(zipWriter, options, "useUnicodeFileNames", true);
  const useCompressionStream = getOptionValue(zipWriter, options, "useCompressionStream");
  const compressionMethod = getOptionValue(zipWriter, options, "compressionMethod");
  let dataDescriptor = getOptionValue(zipWriter, options, "dataDescriptor", true);
  let zip64 = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIP64);
  if (!zipCrypto && (password !== UNDEFINED_VALUE || rawPassword !== UNDEFINED_VALUE) && !(encryptionStrength >= 1 && encryptionStrength <= 3)) {
    throw new Error(ERR_INVALID_ENCRYPTION_STRENGTH);
  }
  let rawExtraField = new Uint8Array();
  const { extraField } = options;
  if (extraField) {
    let extraFieldSize = 0;
    let offset = 0;
    extraField.forEach((data) => extraFieldSize += 4 + getLength(data));
    rawExtraField = new Uint8Array(extraFieldSize);
    extraField.forEach((data, type) => {
      if (type > MAX_16_BITS) {
        throw new Error(ERR_INVALID_EXTRAFIELD_TYPE);
      }
      if (getLength(data) > MAX_16_BITS) {
        throw new Error(ERR_INVALID_EXTRAFIELD_DATA);
      }
      arraySet(rawExtraField, new Uint16Array([type]), offset);
      arraySet(rawExtraField, new Uint16Array([getLength(data)]), offset + 2);
      arraySet(rawExtraField, data, offset + 4);
      offset += 4 + getLength(data);
    });
  }
  let maximumCompressedSize = 0;
  let maximumEntrySize = 0;
  let uncompressedSize = 0;
  if (passThrough) {
    ({ uncompressedSize } = options);
    if (uncompressedSize === UNDEFINED_VALUE) {
      throw new Error(ERR_UNDEFINED_UNCOMPRESSED_SIZE);
    }
  }
  const zip64Enabled = zip64 === true;
  if (reader) {
    reader = initReader(reader);
    await initStream(reader);
    if (!passThrough) {
      if (reader.size === UNDEFINED_VALUE) {
        dataDescriptor = true;
        if (zip64 || zip64 === UNDEFINED_VALUE) {
          zip64 = true;
          uncompressedSize = maximumCompressedSize = MAX_32_BITS + 1;
        }
      } else {
        uncompressedSize = reader.size;
        maximumCompressedSize = getMaximumCompressedSize(uncompressedSize);
      }
    } else {
      maximumCompressedSize = getMaximumCompressedSize(uncompressedSize);
    }
  }
  const { diskOffset, diskNumber, maxSize } = zipWriter.writer;
  const zip64UncompressedSize = zip64Enabled || uncompressedSize > MAX_32_BITS;
  const zip64CompressedSize = zip64Enabled || maximumCompressedSize > MAX_32_BITS;
  const zip64Offset = zip64Enabled || zipWriter.offset + zipWriter.pendingEntriesSize - diskOffset > MAX_32_BITS;
  const supportZip64SplitFile = getOptionValue(zipWriter, options, "supportZip64SplitFile", true);
  const zip64DiskNumberStart = supportZip64SplitFile && zip64Enabled || diskNumber + Math.ceil(zipWriter.pendingEntriesSize / maxSize) > MAX_16_BITS;
  if (zip64Offset || zip64UncompressedSize || zip64CompressedSize || zip64DiskNumberStart) {
    if (zip64 === false || !keepOrder) {
      throw new Error(ERR_UNSUPPORTED_FORMAT);
    } else {
      zip64 = true;
    }
  }
  zip64 = zip64 || false;
  const encrypted = getOptionValue(zipWriter, options, PROPERTY_NAME_ENCRYPTED);
  const { signature } = options;
  options = Object.assign({}, options, {
    rawFilename,
    rawComment,
    version: version2,
    versionMadeBy,
    lastModDate,
    lastAccessDate,
    creationDate,
    rawExtraField,
    zip64,
    zip64UncompressedSize,
    zip64CompressedSize,
    zip64Offset,
    zip64DiskNumberStart,
    password,
    rawPassword,
    level: !useCompressionStream && (zipWriter.config.CompressionStream === UNDEFINED_VALUE && zipWriter.config.CompressionStreamNative === UNDEFINED_VALUE) ? 0 : level2,
    useWebWorkers,
    encryptionStrength,
    extendedTimestamp,
    zipCrypto,
    bufferedWrite,
    keepOrder,
    useUnicodeFileNames,
    dataDescriptor,
    dataDescriptorSignature,
    signal,
    msDosCompatible,
    internalFileAttribute,
    externalFileAttribute,
    useCompressionStream,
    passThrough,
    encrypted: Boolean(password && getLength(password) || rawPassword && getLength(rawPassword)) || passThrough && encrypted,
    signature,
    compressionMethod
  });
  const headerInfo = getHeaderInfo(options);
  const dataDescriptorInfo = getDataDescriptorInfo(options);
  const metadataSize = getLength(headerInfo.localHeaderArray, dataDescriptorInfo.dataDescriptorArray);
  maximumEntrySize = metadataSize + maximumCompressedSize;
  if (zipWriter.options.usdz) {
    maximumEntrySize += maximumEntrySize + 64;
  }
  zipWriter.pendingEntriesSize += maximumEntrySize;
  let fileEntry;
  try {
    fileEntry = await getFileEntry(zipWriter, name, reader, { headerInfo, dataDescriptorInfo, metadataSize }, options);
  } finally {
    zipWriter.pendingEntriesSize -= maximumEntrySize;
  }
  Object.assign(fileEntry, { name, comment, extraField });
  return new Entry(fileEntry);
}
__name(addFile, "addFile");
async function getFileEntry(zipWriter, name, reader, entryInfo, options) {
  const {
    files,
    writer
  } = zipWriter;
  const {
    keepOrder,
    dataDescriptor,
    signal
  } = options;
  const {
    headerInfo
  } = entryInfo;
  const { usdz } = zipWriter.options;
  const previousFileEntry = Array.from(files.values()).pop();
  let fileEntry = {};
  let bufferedWrite;
  let releaseLockWriter;
  let releaseLockCurrentFileEntry;
  let writingBufferedEntryData;
  let writingEntryData;
  let fileWriter;
  let blobPromise;
  files.set(name, fileEntry);
  try {
    let lockPreviousFileEntry;
    if (keepOrder) {
      lockPreviousFileEntry = previousFileEntry && previousFileEntry.lock;
      requestLockCurrentFileEntry();
    }
    if ((options.bufferedWrite || zipWriter.writerLocked || zipWriter.bufferedWrites && keepOrder || !dataDescriptor) && !usdz) {
      fileWriter = new TransformStream();
      blobPromise = new Response(fileWriter.readable).blob();
      fileWriter.writable.size = 0;
      bufferedWrite = true;
      zipWriter.bufferedWrites++;
      await initStream(writer);
    } else {
      fileWriter = writer;
      await requestLockWriter();
    }
    await initStream(fileWriter);
    const { writable: writable2 } = writer;
    let { diskOffset } = writer;
    if (zipWriter.addSplitZipSignature) {
      delete zipWriter.addSplitZipSignature;
      const signatureArray = new Uint8Array(4);
      const signatureArrayView = getDataView(signatureArray);
      setUint32(signatureArrayView, 0, SPLIT_ZIP_FILE_SIGNATURE);
      await writeData(writable2, signatureArray);
      zipWriter.offset += 4;
    }
    if (usdz) {
      appendExtraFieldUSDZ(entryInfo, zipWriter.offset - diskOffset);
    }
    if (!bufferedWrite) {
      await lockPreviousFileEntry;
      await skipDiskIfNeeded(writable2);
    }
    const { diskNumber } = writer;
    writingEntryData = true;
    fileEntry.diskNumberStart = diskNumber;
    fileEntry = await createFileEntry(reader, fileWriter, fileEntry, entryInfo, zipWriter.config, options);
    writingEntryData = false;
    files.set(name, fileEntry);
    fileEntry.filename = name;
    if (bufferedWrite) {
      await fileWriter.writable.getWriter().close();
      let blob = await blobPromise;
      await lockPreviousFileEntry;
      await requestLockWriter();
      writingBufferedEntryData = true;
      if (!dataDescriptor) {
        blob = await writeExtraHeaderInfo(fileEntry, blob, writable2, options);
      }
      await skipDiskIfNeeded(writable2);
      fileEntry.diskNumberStart = writer.diskNumber;
      diskOffset = writer.diskOffset;
      await blob.stream().pipeTo(writable2, { preventClose: true, preventAbort: true, signal });
      writable2.size += blob.size;
      writingBufferedEntryData = false;
    }
    fileEntry.offset = zipWriter.offset - diskOffset;
    if (fileEntry.zip64) {
      setZip64ExtraInfo(fileEntry, options);
    } else if (fileEntry.offset > MAX_32_BITS) {
      throw new Error(ERR_UNSUPPORTED_FORMAT);
    }
    zipWriter.offset += fileEntry.size;
    return fileEntry;
  } catch (error) {
    if (bufferedWrite && writingBufferedEntryData || !bufferedWrite && writingEntryData) {
      zipWriter.hasCorruptedEntries = true;
      if (error) {
        try {
          error.corruptedEntry = true;
        } catch (_error) {
        }
      }
      if (bufferedWrite) {
        zipWriter.offset += fileWriter.writable.size;
      } else {
        zipWriter.offset = fileWriter.writable.size;
      }
    }
    files.delete(name);
    throw error;
  } finally {
    if (bufferedWrite) {
      zipWriter.bufferedWrites--;
    }
    if (releaseLockCurrentFileEntry) {
      releaseLockCurrentFileEntry();
    }
    if (releaseLockWriter) {
      releaseLockWriter();
    }
  }
  function requestLockCurrentFileEntry() {
    fileEntry.lock = new Promise((resolve2) => releaseLockCurrentFileEntry = resolve2);
  }
  __name(requestLockCurrentFileEntry, "requestLockCurrentFileEntry");
  async function requestLockWriter() {
    zipWriter.writerLocked = true;
    const { lockWriter } = zipWriter;
    zipWriter.lockWriter = new Promise((resolve2) => releaseLockWriter = /* @__PURE__ */ __name(() => {
      zipWriter.writerLocked = false;
      resolve2();
    }, "releaseLockWriter"));
    await lockWriter;
  }
  __name(requestLockWriter, "requestLockWriter");
  async function skipDiskIfNeeded(writable2) {
    if (getLength(headerInfo.localHeaderArray) > writer.availableSize) {
      writer.availableSize = 0;
      await writeData(writable2, new Uint8Array());
    }
  }
  __name(skipDiskIfNeeded, "skipDiskIfNeeded");
}
__name(getFileEntry, "getFileEntry");
async function createFileEntry(reader, writer, { diskNumberStart, lock }, entryInfo, config2, options) {
  const {
    headerInfo,
    dataDescriptorInfo,
    metadataSize
  } = entryInfo;
  const {
    localHeaderArray,
    headerArray,
    lastModDate,
    rawLastModDate,
    encrypted,
    compressed,
    version: version2,
    compressionMethod,
    rawExtraFieldExtendedTimestamp,
    extraFieldExtendedTimestampFlag,
    rawExtraFieldNTFS,
    rawExtraFieldAES
  } = headerInfo;
  const { dataDescriptorArray } = dataDescriptorInfo;
  const {
    rawFilename,
    lastAccessDate,
    creationDate,
    password,
    rawPassword,
    level: level2,
    zip64,
    zip64UncompressedSize,
    zip64CompressedSize,
    zip64Offset,
    zip64DiskNumberStart,
    zipCrypto,
    dataDescriptor,
    directory,
    versionMadeBy,
    rawComment,
    rawExtraField,
    useWebWorkers,
    onstart,
    onprogress,
    onend,
    signal,
    encryptionStrength,
    extendedTimestamp,
    msDosCompatible,
    internalFileAttribute,
    externalFileAttribute,
    useCompressionStream,
    passThrough
  } = options;
  const fileEntry = {
    lock,
    versionMadeBy,
    zip64,
    directory: Boolean(directory),
    filenameUTF8: true,
    rawFilename,
    commentUTF8: true,
    rawComment,
    rawExtraFieldExtendedTimestamp,
    rawExtraFieldNTFS,
    rawExtraFieldAES,
    rawExtraField,
    extendedTimestamp,
    msDosCompatible,
    internalFileAttribute,
    externalFileAttribute,
    diskNumberStart
  };
  let {
    signature,
    uncompressedSize
  } = options;
  let compressedSize = 0;
  if (!passThrough) {
    uncompressedSize = 0;
  }
  const { writable: writable2 } = writer;
  if (reader) {
    reader.chunkSize = getChunkSize(config2);
    await writeData(writable2, localHeaderArray);
    const readable2 = reader.readable;
    const size = readable2.size = reader.size;
    const workerOptions = {
      options: {
        codecType: CODEC_DEFLATE,
        level: level2,
        rawPassword,
        password,
        encryptionStrength,
        zipCrypto: encrypted && zipCrypto,
        passwordVerification: encrypted && zipCrypto && rawLastModDate >> 8 & 255,
        signed: !passThrough,
        compressed: compressed && !passThrough,
        encrypted: encrypted && !passThrough,
        useWebWorkers,
        useCompressionStream,
        transferStreams: false
      },
      config: config2,
      streamOptions: { signal, size, onstart, onprogress, onend }
    };
    const result = await runWorker({ readable: readable2, writable: writable2 }, workerOptions);
    compressedSize = result.outputSize;
    if (!passThrough) {
      uncompressedSize = result.inputSize;
      signature = result.signature;
    }
    writable2.size += uncompressedSize;
  } else {
    await writeData(writable2, localHeaderArray);
  }
  let rawExtraFieldZip64;
  if (zip64) {
    let rawExtraFieldZip64Length = 4;
    if (zip64UncompressedSize) {
      rawExtraFieldZip64Length += 8;
    }
    if (zip64CompressedSize) {
      rawExtraFieldZip64Length += 8;
    }
    if (zip64Offset) {
      rawExtraFieldZip64Length += 8;
    }
    if (zip64DiskNumberStart) {
      rawExtraFieldZip64Length += 4;
    }
    rawExtraFieldZip64 = new Uint8Array(rawExtraFieldZip64Length);
  } else {
    rawExtraFieldZip64 = new Uint8Array();
  }
  setEntryInfo({
    signature,
    rawExtraFieldZip64,
    compressedSize,
    uncompressedSize,
    headerInfo,
    dataDescriptorInfo
  }, options);
  if (dataDescriptor) {
    await writeData(writable2, dataDescriptorArray);
  }
  Object.assign(fileEntry, {
    uncompressedSize,
    compressedSize,
    lastModDate,
    rawLastModDate,
    creationDate,
    lastAccessDate,
    encrypted,
    zipCrypto,
    size: metadataSize + compressedSize,
    compressionMethod,
    version: version2,
    headerArray,
    signature,
    rawExtraFieldZip64,
    extraFieldExtendedTimestampFlag,
    zip64UncompressedSize,
    zip64CompressedSize,
    zip64Offset,
    zip64DiskNumberStart
  });
  return fileEntry;
}
__name(createFileEntry, "createFileEntry");
function getHeaderInfo(options) {
  const {
    rawFilename,
    lastModDate,
    lastAccessDate,
    creationDate,
    level: level2,
    zip64,
    zipCrypto,
    useUnicodeFileNames,
    dataDescriptor,
    directory,
    rawExtraField,
    encryptionStrength,
    extendedTimestamp,
    encrypted
  } = options;
  const compressed = level2 !== 0 && !directory;
  let { version: version2, compressionMethod } = options;
  let rawExtraFieldAES;
  if (encrypted && !zipCrypto) {
    rawExtraFieldAES = new Uint8Array(getLength(EXTRAFIELD_DATA_AES) + 2);
    const extraFieldAESView = getDataView(rawExtraFieldAES);
    setUint16(extraFieldAESView, 0, EXTRAFIELD_TYPE_AES);
    arraySet(rawExtraFieldAES, EXTRAFIELD_DATA_AES, 2);
    setUint8(extraFieldAESView, 8, encryptionStrength);
  } else {
    rawExtraFieldAES = new Uint8Array();
  }
  let rawExtraFieldNTFS;
  let rawExtraFieldExtendedTimestamp;
  let extraFieldExtendedTimestampFlag;
  if (extendedTimestamp) {
    rawExtraFieldExtendedTimestamp = new Uint8Array(9 + (lastAccessDate ? 4 : 0) + (creationDate ? 4 : 0));
    const extraFieldExtendedTimestampView = getDataView(rawExtraFieldExtendedTimestamp);
    setUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);
    setUint16(extraFieldExtendedTimestampView, 2, getLength(rawExtraFieldExtendedTimestamp) - 4);
    extraFieldExtendedTimestampFlag = 1 + (lastAccessDate ? 2 : 0) + (creationDate ? 4 : 0);
    setUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);
    let offset = 5;
    setUint32(extraFieldExtendedTimestampView, offset, Math.floor(lastModDate.getTime() / 1e3));
    offset += 4;
    if (lastAccessDate) {
      setUint32(extraFieldExtendedTimestampView, offset, Math.floor(lastAccessDate.getTime() / 1e3));
      offset += 4;
    }
    if (creationDate) {
      setUint32(extraFieldExtendedTimestampView, offset, Math.floor(creationDate.getTime() / 1e3));
    }
    try {
      rawExtraFieldNTFS = new Uint8Array(36);
      const extraFieldNTFSView = getDataView(rawExtraFieldNTFS);
      const lastModTimeNTFS = getTimeNTFS(lastModDate);
      setUint16(extraFieldNTFSView, 0, EXTRAFIELD_TYPE_NTFS);
      setUint16(extraFieldNTFSView, 2, 32);
      setUint16(extraFieldNTFSView, 8, EXTRAFIELD_TYPE_NTFS_TAG1);
      setUint16(extraFieldNTFSView, 10, 24);
      setBigUint64(extraFieldNTFSView, 12, lastModTimeNTFS);
      setBigUint64(extraFieldNTFSView, 20, getTimeNTFS(lastAccessDate) || lastModTimeNTFS);
      setBigUint64(extraFieldNTFSView, 28, getTimeNTFS(creationDate) || lastModTimeNTFS);
    } catch (_error) {
      rawExtraFieldNTFS = new Uint8Array();
    }
  } else {
    rawExtraFieldNTFS = rawExtraFieldExtendedTimestamp = new Uint8Array();
  }
  let bitFlag = 0;
  if (useUnicodeFileNames) {
    bitFlag = bitFlag | BITFLAG_LANG_ENCODING_FLAG;
  }
  if (dataDescriptor) {
    bitFlag = bitFlag | BITFLAG_DATA_DESCRIPTOR;
  }
  if (compressionMethod === UNDEFINED_VALUE) {
    compressionMethod = compressed ? COMPRESSION_METHOD_DEFLATE : COMPRESSION_METHOD_STORE;
  }
  if (compressionMethod == COMPRESSION_METHOD_DEFLATE) {
    if (level2 >= 1 && level2 < 3) {
      bitFlag = bitFlag | 6;
    }
    if (level2 >= 3 && level2 < 5) {
      bitFlag = bitFlag | 1;
    }
    if (level2 === 9) {
      bitFlag = bitFlag | 2;
    }
  }
  if (zip64) {
    version2 = version2 > VERSION_ZIP64 ? version2 : VERSION_ZIP64;
  }
  if (encrypted) {
    bitFlag = bitFlag | BITFLAG_ENCRYPTED;
    if (!zipCrypto) {
      version2 = version2 > VERSION_AES ? version2 : VERSION_AES;
      rawExtraFieldAES[9] = compressionMethod;
      compressionMethod = COMPRESSION_METHOD_AES;
    }
  }
  const headerArray = new Uint8Array(26);
  const headerView = getDataView(headerArray);
  setUint16(headerView, 0, version2);
  setUint16(headerView, 2, bitFlag);
  setUint16(headerView, 4, compressionMethod);
  const dateArray = new Uint32Array(1);
  const dateView = getDataView(dateArray);
  let lastModDateMsDos;
  if (lastModDate < MIN_DATE) {
    lastModDateMsDos = MIN_DATE;
  } else if (lastModDate > MAX_DATE) {
    lastModDateMsDos = MAX_DATE;
  } else {
    lastModDateMsDos = lastModDate;
  }
  setUint16(dateView, 0, (lastModDateMsDos.getHours() << 6 | lastModDateMsDos.getMinutes()) << 5 | lastModDateMsDos.getSeconds() / 2);
  setUint16(dateView, 2, (lastModDateMsDos.getFullYear() - 1980 << 4 | lastModDateMsDos.getMonth() + 1) << 5 | lastModDateMsDos.getDate());
  const rawLastModDate = dateArray[0];
  setUint32(headerView, 6, rawLastModDate);
  setUint16(headerView, 22, getLength(rawFilename));
  const extraFieldLength = getLength(rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraField);
  setUint16(headerView, 24, extraFieldLength);
  const localHeaderArray = new Uint8Array(30 + getLength(rawFilename) + extraFieldLength);
  const localHeaderView = getDataView(localHeaderArray);
  setUint32(localHeaderView, 0, LOCAL_FILE_HEADER_SIGNATURE);
  arraySet(localHeaderArray, headerArray, 4);
  arraySet(localHeaderArray, rawFilename, 30);
  arraySet(localHeaderArray, rawExtraFieldAES, 30 + getLength(rawFilename));
  arraySet(localHeaderArray, rawExtraFieldExtendedTimestamp, 30 + getLength(rawFilename, rawExtraFieldAES));
  arraySet(localHeaderArray, rawExtraFieldNTFS, 30 + getLength(rawFilename, rawExtraFieldAES, rawExtraFieldExtendedTimestamp));
  arraySet(localHeaderArray, rawExtraField, 30 + getLength(rawFilename, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS));
  return {
    localHeaderArray,
    headerArray,
    headerView,
    lastModDate,
    rawLastModDate,
    encrypted,
    compressed,
    version: version2,
    compressionMethod,
    extraFieldExtendedTimestampFlag,
    rawExtraFieldExtendedTimestamp,
    rawExtraFieldNTFS,
    rawExtraFieldAES,
    extraFieldLength
  };
}
__name(getHeaderInfo, "getHeaderInfo");
function appendExtraFieldUSDZ(entryInfo, zipWriterOffset) {
  const { headerInfo } = entryInfo;
  let { localHeaderArray, extraFieldLength } = headerInfo;
  let localHeaderArrayView = getDataView(localHeaderArray);
  let extraBytesLength = 64 - (zipWriterOffset + getLength(localHeaderArray)) % 64;
  if (extraBytesLength < 4) {
    extraBytesLength += 64;
  }
  const rawExtraFieldUSDZ = new Uint8Array(extraBytesLength);
  const extraFieldUSDZView = getDataView(rawExtraFieldUSDZ);
  setUint16(extraFieldUSDZView, 0, EXTRAFIELD_TYPE_USDZ);
  setUint16(extraFieldUSDZView, 2, extraBytesLength - 2);
  const previousLocalHeaderArray = localHeaderArray;
  headerInfo.localHeaderArray = localHeaderArray = new Uint8Array(getLength(previousLocalHeaderArray) + extraBytesLength);
  arraySet(localHeaderArray, previousLocalHeaderArray);
  arraySet(localHeaderArray, rawExtraFieldUSDZ, getLength(previousLocalHeaderArray));
  localHeaderArrayView = getDataView(localHeaderArray);
  setUint16(localHeaderArrayView, 28, extraFieldLength + extraBytesLength);
  entryInfo.metadataSize += extraBytesLength;
}
__name(appendExtraFieldUSDZ, "appendExtraFieldUSDZ");
function getDataDescriptorInfo(options) {
  const {
    zip64,
    dataDescriptor,
    dataDescriptorSignature
  } = options;
  let dataDescriptorArray = new Uint8Array();
  let dataDescriptorView, dataDescriptorOffset = 0;
  if (dataDescriptor) {
    dataDescriptorArray = new Uint8Array(zip64 ? dataDescriptorSignature ? 24 : 20 : dataDescriptorSignature ? 16 : 12);
    dataDescriptorView = getDataView(dataDescriptorArray);
    if (dataDescriptorSignature) {
      dataDescriptorOffset = 4;
      setUint32(dataDescriptorView, 0, DATA_DESCRIPTOR_RECORD_SIGNATURE);
    }
  }
  return {
    dataDescriptorArray,
    dataDescriptorView,
    dataDescriptorOffset
  };
}
__name(getDataDescriptorInfo, "getDataDescriptorInfo");
function setEntryInfo(entryInfo, options) {
  const {
    signature,
    rawExtraFieldZip64,
    compressedSize,
    uncompressedSize,
    headerInfo,
    dataDescriptorInfo
  } = entryInfo;
  const {
    headerView,
    encrypted
  } = headerInfo;
  const {
    dataDescriptorView,
    dataDescriptorOffset
  } = dataDescriptorInfo;
  const {
    zip64,
    zip64UncompressedSize,
    zip64CompressedSize,
    zipCrypto,
    dataDescriptor
  } = options;
  if ((!encrypted || zipCrypto) && signature !== UNDEFINED_VALUE) {
    setUint32(headerView, 10, signature);
    if (dataDescriptor) {
      setUint32(dataDescriptorView, dataDescriptorOffset, signature);
    }
  }
  if (zip64) {
    const rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);
    setUint16(rawExtraFieldZip64View, 0, EXTRAFIELD_TYPE_ZIP64);
    setUint16(rawExtraFieldZip64View, 2, getLength(rawExtraFieldZip64) - 4);
    let rawExtraFieldZip64Offset = 4;
    if (zip64UncompressedSize) {
      setUint32(headerView, 18, MAX_32_BITS);
      setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(uncompressedSize));
      rawExtraFieldZip64Offset += 8;
    }
    if (zip64CompressedSize) {
      setUint32(headerView, 14, MAX_32_BITS);
      setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(compressedSize));
    }
    if (dataDescriptor) {
      setBigUint64(dataDescriptorView, dataDescriptorOffset + 4, BigInt(compressedSize));
      setBigUint64(dataDescriptorView, dataDescriptorOffset + 12, BigInt(uncompressedSize));
    }
  } else {
    setUint32(headerView, 14, compressedSize);
    setUint32(headerView, 18, uncompressedSize);
    if (dataDescriptor) {
      setUint32(dataDescriptorView, dataDescriptorOffset + 4, compressedSize);
      setUint32(dataDescriptorView, dataDescriptorOffset + 8, uncompressedSize);
    }
  }
}
__name(setEntryInfo, "setEntryInfo");
async function writeExtraHeaderInfo(fileEntry, entryData, writable2, { zipCrypto }) {
  let arrayBuffer;
  arrayBuffer = await entryData.slice(0, 26).arrayBuffer();
  if (arrayBuffer.byteLength != 26) {
    arrayBuffer = arrayBuffer.slice(0, 26);
  }
  const arrayBufferView = new DataView(arrayBuffer);
  if (!fileEntry.encrypted || zipCrypto) {
    setUint32(arrayBufferView, 14, fileEntry.signature);
  }
  if (fileEntry.zip64) {
    setUint32(arrayBufferView, 18, MAX_32_BITS);
    setUint32(arrayBufferView, 22, MAX_32_BITS);
  } else {
    setUint32(arrayBufferView, 18, fileEntry.compressedSize);
    setUint32(arrayBufferView, 22, fileEntry.uncompressedSize);
  }
  await writeData(writable2, new Uint8Array(arrayBuffer));
  return entryData.slice(arrayBuffer.byteLength);
}
__name(writeExtraHeaderInfo, "writeExtraHeaderInfo");
function setZip64ExtraInfo(fileEntry, options) {
  const { rawExtraFieldZip64, offset, diskNumberStart } = fileEntry;
  const { zip64UncompressedSize, zip64CompressedSize, zip64Offset, zip64DiskNumberStart } = options;
  const rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);
  let rawExtraFieldZip64Offset = 4;
  if (zip64UncompressedSize) {
    rawExtraFieldZip64Offset += 8;
  }
  if (zip64CompressedSize) {
    rawExtraFieldZip64Offset += 8;
  }
  if (zip64Offset) {
    setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(offset));
    rawExtraFieldZip64Offset += 8;
  }
  if (zip64DiskNumberStart) {
    setUint32(rawExtraFieldZip64View, rawExtraFieldZip64Offset, diskNumberStart);
  }
}
__name(setZip64ExtraInfo, "setZip64ExtraInfo");
async function closeFile(zipWriter, comment, options) {
  const { files, writer } = zipWriter;
  const { diskOffset, writable: writable2 } = writer;
  let { diskNumber } = writer;
  let offset = 0;
  let directoryDataLength = 0;
  let directoryOffset = zipWriter.offset - diskOffset;
  let filesLength = files.size;
  for (const [, fileEntry] of files) {
    const {
      rawFilename,
      rawExtraFieldZip64,
      rawExtraFieldAES,
      rawComment,
      rawExtraFieldNTFS,
      rawExtraField,
      extendedTimestamp,
      extraFieldExtendedTimestampFlag,
      lastModDate
    } = fileEntry;
    let rawExtraFieldTimestamp;
    if (extendedTimestamp) {
      rawExtraFieldTimestamp = new Uint8Array(9);
      const extraFieldExtendedTimestampView = getDataView(rawExtraFieldTimestamp);
      setUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);
      setUint16(extraFieldExtendedTimestampView, 2, 5);
      setUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);
      setUint32(extraFieldExtendedTimestampView, 5, Math.floor(lastModDate.getTime() / 1e3));
    } else {
      rawExtraFieldTimestamp = new Uint8Array();
    }
    fileEntry.rawExtraFieldCDExtendedTimestamp = rawExtraFieldTimestamp;
    directoryDataLength += 46 + getLength(
      rawFilename,
      rawComment,
      rawExtraFieldZip64,
      rawExtraFieldAES,
      rawExtraFieldNTFS,
      rawExtraFieldTimestamp,
      rawExtraField
    );
  }
  const directoryArray = new Uint8Array(directoryDataLength);
  const directoryView = getDataView(directoryArray);
  await initStream(writer);
  let directoryDiskOffset = 0;
  for (const [indexFileEntry, fileEntry] of Array.from(files.values()).entries()) {
    const {
      offset: fileEntryOffset,
      rawFilename,
      rawExtraFieldZip64,
      rawExtraFieldAES,
      rawExtraFieldCDExtendedTimestamp,
      rawExtraFieldNTFS,
      rawExtraField,
      rawComment,
      versionMadeBy,
      headerArray,
      directory,
      zip64: zip642,
      zip64UncompressedSize,
      zip64CompressedSize,
      zip64DiskNumberStart,
      zip64Offset,
      msDosCompatible,
      internalFileAttribute,
      externalFileAttribute,
      diskNumberStart,
      uncompressedSize,
      compressedSize
    } = fileEntry;
    const extraFieldLength = getLength(rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldCDExtendedTimestamp, rawExtraFieldNTFS, rawExtraField);
    setUint32(directoryView, offset, CENTRAL_FILE_HEADER_SIGNATURE);
    setUint16(directoryView, offset + 4, versionMadeBy);
    const headerView = getDataView(headerArray);
    if (!zip64UncompressedSize) {
      setUint32(headerView, 18, uncompressedSize);
    }
    if (!zip64CompressedSize) {
      setUint32(headerView, 14, compressedSize);
    }
    arraySet(directoryArray, headerArray, offset + 6);
    setUint16(directoryView, offset + 30, extraFieldLength);
    setUint16(directoryView, offset + 32, getLength(rawComment));
    setUint16(directoryView, offset + 34, zip642 && zip64DiskNumberStart ? MAX_16_BITS : diskNumberStart);
    setUint16(directoryView, offset + 36, internalFileAttribute);
    if (externalFileAttribute) {
      setUint32(directoryView, offset + 38, externalFileAttribute);
    } else if (directory && msDosCompatible) {
      setUint8(directoryView, offset + 38, FILE_ATTR_MSDOS_DIR_MASK);
    }
    setUint32(directoryView, offset + 42, zip642 && zip64Offset ? MAX_32_BITS : fileEntryOffset);
    arraySet(directoryArray, rawFilename, offset + 46);
    arraySet(directoryArray, rawExtraFieldZip64, offset + 46 + getLength(rawFilename));
    arraySet(directoryArray, rawExtraFieldAES, offset + 46 + getLength(rawFilename, rawExtraFieldZip64));
    arraySet(directoryArray, rawExtraFieldCDExtendedTimestamp, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES));
    arraySet(directoryArray, rawExtraFieldNTFS, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldCDExtendedTimestamp));
    arraySet(directoryArray, rawExtraField, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldCDExtendedTimestamp, rawExtraFieldNTFS));
    arraySet(directoryArray, rawComment, offset + 46 + getLength(rawFilename) + extraFieldLength);
    const directoryEntryLength = 46 + getLength(rawFilename, rawComment) + extraFieldLength;
    if (offset - directoryDiskOffset > writer.availableSize) {
      writer.availableSize = 0;
      await writeData(writable2, directoryArray.slice(directoryDiskOffset, offset));
      directoryDiskOffset = offset;
    }
    offset += directoryEntryLength;
    if (options.onprogress) {
      try {
        await options.onprogress(indexFileEntry + 1, files.size, new Entry(fileEntry));
      } catch (_error) {
      }
    }
  }
  await writeData(writable2, directoryDiskOffset ? directoryArray.slice(directoryDiskOffset) : directoryArray);
  let lastDiskNumber = writer.diskNumber;
  const { availableSize } = writer;
  if (availableSize < END_OF_CENTRAL_DIR_LENGTH) {
    lastDiskNumber++;
  }
  let zip64 = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIP64);
  if (directoryOffset > MAX_32_BITS || directoryDataLength > MAX_32_BITS || filesLength > MAX_16_BITS || lastDiskNumber > MAX_16_BITS) {
    if (zip64 === false) {
      throw new Error(ERR_UNSUPPORTED_FORMAT);
    } else {
      zip64 = true;
    }
  }
  const endOfdirectoryArray = new Uint8Array(zip64 ? ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH : END_OF_CENTRAL_DIR_LENGTH);
  const endOfdirectoryView = getDataView(endOfdirectoryArray);
  offset = 0;
  if (zip64) {
    setUint32(endOfdirectoryView, 0, ZIP64_END_OF_CENTRAL_DIR_SIGNATURE);
    setBigUint64(endOfdirectoryView, 4, BigInt(44));
    setUint16(endOfdirectoryView, 12, 45);
    setUint16(endOfdirectoryView, 14, 45);
    setUint32(endOfdirectoryView, 16, lastDiskNumber);
    setUint32(endOfdirectoryView, 20, diskNumber);
    setBigUint64(endOfdirectoryView, 24, BigInt(filesLength));
    setBigUint64(endOfdirectoryView, 32, BigInt(filesLength));
    setBigUint64(endOfdirectoryView, 40, BigInt(directoryDataLength));
    setBigUint64(endOfdirectoryView, 48, BigInt(directoryOffset));
    setUint32(endOfdirectoryView, 56, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE);
    setBigUint64(endOfdirectoryView, 64, BigInt(directoryOffset) + BigInt(directoryDataLength));
    setUint32(endOfdirectoryView, 72, lastDiskNumber + 1);
    const supportZip64SplitFile = getOptionValue(zipWriter, options, "supportZip64SplitFile", true);
    if (supportZip64SplitFile) {
      lastDiskNumber = MAX_16_BITS;
      diskNumber = MAX_16_BITS;
    }
    filesLength = MAX_16_BITS;
    directoryOffset = MAX_32_BITS;
    directoryDataLength = MAX_32_BITS;
    offset += ZIP64_END_OF_CENTRAL_DIR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH;
  }
  setUint32(endOfdirectoryView, offset, END_OF_CENTRAL_DIR_SIGNATURE);
  setUint16(endOfdirectoryView, offset + 4, lastDiskNumber);
  setUint16(endOfdirectoryView, offset + 6, diskNumber);
  setUint16(endOfdirectoryView, offset + 8, filesLength);
  setUint16(endOfdirectoryView, offset + 10, filesLength);
  setUint32(endOfdirectoryView, offset + 12, directoryDataLength);
  setUint32(endOfdirectoryView, offset + 16, directoryOffset);
  const commentLength = getLength(comment);
  if (commentLength) {
    if (commentLength <= MAX_16_BITS) {
      setUint16(endOfdirectoryView, offset + 20, commentLength);
    } else {
      throw new Error(ERR_INVALID_COMMENT);
    }
  }
  await writeData(writable2, endOfdirectoryArray);
  if (commentLength) {
    await writeData(writable2, comment);
  }
}
__name(closeFile, "closeFile");
async function writeData(writable2, array2) {
  const streamWriter = writable2.getWriter();
  try {
    await streamWriter.ready;
    writable2.size += getLength(array2);
    await streamWriter.write(array2);
  } finally {
    streamWriter.releaseLock();
  }
}
__name(writeData, "writeData");
function getTimeNTFS(date) {
  if (date) {
    return (BigInt(date.getTime()) + BigInt(116444736e5)) * BigInt(1e4);
  }
}
__name(getTimeNTFS, "getTimeNTFS");
function getOptionValue(zipWriter, options, name, defaultValue) {
  const result = options[name] === UNDEFINED_VALUE ? zipWriter.options[name] : options[name];
  return result === UNDEFINED_VALUE ? defaultValue : result;
}
__name(getOptionValue, "getOptionValue");
function getMaximumCompressedSize(uncompressedSize) {
  return uncompressedSize + 5 * (Math.floor(uncompressedSize / 16383) + 1);
}
__name(getMaximumCompressedSize, "getMaximumCompressedSize");
function setUint8(view2, offset, value) {
  view2.setUint8(offset, value);
}
__name(setUint8, "setUint8");
function setUint16(view2, offset, value) {
  view2.setUint16(offset, value, true);
}
__name(setUint16, "setUint16");
function setUint32(view2, offset, value) {
  view2.setUint32(offset, value, true);
}
__name(setUint32, "setUint32");
function setBigUint64(view2, offset, value) {
  view2.setBigUint64(offset, value, true);
}
__name(setBigUint64, "setBigUint64");
function arraySet(array2, typedArray, offset) {
  array2.set(typedArray, offset);
}
__name(arraySet, "arraySet");
function getDataView(array2) {
  return new DataView(array2.buffer);
}
__name(getDataView, "getDataView");
function getLength(...arrayLikes) {
  let result = 0;
  arrayLikes.forEach((arrayLike) => arrayLike && (result += arrayLike.length));
  return result;
}
__name(getLength, "getLength");
let baseURL;
try {
  baseURL = import.meta.url;
} catch (_error) {
}
configure({ baseURL });
e(configure);
configure({ Deflate: ZipDeflate, Inflate: ZipInflate });
var KernelEvents;
(function(KernelEvents2) {
  KernelEvents2["BOOT"] = "kernel:boot";
  KernelEvents2["EXECUTE"] = "kernel:execute";
  KernelEvents2["PANIC"] = "kernel:panic";
  KernelEvents2["REBOOT"] = "kernel:reboot";
  KernelEvents2["SHUTDOWN"] = "kernel:shutdown";
  KernelEvents2["UPLOAD"] = "kernel:upload";
})(KernelEvents || (KernelEvents = {}));
var KernelState;
(function(KernelState2) {
  KernelState2["BOOTING"] = "booting";
  KernelState2["PANIC"] = "panic";
  KernelState2["RUNNING"] = "running";
  KernelState2["SHUTDOWN"] = "shutdown";
})(KernelState || (KernelState = {}));
var ProcessEvents;
(function(ProcessEvents2) {
  ProcessEvents2["EXIT"] = "exit";
  ProcessEvents2["PAUSE"] = "pause";
  ProcessEvents2["RESUME"] = "resume";
  ProcessEvents2["START"] = "start";
  ProcessEvents2["STOP"] = "stop";
})(ProcessEvents || (ProcessEvents = {}));
var TerminalEvents;
(function(TerminalEvents2) {
  TerminalEvents2["ATTACH"] = "terminal:attach";
  TerminalEvents2["CREATED"] = "terminal:created";
  TerminalEvents2["EXECUTE"] = "terminal:execute";
  TerminalEvents2["INPUT"] = "terminal:input";
  TerminalEvents2["INTERRUPT"] = "terminal:interrupt";
  TerminalEvents2["KEY"] = "terminal:key";
  TerminalEvents2["LISTEN"] = "terminal:listen";
  TerminalEvents2["MESSAGE"] = "terminal:message";
  TerminalEvents2["MOUNT"] = "terminal:mount";
  TerminalEvents2["PASTE"] = "terminal:paste";
  TerminalEvents2["RESIZE"] = "terminal:resize";
  TerminalEvents2["UNLISTEN"] = "terminal:unlisten";
  TerminalEvents2["WRITE"] = "terminal:write";
  TerminalEvents2["WRITELN"] = "terminal:writeln";
})(TerminalEvents || (TerminalEvents = {}));
async function writeStdout(process2, terminal, text) {
  if (process2 && process2.stdout) {
    const writer = process2.stdout.getWriter();
    try {
      await writer.write(new TextEncoder().encode(text));
    } finally {
      writer.releaseLock();
    }
  } else {
    terminal.write(text);
  }
}
__name(writeStdout, "writeStdout");
async function writelnStdout(process2, terminal, text) {
  await writeStdout(process2, terminal, text + "\n");
}
__name(writelnStdout, "writelnStdout");
async function writeStderr(process2, terminal, text) {
  if (process2) {
    const writer = process2.stderr.getWriter();
    try {
      await writer.write(new TextEncoder().encode(text));
    } finally {
      writer.releaseLock();
    }
  } else {
    terminal.write(text);
  }
}
__name(writeStderr, "writeStderr");
async function writelnStderr(process2, terminal, text) {
  await writeStderr(process2, terminal, text + "\n");
}
__name(writelnStderr, "writelnStderr");
const _TerminalCommand = class _TerminalCommand {
  constructor({ command, description, kernel, options, run, shell, terminal, stdin, stdout, stderr }) {
    __publicField(this, "command", "");
    __publicField(this, "description", "");
    __publicField(this, "kernel");
    __publicField(this, "options", []);
    __publicField(this, "run");
    __publicField(this, "shell");
    __publicField(this, "terminal");
    __publicField(this, "stdin");
    __publicField(this, "stdout");
    __publicField(this, "stderr");
    this.command = command;
    this.description = description;
    this.kernel = kernel;
    this.options = options;
    this.shell = shell;
    this.terminal = terminal;
    this.stdin = stdin;
    this.stdout = stdout;
    this.stderr = stderr;
    this.run = async (pid, argv) => {
      if (argv === null) return 1;
      const process2 = this.kernel.processes.get(pid);
      try {
        const parsed = commandLineArgs(this.options, { argv });
        if (parsed.help) {
          await writelnStdout(process2, this.terminal, this.usage);
          return 0;
        }
        return await run(parsed, process2);
      } catch (error) {
        await writelnStderr(process2, this.terminal, chalk$1.red(String(error)));
        return 1;
      }
    };
  }
  get usage() {
    return commandLineUsage([
      { header: this.command, content: this.description },
      { header: "Usage", content: this.usageContent },
      { header: "Options", optionList: this.options }
    ]);
  }
  get usageContent() {
    return `${this.command} ${this.options.map((option) => {
      let optionStr = option.name;
      if (option.type === Boolean) optionStr = `[--${option.name}]`;
      else if (option.type === String) optionStr = option.defaultOption ? `<${option.name}>` : `[--${option.name} <value>]`;
      if (option.multiple) optionStr += "...";
      return optionStr;
    }).join(" ")}`;
  }
};
__name(_TerminalCommand, "TerminalCommand");
let TerminalCommand = _TerminalCommand;
const TerminalCommands = /* @__PURE__ */ __name((kernel, shell, terminal) => {
  const HelpOption = { name: "help", type: Boolean, description: kernel.i18n.t("Display help") };
  return {
    // ai: new TerminalCommand({
    //   command: 'ai',
    //   description: 'Access an AI',
    //   kernel,
    //   shell,
    //   terminal,
    //   options: [
    //     HelpOption,
    //     { name: 'model', type: String, description: 'The model to use', defaultValue: 'openai/gpt-oss-20b:free' },
    //     { name: 'prompt', type: String, defaultOption: true, description: 'The prompt to send to the AI' }
    //   ],
    //   run: async (argv: CommandLineOptions, process?: Process) => {
    //     return await ai({ kernel, shell, terminal, process, args: [argv.prompt] })
    //   }
    // }),
    cat: new TerminalCommand({
      command: "cat",
      description: "Concatenate files and print on the standard output",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, multiple: true, description: "The path(s) to the file(s) to concatenate" },
        { name: "bytes", type: Number, description: "The number of bytes to read from the file" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await cat({ kernel, shell, terminal, process: process2, args: [argv.path, argv.bytes] });
      }, "run")
    }),
    cd: new TerminalCommand({
      command: "cd",
      description: "Change the shell working directory",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, description: "The path to the directory to change to" }
      ],
      run: /* @__PURE__ */ __name(async (argv) => {
        return await cd({ shell, args: [argv.path || shell.cwd] });
      }, "run")
    }),
    chmod: new TerminalCommand({
      command: "chmod",
      description: "Change file mode bits",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "args", type: String, multiple: true, defaultOption: true, description: "The mode and path to the file or directory" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await chmod({ shell, terminal, process: process2, args: argv.args });
      }, "run")
    }),
    chown: new TerminalCommand({
      command: "chown",
      description: "Change file ownership",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "args", type: String, multiple: true, defaultOption: true, description: "The user and path to the file or directory" },
        { name: "group", type: String, description: "The group to set for the file or directory" }
      ],
      run: /* @__PURE__ */ __name(async (argv) => {
        return await chown({ shell, args: [argv.args[0], argv.args[1], argv.group] });
      }, "run")
    }),
    clear: new TerminalCommand({
      command: "clear",
      description: "Clear the terminal screen",
      kernel,
      shell,
      terminal,
      options: [],
      run: /* @__PURE__ */ __name(async () => {
        return await clear({ terminal });
      }, "run")
    }),
    cp: new TerminalCommand({
      command: "cp",
      description: "Copy files",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "args", type: String, multiple: true, defaultOption: true, description: "The source and destination paths" }
      ],
      run: /* @__PURE__ */ __name(async (argv) => {
        return await cp({ shell, args: argv.args });
      }, "run")
    }),
    df: new TerminalCommand({
      command: "df",
      description: "Display disk space usage",
      kernel,
      shell,
      terminal,
      options: [],
      run: /* @__PURE__ */ __name(async (_argv, process2) => {
        return await df({ kernel, terminal, process: process2 });
      }, "run")
    }),
    download: new TerminalCommand({
      command: "download",
      description: "Download a file from the filesystem",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, multiple: true, description: "The path(s) to the file(s) to download" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await download({ shell, terminal, process: process2, args: argv.path });
      }, "run")
    }),
    echo: new TerminalCommand({
      command: "echo",
      description: "Print arguments to the standard output",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "text", type: String, typeLabel: "{underline text}", defaultOption: true, multiple: true, description: "The text to print" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await echo({ terminal, process: process2, args: argv.text });
      }, "run")
    }),
    edit: new TerminalCommand({
      command: "edit",
      description: "Edit a file",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, description: "The path to the file to edit" }
      ],
      run: /* @__PURE__ */ __name(async (argv) => {
        return await edit({ shell, terminal, args: [argv.path] });
      }, "run")
    }),
    env: new TerminalCommand({
      command: "env",
      description: "Print or set an environment variable",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "variables", type: String, multiple: true, defaultOption: true, typeLabel: "{underline variables}", description: "The environment variable(s) to print" },
        { name: "set", type: String, description: "Set the environment variable" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await env({ shell, terminal, process: process2, args: [argv.variables, argv.set] });
      }, "run")
    }),
    fetch: new TerminalCommand({
      command: "fetch",
      description: "Fetch a resource from the network",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "url", type: String, typeLabel: "{underline url}", defaultOption: true, description: "The URL to fetch" },
        { name: "filename", type: String, description: "Output the response to a file" },
        { name: "method", type: String, description: "The HTTP method to use", defaultValue: "GET" },
        { name: "body", type: String, description: "The body to send with the request" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await fetch$1({ shell, terminal, process: process2, args: [argv.url, argv.filename, argv.method, argv.body] });
      }, "run")
    }),
    install: new TerminalCommand({
      command: "install",
      description: "Install a package",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "package", type: String, typeLabel: "{underline package}", defaultOption: true, description: "The package name and optional version (e.g. package@1.0.0)" },
        { name: "registry", type: String, description: "The registry to use", defaultValue: "https://registry.npmjs.org" },
        { name: "reinstall", type: Boolean, description: "Reinstall the package if it is already installed" }
      ],
      run: /* @__PURE__ */ __name(async (argv) => {
        const { default: install } = await import("./install-DZKuxdnb.js");
        return await install({ kernel, shell, terminal, args: [argv.package, argv.registry, argv.reinstall] });
      }, "run")
    }),
    load: new TerminalCommand({
      command: "load",
      description: "Load a JavaScript file",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, description: "The path to the file to load" }
      ],
      run: /* @__PURE__ */ __name(async (argv) => {
        return await load({ shell, args: [argv.path] });
      }, "run")
    }),
    ls: new TerminalCommand({
      command: "ls",
      description: "List directory contents",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, description: "The path to the directory to list" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await ls({ kernel, shell, terminal, process: process2, args: [argv.path || shell.cwd] });
      }, "run")
    }),
    mkdir: new TerminalCommand({
      command: "mkdir",
      description: "Create a directory",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, description: "The path to the directory to create" }
      ],
      run: /* @__PURE__ */ __name(async (argv) => {
        return await mkdir({ shell, args: [argv.path] });
      }, "run")
    }),
    mount: new TerminalCommand({
      command: "mount",
      description: "Mount a filesystem",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "args", type: String, multiple: true, defaultOption: true, description: "The source and target of the filesystem to mount" },
        { name: "type", type: String, description: "The filesystem type", alias: "t" },
        { name: "options", type: String, description: "The options to pass to the filesystem type", alias: "o" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await mount({ kernel, shell, terminal, process: process2, args: [argv.args, argv.type, argv.options] });
      }, "run")
    }),
    mv: new TerminalCommand({
      command: "mv",
      description: "Move or rename files",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "args", type: String, multiple: true, defaultOption: true, description: "The source and destination paths" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await mv({ shell, terminal, process: process2, args: argv.args });
      }, "run")
    }),
    observe: new TerminalCommand({
      command: "observe",
      description: "Observe piped streams",
      kernel,
      shell,
      terminal,
      options: [HelpOption],
      run: /* @__PURE__ */ __name(async (_, process2) => {
        return await observe({ terminal, process: process2 });
      }, "run")
    }),
    open: new TerminalCommand({
      command: "open",
      description: "Open a file or URL",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, description: "The path to the file or URL to open" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await open({ terminal, process: process2, args: [argv.path] });
      }, "run")
    }),
    passwd: new TerminalCommand({
      command: "passwd",
      description: "Change user password",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "password", type: String, multiple: true, defaultOption: true, description: "Old and new passwords (optional - will prompt if not provided)" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await passwd({ kernel, terminal, process: process2, args: argv.password });
      }, "run")
    }),
    play: new TerminalCommand({
      command: "play",
      description: "Play a media file",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "file", type: String, typeLabel: "{underline file}", defaultOption: true, description: "The path to the media file to play" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await play({ shell, terminal, process: process2, args: [argv.file] });
      }, "run")
    }),
    ps: new TerminalCommand({
      command: "ps",
      description: "List all running processes",
      kernel,
      shell,
      terminal,
      options: [],
      run: /* @__PURE__ */ __name(async (_argv, process2) => {
        return await ps({ kernel, terminal, process: process2 });
      }, "run")
    }),
    pwd: new TerminalCommand({
      command: "pwd",
      description: "Print the shell working directory",
      kernel,
      shell,
      terminal,
      options: [],
      run: /* @__PURE__ */ __name(async (_argv, process2) => {
        return await pwd({ shell, terminal, process: process2 });
      }, "run")
    }),
    reboot: new TerminalCommand({
      command: "reboot",
      description: "Reboot the system",
      kernel,
      shell,
      terminal,
      options: [],
      run: /* @__PURE__ */ __name(async () => {
        return await reboot({ kernel });
      }, "run")
    }),
    rm: new TerminalCommand({
      command: "rm",
      description: "Remove files or directories",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, description: "The path to the file or directory to remove" }
      ],
      run: /* @__PURE__ */ __name(async (argv) => {
        return await rm({ shell, args: [argv.path] });
      }, "run")
    }),
    rmdir: new TerminalCommand({
      command: "rmdir",
      description: "Remove a directory",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, description: "The path to the directory to remove" }
      ],
      run: /* @__PURE__ */ __name(async (argv) => {
        return await rmdir({ shell, args: [argv.path] });
      }, "run")
    }),
    screensaver: new TerminalCommand({
      command: "screensaver",
      description: "Start the screensaver",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "screensaver", type: String, typeLabel: "{underline screensaver}", defaultOption: true, description: "The screensaver to start" },
        { name: "set", type: Boolean, description: "Set the default screensaver" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await screensaver({ kernel, terminal, process: process2, args: [argv.screensaver, argv.set] });
      }, "run")
    }),
    snake: new TerminalCommand({
      command: "snake",
      description: "Play a simple snake game",
      kernel,
      shell,
      terminal,
      options: [],
      run: /* @__PURE__ */ __name(async () => {
        await snake({ kernel, terminal });
      }, "run")
    }),
    socket: new TerminalCommand({
      command: "socket",
      description: "Send a message to the terminal socket",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "command", type: String, defaultOption: true, description: "The command to send to the terminal socket" },
        { name: "args", type: String, multiple: true, description: "The arguments to send to the command" }
      ],
      run: /* @__PURE__ */ __name(async () => {
        return await socket();
      }, "run")
    }),
    stat: new TerminalCommand({
      command: "stat",
      description: "Display information about a file or directory",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, description: "The path to the file or directory to display" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await stat({ shell, terminal, process: process2, args: [argv.path] });
      }, "run")
    }),
    su: new TerminalCommand({
      command: "su",
      description: "Switch user",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "user", type: String, defaultOption: true, description: "The user to switch to" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await su({ kernel, shell, terminal, process: process2, args: [argv.user] });
      }, "run")
    }),
    touch: new TerminalCommand({
      command: "touch",
      description: "Create an empty file",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, description: "The path to the file to create" }
      ],
      run: /* @__PURE__ */ __name(async (argv) => {
        return await touch({ shell, args: [argv.path] });
      }, "run")
    }),
    umount: new TerminalCommand({
      command: "umount",
      description: "Unmount a filesystem",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, description: "The path to the directory to unmount" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await umount({ kernel, shell, terminal, process: process2, args: [argv.path] });
      }, "run")
    }),
    unzip: new TerminalCommand({
      command: "unzip",
      description: "Unzip a file",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, description: "The path to the file to unzip" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await unzip({ shell, terminal, process: process2, args: [argv.path] });
      }, "run")
    }),
    upload: new TerminalCommand({
      command: "upload",
      description: "Upload a file to the filesystem",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "path", type: String, typeLabel: "{underline path}", defaultOption: true, description: "The path to store the file" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await upload({ kernel, shell, terminal, process: process2, args: [argv.path] });
      }, "run")
    }),
    user: new TerminalCommand({
      command: "user",
      description: "Manage users",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        {
          name: "command",
          type: String,
          defaultOption: true,
          description: "Command to run (list, add, del, mod)"
        },
        {
          name: "username",
          alias: "u",
          type: String,
          description: "Username for the operation",
          typeLabel: "{underline username}"
        },
        {
          name: "password",
          alias: "p",
          type: String,
          description: "Password for add/mod operations",
          typeLabel: "{underline password}"
        }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await user({ kernel, shell, terminal, process: process2, args: [argv.command, argv.username, argv.password] });
      }, "run")
    }),
    video: new TerminalCommand({
      command: "video",
      description: "Play a video file",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "file", type: String, typeLabel: "{underline file}", defaultOption: true, description: "The path to the video file to play" }
      ],
      run: /* @__PURE__ */ __name(async (argv) => {
        return await video({ kernel, shell, args: [argv.file] });
      }, "run")
    }),
    zip: new TerminalCommand({
      command: "zip",
      description: "Zip a directory",
      kernel,
      shell,
      terminal,
      options: [
        HelpOption,
        { name: "output", type: String, typeLabel: "{underline path}", defaultOption: true, description: "The path to the zip file to create" },
        { name: "path", type: String, typeLabel: "{underline path}", multiple: true, description: "The paths to the files or directories to zip" }
      ],
      run: /* @__PURE__ */ __name(async (argv, process2) => {
        return await zip({ shell, terminal, process: process2, args: [argv.output, argv.path] });
      }, "run")
    })
  };
}, "TerminalCommands");
const cat = /* @__PURE__ */ __name(async ({ kernel, shell, terminal, process: process2, args }) => {
  if (!process2) return 1;
  const writer = process2.stdout.getWriter();
  try {
    if (!args || !args[0]) {
      const reader = process2.stdin.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          await writer.write(value);
        }
      } finally {
        reader.releaseLock();
      }
      return 0;
    }
    const [files = [], bytes] = args;
    for (const file of files) {
      const fullPath = path$1.resolve(shell.cwd, file);
      let interrupted = false;
      const interruptHandler = /* @__PURE__ */ __name(() => {
        interrupted = true;
      }, "interruptHandler");
      kernel.terminal.events.on(TerminalEvents.INTERRUPT, interruptHandler);
      try {
        if (!fullPath.startsWith("/dev")) {
          const handle = await shell.context.fs.promises.open(fullPath, "r");
          const stat2 = await shell.context.fs.promises.stat(fullPath);
          let bytesRead = 0;
          const chunkSize = 1024;
          while (bytesRead < stat2.size) {
            if (interrupted) break;
            const data = new Uint8Array(chunkSize);
            const readSize = Math.min(chunkSize, stat2.size - bytesRead);
            await handle.read(data, 0, readSize, bytesRead);
            await writer.write(data.subarray(0, readSize));
            bytesRead += readSize;
          }
        } else {
          const device = await shell.context.fs.promises.open(fullPath);
          const maxBytes = bytes ? parseInt(bytes) : void 0;
          let totalBytesRead = 0;
          const chunkSize = 1024;
          const data = new Uint8Array(chunkSize);
          let bytesRead = 0;
          do {
            if (interrupted) break;
            const result = await device.read(data);
            bytesRead = result.bytesRead;
            if (bytesRead > 0) {
              const bytesToWrite = maxBytes ? Math.min(bytesRead, maxBytes - totalBytesRead) : bytesRead;
              if (bytesToWrite > 0) {
                await writer.write(data.subarray(0, bytesToWrite));
                totalBytesRead += bytesToWrite;
              }
            }
          } while (bytesRead > 0 && (!maxBytes || totalBytesRead < maxBytes));
        }
      } finally {
        kernel.terminal.events.off(TerminalEvents.INTERRUPT, interruptHandler);
      }
    }
    return 0;
  } finally {
    writer.releaseLock();
    await writeStdout(process2, terminal, "\n");
  }
}, "cat");
const cd = /* @__PURE__ */ __name(async ({ shell, args }) => {
  let destination = args[0];
  if (destination && destination.startsWith("~")) {
    const home = shell.env.get("HOME");
    if (home) {
      destination = destination.replace(/^~(?=$|\/)/, home);
    }
  }
  const fullPath = destination ? path$1.resolve(shell.cwd, destination) : shell.cwd;
  await shell.context.fs.promises.access(fullPath);
  shell.cwd = fullPath;
  localStorage.setItem(`cwd:${shell.credentials.uid}`, fullPath);
}, "cd");
const chmod = /* @__PURE__ */ __name(async ({ shell, terminal, process: process2, args }) => {
  if (!args || args.length === 0) {
    await writelnStderr(process2, terminal, chalk$1.red("chmod: missing operand"));
    await writelnStderr(process2, terminal, "Try 'chmod --help' for more information.");
    return 1;
  }
  const [mode2, target] = args;
  if (!mode2 || !target) return 1;
  const fullPath = path$1.resolve(shell.cwd, target);
  await shell.context.fs.promises.chmod(fullPath, mode2);
  return 0;
}, "chmod");
const chown = /* @__PURE__ */ __name(async ({ shell, args }) => {
  const [user2, target, group] = args;
  if (!user2 || !target) return 1;
  const fullPath = path$1.resolve(shell.cwd, target);
  await shell.context.fs.promises.chown(fullPath, parseInt(user2), parseInt(group ?? user2));
}, "chown");
const clear = /* @__PURE__ */ __name(async ({ terminal }) => {
  terminal.write("\x1B[2J\x1B[H");
}, "clear");
const cp = /* @__PURE__ */ __name(async ({ shell, args }) => {
  const [source2, destination] = args.map((arg) => path$1.resolve(shell.cwd, arg));
  if (!source2 || !destination) return 1;
  const destinationStats = await shell.context.fs.promises.stat(destination).catch(() => null);
  const finalDestination = destinationStats?.isDirectory() ? path$1.join(destination, path$1.basename(source2)) : destination;
  await shell.context.fs.promises.copyFile(source2, finalDestination);
}, "cp");
const df = /* @__PURE__ */ __name(async ({ kernel, terminal, process: process2 }) => {
  const usage = await kernel.storage.usage();
  if (!usage) return 1;
  const getData = /* @__PURE__ */ __name((usage2) => {
    const data2 = {};
    for (const [key, value] of Object.entries(usage2)) {
      if (typeof value === "object" && value !== null) {
        data2[key] = getData(value);
      } else if (typeof value === "number") {
        data2[key] = humanFormat(value);
      } else {
        data2[key] = String(value);
      }
    }
    return data2;
  }, "getData");
  const data = getData(usage);
  await writelnStdout(process2, terminal, JSON.stringify(data, null, 2));
  return 0;
}, "df");
const download = /* @__PURE__ */ __name(async ({ shell, terminal, process: process2, args }) => {
  const destination = args[0];
  const fullPath = destination ? path$1.resolve(shell.cwd, destination) : shell.cwd;
  if (await shell.context.fs.promises.exists(fullPath)) {
    const data = await shell.context.fs.promises.readFile(fullPath);
    const blob = new Blob([new Uint8Array(data)], { type: "application/octet-stream" });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = path$1.basename(fullPath);
    a.click();
    window.URL.revokeObjectURL(url);
  } else {
    await writelnStderr(process2, terminal, chalk$1.red(`${fullPath} not found`));
  }
}, "download");
const echo = /* @__PURE__ */ __name(async ({ process: process2, terminal, args }) => {
  const text = args.join(" ");
  const data = new TextEncoder().encode(text + "\n");
  if (process2) {
    const writer = process2.stdout.getWriter();
    try {
      await writer.write(data);
    } finally {
      writer.releaseLock();
    }
  } else {
    terminal.write(text + "\n");
  }
  return 0;
}, "echo");
const edit = /* @__PURE__ */ __name(async ({ shell, terminal, args }) => {
  const target = args[0];
  if (!target) return 1;
  const fullPath = path$1.resolve(shell.cwd, target);
  const content = await shell.context.fs.promises.readFile(fullPath, "utf-8").catch(() => "");
  const lines = content.split("\n");
  let cursorX = 0;
  let cursorY = 0;
  let message;
  let mode2 = "normal";
  let startLine = 0;
  const renderScreen = /* @__PURE__ */ __name(() => {
    terminal.write(ansi$6.erase.display(2) + ansi$6.cursor.position(0, 0));
    const visibleLines = lines.slice(startLine, startLine + terminal.rows - 1);
    visibleLines.forEach((line3) => terminal.writeln(line3));
    let modeColor = chalk$1.gray;
    switch (mode2) {
      case "insert":
        modeColor = chalk$1.green;
        break;
      case "replace":
        modeColor = chalk$1.red;
        break;
    }
    if (!message) terminal.write(modeColor(`-- ${mode2.toUpperCase()} MODE (${cursorY + 1}, ${cursorX + 1}) = ${lines[cursorY]?.[cursorX] ?? ""} --`));
    else terminal.write(`--- ${message} ---`);
    if (message) message = void 0;
    terminal.write(`\x1B[${cursorY - startLine + 1};${cursorX + 1}H`);
  }, "renderScreen");
  const handleNormalMode = /* @__PURE__ */ __name(async (event) => {
    switch (event.key) {
      case "Insert":
      case "i":
        mode2 = "insert";
        break;
      case "r":
        mode2 = "replace";
        break;
      case "ArrowLeft":
      case "h":
        cursorX = Math.max(0, cursorX - 1);
        break;
      case "ArrowDown":
      case "j":
        if (cursorY < lines.length - 1) {
          cursorY++;
          if (cursorY >= startLine + terminal.rows - 1) startLine++;
        }
        break;
      case "ArrowUp":
      case "k":
        if (cursorY > 0) {
          cursorY--;
          if (cursorY < startLine) {
            startLine--;
          }
        }
        break;
      case "ArrowRight":
      case "l":
        cursorX = lines[cursorY]?.length === 0 ? 0 : Math.min((lines[cursorY]?.length ?? 1) - 1, cursorX + 1);
        break;
      case "Home":
        cursorX = 0;
        break;
      case "End":
        cursorX = (lines[cursorY]?.length ?? 0) - 1;
        break;
      case "PageUp":
        if (cursorY > 0) {
          const pageSize = terminal.rows - 2;
          cursorY = Math.max(0, cursorY - pageSize);
          startLine = Math.max(0, startLine - pageSize);
          if (cursorY < startLine) {
            startLine = cursorY;
          }
        }
        break;
      case "PageDown":
        if (cursorY < lines.length - 1) {
          const pageSize = terminal.rows - 2;
          cursorY = Math.min(lines.length - 1, cursorY + pageSize);
          startLine = Math.min(lines.length - pageSize, startLine + pageSize);
          if (cursorY >= startLine + pageSize) {
            startLine = cursorY - pageSize + 1;
          }
        }
        break;
      case "Delete":
      case "d":
        if (cursorX < (lines[cursorY]?.length ?? 0)) {
          lines[cursorY] = (lines[cursorY]?.slice(0, cursorX) ?? "") + (lines[cursorY]?.slice(cursorX + 1) ?? "");
        } else if (cursorY < lines.length - 1) {
          lines[cursorY] += lines[cursorY + 1] ?? "";
          lines.splice(cursorY + 1, 1);
        }
        break;
      case ":":
        terminal.write(ansi$6.cursor.position(terminal.rows, 0) + ansi$6.erase.inLine());
        const cmdLine = await terminal.readline(":", false, true);
        const lineNum = parseInt(cmdLine);
        if (!isNaN(lineNum)) {
          const targetLine = Math.max(0, Math.min(lines.length - 1, lineNum - 1));
          if (targetLine < startLine || targetLine >= startLine + terminal.rows - 1)
            startLine = Math.max(0, Math.min(lines.length - terminal.rows + 1, targetLine - Math.floor((terminal.rows - 1) / 2)));
          cursorY = targetLine;
        } else for (const command of cmdLine.split("")) {
          switch (command) {
            case "w":
              message = chalk$1.green(`Saved to ${fullPath}`);
              await shell.context.fs.promises.writeFile(fullPath, lines.join("\n"));
              break;
            case "q":
              return true;
          }
        }
        break;
      case "v":
        if (!event.ctrlKey) break;
        try {
          const clipboardText = await navigator.clipboard.readText();
          const clipboardLines = clipboardText.split("\n");
          lines.splice(cursorY, 0, ...clipboardLines);
          message = chalk$1.green("Pasted text");
        } catch (err2) {
          message = chalk$1.red("Failed to paste: " + (err2 instanceof Error ? err2.message : "Unknown error"));
        }
        break;
    }
    return false;
  }, "handleNormalMode");
  const handleEditMode = /* @__PURE__ */ __name((event, replace = false) => {
    switch (event.key) {
      case "Insert":
        mode2 = replace ? "insert" : "replace";
        break;
      case "Escape":
        mode2 = "normal";
        break;
      case "Home":
        cursorX = 0;
        break;
      case "End":
        cursorX = lines[cursorY]?.length ?? 0;
        break;
      case "PageUp":
        if (cursorY > 0) {
          const pageSize = terminal.rows - 2;
          cursorY = Math.max(0, cursorY - pageSize);
          startLine = Math.max(0, startLine - pageSize);
          if (cursorY < startLine) {
            startLine = cursorY;
          }
        }
        break;
      case "PageDown":
        if (cursorY < lines.length - 1) {
          const pageSize = terminal.rows - 2;
          cursorY = Math.min(lines.length - 1, cursorY + pageSize);
          startLine = Math.min(lines.length - pageSize, startLine + pageSize);
          if (cursorY >= startLine + pageSize) {
            startLine = cursorY - pageSize + 1;
          }
        }
        break;
      case "Enter":
        lines.splice(cursorY + 1, 0, lines[cursorY]?.slice(cursorX) ?? "");
        lines[cursorY] = lines[cursorY]?.slice(0, cursorX) ?? "";
        cursorY++;
        cursorX = 0;
        break;
      case "Backspace":
        if (cursorX > 0) {
          lines[cursorY] = (lines[cursorY]?.slice(0, cursorX - 1) ?? "") + (lines[cursorY]?.slice(cursorX) ?? "");
          cursorX--;
        } else if (cursorY > 0) {
          cursorX = (lines[cursorY - 1]?.length ?? 0) - 1;
          lines[cursorY - 1] += lines[cursorY] ?? "";
          lines.splice(cursorY, 1);
          cursorY--;
        }
        break;
      case "Delete":
        if (cursorX < (lines[cursorY]?.length ?? 0)) {
          lines[cursorY] = (lines[cursorY]?.slice(0, cursorX) ?? "") + (lines[cursorY]?.slice(cursorX + 1) ?? "");
        } else if (cursorY < lines.length - 1) {
          lines[cursorY] += lines[cursorY + 1] ?? "";
          lines.splice(cursorY + 1, 1);
        }
        break;
      case "ArrowLeft":
        cursorX = Math.max(0, cursorX - 1);
        break;
      case "ArrowUp":
        if (cursorY > 0) {
          cursorY--;
          cursorX = Math.min(lines[cursorY]?.length ?? 0, cursorX);
        }
        break;
      case "ArrowDown":
        if (cursorY < lines.length - 1) {
          cursorY++;
          cursorX = Math.min(lines[cursorY]?.length ?? 0, cursorX);
        }
        break;
      case "ArrowRight":
        cursorX = Math.min(lines[cursorY]?.length ?? 0, cursorX + 1);
        break;
      case "v":
        if (event.ctrlKey || event.metaKey) {
          navigator.clipboard.readText().then((clipboardText) => {
            const clipboardLines = clipboardText.split("\n");
            if (replace) {
              lines.splice(cursorY, clipboardLines.length, ...clipboardLines);
            } else {
              const currentLine = lines[cursorY] ?? "";
              const beforeCursor = currentLine.slice(0, cursorX);
              const afterCursor = currentLine.slice(cursorX);
              lines[cursorY] = beforeCursor + clipboardLines[0];
              if (clipboardLines.length > 1) {
                const remainingLines = clipboardLines.slice(1);
                remainingLines[remainingLines.length - 1] += afterCursor;
                lines.splice(cursorY + 1, 0, ...remainingLines);
              } else {
                lines[cursorY] += afterCursor;
              }
              cursorY += clipboardLines.length - 1;
              cursorX = clipboardLines[clipboardLines.length - 1]?.length ?? 0;
            }
          }).catch((err2) => {
            message = chalk$1.red("Failed to paste: " + err2.message);
          });
        } else {
          if (replace) lines[cursorY] = (lines[cursorY]?.slice(0, cursorX) ?? "") + event.key + (lines[cursorY]?.slice(cursorX + 1) ?? "");
          else lines[cursorY] = (lines[cursorY]?.slice(0, cursorX) ?? "") + event.key + (lines[cursorY]?.slice(cursorX) ?? "");
          cursorX++;
        }
        break;
      default:
        if (replace) lines[cursorY] = (lines[cursorY]?.slice(0, cursorX) ?? "") + event.key + (lines[cursorY]?.slice(cursorX + 1) ?? "");
        else lines[cursorY] = (lines[cursorY]?.slice(0, cursorX) ?? "") + event.key + (lines[cursorY]?.slice(cursorX) ?? "");
        cursorX++;
    }
  }, "handleEditMode");
  let active = true;
  terminal.unlisten();
  while (active) {
    renderScreen();
    const { domEvent } = await new Promise((resolve2) => terminal.onKey(resolve2));
    switch (mode2) {
      case "normal":
        if (await handleNormalMode(domEvent)) active = false;
        break;
      case "insert":
        handleEditMode(domEvent);
        break;
      case "replace":
        handleEditMode(domEvent, true);
        break;
    }
  }
  terminal.write(ansi$6.erase.display(2) + ansi$6.cursor.position());
  terminal.listen();
}, "edit");
const env = /* @__PURE__ */ __name(async ({ shell, terminal, process: process2, args }) => {
  const [variables, value] = args;
  if (!variables) {
    for (const [key, value2] of shell.env.entries()) {
      await writelnStdout(process2, terminal, `${chalk$1.bold(key)}=${chalk$1.green(value2)}`);
    }
  } else {
    for (const variable of variables) {
      if (!value) {
        await writelnStdout(process2, terminal, `${chalk$1.bold(variable)}=${chalk$1.green(shell.env.get(variable) || "")}`);
      } else {
        shell.env.set(variable, value);
        globalThis.process.env[variable] = value;
      }
    }
  }
}, "env");
const fetch$1 = /* @__PURE__ */ __name(async ({ shell, terminal, process: process2, args }) => {
  const [url, filename, method, body2] = args;
  if (!url) {
    await shell.execute("fetch --help");
    return 1;
  }
  try {
    const fetchOptions = { method: method || "GET" };
    if (body2) fetchOptions.body = body2;
    const response = await globalThis.fetch(url, fetchOptions);
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const reader = response.body?.getReader();
    if (!reader) throw new Error("No response body");
    let writer;
    if (filename) {
      const fullPath = path$1.resolve(shell.cwd, filename);
      const fileHandle = await shell.context.fs.promises.open(fullPath, "w");
      writer = {
        write: /* @__PURE__ */ __name(async (chunk) => {
          await fileHandle.write(chunk);
        }, "write"),
        releaseLock: /* @__PURE__ */ __name(async () => {
          await fileHandle.close();
        }, "releaseLock")
      };
    } else writer = process2?.stdout?.getWriter();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        await writer?.write(value);
      }
    } finally {
      reader.releaseLock();
      writer?.releaseLock();
      await writeStdout(process2, terminal, "\n");
    }
    return 0;
  } catch (error) {
    await writelnStderr(process2, terminal, chalk$1.red(`Error: ${error instanceof Error ? error.message : "Unknown error"}`));
    return 1;
  }
}, "fetch$1");
const load = /* @__PURE__ */ __name(async ({ shell, args }) => {
  const [target] = args;
  if (!target) {
    await shell.execute("load --help");
    return 1;
  }
  const fullPath = path$1.resolve(shell.cwd, target);
  const code2 = await shell.context.fs.promises.readFile(fullPath, "utf-8");
  const script = new Function(code2);
  script();
}, "load");
const ls = /* @__PURE__ */ __name(async ({ kernel, shell, terminal, process: process2, args }) => {
  const target = args[0];
  const fullPath = target ? path$1.resolve(shell.cwd, target === "" ? "." : target) : shell.cwd;
  const stats = await shell.context.fs.promises.stat(fullPath);
  const entries2 = stats.isDirectory() ? await shell.context.fs.promises.readdir(fullPath) : [fullPath];
  const descriptions = kernel.filesystem.descriptions(kernel.i18n.t);
  const getModeType = /* @__PURE__ */ __name((stats2) => {
    let type = "-";
    if (stats2.isDirectory()) type = "d";
    else if (stats2.isSymbolicLink()) type = "l";
    else if (stats2.isBlockDevice()) type = "b";
    else if (stats2.isCharacterDevice()) type = "c";
    else if (stats2.isFIFO()) type = "p";
    else if (stats2.isSocket()) type = "s";
    return type;
  }, "getModeType");
  const getModeString = /* @__PURE__ */ __name((stats2) => {
    return getModeType(stats2) + (stats2.mode & parseInt("777", 8)).toString(8).padStart(3, "0").replace(/0/g, "---").replace(/1/g, "--" + chalk$1.red("x")).replace(/2/g, "-" + chalk$1.yellow("w") + "-").replace(/3/g, "-" + chalk$1.yellow("w") + chalk$1.red("x")).replace(/4/g, chalk$1.green("r") + "--").replace(/5/g, chalk$1.green("r") + "-" + chalk$1.red("x")).replace(/6/g, chalk$1.green("r") + chalk$1.yellow("w") + "-").replace(/7/g, chalk$1.green("r") + chalk$1.yellow("w") + chalk$1.red("x"));
  }, "getModeString");
  const getTimestampString = /* @__PURE__ */ __name((timestamp) => {
    const diff = ((/* @__PURE__ */ new Date()).getTime() - timestamp.getTime()) / 1e3;
    if (diff < 24 * 60 * 60) return chalk$1.green(timestamp.toISOString().slice(0, 19).replace("T", " "));
    else if (diff < 7 * 24 * 60 * 60) return chalk$1.yellow(timestamp.toISOString().slice(0, 19).replace("T", " "));
    else if (diff < 30 * 24 * 60 * 60) return chalk$1.blue(timestamp.toISOString().slice(0, 19).replace("T", " "));
    else if (diff < 365 * 24 * 60 * 60) return chalk$1.magenta(timestamp.toISOString().slice(0, 19).replace("T", " "));
    else return chalk$1.gray(timestamp.toISOString().slice(0, 19).replace("T", " "));
  }, "getTimestampString");
  const getOwnerString = /* @__PURE__ */ __name((stats2) => {
    const owner = kernel.users.all.get(stats2.uid) || kernel.users.all.get(0);
    if (owner?.username === shell.username) return chalk$1.green(`${owner?.username || stats2.uid}:${owner?.username || stats2.gid}`);
    else if (stats2.uid === 0) return chalk$1.red(`${owner?.username || stats2.uid}:${owner?.username || stats2.gid}`);
    else return chalk$1.gray(`${owner?.username || stats2.uid}:${owner?.username || stats2.gid}`);
  }, "getOwnerString");
  const filesMap = await Promise.all(entries2.map(async (entry) => {
    const target2 = path$1.resolve(fullPath, entry);
    try {
      return { target: target2, name: entry, stats: await shell.context.fs.promises.stat(target2) };
    } catch {
      return { target: target2, name: entry, stats: null };
    }
  }));
  const files = filesMap.filter((entry) => entry && entry.stats && !entry.stats.isDirectory()).filter((entry) => entry !== null && entry !== void 0);
  const directoryMap = await Promise.all(entries2.map(async (entry) => {
    const target2 = path$1.resolve(fullPath, entry);
    try {
      return { target: target2, name: entry, stats: await shell.context.fs.promises.stat(target2) };
    } catch {
      return { target: target2, name: entry, stats: null };
    }
  }));
  const directories = directoryMap.filter((entry) => entry && entry.stats && entry.stats.isDirectory()).filter((entry, index, self2) => self2.findIndex((e2) => e2?.name === entry?.name) === index).filter((entry) => entry !== null && entry !== void 0);
  const data = [
    ["Name", "Size", "Modified", "Mode", "Owner", "Info"],
    ...directories.sort((a, b) => a.name.localeCompare(b.name)).map((directory) => {
      return [
        directory.name,
        "",
        directory.stats ? getTimestampString(directory.stats.mtime) : "",
        directory.stats ? getModeString(directory.stats) : "",
        directory.stats ? getOwnerString(directory.stats) : ""
        // (() => {
        //   const mount = mounts.find(([target]) => target.endsWith(`/${directory.name}`))
        //   // TODO: store does not exist on FileSystem (but we can access it here)
        //   // @ts-ignore
        //   if (mount) return chalk.white(`(${mount[1].store?.constructor.name || mount[1].constructor.name}/${mount[1].metadata().name})`)
        //   return descriptions.get(path.resolve(fullPath, directory.name)) || ''
        // })()
      ];
    }),
    ...files.sort((a, b) => a.name.localeCompare(b.name)).map((file) => {
      return [
        file.name,
        file.stats ? humanFormat(file.stats.size) : "",
        file.stats ? getTimestampString(file.stats.mtime) : "",
        file.stats ? getModeString(file.stats) : "",
        file.stats ? getOwnerString(file.stats) : "",
        (() => {
          if (descriptions.has(path$1.resolve(fullPath, file.name))) return descriptions.get(path$1.resolve(fullPath, file.name));
          const ext = file.name.split(".").pop();
          if (ext && descriptions.has("." + ext)) return descriptions.get("." + ext);
          if (!file.stats) return "";
          if (file.stats.isBlockDevice() || file.stats.isCharacterDevice()) ;
          return "";
        })()
      ];
    })
  ];
  if (fullPath.startsWith("/dev")) data.forEach((row) => row.splice(1, 2));
  const columnWidths = data[0]?.map((_, colIndex) => Math.max(...data.map((row) => {
    const cleanedCell = row[colIndex]?.replace(/\u001b\[.*?m/g, "");
    return cleanedCell?.length || 0;
  })));
  for (const [rowIndex, row] of data.entries()) {
    const line3 = row.map((cell, index) => {
      const paddedCell = cell.padEnd(columnWidths?.[index] ?? 0);
      if (index === 0 && rowIndex > 0) {
        return row[3]?.startsWith("d") ? chalk$1.blue(paddedCell) : chalk$1.green(paddedCell);
      } else return rowIndex === 0 ? chalk$1.bold(paddedCell) : chalk$1.gray(paddedCell);
    }).join("  ");
    if (data.length > 1) await writelnStdout(process2, terminal, line3);
  }
  return 0;
}, "ls");
const mount = /* @__PURE__ */ __name(async ({ kernel, shell, terminal, process: process2, args }) => {
  const [points, type, config2] = args;
  if (!points || !type || points.length !== 2) {
    await writelnStderr(process2, terminal, chalk$1.red("Usage: mount -t <type> <source> <target>"));
    const currentMounts = Array.from(kernel.filesystem.fsSync.mounts.entries()).map(([target2, mount2]) => `${chalk$1.blue(target2)} (${mount2.store?.constructor.name || mount2.constructor.name}/${mount2.metadata().name})`);
    const maxTargetLength = Math.max(...currentMounts.map((mount2) => mount2.split(" ")[0]?.length ?? 0));
    for (const mount2 of currentMounts) {
      const [target2, name] = mount2.split(" ");
      if (!target2 || !name) continue;
      await writelnStdout(process2, terminal, chalk$1.gray(`${target2.padEnd(maxTargetLength + 2)}${name}`));
    }
    return 1;
  }
  const options = config2?.split(",").map((option) => option.split("=")).reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});
  const [source2, target] = points;
  if (!source2 || !target) {
    await writelnStderr(process2, terminal, chalk$1.red("Usage: mount -t <type> <source> <target>"));
    return 1;
  }
  const fullSourcePath = path$1.resolve(shell.cwd, source2);
  const fullTargetPath = path$1.resolve(shell.cwd, target);
  switch (type.toLowerCase()) {
    case "fetch":
      kernel.filesystem.fsSync.mount(fullTargetPath, await resolveMountConfig({ backend: Fetch, index: fullSourcePath, baseUrl: options?.baseUrl || "" }));
      break;
    case "indexeddb":
      kernel.filesystem.fsSync.mount(fullTargetPath, await resolveMountConfig({ backend: IndexedDB, storeName: fullSourcePath }));
      break;
    case "memory":
      kernel.filesystem.fsSync.mount(fullTargetPath, await resolveMountConfig({ backend: InMemory }));
      break;
  }
  return 0;
}, "mount");
const mkdir = /* @__PURE__ */ __name(async ({ shell, args }) => {
  const target = args[0];
  const fullPath = target ? path$1.resolve(shell.cwd, target) : shell.cwd;
  await shell.context.fs.promises.mkdir(fullPath);
}, "mkdir");
const mv = /* @__PURE__ */ __name(async ({ shell, terminal, process: process2, args }) => {
  const [sourceInput, destinationInput] = args;
  if (!sourceInput || !destinationInput) {
    await writelnStderr(process2, terminal, chalk$1.red("Usage: mv <source> <destination>"));
    return 1;
  }
  const source2 = path$1.resolve(shell.cwd, sourceInput);
  let destination = path$1.resolve(shell.cwd, destinationInput);
  if (source2 === destination) return 0;
  const disallowedPaths = ["/dev", "/proc", "/sys", "/run"];
  if (disallowedPaths.some((path2) => source2.startsWith(path2) || destination.startsWith(path2))) {
    await writelnStderr(process2, terminal, chalk$1.red("Cannot move disallowed paths"));
    return 2;
  }
  if (await shell.context.fs.promises.exists(destination)) {
    if ((await shell.context.fs.promises.stat(destination)).isDirectory()) {
      destination = path$1.resolve(destination, path$1.basename(source2));
    } else {
      await writelnStderr(process2, terminal, chalk$1.red(`${destination} already exists`));
      return 1;
    }
  }
  await shell.context.fs.promises.rename(source2, destination);
  return 0;
}, "mv");
const observe = /* @__PURE__ */ __name(async ({ process: process2, terminal }) => {
  if (!process2) throw new Error("Missing process");
  const { stdin, stdout, stderr } = process2;
  if (!stdin) {
    await writelnStderr(process2, terminal, chalk$1.red("No stdin available"));
    return 1;
  }
  const reader = stdin.getReader();
  const decoder2 = new TextDecoder();
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      const text = decoder2.decode(value);
      if (stderr) {
        const errWriter = stderr.getWriter();
        try {
          await errWriter.write(new TextEncoder().encode(chalk$1.green(`[stdin] ${text.trim()}
`)));
        } finally {
          errWriter.releaseLock();
        }
      }
      if (stdout) {
        const writer = stdout.getWriter();
        try {
          await writer.write(value);
        } finally {
          writer.releaseLock();
        }
      }
    }
  } finally {
    reader.releaseLock();
  }
  return 0;
}, "observe");
const open = /* @__PURE__ */ __name(async ({ terminal, process: process2, args }) => {
  const [filePath] = args;
  if (!filePath) return 1;
  const isURL = !filePath.startsWith("/") || !filePath.startsWith(".");
  if (isURL) window.open(filePath, "_blank");
  else {
    await writelnStderr(process2, terminal, chalk$1.red("Unsupported path"));
  }
}, "open");
const passwd = /* @__PURE__ */ __name(async ({ kernel, terminal, process: process2, args }) => {
  let oldPass, newPass;
  if (!args || !Array.isArray(args) || args.length < 2) {
    oldPass = await terminal.readline(chalk$1.cyan("Enter current password: "), true);
    if (!oldPass) {
      await writelnStderr(process2, terminal, chalk$1.red("Current password required"));
      return 1;
    }
    newPass = await terminal.readline(chalk$1.cyan("Enter new password: "), true);
    if (!newPass) {
      await writelnStderr(process2, terminal, chalk$1.red("New password required"));
      return 1;
    }
    const confirmPass = await terminal.readline(chalk$1.cyan("Confirm new password: "), true);
    if (newPass !== confirmPass) {
      await writelnStderr(process2, terminal, chalk$1.red("Passwords do not match"));
      return 1;
    }
  } else {
    [oldPass, newPass] = args;
  }
  try {
    if (!oldPass || !newPass) throw new Error("Missing password");
    await kernel.users.password(oldPass, newPass);
    await writelnStdout(process2, terminal, chalk$1.green("Password updated successfully"));
    return 0;
  } catch (error) {
    await writelnStderr(process2, terminal, chalk$1.red(`Failed to update password: ${error instanceof Error ? error.message : "Unknown error"}`));
    return 1;
  }
}, "passwd");
const play = /* @__PURE__ */ __name(async ({ shell, terminal, process: process2, args }) => {
  const [file] = args;
  if (!file || file === "") {
    await writelnStderr(process2, terminal, chalk$1.red("Usage: play <file>"));
    return 1;
  }
  const fullPath = path$1.resolve(shell.cwd, file);
  const blob = new Blob([new Uint8Array(await shell.context.fs.promises.readFile(fullPath))]);
  const url = URL.createObjectURL(blob);
  const audio = new Audio(url);
  audio.play();
}, "play");
const ps = /* @__PURE__ */ __name(async ({ kernel, terminal, process: process2 }) => {
  await writelnStdout(process2, terminal, "PID	COMMAND			STATUS");
  for (const [pid, proc] of kernel.processes.all.entries()) {
    await writelnStdout(process2, terminal, `${chalk$1.yellow(pid)}	${chalk$1.green(proc.command)}			${chalk$1.blue(proc.status)}`);
  }
}, "ps");
const pwd = /* @__PURE__ */ __name(async ({ shell, terminal, process: process2 }) => {
  await writelnStdout(process2, terminal, shell.cwd);
}, "pwd");
const reboot = /* @__PURE__ */ __name(async ({ kernel }) => {
  kernel.reboot();
}, "reboot");
const rm = /* @__PURE__ */ __name(async ({ shell, args }) => {
  const target = args[0];
  const fullPath = target ? path$1.resolve(shell.cwd, target) : shell.cwd;
  if ((await shell.context.fs.promises.stat(fullPath)).isDirectory()) await shell.context.fs.promises.rmdir(fullPath);
  else await shell.context.fs.promises.unlink(fullPath);
  return 0;
}, "rm");
const rmdir = /* @__PURE__ */ __name(async ({ shell, args }) => {
  const target = args[0];
  const fullPath = target ? path$1.resolve(shell.cwd, target) : shell.cwd;
  await shell.context.fs.promises.rm(fullPath, { recursive: true, force: true });
}, "rmdir");
const screensaver = /* @__PURE__ */ __name(async ({ kernel, terminal, process: process2, args }) => {
  const [screensaverName, set2] = args;
  if (screensaverName === "off") {
    kernel.storage.local.removeItem("screensaver");
    return 0;
  }
  let saverName = screensaverName;
  if (!saverName) saverName = kernel.storage.local.getItem("screensaver") || "matrix";
  const saver = kernel.screensavers.get(saverName);
  if (!saver) {
    await writelnStderr(process2, terminal, chalk$1.red("Invalid screensaver"));
    return 1;
  }
  terminal.blur();
  saver.default({ terminal });
  if (set2) kernel.storage.local.setItem("screensaver", saverName);
}, "screensaver");
const snake = /* @__PURE__ */ __name(({ kernel, terminal }) => {
  const width = 20;
  const height = 10;
  const snake2 = [{ x: 10, y: 5 }];
  let food = { x: 15, y: 5 };
  let direction = { x: 1, y: 0 };
  let score = 0;
  let gameOver = false;
  let gameStarted = false;
  const renderGame = /* @__PURE__ */ __name(() => {
    const gameBoard = Array(height).fill(null).map(() => Array(width).fill(" "));
    snake2.forEach((segment) => gameBoard[segment.y][segment.x] = segment.y === snake2[0].y && segment.x === snake2[0].x ? chalk$1.yellow("█") : chalk$1.gray("█"));
    gameBoard[food.y][food.x] = chalk$1.green("●");
    terminal.write(ansi$6.erase.display(2) + ansi$6.cursor.position(2, 1));
    terminal.writeln(chalk$1.blue("┌" + "─".repeat(width) + "┐"));
    gameBoard.forEach((row) => terminal.writeln(chalk$1.blue("│" + row.join("") + "│")));
    terminal.writeln(chalk$1.blue(`└${"─".repeat(width)}┘`));
    terminal.writeln(`Score: ${score}  High Score: ${kernel.storage.local.getItem("snake-high-score") || 0}`);
    if (!gameStarted) terminal.writeln("\nPress any key to start...");
  }, "renderGame");
  const moveSnake = /* @__PURE__ */ __name(() => {
    const head = { x: snake2[0].x + direction.x, y: snake2[0].y + direction.y };
    if (head.x < 0 || head.x >= width || head.y < 0 || head.y >= height) return gameOver = true;
    if (snake2.some((segment) => segment.x === head.x && segment.y === head.y)) return gameOver = true;
    snake2.unshift(head);
    if (head.x === food.x && head.y === food.y) {
      score++;
      food = { x: Math.floor(Math.random() * width), y: Math.floor(Math.random() * height) };
      if (!kernel.storage.local.getItem("snake-high-score") || Number(kernel.storage.local.getItem("snake-high-score")) < score)
        kernel.storage.local.setItem("snake-high-score", score.toString());
    } else snake2.pop();
    return;
  }, "moveSnake");
  terminal.write(ansi$6.cursor.hide);
  terminal.unlisten();
  renderGame();
  const keyListener = terminal.onKey(({ domEvent }) => {
    const newDirection = (() => {
      switch (domEvent.key) {
        case "ArrowUp":
          return { x: 0, y: -1 };
        case "ArrowDown":
          return { x: 0, y: 1 };
        case "ArrowRight":
          return { x: 1, y: 0 };
        case "ArrowLeft":
          return { x: -1, y: 0 };
        default:
          return null;
      }
    })();
    if (newDirection && !(newDirection.x + direction.x === 0 && newDirection.y + direction.y === 0)) direction = newDirection;
    if (domEvent.key === "Escape") gameOver = true;
    if (!gameStarted) {
      gameStarted = true;
      switch (domEvent.key) {
        case "ArrowUp":
          return direction = { x: 0, y: -1 };
        case "ArrowDown":
          return direction = { x: 0, y: 1 };
        case "ArrowRight":
          return direction = { x: 1, y: 0 };
        case "ArrowLeft":
          return direction = { x: -1, y: 0 };
      }
    }
  });
  const gameLoop = setInterval(() => {
    if (gameOver) {
      keyListener.dispose();
      terminal.listen();
      clearInterval(gameLoop);
      terminal.writeln("Game Over!");
      terminal.write(ansi$6.cursor.show + terminal.prompt());
      return;
    }
    if (!gameStarted) return;
    moveSnake();
    renderGame();
  }, 150);
  return new Promise((resolve2) => {
    const checkGameOver = setInterval(() => {
      if (gameOver) {
        clearInterval(checkGameOver);
        resolve2(0);
      }
    }, 100);
  });
}, "snake");
const socket = /* @__PURE__ */ __name(async () => {
  return 0;
}, "socket");
const stat = /* @__PURE__ */ __name(async ({ shell, terminal, process: process2, args }) => {
  const argPath = args[0];
  const fullPath = argPath ? path$1.resolve(shell.cwd, argPath) : shell.cwd;
  const stats = await shell.context.fs.promises.stat(fullPath);
  await writelnStdout(process2, terminal, JSON.stringify(stats, null, 2));
  const extension = path$1.extname(fullPath);
  if (extension === ".zip") {
    const blob = new Blob([new Uint8Array(await shell.context.fs.promises.readFile(fullPath))]);
    const zipReader = new ZipReader(new BlobReader(blob));
    const entries2 = await zipReader.getEntries();
    await writelnStdout(process2, terminal, chalk$1.bold("\nZIP Entries:"));
    for (const entry of entries2) {
      await writelnStdout(process2, terminal, `${chalk$1.blue(entry.filename)} (${entry.uncompressedSize} bytes)`);
    }
  }
}, "stat");
const su = /* @__PURE__ */ __name(async ({ kernel, shell, terminal, process: process2, args }) => {
  const username = args[0];
  const currentUser = kernel.users.get(shell.credentials.suid);
  if (!currentUser || shell.credentials.suid !== 0) {
    await writelnStderr(process2, terminal, chalk$1.red(kernel.i18n.t("Unauthorized")));
    return 1;
  }
  const user2 = Array.from(kernel.users.all.values()).find((user3) => user3.username === username);
  if (!user2) {
    await writelnStderr(process2, terminal, chalk$1.red(kernel.i18n.t("User not found", { username })));
    return 1;
  }
  shell.context = bindContext({ root: "/", pwd: "/", credentials: user2 });
  shell.credentials = createCredentials({ uid: user2.uid, gid: user2.gid, suid: currentUser.uid, sgid: currentUser.gid, euid: user2.uid, egid: user2.gid, groups: user2.groups });
  terminal.promptTemplate = `{user}:{cwd}${user2.uid === 0 ? "#" : "$"} `;
}, "su");
const touch = /* @__PURE__ */ __name(async ({ shell, args }) => {
  const target = args[0];
  const fullPath = target ? path$1.resolve(shell.cwd, target) : shell.cwd;
  await shell.context.fs.promises.appendFile(fullPath, "");
}, "touch");
const umount = /* @__PURE__ */ __name(async ({ kernel, shell, terminal, process: process2, args }) => {
  const target = args[0];
  const fullPath = target ? path$1.resolve(shell.cwd, target) : shell.cwd;
  await writelnStdout(process2, terminal, `umount ${fullPath}`);
  kernel.filesystem.fsSync.umount(fullPath);
}, "umount");
const unzip = /* @__PURE__ */ __name(async ({ shell, terminal, process: process2, args }) => {
  const target = args[0];
  const fullPath = target ? path$1.resolve(shell.cwd, target) : shell.cwd;
  const blob = new Blob([new Uint8Array(await shell.context.fs.promises.readFile(fullPath))]);
  const zipReader = new ZipReader(new BlobReader(blob));
  for (const entry of await zipReader.getEntries()) {
    const entryPath = path$1.resolve(shell.cwd, entry.filename);
    if (entry.directory) {
      await shell.context.fs.promises.mkdir(entryPath);
    } else {
      const writer = new Uint8ArrayWriter();
      const data = await entry.getData?.(writer);
      if (!data) {
        await writelnStderr(process2, terminal, chalk$1.red(`Failed to read ${entryPath}`));
        return 1;
      }
      await shell.context.fs.promises.writeFile(entryPath, data);
    }
  }
  return 0;
}, "unzip");
const upload = /* @__PURE__ */ __name(async ({ kernel, shell, terminal, process: process2, args }) => {
  const destination = path$1.resolve(args[0] || shell.cwd);
  if (!destination) {
    await writelnStderr(process2, terminal, chalk$1.red("File path is required"));
    return 1;
  }
  const input = document.createElement("input");
  input.type = "file";
  input.accept = "*";
  input.onchange = async (event) => {
    if (!event.target) {
      await writelnStderr(process2, terminal, chalk$1.red("No file selected"));
      return;
    }
    const files = event.target.files;
    if (!files) {
      await writelnStderr(process2, terminal, chalk$1.red("No file selected"));
      return;
    }
    for (const file of files) {
      const fileReader = new FileReader();
      fileReader.onload = async (event2) => {
        if (!event2.target) {
          await writelnStderr(process2, terminal, chalk$1.red("No file selected"));
          return;
        }
        const data = new Uint8Array(event2.target.result);
        await shell.context.fs.promises.writeFile(path$1.resolve(destination, file.name), data);
        kernel.events.dispatch(KernelEvents.UPLOAD, { file: file.name, path: path$1.resolve(destination, file.name) });
      };
      fileReader.readAsArrayBuffer(file);
    }
  };
  input.click();
  return 0;
}, "upload");
const user = /* @__PURE__ */ __name(async ({ kernel, shell, terminal, process: process2, args }) => {
  if (shell.credentials.suid !== 0) {
    await writelnStderr(process2, terminal, chalk$1.red("Unauthorized"));
    return 1;
  }
  const command = args[0]?.toLowerCase();
  const [username, password] = args.slice(1);
  if (!command || command.trim() === "") {
    await writelnStderr(process2, terminal, chalk$1.red("Usage: user <command> [options]"));
    await writelnStdout(process2, terminal, "Commands:");
    await writelnStdout(process2, terminal, "  list                    List all users");
    await writelnStdout(process2, terminal, "  add --username <user>   Add a new user");
    await writelnStdout(process2, terminal, "  del --username <user>   Delete a user");
    await writelnStdout(process2, terminal, "  mod --username <user>   Modify a user");
    await writelnStdout(process2, terminal, "\nYou may specify --password or you will be prompted for it.");
    return 1;
  }
  switch (command) {
    case "list": {
      const users = Array.from(kernel.users.all.values());
      const uidWidth = Math.max(3, ...users.map((u) => u.uid.toString().length));
      const usernameWidth = Math.max(8, ...users.map((u) => u.username.length));
      const gidWidth = Math.max(3, ...users.map((u) => u.gid.toString().length));
      await writelnStdout(process2, terminal, chalk$1.bold(
        "UID".padEnd(uidWidth) + "	" + "Username".padEnd(usernameWidth) + "	" + "GID".padEnd(gidWidth) + "	Groups"
      ));
      for (const usr of users) {
        await writelnStdout(
          process2,
          terminal,
          chalk$1.yellow(usr.uid.toString().padEnd(uidWidth)) + "	" + chalk$1.green(usr.username.padEnd(usernameWidth)) + "	" + chalk$1.cyan(usr.gid.toString().padEnd(gidWidth)) + "	" + chalk$1.blue(usr.groups.join(", "))
        );
      }
      return 0;
    }
    case "add": {
      if (!username) {
        await writelnStderr(process2, terminal, chalk$1.red("Username required"));
        return 1;
      }
      if (Array.from(kernel.users.all.values()).some((u) => u.username === username)) {
        await writelnStderr(process2, terminal, chalk$1.red(`User ${username} already exists`));
        return 1;
      }
      let userPassword = password;
      if (!userPassword) {
        userPassword = await terminal.readline(chalk$1.cyan(`Enter password for ${username}: `), true);
        const confirm2 = await terminal.readline(chalk$1.cyan("Confirm password: "), true);
        if (userPassword !== confirm2) {
          await writelnStderr(process2, terminal, chalk$1.red("Passwords do not match"));
          return 1;
        }
      }
      try {
        await kernel.users.add({ username, password: userPassword });
        await writelnStdout(process2, terminal, chalk$1.green(`User ${username} created successfully`));
        return 0;
      } catch (error) {
        await writelnStderr(process2, terminal, chalk$1.red(`Failed to create user: ${error instanceof Error ? error.message : "Unknown error"}`));
        return 1;
      }
    }
    case "del": {
      if (!username) {
        await writelnStderr(process2, terminal, chalk$1.red("Username required"));
        return 1;
      }
      const usr = Array.from(kernel.users.all.values()).find((u) => u.username === username);
      if (!usr) {
        await writelnStderr(process2, terminal, chalk$1.red(`User ${username} not found`));
        return 1;
      }
      if (usr.uid === 0) {
        await writelnStderr(process2, terminal, chalk$1.red("Cannot delete root user"));
        return 1;
      }
      try {
        await kernel.users.remove(usr.uid);
        await shell.context.fs.promises.writeFile("/etc/passwd", (await shell.context.fs.promises.readFile("/etc/passwd", "utf8")).split("\n").filter((line3) => !line3.startsWith(`${username}:`)).join("\n"));
        await shell.context.fs.promises.writeFile("/etc/shadow", (await shell.context.fs.promises.readFile("/etc/shadow", "utf8")).split("\n").filter((line3) => !line3.startsWith(`${username}:`)).join("\n"));
        await writelnStdout(process2, terminal, chalk$1.green(`User ${username} deleted successfully`));
        return 0;
      } catch (error) {
        await writelnStderr(process2, terminal, chalk$1.red(`Failed to delete user: ${error instanceof Error ? error.message : "Unknown error"}`));
        return 1;
      }
    }
    case "mod": {
      if (!username) {
        await writelnStderr(process2, terminal, chalk$1.red("Username required"));
        return 1;
      }
      const usr = Array.from(kernel.users.all.values()).find((u) => u.username === username);
      if (!usr) {
        await writelnStderr(process2, terminal, chalk$1.red(`User ${username} not found`));
        return 1;
      }
      const newPassword = await terminal.readline(chalk$1.cyan("Enter new password: "), true);
      const confirm2 = await terminal.readline(chalk$1.cyan("Confirm new password: "), true);
      if (newPassword !== confirm2) {
        await writelnStderr(process2, terminal, chalk$1.red("Passwords do not match"));
        return 1;
      }
      try {
        await kernel.users.update(usr.uid, { password: newPassword });
        await writelnStdout(process2, terminal, chalk$1.green(`Password updated for ${username}`));
        return 0;
      } catch (error) {
        await writelnStderr(process2, terminal, chalk$1.red(`Failed to update user: ${error instanceof Error ? error.message : "Unknown error"}`));
        return 1;
      }
    }
    default:
      await writelnStderr(process2, terminal, chalk$1.red(`Unknown command: ${command}`));
      return 1;
  }
}, "user");
const video = /* @__PURE__ */ __name(async ({ kernel, shell, args }) => {
  const file = args[0];
  const fullPath = file ? path$1.resolve(shell.cwd, file) : shell.cwd;
  const blob = new Blob([new Uint8Array(await shell.context.fs.promises.readFile(fullPath))]);
  const url = URL.createObjectURL(blob);
  const video2 = document.createElement("video");
  video2.src = url;
  await new Promise((resolve2) => {
    video2.onloadedmetadata = resolve2;
  });
  const { videoWidth, videoHeight } = video2;
  const { innerWidth, innerHeight } = window;
  const shouldMaximize = videoWidth > innerWidth || videoHeight > innerHeight;
  kernel.windows.create({
    title: file,
    html: `<video src="${url}" autoplay controls style="width:100%;height:100%"></video>`,
    width: shouldMaximize ? innerWidth : videoWidth,
    height: shouldMaximize ? innerHeight : videoHeight,
    max: shouldMaximize
  });
}, "video");
const zip = /* @__PURE__ */ __name(async ({ shell, terminal, process: process2, args }) => {
  const [output2, paths = []] = args;
  if (!output2 || paths.length === 0) {
    await writelnStdout(process2, terminal, "Usage: zip <output> <paths...>");
    return 1;
  }
  const outputPath = path$1.resolve(shell.cwd, output2);
  let zipWriter = null;
  try {
    zipWriter = new ZipWriter(new BlobWriter());
    for (const inputPath of paths) {
      const fullPath = path$1.resolve(shell.cwd, inputPath);
      try {
        const fileStat = await shell.context.fs.promises.stat(fullPath);
        if (fileStat.isFile()) {
          const relativePath = path$1.relative(shell.cwd, fullPath);
          const fileData = await shell.context.fs.promises.readFile(fullPath);
          const reader = new Uint8ArrayReader(fileData);
          await zipWriter.add(relativePath, reader);
          await writelnStdout(process2, terminal, `Added file: ${relativePath}`);
        } else if (fileStat.isDirectory()) {
          async function addDirectory(dirPath) {
            const entries2 = await shell.context.fs.promises.readdir(dirPath);
            for (const entry of entries2) {
              const entryPath = path$1.join(dirPath, entry);
              const relativePath = path$1.relative(shell.cwd, entryPath);
              const entryStat = await shell.context.fs.promises.stat(entryPath);
              if (entryStat.isFile()) {
                const fileData = await shell.context.fs.promises.readFile(entryPath);
                const reader = new Uint8ArrayReader(fileData);
                await zipWriter?.add(relativePath, reader);
                await writelnStdout(process2, terminal, `Added file: ${relativePath}`);
              } else if (entryStat.isDirectory()) {
                await addDirectory(entryPath);
              }
            }
          }
          __name(addDirectory, "addDirectory");
          await addDirectory(fullPath);
          await writelnStdout(process2, terminal, `Added directory: ${path$1.relative(shell.cwd, fullPath)}`);
        } else {
          await writelnStdout(process2, terminal, `Skipping ${inputPath}: Not a file or directory`);
        }
      } catch (err2) {
        await writelnStderr(process2, terminal, `Error processing ${inputPath}: ${err2 instanceof Error ? err2.message : "Unknown error"}`);
      }
    }
    const blob = await zipWriter.close();
    zipWriter = null;
    await shell.context.fs.promises.writeFile(outputPath, new Uint8Array(await blob.arrayBuffer()));
    await writelnStdout(process2, terminal, `Created zip file: ${output2}`);
    return 0;
  } catch (err2) {
    await writelnStderr(process2, terminal, `Failed to create zip file: ${err2 instanceof Error ? err2.message : "Unknown error"}`);
    return 1;
  } finally {
    if (zipWriter) {
      await zipWriter.close();
    }
  }
}, "zip");
const _Events = class _Events {
  constructor() {
    __publicField(this, "_callbacks", /* @__PURE__ */ new Map());
    __publicField(this, "_listeners", /* @__PURE__ */ new Map());
  }
  clear() {
    this._callbacks.clear();
    this._listeners.clear();
  }
  dispatch(event, data) {
    globalThis.dispatchEvent(new CustomEvent(event, { detail: data }));
  }
  emit(event, data) {
    this.dispatch(event, data);
  }
  listen(event, callback) {
    this.on(event, callback);
  }
  on(event, callback) {
    if (!this._callbacks.has(event)) this._callbacks.set(event, []);
    this._callbacks.get(event)?.push(callback);
    const listener = /* @__PURE__ */ __name((e2) => {
      if (e2 instanceof CustomEvent) callback(e2.detail);
    }, "listener");
    this._listeners.set(`${event}-${callback.toString()}`, listener);
    globalThis.addEventListener(event, listener);
  }
  off(event, callback) {
    const callbacks = this._callbacks.get(event);
    if (callbacks) {
      const index = callbacks.indexOf(callback);
      if (index !== -1) {
        callbacks.splice(index, 1);
        if (callbacks.length === 0) this._callbacks.delete(event);
        const listenerKey = `${event}-${callback.toString()}`;
        const listener = this._listeners.get(listenerKey);
        if (listener) {
          globalThis.removeEventListener(event, listener);
          this._listeners.delete(listenerKey);
        }
      }
    }
  }
  unlisten(event, callback) {
    this.off(event, callback);
  }
};
__name(_Events, "Events");
let Events = _Events;
const DefaultTerminalOptions = {
  fontFamily: "FiraCode Nerd Font Mono, Ubuntu Mono, courier-new, courier, monospace",
  fontSize: 16,
  smoothScrollDuration: 100,
  convertEol: true,
  cursorBlink: true,
  macOptionIsMeta: true,
  allowProposedApi: true,
  theme: {
    background: "#000000",
    foreground: "#00FF00",
    promptColor: "green"
  },
  linkHandler: {
    allowNonHttpProtocols: true,
    activate: /* @__PURE__ */ __name((event, text, range2) => {
      console.log("activate", event, text, range2);
      if (text.startsWith("http")) window.open(text, "_blank", "noopener,noreferrer");
      if (text.startsWith("ecmaos://")) {
        const [protocol, argstr] = text.replace("ecmaos://", "").split("?");
        if (!protocol || !argstr) return;
        const commandPath = protocol.split(".");
        const args = {};
        for (const arg of argstr.split("&")) {
          const [key, value] = arg.split("=");
          if (!key || !value) continue;
          args[key] = value;
        }
        switch (commandPath[0]) {
          case "kernel":
            switch (commandPath[1]) {
              case "execute":
                if (!args["command"]) break;
                globalThis?.kernel?.execute({ command: args["command"], args: args["args"]?.split(" ") || [], shell: globalThis?.kernel?.shell });
                break;
            }
            break;
        }
      }
    }, "activate")
    // hover: (event, text, range) => {
    // console.log('hover', event, text, range)
    // },
    // leave: (event, text, range) => {
    // console.log('leave', event, text, range)
    // }
  }
};
const _Terminal = class _Terminal extends xtermExports.Terminal {
  constructor(options = DefaultTerminalOptions) {
    if (!options.kernel) throw new Error("Terminal requires a kernel");
    super({ ...DefaultTerminalOptions, ...options });
    __publicField(this, "_addons", /* @__PURE__ */ new Map());
    __publicField(this, "_ansi", ansi$6);
    __publicField(this, "_cmd", "");
    __publicField(this, "_commands");
    __publicField(this, "_cursorPosition", 0);
    __publicField(this, "_events");
    __publicField(this, "_history", {});
    __publicField(this, "_historyPosition", 0);
    __publicField(this, "_id", crypto.randomUUID());
    __publicField(this, "_kernel");
    __publicField(this, "_keyListener");
    __publicField(this, "_promptTemplate", "{user}:{cwd}# ");
    __publicField(this, "_shell");
    __publicField(this, "_socket");
    __publicField(this, "_socketKey");
    __publicField(this, "_stdin");
    __publicField(this, "_stdout");
    __publicField(this, "_stderr");
    __publicField(this, "_stdinSubscribers", /* @__PURE__ */ new Set());
    __publicField(this, "_multiLineMode", false);
    __publicField(this, "_multiLineBuffer", "");
    __publicField(this, "_tabCompletionIndex", 0);
    __publicField(this, "_lastTabCommand", "");
    __publicField(this, "_isTabCycling", false);
    globalThis.terminals?.set(this.id, this);
    this._stdin = this.createSubscribedInputStream();
    this._stdout = new WritableStream({
      write: /* @__PURE__ */ __name((chunk) => {
        const text = new TextDecoder().decode(chunk);
        this.write(text);
      }, "write")
    });
    this._stderr = new WritableStream({
      write: /* @__PURE__ */ __name((chunk) => {
        const text = new TextDecoder().decode(chunk);
        this.write(chalk$1.red(text));
      }, "write")
    });
    this.onKey(({ key }) => {
      if (key && key.length > 0) {
        const data = new TextEncoder().encode(key);
        for (const callback of this._stdinSubscribers) {
          try {
            callback(data);
          } catch {
          }
        }
      }
    });
    this.onBell(() => {
      const theme = { ...this.options.theme };
      theme.background = "#FFFFFF";
      this.options.theme = theme;
      setTimeout(() => {
        const theme2 = { ...this.options.theme };
        theme2.background = "#000000";
        this.options.theme = theme2;
      }, 100);
    });
    this._events = new Events();
    this._addons = options.addons || /* @__PURE__ */ new Map([
      ["fit", new addonFitExports.FitAddon()],
      ["image", new addonImageExports.ImageAddon()],
      ["search", new addonSearchExports.SearchAddon()],
      ["serialize", new addonSerializeExports.SerializeAddon()],
      ["web-links", new addonWebLinksExports.WebLinksAddon()]
    ]);
    for (const addon of this._addons.values()) this.loadAddon(addon);
    if (this.addons?.get("fit")) this.addons.get("fit").fit();
    globalThis.addEventListener("resize", () => {
      if (this.addons?.get("fit")) this.addons.get("fit").fit();
      this.events.dispatch(TerminalEvents.RESIZE, { cols: this.cols, rows: this.rows });
    });
    if (options.socket) {
      this._socket = options.socket;
      this._socket.addEventListener("message", (event) => {
        this.writeln(`Connected to socket at ${this._socket.url}`);
        this._kernel.events.dispatch(TerminalEvents.MESSAGE, { terminal: this, message: event });
        if (event.data.startsWith("@ecmaos/metal")) {
          const [name, version2, id, encodedPublicKey] = event.data.split(":");
          this._kernel.log.info(`${name}:${version2}:${id} connected`);
          this._socketKey = JSON.parse(atob(encodedPublicKey));
        }
      });
      const attachSocket = /* @__PURE__ */ __name(async () => {
        await new Promise((resolve2) => {
          const checkState = /* @__PURE__ */ __name(() => {
            if (options.kernel?.state === "running") resolve2();
            else setTimeout(checkState, 100);
          }, "checkState");
          checkState();
        });
        if (this._socket) {
          try {
            await new Promise((resolve2, reject) => {
              if (this._socket.readyState === WebSocket.OPEN) resolve2();
              else {
                const onOpen = /* @__PURE__ */ __name(() => {
                  this._socket.removeEventListener("open", onOpen);
                  resolve2();
                }, "onOpen");
                const onError = /* @__PURE__ */ __name(() => {
                  this._socket.removeEventListener("error", onError);
                  reject(new Error("Socket failed to open"));
                }, "onError");
                this._socket.addEventListener("open", onOpen);
                this._socket.addEventListener("error", onError);
              }
            });
            const attachAddon = new addonAttachExports.AttachAddon(this._socket);
            this.loadAddon(attachAddon);
            this._kernel.events.dispatch(TerminalEvents.ATTACH, { terminal: this, socket: this._socket });
          } catch (err2) {
            console.error(err2);
          }
        }
      }, "attachSocket");
      attachSocket();
    }
    this.onKey(this.shortcutKeyHandler.bind(this));
    this._keyListener = this.onKey(this.keyHandler.bind(this));
    this._shell = options.shell || options.kernel.shell;
    this._kernel = options.kernel;
    this._commands = TerminalCommands(this._kernel, this._shell, this);
    this._history[this._shell.credentials.uid] = this._kernel.storage.local.getItem(`history:${this._shell.credentials.uid}`) ? JSON.parse(this._kernel.storage.local.getItem(`history:${this._shell.credentials.uid}`) || "[]") : [];
    this._historyPosition = this._history[this._shell.credentials.uid]?.length || 0;
    this.events.dispatch(TerminalEvents.CREATED, { terminal: this });
    this.element?.setAttribute("enterkeyhint", "send");
  }
  get addons() {
    return this._addons;
  }
  get ansi() {
    return this._ansi;
  }
  get commands() {
    return this._commands;
  }
  get cmd() {
    return this._cmd;
  }
  get cwd() {
    return this._shell.cwd;
  }
  get emojis() {
    return emoji;
  }
  get events() {
    return this._events;
  }
  get id() {
    return this._id;
  }
  get socket() {
    return this._socket;
  }
  get socketKey() {
    return this._socketKey;
  }
  get stdin() {
    return this._stdin;
  }
  get stdout() {
    return this._stdout;
  }
  get stderr() {
    return this._stderr;
  }
  get promptTemplate() {
    return this._promptTemplate;
  }
  set promptTemplate(value) {
    this._promptTemplate = value;
  }
  mount(element) {
    this.open(element);
    if (this.addons?.get("fit")) this.addons.get("fit").fit();
    element.querySelector("textarea")?.addEventListener("paste", (e2) => this.paste(e2.clipboardData?.getData("text/plain") || ""));
    this.events.dispatch(TerminalEvents.MOUNT, { terminal: this, element });
  }
  hide() {
    if (this.element) this.element.style.display = "none";
  }
  createSpecialLink(uri, text) {
    return `\x1B]8;;${uri}\x1B\\${text}\x1B]8;;\x1B\\`;
  }
  connect(socket2) {
    this.loadAddon(new addonAttachExports.AttachAddon(socket2));
  }
  listen() {
    this.unlisten();
    this._keyListener = this.onKey(this.keyHandler.bind(this));
    this.events.dispatch(TerminalEvents.LISTEN, { terminal: this });
  }
  unlisten() {
    try {
      this._keyListener.dispose();
    } catch {
    }
    this.events.dispatch(TerminalEvents.UNLISTEN, { terminal: this });
  }
  // TODO: Make configurable; expand and organize keyboard shortcut functionality
  async shortcutKeyHandler({ domEvent }) {
    this.events.dispatch(TerminalEvents.KEY, { key: domEvent.key, domEvent });
    if (!domEvent.ctrlKey && !domEvent.shiftKey) {
      switch (domEvent.key) {
        case "F11":
          document.documentElement.requestFullscreen();
          break;
      }
    }
    if (domEvent.ctrlKey && domEvent.shiftKey) {
      switch (domEvent.key) {
        case "F1":
          this.listen();
          break;
        case "F2":
          this.unlisten();
          break;
        case "Delete":
          this._kernel.reboot();
          break;
      }
    }
  }
  async readline(prompt = "", hide = false, noListen = false) {
    let input = "";
    let cursor = 0;
    if (!noListen) this.unlisten();
    this.write(prompt);
    this.focus();
    const result = await new Promise((resolve2) => {
      const disposable = this.onKey(({ domEvent }) => {
        switch (domEvent.key) {
          case "Enter":
            disposable.dispose();
            this.write("\n");
            resolve2(input);
            break;
          case "ArrowLeft":
            this.write(ansi$6.cursor.back());
            cursor--;
            break;
          case "ArrowRight":
            this.write(ansi$6.cursor.forward());
            cursor++;
            break;
          case "Home":
            this.write(ansi$6.cursor.horizontalAbsolute(0));
            break;
          case "End":
            this.write(ansi$6.cursor.horizontalAbsolute(input.length));
            break;
          case "Escape":
            disposable.dispose();
            resolve2("");
            break;
          case "Backspace":
            if (cursor > 0) {
              input = input.slice(0, cursor - 1) + input.slice(cursor);
              this.write(ansi$6.cursor.horizontalAbsolute(0) + ansi$6.erase.inLine(2) + ":" + input);
              cursor--;
            } else this.write("\x07");
            break;
          case "Delete":
            if (cursor < input.length) input = input.slice(0, cursor) + input.slice(cursor + 1);
            break;
          default:
            if (domEvent.key.length === 1 && domEvent.key.match(/^[a-zA-Z0-9]$/)) {
              input = input.slice(0, cursor) + domEvent.key + input.slice(cursor);
              if (!hide) this.write(ansi$6.cursor.horizontalAbsolute(0) + ansi$6.erase.inLine(2) + prompt + input);
              cursor++;
            }
        }
        if (cursor < 0) cursor = 0;
        if (cursor > input.length) cursor = input.length;
      });
    });
    if (!noListen) this.listen();
    return result;
  }
  spinner(spinner, prefix, suffix) {
    const { interval, frames } = spinners[spinner];
    if (!interval || !frames) throw new Error("Invalid spinner");
    return new Spinner(this, interval, frames, prefix, suffix);
  }
  // TODO: make more configurable and robust
  prompt(text = this._promptTemplate) {
    const user2 = this._kernel.users.get(this._shell.credentials.euid ?? 0);
    return this.ansi.style[this.options.theme?.promptColor || "green"] + text.replace("{cwd}", chalk$1.cyan(this.cwd)).replace("{uid}", chalk$1.white(user2?.uid.toString() || "")).replace("{gid}", chalk$1.white(user2?.gid.toString() || "")).replace("{user}", chalk$1.white(user2?.username || "")) + this.ansi.style.white;
  }
  async paste(data) {
    const clip = data ? data : await navigator.clipboard.readText();
    this.write(clip);
    this._cmd += clip;
    this._cursorPosition += clip.length;
    this.events.dispatch(TerminalEvents.PASTE, { text: clip });
    this.events.dispatch(TerminalEvents.INPUT, { terminal: this, data: clip });
  }
  async keyHandler({ key, domEvent }) {
    if (!key) return;
    const keyName = domEvent.key;
    if (domEvent.ctrlKey && domEvent.shiftKey) {
      if (keyName === "F1" || keyName === "F2") return;
    }
    this.events.dispatch(TerminalEvents.KEY, { key, domEvent });
    if (domEvent.ctrlKey) {
      switch (keyName) {
        case "c":
          this.events.dispatch(TerminalEvents.INTERRUPT, { terminal: this });
          this._cmd = "";
          this._cursorPosition = 0;
          this.unlisten();
          this.write("\n" + this.prompt());
          this.listen();
          return;
        case "l":
          return this.clear();
        case "v":
          return this.paste();
        case "Escape":
          return this.write(ansi$6.erase.display(2) + ansi$6.cursor.position() + this.prompt());
      }
    }
    switch (keyName) {
      case "Enter":
        if (this._cmd.trim().endsWith("\\")) {
          this._multiLineBuffer += this._cmd.slice(0, -1) + "\n";
          this._multiLineMode = true;
          this._cmd = "";
          this._cursorPosition = 0;
          this.write("\n> ");
          break;
        }
        if (this._multiLineMode) {
          this._multiLineBuffer += this._cmd;
          this._cmd = this._multiLineBuffer;
          this._multiLineMode = false;
          this._multiLineBuffer = "";
        }
        this.write("\n");
        if (this._cmd.trim().length > 0) {
          const uid = this._shell.credentials.uid;
          if (this._cmd[0] !== " " && this._cmd !== this._history[uid]?.[this._history[uid]?.length - 1]) {
            this._history[uid] = this._history[uid] || [];
            this._history[uid].push(this._cmd);
            try {
              this._kernel.storage.local.setItem(`history:${uid}`, JSON.stringify(this._history[uid] || []));
            } catch (error) {
              this._kernel.log.error("Failed to save history", error);
            }
          }
          this._historyPosition = this._history[uid]?.length || 0;
          try {
            this.events.dispatch(TerminalEvents.EXECUTE, { terminal: this, command: this._cmd });
            const result = await this._shell.execute(this._cmd);
            if (result === Infinity) throw new Error(`${this._kernel.i18n.t("kernel.commandNotFound", "Command not found")}: ${this._cmd.split(" ")[0]}`);
          } catch (error) {
            this.writeln(chalk$1.red(`${error}`));
          }
        }
        this._cmd = "";
        this._cursorPosition = 0;
        this.write(ansi$6.erase.inLine(2) + this.prompt());
        break;
      case "Backspace":
        if (this._cursorPosition > 0) {
          this._cmd = this._cmd.slice(0, this._cursorPosition - 1) + this._cmd.slice(this._cursorPosition);
          this._cursorPosition--;
          this.write("\b");
          this.write(this._cmd.slice(this._cursorPosition) + " ");
          this.write(`\x1B[${this._cmd.length - this._cursorPosition + 1}D`);
        } else this.write("\x07");
        break;
      case "Delete":
        if (this._cursorPosition < this._cmd.length) {
          this._cmd = this._cmd.slice(0, this._cursorPosition) + this._cmd.slice(this._cursorPosition + 1);
          this.write(ansi$6.erase.inLine(2) + ansi$6.cursor.horizontalAbsolute(0));
          if (this._multiLineMode) {
            const parts = this._cmd.split("#");
            if (parts.length > 1) {
              this.write("> " + parts[0] + chalk$1.gray("#" + parts.slice(1).join("#")));
            } else {
              this.write("> " + this._cmd);
            }
          } else {
            const parts = this._cmd.split("#");
            if (parts.length > 1) {
              this.write(this.prompt() + parts[0] + chalk$1.gray("#" + parts.slice(1).join("#")));
            } else {
              this.write(this.prompt() + this._cmd);
            }
          }
          if (this._cursorPosition < this._cmd.length) this.write(`\x1B[${this._cmd.length - this._cursorPosition}D`);
        }
        break;
      case "ArrowUp":
        if (this._historyPosition > 0) {
          this._historyPosition--;
          this._cmd = this._history[this._shell.credentials.uid]?.[this._historyPosition] || "";
          this._cursorPosition = this._cmd.length;
          this.write("\x1B[2K\r");
          if (this._multiLineMode) {
            const parts = this._cmd.split("#");
            if (parts.length > 1) {
              this.write("> " + parts[0] + chalk$1.gray("#" + parts.slice(1).join("#")));
            } else {
              this.write("> " + this._cmd);
            }
          } else {
            const parts = this._cmd.split("#");
            if (parts.length > 1) {
              this.write(this.prompt() + parts[0] + chalk$1.gray("#" + parts.slice(1).join("#")));
            } else {
              this.write(this.prompt() + this._cmd);
            }
          }
        }
        break;
      case "ArrowDown":
        if (this._historyPosition < (this._history[this._shell.credentials.uid]?.length || 0)) {
          this._historyPosition++;
          this._cmd = this._history[this._shell.credentials.uid]?.[this._historyPosition] || "";
          this._cursorPosition = this._cmd.length;
          this.write("\x1B[2K\r");
          if (this._multiLineMode) {
            const parts = this._cmd.split("#");
            if (parts.length > 1) {
              this.write("> " + parts[0] + chalk$1.gray("#" + parts.slice(1).join("#")));
            } else {
              this.write("> " + this._cmd);
            }
          } else {
            const parts = this._cmd.split("#");
            if (parts.length > 1) {
              this.write(this.prompt() + parts[0] + chalk$1.gray("#" + parts.slice(1).join("#")));
            } else {
              this.write(this.prompt() + this._cmd);
            }
          }
        }
        break;
      case "ArrowLeft":
        if (this._cursorPosition > 0) {
          this._cursorPosition--;
          this.write("\b");
        }
        break;
      case "ArrowRight":
        if (this._cursorPosition < this._cmd.length) {
          this._cursorPosition++;
          this.write(key);
        }
        break;
      case "Home":
        this._cursorPosition = 0;
        this.write(ansi$6.cursor.horizontalAbsolute(this.prompt().replace(/\x1b\[[0-9;]*[a-zA-Z]/g, "").length + 1));
        break;
      case "End":
        this._cursorPosition = this._cmd.length + 1;
        this.write(ansi$6.cursor.horizontalAbsolute(this.prompt().replace(/\x1b\[[0-9;]*[a-zA-Z]/g, "").length + this._cmd.length + 1));
        break;
      case "Tab": {
        domEvent.preventDefault();
        if (!this._isTabCycling) {
          this._tabCompletionIndex = -1;
          this._lastTabCommand = this._cmd;
          this._isTabCycling = true;
        }
        const matches = await this.getCompletionMatches(this._lastTabCommand);
        if (this._cmd.endsWith("/")) {
          const path2 = this._cmd.split(" ").slice(-1)[0];
          if (!path2) break;
          if (!await this._kernel.filesystem.fs.exists(path2)) break;
          await this.write("\n");
          await this._shell.execute(`ls ${path2}`);
          this.write(this.prompt() + this._cmd);
        } else if (matches.length > 0) {
          this.write("\r" + ansi$6.erase.inLine());
          this._tabCompletionIndex = (this._tabCompletionIndex + 1) % matches.length;
          const newCmd = matches[this._tabCompletionIndex] || "";
          this._cmd = newCmd;
          this._cursorPosition = newCmd.length;
          const parts = newCmd.split("#");
          if (parts.length > 1) {
            this.write(this.prompt() + parts[0] + chalk$1.gray("#" + parts.slice(1).join("#")));
          } else {
            this.write(this.prompt() + newCmd);
          }
        }
        break;
      }
      default:
        this._isTabCycling = false;
        if (key.length === 1) {
          this._cmd = this._cmd.slice(0, this._cursorPosition) + key + this._cmd.slice(this._cursorPosition);
          this._cursorPosition++;
          this.write(ansi$6.erase.inLine(2) + ansi$6.cursor.horizontalAbsolute(0));
          if (this._multiLineMode) {
            const parts = this._cmd.split("#");
            if (parts.length > 1) {
              this.write("> " + parts[0] + chalk$1.gray("#" + parts.slice(1).join("#")));
            } else {
              this.write("> " + this._cmd);
            }
          } else {
            const parts = this._cmd.split("#");
            if (parts.length > 1) {
              this.write(this.prompt() + parts[0] + chalk$1.gray("#" + parts.slice(1).join("#")));
            } else {
              this.write(this.prompt() + this._cmd);
            }
          }
          if (this._cursorPosition < this._cmd.length) this.write(`\x1B[${this._cmd.length - this._cursorPosition}D`);
        }
    }
  }
  serialize() {
    if (this.addons?.get("serialize")) return this.addons.get("serialize").serialize();
    else return null;
  }
  show() {
    if (this.element) this.element.style.display = "";
  }
  write(data) {
    super.write(data);
    this.events.dispatch(TerminalEvents.WRITE, { text: data instanceof Uint8Array ? new TextDecoder().decode(data) : data });
  }
  writeln(data) {
    super.writeln(data);
    this.events.dispatch(TerminalEvents.WRITELN, { text: data instanceof Uint8Array ? new TextDecoder().decode(data) : data });
  }
  /**
   * Creates a new ReadableStream subscribed to keyboard input.
   * Each call returns an independent stream that receives all keyboard input.
   * The stream is automatically unsubscribed when cancelled or closed.
   */
  createSubscribedInputStream() {
    let callback = null;
    return new ReadableStream({
      start: /* @__PURE__ */ __name((controller) => {
        callback = /* @__PURE__ */ __name((data) => {
          try {
            controller.enqueue(data);
          } catch {
            if (callback) {
              this._stdinSubscribers.delete(callback);
              callback = null;
            }
          }
        }, "callback");
        this._stdinSubscribers.add(callback);
      }, "start"),
      cancel: /* @__PURE__ */ __name(() => {
        if (callback) {
          this._stdinSubscribers.delete(callback);
          callback = null;
        }
      }, "cancel")
    });
  }
  /**
   * Get a new input stream subscribed to keyboard input.
   * Each call returns an independent stream.
   */
  getInputStream() {
    return this.createSubscribedInputStream();
  }
  clearCommand() {
    const currentLine = this._cmd;
    this._cmd = "";
    this._cursorPosition = 0;
    this.write("\r" + ansi$6.erase.inLine(2));
    return currentLine;
  }
  restoreCommand(cmd) {
    this._cmd = cmd;
    this._cursorPosition = cmd.length;
    const parts = cmd.split("#");
    if (parts.length > 1) {
      this.write(this.prompt() + parts[0] + chalk$1.gray("#" + parts.slice(1).join("#")));
    } else {
      this.write(this.prompt() + cmd);
    }
  }
  async getCompletionMatches(partial) {
    const parts = partial.split(" ");
    const lastWord = parts[parts.length - 1];
    if (!lastWord) return [];
    if (parts.length === 1) {
      const pathDirs = (this._shell.env.get("PATH") || "").split(":");
      const matches = [];
      const builtinMatches = Object.keys(this._commands).filter(
        (cmd) => cmd.toLowerCase().startsWith(lastWord.toLowerCase())
      );
      matches.push(...builtinMatches);
      for (const dir of pathDirs) {
        try {
          const entries2 = await this._kernel.filesystem.fs.readdir(dir);
          const dirMatches = entries2.filter(
            (entry) => entry.toLowerCase().startsWith(lastWord.toLowerCase())
          );
          matches.push(...dirMatches);
        } catch {
          continue;
        }
      }
      return [...new Set(matches)].map((match) => match);
    }
    const lastSlashIndex = lastWord.lastIndexOf("/");
    const searchDir = lastSlashIndex !== -1 ? path$1.resolve(this._shell.cwd, lastWord.substring(0, lastSlashIndex + 1)) : this._shell.cwd;
    const searchTerm = lastSlashIndex !== -1 ? lastWord.substring(lastSlashIndex + 1) : lastWord;
    try {
      const entries2 = await this._kernel.filesystem.fs.readdir(searchDir);
      const matches = entries2.filter((entry) => {
        if (!searchTerm) return true;
        return entry.toLowerCase().startsWith(searchTerm.toLowerCase());
      });
      const prefix = lastSlashIndex !== -1 ? (lastWord || "").substring(0, lastSlashIndex + 1) : "";
      const matchesMap = await Promise.all(matches.map(async (match) => {
        const fullPath = path$1.join(searchDir, match);
        const isDirectory2 = (await this._kernel.filesystem.fs.stat(fullPath)).isDirectory();
        const escapedMatch = match.includes(" ") ? match.replace(/ /g, "\\ ") : match;
        const matchWithSlash = isDirectory2 ? escapedMatch + "/" : escapedMatch;
        const newParts = [...parts];
        newParts[newParts.length - 1] = prefix + matchWithSlash;
        return newParts.join(" ");
      }));
      return matchesMap;
    } catch {
      return [];
    }
  }
};
__name(_Terminal, "Terminal");
let Terminal = _Terminal;
const _Spinner = class _Spinner {
  constructor(terminal, interval, frames, prefix, suffix) {
    __publicField(this, "terminal");
    __publicField(this, "interval");
    __publicField(this, "frames");
    __publicField(this, "loop");
    __publicField(this, "prefix");
    __publicField(this, "suffix");
    this.terminal = terminal;
    this.interval = interval;
    this.frames = frames;
    this.prefix = prefix;
    this.suffix = suffix;
  }
  once() {
    this.start();
    setTimeout(() => this.stop(), this.interval * this.frames.length);
  }
  start() {
    let index = 0;
    this.terminal.write(ansi$6.cursor.hide);
    const interval = setInterval(() => {
      const currentFrame = this.frames[index];
      const fullText = `${this.prefix ? this.prefix + " " : ""}${currentFrame}${this.suffix ? " " + this.suffix : ""}`;
      this.terminal.write(fullText);
      index = (index + 1) % this.frames.length;
      const fullWidth = [...fullText].reduce((width, char) => {
        if (/\p{Emoji}/ug.test(char)) return width + 1;
        if (/[\u3000\u3001-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/ug.test(char)) return width + 2;
        return width + 1;
      }, 0);
      this.terminal.write(`\x1B[${fullWidth}D`);
    }, this.interval);
    this.loop = interval;
    return interval;
  }
  stop() {
    clearInterval(this.loop);
    this.terminal.write(ansi$6.cursor.show);
  }
};
__name(_Spinner, "Spinner");
let Spinner = _Spinner;
const isString = /* @__PURE__ */ __name((obj) => typeof obj === "string", "isString");
const defer = /* @__PURE__ */ __name(() => {
  let res;
  let rej;
  const promise = new Promise((resolve2, reject) => {
    res = resolve2;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}, "defer");
const makeString = /* @__PURE__ */ __name((object) => {
  if (object == null) return "";
  return "" + object;
}, "makeString");
const copy = /* @__PURE__ */ __name((a, s, t2) => {
  a.forEach((m) => {
    if (s[m]) t2[m] = s[m];
  });
}, "copy");
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = /* @__PURE__ */ __name((key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key, "cleanKey");
const canNotTraverseDeeper = /* @__PURE__ */ __name((object) => !object || isString(object), "canNotTraverseDeeper");
const getLastOfPath = /* @__PURE__ */ __name((object, path2, Empty) => {
  const stack = !isString(path2) ? path2 : path2.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
}, "getLastOfPath");
const setPath = /* @__PURE__ */ __name((object, path2, newValue) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path2, Object);
  if (obj !== void 0 || path2.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e2 = path2[path2.length - 1];
  let p = path2.slice(0, path2.length - 1);
  let last = getLastOfPath(object, p, Object);
  while (last.obj === void 0 && p.length) {
    e2 = `${p[p.length - 1]}.${e2}`;
    p = p.slice(0, p.length - 1);
    last = getLastOfPath(object, p, Object);
    if (last && last.obj && typeof last.obj[`${last.k}.${e2}`] !== "undefined") {
      last.obj = void 0;
    }
  }
  last.obj[`${last.k}.${e2}`] = newValue;
}, "setPath");
const pushPath = /* @__PURE__ */ __name((object, path2, newValue, concat2) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path2, Object);
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
}, "pushPath");
const getPath = /* @__PURE__ */ __name((object, path2) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path2);
  if (!obj) return void 0;
  return obj[k];
}, "getPath");
const getPathWithDefaults = /* @__PURE__ */ __name((data, defaultData, key) => {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}, "getPathWithDefaults");
const deepExtend = /* @__PURE__ */ __name((target, source2, overwrite) => {
  for (const prop in source2) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString(target[prop]) || target[prop] instanceof String || isString(source2[prop]) || source2[prop] instanceof String) {
          if (overwrite) target[prop] = source2[prop];
        } else {
          deepExtend(target[prop], source2[prop], overwrite);
        }
      } else {
        target[prop] = source2[prop];
      }
    }
  }
  return target;
}, "deepExtend");
const regexEscape = /* @__PURE__ */ __name((str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), "regexEscape");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const escape = /* @__PURE__ */ __name((data) => {
  if (isString(data)) {
    return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
  }
  return data;
}, "escape");
const _RegExpCache = class _RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern2) {
    const regExpFromCache = this.regExpMap.get(pattern2);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern2);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern2, regExpNew);
    this.regExpQueue.push(pattern2);
    return regExpNew;
  }
};
__name(_RegExpCache, "RegExpCache");
let RegExpCache = _RegExpCache;
const chars = [" ", ",", "?", "!", ";"];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = /* @__PURE__ */ __name((key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0) return true;
  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
}, "looksLikeObjectPath");
const deepFind = /* @__PURE__ */ __name(function(obj, path2) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj) return void 0;
  if (obj[path2]) return obj[path2];
  const tokens = path2.split(keySeparator);
  let current = obj;
  for (let i = 0; i < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j = i; j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i += j - i + 1;
        break;
      }
    }
    current = next;
  }
  return current;
}, "deepFind");
const getCleanedCode = /* @__PURE__ */ __name((code2) => code2 && code2.replace("_", "-"), "getCleanedCode");
const consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    if (console && console[type]) console[type].apply(console, args);
  }
};
const _Logger = class _Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new _Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new _Logger(this.logger, options);
  }
};
__name(_Logger, "Logger");
let Logger = _Logger;
var baseLogger = new Logger();
const _EventEmitter = class _EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events2, listener) {
    events2.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach((_ref) => {
        let [observer, numTimesAdded] = _ref;
        for (let i = 0; i < numTimesAdded; i++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i = 0; i < numTimesAdded; i++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
};
__name(_EventEmitter, "EventEmitter");
let EventEmitter = _EventEmitter;
const _ResourceStore = class _ResourceStore extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path2;
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
    } else {
      path2 = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path2.push(...key);
        } else if (isString(key) && keySeparator) {
          path2.push(...key.split(keySeparator));
        } else {
          path2.push(key);
        }
      }
    }
    const result = getPath(this.data, path2);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path2[0];
      ns = path2[1];
      key = path2.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || !isString(key)) return result;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path2 = [lng, ns];
    if (key) path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      value = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path2, value);
    if (!options.silent) this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources2) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m in resources2) {
      if (isString(resources2[m]) || Array.isArray(resources2[m])) this.addResource(lng, ns, m, resources2[m], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng, ns, resources2);
  }
  addResourceBundle(lng, ns, resources2, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path2 = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      deep = resources2;
      resources2 = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path2) || {};
    if (!options.skipCopy) resources2 = JSON.parse(JSON.stringify(resources2));
    if (deep) {
      deepExtend(pack, resources2, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources2
      };
    }
    setPath(this.data, path2, pack);
    if (!options.silent) this.emit("added", lng, ns, resources2);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === "v1") return {
      ...{},
      ...this.getResource(lng, ns)
    };
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n = data && Object.keys(data) || [];
    return !!n.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
};
__name(_ResourceStore, "ResourceStore");
let ResourceStore = _ResourceStore;
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
const checkedLoadedFor = {};
const _Translator = class _Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key === void 0 || key === null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return resolved && resolved.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces: isString(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    return {
      key,
      namespaces: isString(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object") options = {
      ...options
    };
    if (!options) options = {};
    if (keys === void 0 || keys === null) return "";
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, options);
    let res = resolved && resolved.res;
    const resUsedKey = resolved && resolved.usedKey || key;
    const resExactUsedKey = resolved && resolved.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = !isString(res) && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(res))) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return r;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(res);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in res) {
          if (Object.prototype.hasOwnProperty.call(res, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            copy2[m] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces
              }
            });
            if (copy2[m] === deepKey) copy2[m] = res[m];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && !isString(options.count);
      const hasDefaultValue = _Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = /* @__PURE__ */ __name((l, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector && this.backendConnector.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l, namespace, k, res);
        }, "send");
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, options);
              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== "v1") {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation) this.interpolator.init({
        ...options,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...options.interpolation
          }
        }
      });
      const skipOnVariables = isString(res) && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && !isString(options.replace) ? options.replace : options;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) options.nest = false;
      }
      if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res) options.lng = this.language || resolved.usedLng;
      if (options.nest !== false) res = this.interpolator.nest(res, function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (lastKey && lastKey[0] === args[0] && !options.context) {
          _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return _this.translate(...args, key);
      }, options);
      if (options.interpolation) this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = isString(postProcess) ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString(keys)) keys = [keys];
    keys.forEach((k) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && !isString(options.count);
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const needsContextHandling = options.context !== void 0 && (isString(options.context) || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code2) => {
          if (this.isValidLookup(found)) return;
          usedLng = code2;
          const finalKeys = [key];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code2, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code2, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code2, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code2, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code2, ns, key, options);
    return this.resourceStore.getResource(code2, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && !isString(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
};
__name(_Translator, "Translator");
let Translator = _Translator;
const capitalize = /* @__PURE__ */ __name((string) => string.charAt(0).toUpperCase() + string.slice(1), "capitalize");
const _LanguageUtil = class _LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code2) {
    code2 = getCleanedCode(code2);
    if (!code2 || code2.indexOf("-") < 0) return null;
    const p = code2.split("-");
    if (p.length === 2) return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code2) {
    code2 = getCleanedCode(code2);
    if (!code2 || code2.indexOf("-") < 0) return code2;
    const p = code2.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code2) {
    if (isString(code2) && code2.indexOf("-") > -1) {
      if (typeof Intl !== "undefined" && typeof Intl.getCanonicalLocales !== "undefined") {
        try {
          let formattedCode = Intl.getCanonicalLocales(code2)[0];
          if (formattedCode && this.options.lowerCaseLng) {
            formattedCode = formattedCode.toLowerCase();
          }
          if (formattedCode) return formattedCode;
        } catch (e2) {
        }
      }
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p = code2.split("-");
      if (this.options.lowerCaseLng) {
        p = p.map((part) => part.toLowerCase());
      } else if (p.length === 2) {
        p[0] = p[0].toLowerCase();
        p[1] = p[1].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
      } else if (p.length === 3) {
        p[0] = p[0].toLowerCase();
        if (p[1].length === 2) p[1] = p[1].toUpperCase();
        if (p[0] !== "sgn" && p[2].length === 2) p[2] = p[2].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
      }
      return p.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code2.toLowerCase() : code2;
  }
  isSupportedCode(code2) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code2 = this.getLanguagePartFromCode(code2);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code2) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code2) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code2);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code2) => {
        if (found) return;
        const lngOnly = this.getLanguagePartFromCode(code2);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code2) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code2);
    if (isString(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code2) return fallbacks.default || [];
    let found = fallbacks[code2];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code2)];
    if (!found) found = fallbacks[this.formatLanguageCode(code2)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code2)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code2, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code2);
    const codes = [];
    const addCode = /* @__PURE__ */ __name((c) => {
      if (!c) return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    }, "addCode");
    if (isString(code2) && (code2.indexOf("-") > -1 || code2.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code2));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code2));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code2));
    } else if (isString(code2)) {
      addCode(this.formatLanguageCode(code2));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
};
__name(_LanguageUtil, "LanguageUtil");
let LanguageUtil = _LanguageUtil;
let sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
let _rulesPluralsTypes = {
  1: (n) => Number(n > 1),
  2: (n) => Number(n != 1),
  3: (n) => 0,
  4: (n) => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
  5: (n) => Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5),
  6: (n) => Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2),
  7: (n) => Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
  8: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3),
  9: (n) => Number(n >= 2),
  10: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4),
  11: (n) => Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3),
  12: (n) => Number(n % 10 != 1 || n % 100 == 11),
  13: (n) => Number(n !== 0),
  14: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3),
  15: (n) => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
  16: (n) => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2),
  17: (n) => Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1),
  18: (n) => Number(n == 0 ? 0 : n == 1 ? 1 : 2),
  19: (n) => Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3),
  20: (n) => Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2),
  21: (n) => Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0),
  22: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3)
};
const nonIntlVersions = ["v1", "v2", "v3"];
const intlVersions = ["v4"];
const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
const createRules = /* @__PURE__ */ __name(() => {
  const rules = {};
  sets.forEach((set2) => {
    set2.lngs.forEach((l) => {
      rules[l] = {
        numbers: set2.nr,
        plurals: _rulesPluralsTypes[set2.fc]
      };
    });
  });
  return rules;
}, "createRules");
const _PluralResolver = class _PluralResolver {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      try {
        const cleanedCode = getCleanedCode(code2 === "dev" ? "en" : code2);
        const type = options.ordinal ? "ordinal" : "cardinal";
        const cacheKey = JSON.stringify({
          cleanedCode,
          type
        });
        if (cacheKey in this.pluralRulesCache) {
          return this.pluralRulesCache[cacheKey];
        }
        const rule = new Intl.PluralRules(cleanedCode, {
          type
        });
        this.pluralRulesCache[cacheKey] = rule;
        return rule;
      } catch (err2) {
        return;
      }
    }
    return this.rules[code2] || this.rules[this.languageUtils.getLanguagePartFromCode(code2)];
  }
  needsPlural(code2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code2, options);
    if (this.shouldUseIntlApi()) {
      return rule && rule.resolvedOptions().pluralCategories.length > 1;
    }
    return rule && rule.numbers.length > 1;
  }
  getPluralFormsOfKey(code2, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code2, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code2, options);
    if (!rule) {
      return [];
    }
    if (this.shouldUseIntlApi()) {
      return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
    }
    return rule.numbers.map((number) => this.getSuffix(code2, number, options));
  }
  getSuffix(code2, count) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code2, options);
    if (rule) {
      if (this.shouldUseIntlApi()) {
        return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
      }
      return this.getSuffixRetroCompatible(rule, count);
    }
    this.logger.warn(`no plural rule found for: ${code2}`);
    return "";
  }
  getSuffixRetroCompatible(rule, count) {
    const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
    let suffix = rule.numbers[idx];
    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      if (suffix === 2) {
        suffix = "plural";
      } else if (suffix === 1) {
        suffix = "";
      }
    }
    const returnSuffix = /* @__PURE__ */ __name(() => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString(), "returnSuffix");
    if (this.options.compatibilityJSON === "v1") {
      if (suffix === 1) return "";
      if (typeof suffix === "number") return `_plural_${suffix.toString()}`;
      return returnSuffix();
    } else if (this.options.compatibilityJSON === "v2") {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      return returnSuffix();
    }
    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
};
__name(_PluralResolver, "PluralResolver");
let PluralResolver = _PluralResolver;
const deepFindWithDefaults = /* @__PURE__ */ __name(function(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path2 = getPathWithDefaults(data, defaultData, key);
  if (!path2 && ignoreJSONStructure && isString(key)) {
    path2 = deepFind(data, key, keySeparator);
    if (path2 === void 0) path2 = deepFind(defaultData, key, keySeparator);
  }
  return path2;
}, "deepFindWithDefaults");
const regexSafe = /* @__PURE__ */ __name((val) => val.replace(/\$/g, "$$$$"), "regexSafe");
const _Interpolator = class _Interpolator {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || ((value) => value);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== void 0 ? escape$1 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = /* @__PURE__ */ __name((existingRegExp, pattern2) => {
      if (existingRegExp && existingRegExp.source === pattern2) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern2, "g");
    }, "getOrResetRegExp");
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = /* @__PURE__ */ __name((key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path2 = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path2, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path2;
      }
      const p = key.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    }, "handleFormat");
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: /* @__PURE__ */ __name((val) => regexSafe(val), "safeValue")
    }, {
      regex: this.regexp,
      safeValue: /* @__PURE__ */ __name((val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val), "safeValue")
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value = isString(temp) ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (!isString(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = /* @__PURE__ */ __name((key, inheritedOptions) => {
      const sep2 = this.nestingOptionsSeparator;
      if (key.indexOf(sep2) < 0) return key;
      const c = key.split(new RegExp(`${sep2}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e2) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e2);
        return `${key}${sep2}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    }, "handleHasOptions");
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        const r = match[1].split(this.formatSeparator).map((elem) => elem.trim());
        match[1] = r.shift();
        formatters = r;
        doReduce = true;
      }
      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && !isString(value)) return value;
      if (!isString(value)) value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = "";
      }
      if (doReduce) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
};
__name(_Interpolator, "Interpolator");
let Interpolator = _Interpolator;
const parseFormatStr = /* @__PURE__ */ __name((formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}, "parseFormatStr");
const createCachedFormatter = /* @__PURE__ */ __name((fn) => {
  const cache = {};
  return (val, lng, options) => {
    let optForCache = options;
    if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [options.interpolationkey]: void 0
      };
    }
    const key = lng + JSON.stringify(optForCache);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
}, "createCachedFormatter");
const _Formatter = class _Formatter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = options.interpolation.formatSeparator || ",";
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format2, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format2.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f) => f.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f) => f.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
};
__name(_Formatter, "Formatter");
let Formatter = _Formatter;
const removePending = /* @__PURE__ */ __name((q, name) => {
  if (q.pending[name] !== void 0) {
    delete q.pending[name];
    q.pendingCount--;
  }
}, "removePending");
const _Connector = class _Connector extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    if (this.backend && this.backend.init) {
      this.backend.init(services, options.backend, options);
    }
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0) ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0) pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0) pending[name] = true;
          if (toLoad[name] === void 0) toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err2, data) {
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    if (err2) this.emit("failedLoading", lng, ns, err2);
    if (!err2 && data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name] = err2 ? -1 : 2;
    if (err2 && data) this.state[name] = 0;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name);
      if (err2) q.errors.push(err2);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l) => {
          if (!loaded[l]) loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach((n) => {
              if (loaded[l][n] === void 0) loaded[l][n] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = /* @__PURE__ */ __name((err2, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err2 && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err2, data);
    }, "resolver");
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r = fc(lng, ns);
        if (r && typeof r.then === "function") {
          r.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r);
        }
      } catch (err2) {
        resolver(err2);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    this.read(lng, ns, "read", void 0, void 0, (err2, data) => {
      if (err2) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err2);
      if (!err2 && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err2, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend && this.backend.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r;
          if (fc.length === 5) {
            r = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r = fc(languages, namespace, key, fallbackValue);
          }
          if (r && typeof r.then === "function") {
            r.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r);
          }
        } catch (err2) {
          clb(err2);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
};
__name(_Connector, "Connector");
let Connector = _Connector;
const get = /* @__PURE__ */ __name(() => ({
  debug: false,
  initImmediate: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: /* @__PURE__ */ __name((args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString(args[1])) ret.defaultValue = args[1];
    if (isString(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  }, "overloadTranslationOptionHandler"),
  interpolation: {
    escapeValue: true,
    format: /* @__PURE__ */ __name((value) => value, "format"),
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  }
}), "get");
const transformOptions = /* @__PURE__ */ __name((options) => {
  if (isString(options.ns)) options.ns = [options.ns];
  if (isString(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}, "transformOptions");
const noop = /* @__PURE__ */ __name(() => {
}, "noop");
const bindMemberFunctions = /* @__PURE__ */ __name((inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}, "bindMemberFunctions");
let I18n$1 = (_g = class extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (isString(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    if (this.options.compatibilityAPI !== "v1") {
      this.options.interpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation
      };
    }
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = /* @__PURE__ */ __name((ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    }, "createClassOnDemand");
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== "undefined") {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu;
      s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init) s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m) => {
        if (m.init) m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load2 = /* @__PURE__ */ __name(() => {
      const finish = /* @__PURE__ */ __name((err2, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err2, t2);
      }, "finish");
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    }, "load");
    if (this.options.resources || !this.options.initImmediate) {
      load2();
    } else {
      setTimeout(load2, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    let usedCallback = callback;
    const usedLng = isString(language) ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append2 = /* @__PURE__ */ __name((lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l) => {
          if (l === "cimode") return;
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      }, "append");
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l) => append2(l));
      } else {
        append2(usedLng);
      }
      if (this.options.preload) {
        this.options.preload.forEach((l) => append2(l));
      }
      this.services.backendConnector.load(toLoad, this.options.ns, (e2) => {
        if (!e2 && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e2);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err2) => {
      deferred.resolve();
      callback(err2);
    });
    return deferred;
  }
  use(module) {
    if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages) return;
    if (["cimode", "dev"].indexOf(l) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = /* @__PURE__ */ __name((l) => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l);
    }, "setLngProps");
    const done = /* @__PURE__ */ __name((err2, l) => {
      if (l) {
        setLngProps(l);
        this.translator.changeLanguage(l);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l);
        this.logger.log("languageChanged", l);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback) callback(err2, function() {
        return _this2.t(...arguments);
      });
    }, "done");
    const setLng = /* @__PURE__ */ __name((lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const l = isString(lngs) ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language) this.translator.changeLanguage(l);
        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);
      }
      this.loadResources(l, (err2) => {
        done(err2, l);
      });
    }, "setLng");
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = /* @__PURE__ */ __name(function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      if (options.keyPrefix !== "") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k) => `${options.keyPrefix}${keySeparator}${k}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    }, "fixedT");
    if (isString(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = /* @__PURE__ */ __name((l, n) => {
      const loadState = this.services.backendConnector.state[`${l}|${n}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    }, "loadNotPending");
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString(ns)) ns = [ns];
    ns.forEach((n) => {
      if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);
    });
    this.loadResources((err2) => {
      deferred.resolve();
      if (callback) callback(err2);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err2) => {
      deferred.resolve();
      if (callback) callback(err2);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new _g(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new _g(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m) => {
      clone[m] = this[m];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      clone.store = new ResourceStore(this.store.data, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", function(event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}, __name(_g, "I18n"), _g);
const instance = I18n$1.createInstance();
instance.createInstance = I18n$1.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const en = { "common": {}, "kernel": { "kernel": { "madeBy": "Made with ❤️  by", "panic": "Uh oh, kernel panic! Check the logs for more details.", "permissionNotificationDenied": "Notification permission denied", "modules": { "blacklisted": "Skipping blacklisted module {{module}}" } } } };
const resources = {
  "en": en
};
const DefaultI18nOptions = {
  resources,
  lng: "en",
  fallbackLng: "en",
  ns: ["common", "kernel"],
  defaultNS: "common",
  interpolation: {
    escapeValue: false
  }
};
const _I18n = class _I18n {
  constructor(_options) {
    __publicField(this, "_i18next");
    const options = { ...DefaultI18nOptions, ..._options };
    this._i18next = instance;
    instance.init(options);
  }
  get i18next() {
    return this._i18next;
  }
  get language() {
    return this._i18next.language;
  }
  get t() {
    return this._i18next.t;
  }
};
__name(_I18n, "I18n");
let I18n = _I18n;
const _Intervals = class _Intervals {
  constructor() {
    __publicField(this, "_intervals", /* @__PURE__ */ new Map());
  }
  get(name) {
    return this._intervals.get(name);
  }
  set(name, callback, interval) {
    const intervalId = setInterval(callback, interval);
    this._intervals.set(name, intervalId);
    return intervalId;
  }
  clear(name) {
    const interval = this._intervals.get(name);
    if (interval) {
      clearInterval(interval);
      this._intervals.delete(name);
    }
  }
};
__name(_Intervals, "Intervals");
let Intervals = _Intervals;
const _Memory = class _Memory {
  constructor() {
    __publicField(this, "config");
    __publicField(this, "collection");
    __publicField(this, "heap");
    __publicField(this, "stack");
    __publicField(this, "_memory");
    this._memory = {
      config: /* @__PURE__ */ new Map(),
      collection: /* @__PURE__ */ new Set(),
      heap: /* @__PURE__ */ new Map(),
      stack: new Array()
    };
    this.config = this._memory.config;
    this.collection = this._memory.collection;
    this.heap = this._memory.heap;
    this.stack = this._memory.stack;
    this.config.set("bootTime", Date.now());
  }
  // Stack
  push(value) {
    this._memory.stack.push(value);
  }
  pop() {
    return this._memory.stack.pop();
  }
  peek() {
    return this._memory.stack[this._memory.stack.length - 1];
  }
  // Heap
  allocate(size) {
    const memory = new Uint8Array(size);
    const address = this._memory.heap.size;
    this._memory.heap.set(address, memory);
    return address;
  }
  free(address) {
    this._memory.heap.delete(address);
  }
  read(address) {
    return this._memory.heap.get(address);
  }
  write(address, value) {
    this._memory.heap.set(address, value);
  }
  copy(source2, destination) {
    const sourceMemory = this.read(source2);
    const destinationMemory = this.read(destination);
    if (sourceMemory && destinationMemory) {
      destinationMemory.set(sourceMemory);
    } else {
      throw new Error("Invalid memory addresses");
    }
  }
  move(source2, destination) {
    this.copy(source2, destination);
    this.free(source2);
  }
  compare(address1, address2) {
    const memory1 = this.read(address1);
    const memory2 = this.read(address2);
    if (memory1 && memory2) {
      return memory1.every((value, index) => value === memory2[index]);
    } else {
      throw new Error("Invalid memory addresses");
    }
  }
  search(value) {
    function findPattern(array1, array2) {
      for (let i = 0; i <= array1.length - array2.length; i++) {
        let match = true;
        for (let j = 0; j < array2.length; j++) {
          if (array1[i + j] !== array2[j]) {
            match = false;
            break;
          }
        }
        if (match) return true;
      }
      return false;
    }
    __name(findPattern, "findPattern");
    for (const [address, memory] of this._memory.heap.entries()) {
      if (findPattern(memory, new Uint8Array(value))) return address;
    }
    return -1;
  }
};
__name(_Memory, "Memory");
let Memory = _Memory;
const _FDTable = class _FDTable {
  constructor(stdin, stdout, stderr) {
    __publicField(this, "_stdin");
    __publicField(this, "_stdout");
    __publicField(this, "_stderr");
    // Track ZenFS file handles for cleanup
    __publicField(this, "_fileHandles", /* @__PURE__ */ new Set());
    this._stdin = stdin;
    this._stdout = stdout;
    this._stderr = stderr;
  }
  /**
   * Standard stream accessors
   */
  get stdin() {
    return this._stdin;
  }
  get stdout() {
    return this._stdout;
  }
  get stderr() {
    return this._stderr;
  }
  /**
   * Redirect stdin to a different stream
   */
  setStdin(stream2) {
    this._stdin = stream2;
  }
  /**
   * Redirect stdout to a different stream
   */
  setStdout(stream2) {
    this._stdout = stream2;
  }
  /**
   * Redirect stderr to a different stream
   */
  setStderr(stream2) {
    this._stderr = stream2;
  }
  /**
   * Redirect stderr to stdout (2>&1)
   */
  redirectStderrToStdout() {
    if (this._stdout) this._stderr = this._stdout;
  }
  /**
   * Register a ZenFS FileHandle for tracking
   * The handle's fd is managed by ZenFS, we just track it for cleanup
   */
  trackFileHandle(handle) {
    this._fileHandles.add(handle);
  }
  /**
   * Unregister a ZenFS FileHandle (e.g., after manual close)
   */
  untrackFileHandle(handle) {
    this._fileHandles.delete(handle);
  }
  /**
   * Get all tracked file handles
   */
  get fileHandles() {
    return Array.from(this._fileHandles);
  }
  /**
   * Close all tracked ZenFS file handles
   */
  async closeFileHandles() {
    const handles = Array.from(this._fileHandles);
    await Promise.all(handles.map(async (handle) => {
      try {
        await handle.close();
      } catch {
      }
    }));
    this._fileHandles.clear();
  }
  /**
   * Close all resources (for process cleanup)
   * Note: Does NOT close stdin/stdout/stderr as those may be shared with terminal
   */
  async cleanup() {
    await this.closeFileHandles();
  }
};
__name(_FDTable, "FDTable");
let FDTable = _FDTable;
const _ProcessManager = class _ProcessManager {
  constructor() {
    __publicField(this, "_processes", /* @__PURE__ */ new Map());
    __publicField(this, "_nextPid", 0);
  }
  get all() {
    return this._processes;
  }
  add(process2) {
    this._processes.set(process2.pid, process2);
    return process2.pid;
  }
  create(options) {
    return new Process(options);
  }
  get(pid) {
    return this._processes.get(pid);
  }
  pid() {
    const newPid = this._nextPid++;
    return newPid;
  }
  remove(pid) {
    this._processes.delete(pid);
  }
  spawn(parent, process2) {
    process2.parent = parent;
    return this.add(process2);
  }
};
__name(_ProcessManager, "ProcessManager");
let ProcessManager = _ProcessManager;
const _Process = class _Process {
  constructor(options) {
    __publicField(this, "_args");
    __publicField(this, "_code");
    __publicField(this, "_command");
    __publicField(this, "_cwd");
    __publicField(this, "_entry");
    __publicField(this, "_events");
    __publicField(this, "_fdtable");
    __publicField(this, "_gid");
    __publicField(this, "_kernel");
    __publicField(this, "_pid");
    __publicField(this, "_parent");
    __publicField(this, "_shell");
    __publicField(this, "_status", "stopped");
    __publicField(this, "_stderr");
    __publicField(this, "_stdin");
    __publicField(this, "_stdout");
    __publicField(this, "_terminal");
    __publicField(this, "_uid");
    __publicField(this, "_keepAlive", false);
    if (!options.kernel) throw new Error("Kernel is required");
    this._args = options.args || [];
    this._command = options.command || "";
    this._cwd = options.cwd || options.shell?.cwd || "/";
    this._entry = options.entry || ((params) => {
      options.kernel?.log.silly(params);
      return Promise.resolve(0);
    });
    this._events = new Events();
    this._gid = options.gid;
    this._kernel = options.kernel;
    this._pid = this._kernel.processes.pid();
    this._parent = options.parent;
    this._shell = options.shell || this.kernel.shell;
    this._terminal = options.terminal || this.kernel.terminal;
    this._uid = options.uid;
    this._stdin = options.stdin || this.terminal.getInputStream();
    this._stdout = options.stdout || this.terminal.stdout || new WritableStream();
    this._stderr = options.stderr || this.terminal.stderr || new WritableStream();
    this._fdtable = new FDTable(this._stdin, this._stdout, this._stderr);
    this.kernel.processes.add(this);
  }
  get args() {
    return this._args;
  }
  get code() {
    return this._code;
  }
  get command() {
    return this._command;
  }
  get cwd() {
    return this._cwd;
  }
  get entry() {
    return this._entry;
  }
  get events() {
    return this._events;
  }
  get fd() {
    return this._fdtable;
  }
  get gid() {
    return this._gid;
  }
  get kernel() {
    return this._kernel;
  }
  get pid() {
    return this._pid;
  }
  get shell() {
    return this._shell;
  }
  get status() {
    return this._status;
  }
  get stderr() {
    return this._stderr;
  }
  get stdin() {
    return this._stdin;
  }
  get stdout() {
    return this._stdout;
  }
  get terminal() {
    return this._terminal;
  }
  get uid() {
    return this._uid;
  }
  get parent() {
    return this._parent;
  }
  set parent(parent) {
    this._parent = parent;
  }
  /**
   * Opens a file and automatically tracks it in the FDTable.
   * The file handle will be automatically closed on process cleanup.
   * @param path - Path to the file
   * @param flags - Open flags (default: 'r')
   * @returns The file handle
   */
  async open(path2, flags = "r") {
    const handle = await this.kernel.filesystem.fs.open(path2, flags);
    this._fdtable.trackFileHandle(handle);
    return handle;
  }
  /**
   * Closes a file handle and untracks it from the FDTable.
   * @param handle - The file handle to close
   */
  async close(handle) {
    this._fdtable.untrackFileHandle(handle);
    await handle.close();
  }
  async cleanup() {
    this.events.clear();
    this.kernel.processes.remove(this.pid);
    await this._fdtable.cleanup();
    if (this._stdin && this._stdin !== this.terminal.stdin) {
      try {
        await this._stdin.cancel("Process cleanup");
      } catch {
      }
    }
    if (this._stdout && this._stdout !== this.terminal.stdout) {
      try {
        await this._stdout.close();
      } catch {
      }
    }
    if (this._stderr && this._stderr !== this.terminal.stderr) {
      try {
        await this._stderr.close();
      } catch {
      }
    }
  }
  async exit(exitCode = 0) {
    this._code = exitCode;
    this._status = "exited";
    await this.cleanup();
    this.events.emit(ProcessEvents.EXIT, { pid: this.pid, code: exitCode });
  }
  pause() {
    this._status = "paused";
    this.events.emit(ProcessEvents.PAUSE, { pid: this.pid });
  }
  resume() {
    this._status = "running";
    this.events.emit(ProcessEvents.RESUME, { pid: this.pid });
  }
  keepAlive() {
    this._keepAlive = true;
  }
  async start() {
    this._status = "running";
    this.events.emit(ProcessEvents.START, { pid: this.pid });
    const exitCode = await this.entry({
      args: this.args,
      command: this.command,
      cwd: this.cwd,
      instance: this,
      gid: this.gid,
      kernel: this.kernel,
      pid: this.pid,
      shell: this.shell,
      terminal: this.terminal,
      stdin: this._stdin,
      stdout: this._stdout,
      stderr: this._stderr,
      uid: this.uid
    });
    if (!this._keepAlive) await this.stop(exitCode ?? 0);
    return exitCode ?? 0;
  }
  async stop(exitCode) {
    this._status = "stopped";
    this.events.emit(ProcessEvents.STOP, { pid: this.pid });
    await this.exit(exitCode ?? 0);
  }
  restart() {
    this.stop();
    this.start();
  }
};
__name(_Process, "Process");
let Process = _Process;
const _Protocol = class _Protocol {
  constructor(options) {
    __publicField(this, "_kernel");
    this._kernel = options.kernel;
    globalThis.navigator?.registerProtocolHandler?.(
      options.schema || "web+ecmaos",
      `${window.location.origin}?protocol=%s`
    );
  }
  get kernel() {
    return this._kernel;
  }
  open(uri) {
    this.kernel.terminal.writeln(`Opening ${uri}`);
  }
};
__name(_Protocol, "Protocol");
let Protocol = _Protocol;
const DefaultServiceOptions = {
  path: "/swapi.js",
  register: true
};
const _Service = class _Service {
  constructor(options) {
    __publicField(this, "_fetches", {});
    __publicField(this, "_kernel");
    __publicField(this, "_options");
    __publicField(this, "_registration");
    __publicField(this, "_messageHandler");
    options = { ...DefaultServiceOptions, ...options };
    if (!options.kernel) throw new Error("Kernel is required to initialize a Service Worker.");
    this._kernel = options.kernel;
    this._options = options;
    navigator.serviceWorker?.ready.then(() => this.message(`Kernel ${this._kernel.id} has registered a Service Worker!`));
    if (options.register) this.register();
    this.setupMessageHandler();
  }
  get fetches() {
    return this._fetches;
  }
  get options() {
    return this._options;
  }
  get registration() {
    return this._registration;
  }
  setupMessageHandler() {
    if (!("serviceWorker" in navigator)) return;
    const sendFile = /* @__PURE__ */ __name(async (event) => {
      const data = event.data;
      try {
        event.source?.postMessage({
          type: "fs",
          file: data.file,
          data: await this._kernel.filesystem.fs.readFile(data.file)
        });
      } catch (error) {
        this._kernel.log.error(error instanceof Error ? error.message : "Unknown error");
        event.source?.postMessage({
          type: "fs",
          file: data.file,
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }, "sendFile");
    this._messageHandler = async (event) => {
      if (event.source instanceof ServiceWorker) {
        const data = event.data;
        try {
          switch (data.type) {
            case "log":
              this._kernel.log.info(`[ServiceWorker] ${data.message}`);
              break;
            case "error":
              this._kernel.log.error(`[ServiceWorker] ${data.message}`);
              break;
            case "fs":
              sendFile(event);
              break;
          }
        } catch (error) {
          if (data.type === "fs") {
            this._kernel.log.error(`[ServiceWorker] Error reading file ${data.file}: ${error instanceof Error ? error.message : "Unknown error"}`);
            event.source?.postMessage({
              type: "fs",
              file: data.file,
              error: error instanceof Error ? error.message : "Unknown error"
            });
          }
        }
      }
    };
    navigator.serviceWorker.addEventListener("message", this._messageHandler);
  }
  /**
   * Fetch a list of URLs and save them to the kernel's filesystem using the Background Fetch API.
   * 
   * @param id - The id of the fetch (used as directory name for the downloaded files).
   * @param urls - The URLs to fetch.
   * @param options - The options to pass to the fetch.
   * @returns The fetch registration.
   */
  async fetch(id, urls, options) {
    if (this._fetches[id]) throw new Error(`Fetch with id ${id} already exists.`);
    if (!urls || urls.length === 0) throw new Error("No URLs provided to fetch.");
    if (!("serviceWorker" in navigator)) throw new Error("Service Worker API not supported in this browser.");
    if (!("BackgroundFetchManager" in globalThis)) throw new Error("Background Fetch API not supported in this browser.");
    if (!this.registration) throw new Error("Service Worker is not registered.");
    let downloadTotal = void 0;
    for (const url of urls) {
      if (typeof downloadTotal !== "number") downloadTotal = 0;
      const response = await fetch(url, { method: "HEAD" });
      downloadTotal += parseInt(response.headers.get("content-length") || "0");
    }
    const registration = await this.registration.backgroundFetch.fetch(id, urls, { ...options, downloadTotal });
    this._fetches[id] = registration;
    registration.addEventListener("progress", () => {
      if (!registration.downloadTotal) return;
      const percent = Math.round(registration.downloaded / registration.downloadTotal * 100);
      this._kernel.log.info(`${percent}% of ${urls.length} files downloaded.`);
    });
    navigator.serviceWorker.addEventListener("message", async (e2) => {
      const root = this._kernel.shell.cwd || "/tmp";
      const destination = path$1.resolve(root, e2.data.id);
      if (e2.data.type === "backgroundfetchsuccess") {
        if (!await this._kernel.filesystem.fs.exists(destination)) await this._kernel.filesystem.fs.mkdir(destination);
        for (const url of urls) {
          try {
            const response = await fetch(url);
            const buffer2 = await response.arrayBuffer();
            await this._kernel.filesystem.fs.writeFile(`${destination}/${url.split("/").pop()}`, new Uint8Array(buffer2));
            this._kernel.log.info(`Saved ${url} to ${destination}/${url.split("/").pop()}.`);
          } catch (error) {
            this._kernel.log.error(`Failed to fetch ${url}: ${error}`);
          }
        }
        delete this._fetches[id];
      }
      if (e2.data.type === "backgroundfetchclick") {
        this._kernel.terminal.writeln(`
Your download of ${urls.length} ${urls.length === 1 ? "file" : "files"} has completed and is located at ${destination}`);
        this._kernel.terminal.write(this._kernel.terminal.prompt());
      }
      if (e2.data.type === "backgroundfetchfailure") {
        this._kernel.terminal.writeln(`
Your download of ${urls.length} ${urls.length === 1 ? "file" : "files"} failed!`);
        this._kernel.terminal.write(this._kernel.terminal.prompt());
      }
    });
    return registration;
  }
  /**
   * Send a message to the Service Worker.
   * 
   * @param message - The message to send.
   */
  async message(message) {
    if ("serviceWorker" in navigator) {
      this.registration?.active?.postMessage({
        type: "kernel:message",
        message,
        kernelId: this._kernel.id
      });
    } else throw new Error("Service Worker API not supported in this browser.");
  }
  /**
   * Register the Service Worker.
   */
  async register() {
    if ("serviceWorker" in navigator) {
      const registration = await navigator.serviceWorker.register(this.options.path || "/swapi.js");
      this._registration = registration;
      return registration;
    } else throw new Error("Service Worker API not supported in this browser.");
  }
  /**
   * Unregister the Service Worker.
   */
  async unregister() {
    if ("serviceWorker" in navigator) {
      if (this._messageHandler) {
        navigator.serviceWorker.removeEventListener("message", this._messageHandler);
        this._messageHandler = void 0;
      }
      const registrations = await navigator.serviceWorker.getRegistrations();
      for (const registration of registrations) await registration.unregister();
    } else throw new Error("Service Worker API not supported in this browser.");
  }
  /**
   * Update the Service Worker.
   */
  async update() {
    if ("serviceWorker" in navigator) await this.registration?.update();
    else throw new Error("Service Worker API not supported in this browser.");
  }
};
__name(_Service, "Service");
let Service = _Service;
var shellQuote$1 = {};
var quote;
var hasRequiredQuote;
function requireQuote() {
  if (hasRequiredQuote) return quote;
  hasRequiredQuote = 1;
  quote = /* @__PURE__ */ __name(function quote2(xs) {
    return xs.map(function(s) {
      if (s && typeof s === "object") {
        return s.op.replace(/(.)/g, "\\$1");
      }
      if (/["\s]/.test(s) && !/'/.test(s)) {
        return "'" + s.replace(/(['\\])/g, "\\$1") + "'";
      }
      if (/["'\s]/.test(s)) {
        return '"' + s.replace(/(["\\$`!])/g, "\\$1") + '"';
      }
      return String(s).replace(/([A-Za-z]:)?([#!"$&'()*,:;<=>?@[\\\]^`{|}])/g, "$1\\$2");
    }).join(" ");
  }, "quote");
  return quote;
}
__name(requireQuote, "requireQuote");
var parse$1;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse$1;
  hasRequiredParse = 1;
  var CONTROL = "(?:" + [
    "\\|\\|",
    "\\&\\&",
    ";;",
    "\\|\\&",
    "\\<\\(",
    "\\<\\<\\<",
    ">>",
    ">\\&",
    "<\\&",
    "[&;()|<>]"
  ].join("|") + ")";
  var controlRE = new RegExp("^" + CONTROL + "$");
  var META = "|&;()<> \\t";
  var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
  var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
  var hash2 = /^#$/;
  var SQ = "'";
  var DQ = '"';
  var DS = "$";
  var TOKEN = "";
  var mult = 4294967296;
  for (var i = 0; i < 4; i++) {
    TOKEN += (mult * Math.random()).toString(16);
  }
  var startsWithToken = new RegExp("^" + TOKEN);
  function matchAll(s, r) {
    var origIndex = r.lastIndex;
    var matches = [];
    var matchObj;
    while (matchObj = r.exec(s)) {
      matches.push(matchObj);
      if (r.lastIndex === matchObj.index) {
        r.lastIndex += 1;
      }
    }
    r.lastIndex = origIndex;
    return matches;
  }
  __name(matchAll, "matchAll");
  function getVar(env2, pre, key) {
    var r = typeof env2 === "function" ? env2(key) : env2[key];
    if (typeof r === "undefined" && key != "") {
      r = "";
    } else if (typeof r === "undefined") {
      r = "$";
    }
    if (typeof r === "object") {
      return pre + TOKEN + JSON.stringify(r) + TOKEN;
    }
    return pre + r;
  }
  __name(getVar, "getVar");
  function parseInternal(string, env2, opts) {
    if (!opts) {
      opts = {};
    }
    var BS = opts.escape || "\\";
    var BAREWORD = "(\\" + BS + `['"` + META + `]|[^\\s'"` + META + "])+";
    var chunker = new RegExp([
      "(" + CONTROL + ")",
      // control chars
      "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")+"
    ].join("|"), "g");
    var matches = matchAll(string, chunker);
    if (matches.length === 0) {
      return [];
    }
    if (!env2) {
      env2 = {};
    }
    var commented = false;
    return matches.map(function(match) {
      var s = match[0];
      if (!s || commented) {
        return void 0;
      }
      if (controlRE.test(s)) {
        return { op: s };
      }
      var quote2 = false;
      var esc = false;
      var out = "";
      var isGlob = false;
      var i2;
      function parseEnvVar() {
        i2 += 1;
        var varend;
        var varname;
        var char = s.charAt(i2);
        if (char === "{") {
          i2 += 1;
          if (s.charAt(i2) === "}") {
            throw new Error("Bad substitution: " + s.slice(i2 - 2, i2 + 1));
          }
          varend = s.indexOf("}", i2);
          if (varend < 0) {
            throw new Error("Bad substitution: " + s.slice(i2));
          }
          varname = s.slice(i2, varend);
          i2 = varend;
        } else if (/[*@#?$!_-]/.test(char)) {
          varname = char;
          i2 += 1;
        } else {
          var slicedFromI = s.slice(i2);
          varend = slicedFromI.match(/[^\w\d_]/);
          if (!varend) {
            varname = slicedFromI;
            i2 = s.length;
          } else {
            varname = slicedFromI.slice(0, varend.index);
            i2 += varend.index - 1;
          }
        }
        return getVar(env2, "", varname);
      }
      __name(parseEnvVar, "parseEnvVar");
      for (i2 = 0; i2 < s.length; i2++) {
        var c = s.charAt(i2);
        isGlob = isGlob || !quote2 && (c === "*" || c === "?");
        if (esc) {
          out += c;
          esc = false;
        } else if (quote2) {
          if (c === quote2) {
            quote2 = false;
          } else if (quote2 == SQ) {
            out += c;
          } else {
            if (c === BS) {
              i2 += 1;
              c = s.charAt(i2);
              if (c === DQ || c === BS || c === DS) {
                out += c;
              } else {
                out += BS + c;
              }
            } else if (c === DS) {
              out += parseEnvVar();
            } else {
              out += c;
            }
          }
        } else if (c === DQ || c === SQ) {
          quote2 = c;
        } else if (controlRE.test(c)) {
          return { op: s };
        } else if (hash2.test(c)) {
          commented = true;
          var commentObj = { comment: string.slice(match.index + i2 + 1) };
          if (out.length) {
            return [out, commentObj];
          }
          return [commentObj];
        } else if (c === BS) {
          esc = true;
        } else if (c === DS) {
          out += parseEnvVar();
        } else {
          out += c;
        }
      }
      if (isGlob) {
        return { op: "glob", pattern: out };
      }
      return out;
    }).reduce(function(prev, arg) {
      return typeof arg === "undefined" ? prev : prev.concat(arg);
    }, []);
  }
  __name(parseInternal, "parseInternal");
  parse$1 = /* @__PURE__ */ __name(function parse2(s, env2, opts) {
    var mapped = parseInternal(s, env2, opts);
    if (typeof env2 !== "function") {
      return mapped;
    }
    return mapped.reduce(function(acc, s2) {
      if (typeof s2 === "object") {
        return acc.concat(s2);
      }
      var xs = s2.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
      if (xs.length === 1) {
        return acc.concat(xs[0]);
      }
      return acc.concat(xs.filter(Boolean).map(function(x) {
        if (startsWithToken.test(x)) {
          return JSON.parse(x.split(TOKEN)[1]);
        }
        return x;
      }));
    }, []);
  }, "parse");
  return parse$1;
}
__name(requireParse, "requireParse");
var hasRequiredShellQuote;
function requireShellQuote() {
  if (hasRequiredShellQuote) return shellQuote$1;
  hasRequiredShellQuote = 1;
  shellQuote$1.quote = requireQuote();
  shellQuote$1.parse = requireParse();
  return shellQuote$1;
}
__name(requireShellQuote, "requireShellQuote");
var shellQuoteExports = requireShellQuote();
const shellQuote = /* @__PURE__ */ getDefaultExportFromCjs$1(shellQuoteExports);
const DefaultShellPath = "$HOME/bin:/bin:/usr/bin:/usr/local/bin:/usr/local/sbin:/usr/sbin:/sbin";
const DefaultShellOptions = {
  cwd: "/",
  env: {
    PATH: DefaultShellPath,
    SHELL: "ecmaos",
    TERM: "xterm.js",
    USER: "root",
    HOME: "/root"
  }
};
const _Shell = class _Shell {
  constructor(_options) {
    __publicField(this, "_cwd");
    __publicField(this, "_env");
    __publicField(this, "_id", crypto.randomUUID());
    __publicField(this, "_kernel");
    __publicField(this, "_terminal");
    __publicField(this, "_terminalWriter");
    __publicField(this, "credentials", { uid: 0, gid: 0, suid: 0, sgid: 0, euid: 0, egid: 0, groups: [] });
    __publicField(this, "context", bindContext({ root: "/", pwd: "/", credentials: this.credentials }));
    const options = { ...DefaultShellOptions, ..._options };
    if (!options.kernel) throw new Error("Kernel is required");
    globalThis.shells?.set(this.id, this);
    this._cwd = options.cwd || localStorage.getItem(`cwd:${this.credentials.uid}`) || DefaultShellOptions.cwd;
    this._env = new Map([...Object.entries(DefaultShellOptions.env), ...Object.entries(options.env)]);
    this._kernel = options.kernel;
    this._terminal = options.terminal || options.kernel.terminal;
    this._terminalWriter = this._terminal?.stdout.getWriter() || new WritableStream().getWriter();
    process$1.env = Object.fromEntries(this._env);
  }
  get cwd() {
    return this._cwd;
  }
  set cwd(path2) {
    this._cwd = path2 === "/" ? path2 : path2.endsWith("/") ? path2.slice(0, -1) : path2;
  }
  get env() {
    return this._env;
  }
  set env(env2) {
    this._env = env2;
    globalThis.process.env = { ...globalThis.process.env, ...Object.fromEntries(env2) };
  }
  get envObject() {
    return Object.fromEntries(this._env);
  }
  get id() {
    return this._id;
  }
  get kernel() {
    return this._kernel;
  }
  get terminal() {
    return this._terminal;
  }
  get username() {
    return this._kernel.users.get(this.credentials.uid)?.username || "root";
  }
  async loadEnvFile() {
    const home = this._env.get("HOME");
    if (!home) return;
    const envFilePath = path$1.join(home, ".env");
    try {
      if (!await this.context.fs.promises.exists(envFilePath)) return;
      const content = await this.context.fs.promises.readFile(envFilePath, "utf-8");
      const envVars = this.parseEnvFile(content);
      for (const [key, value] of Object.entries(envVars)) {
        this._env.set(key, value);
      }
      process$1.env = Object.fromEntries(this._env);
    } catch {
    }
  }
  parseEnvFile(content) {
    const envVars = {};
    const lines = content.split("\n");
    for (const line3 of lines) {
      const trimmed = line3.trim();
      if (!trimmed || trimmed.startsWith("#")) continue;
      const match = trimmed.match(/^([^=#\s]+)=(.*)$/);
      if (match) {
        const [, key, value] = match;
        if (!key || !value) continue;
        let parsedValue = value.trim();
        if (parsedValue.startsWith('"') && parsedValue.endsWith('"') || parsedValue.startsWith("'") && parsedValue.endsWith("'"))
          parsedValue = parsedValue.slice(1, -1);
        envVars[key] = parsedValue;
      }
    }
    return envVars;
  }
  attach(terminal) {
    this._terminal = terminal;
    this._terminalWriter = terminal.stdout.getWriter();
  }
  clearPositionalParameters() {
    for (const key of this.env.keys()) {
      if (!isNaN(parseInt(key))) this.env.delete(key);
    }
  }
  parseRedirection(commandLine) {
    const redirections = [];
    let command = commandLine;
    const redirectionRegex = /(&>>|&>|>&|2>&1|2>>|2>|>>|>|<)\s*(\S+)?/g;
    command = command.replace(redirectionRegex, (_, operator, target) => {
      const normalizedOp = operator === ">&" ? "&>" : operator;
      if (normalizedOp === "2>&1") {
        redirections.push({ type: "2>&1", target: "" });
      } else if (target) {
        redirections.push({
          type: normalizedOp,
          target: target.trim()
        });
      }
      return "";
    }).trim();
    return { command, redirections };
  }
  async execute(line3) {
    const lineWithoutComments = line3.split("#")[0]?.trim();
    if (!lineWithoutComments || lineWithoutComments === "") return 0;
    const commandGroups = lineWithoutComments.split(";").map((group) => group.trim());
    let finalResult = 0;
    for (const group of commandGroups) {
      if (group === "") continue;
      const conditionalCommands = group.split("&&").map((cmd) => cmd.trim());
      let shouldContinue = true;
      for (const conditionalCmd of conditionalCommands) {
        if (!shouldContinue) break;
        const commands = conditionalCmd.split("|").map((cmd) => cmd.trim());
        const currentCmd = this._terminal.cmd;
        try {
          const pipelineSetup = [];
          let prevReadable;
          const { env: env2, kernel } = this;
          for (let i = 0; i < commands.length; i++) {
            const commandLine = commands[i];
            if (!commandLine) continue;
            const { command, redirections } = this.parseRedirection(commandLine);
            const [commandName, ...args] = shellQuote.parse(command, this.envObject);
            if (!commandName) return Infinity;
            const finalCommand = await this.resolveCommand(commandName);
            if (!finalCommand) return Infinity;
            const isFirstCommand = i === 0;
            const isLastCommand = i === commands.length - 1;
            let inputStream;
            if (isFirstCommand) {
              const inputRedirect = redirections.find((r) => r.type === "<");
              if (inputRedirect) {
                const sourcePath = path$1.resolve(this.cwd, inputRedirect.target);
                if (!await this.context.fs.promises.exists(sourcePath)) {
                  throw new Error(`File not found: ${sourcePath}`);
                }
                inputStream = this.createFileReadStream(sourcePath, env2, kernel);
              } else {
                inputStream = this._terminal.getInputStream();
              }
            } else {
              if (!prevReadable) {
                throw new Error("Pipeline error: missing previous stream");
              }
              inputStream = prevReadable;
            }
            let outputStream;
            let errorStream;
            const stdoutRedirect = redirections.find((r) => r.type === ">" || r.type === ">>");
            const stderrRedirect = redirections.find((r) => r.type === "2>" || r.type === "2>>");
            const bothRedirect = redirections.find((r) => r.type === "&>" || r.type === "&>>");
            const stderrToStdout = redirections.find((r) => r.type === "2>&1");
            if (isLastCommand) {
              if (bothRedirect) {
                const targetPath = path$1.resolve(this.cwd, bothRedirect.target);
                const append2 = bothRedirect.type === "&>>";
                const shared = this.createSharedFileStreams(targetPath, append2);
                outputStream = shared.stdout;
                errorStream = shared.stderr;
              } else if (stderrToStdout) {
                if (stdoutRedirect) {
                  const targetPath = path$1.resolve(this.cwd, stdoutRedirect.target);
                  const append2 = stdoutRedirect.type === ">>";
                  const shared = this.createSharedFileStreams(targetPath, append2);
                  outputStream = shared.stdout;
                  errorStream = shared.stderr;
                } else {
                  const shared = this.createSharedTerminalStreams();
                  outputStream = shared.stdout;
                  errorStream = shared.stderr;
                }
              } else {
                if (stdoutRedirect) {
                  const targetPath = path$1.resolve(this.cwd, stdoutRedirect.target);
                  const append2 = stdoutRedirect.type === ">>";
                  outputStream = this.createFileWriteStream(targetPath, append2);
                } else {
                  outputStream = this.createTerminalOutputStream();
                }
                if (stderrRedirect) {
                  const targetPath = path$1.resolve(this.cwd, stderrRedirect.target);
                  const append2 = stderrRedirect.type === "2>>";
                  errorStream = this.createFileWriteStream(targetPath, append2);
                } else {
                  errorStream = this.createTerminalErrorStream();
                }
              }
            } else {
              const pipe2 = new TransformStream();
              outputStream = pipe2.writable;
              prevReadable = pipe2.readable;
              if (stderrToStdout) {
                const pipeWriter = pipe2.writable.getWriter();
                errorStream = new WritableStream({
                  write: /* @__PURE__ */ __name(async (chunk) => {
                    await pipeWriter.write(chunk);
                  }, "write"),
                  close: /* @__PURE__ */ __name(async () => {
                    pipeWriter.releaseLock();
                  }, "close")
                });
                outputStream = new WritableStream({
                  write: /* @__PURE__ */ __name(async (chunk) => {
                    await pipeWriter.write(chunk);
                  }, "write")
                });
              } else if (stderrRedirect) {
                const targetPath = path$1.resolve(this.cwd, stderrRedirect.target);
                const append2 = stderrRedirect.type === "2>>";
                errorStream = this.createFileWriteStream(targetPath, append2);
              } else {
                errorStream = this.createTerminalErrorStream();
              }
            }
            pipelineSetup.push({ finalCommand, args, inputStream, outputStream, errorStream });
          }
          const commandPromises = pipelineSetup.map(
            ({ finalCommand, args, inputStream, outputStream, errorStream }) => this._kernel.execute({
              command: finalCommand,
              args,
              kernel: this._kernel,
              shell: this,
              terminal: this._terminal,
              stdin: inputStream,
              stdout: outputStream,
              stderr: errorStream
            })
          );
          const results = await Promise.all(commandPromises);
          for (const result of results) {
            if (result !== 0) {
              finalResult = result;
            }
          }
          if (finalResult !== 0) shouldContinue = false;
        } catch (error) {
          this._terminal.restoreCommand(currentCmd);
          throw error;
        }
      }
    }
    return finalResult;
  }
  /**
   * Creates a ReadableStream that reads from a file
   */
  createFileReadStream(sourcePath, env2, kernel) {
    return new ReadableStream({
      async start(controller) {
        const fileHandle = await kernel.filesystem.fs.open(sourcePath, "r");
        const chunkSize = parseInt(
          env2.get("SHELL_INPUT_REDIRECTION_CHUNK_SIZE") || void 0 || "8192"
        );
        const buffer2 = new Uint8Array(chunkSize);
        try {
          while (true) {
            const { bytesRead } = await fileHandle.read(buffer2, 0, chunkSize);
            if (bytesRead === 0) break;
            controller.enqueue(buffer2.slice(0, bytesRead));
          }
        } finally {
          await fileHandle.close();
          controller.close();
        }
      }
    });
  }
  /**
   * Creates a WritableStream that writes to a file
   */
  createFileWriteStream(targetPath, append2) {
    const context = this.context;
    let isFirstWrite = true;
    return new WritableStream({
      write: /* @__PURE__ */ __name(async (chunk) => {
        if (append2 || !isFirstWrite) {
          await context.fs.promises.appendFile(targetPath, chunk);
        } else {
          await context.fs.promises.writeFile(targetPath, chunk);
          isFirstWrite = false;
        }
      }, "write")
    });
  }
  /**
   * Creates a WritableStream that writes to the terminal
   */
  createTerminalOutputStream() {
    const writer = this._terminalWriter;
    return new WritableStream({
      write: /* @__PURE__ */ __name(async (chunk) => {
        if (writer) await writer.write(chunk);
      }, "write")
    });
  }
  createTerminalErrorStream() {
    const terminal = this._terminal;
    return new WritableStream({
      write: /* @__PURE__ */ __name(async (chunk) => {
        const text = new TextDecoder().decode(chunk);
        terminal.write(`\x1B[31m${text}\x1B[0m`);
      }, "write")
    });
  }
  /**
   * Creates a pair of WritableStreams that both write to the same file.
   * Used for &> and 2>&1 redirections where stdout and stderr go to the same destination.
   */
  createSharedFileStreams(filePath, append2) {
    const context = this.context;
    let writeQueue = Promise.resolve();
    let isFirstWrite = true;
    const writeToFile = /* @__PURE__ */ __name(async (chunk) => {
      if (append2 || !isFirstWrite) {
        await context.fs.promises.appendFile(filePath, chunk);
      } else {
        await context.fs.promises.writeFile(filePath, chunk);
        isFirstWrite = false;
      }
    }, "writeToFile");
    const createStream = /* @__PURE__ */ __name(() => new WritableStream({
      write: /* @__PURE__ */ __name(async (chunk) => {
        const currentWrite = writeQueue.then(() => writeToFile(chunk));
        writeQueue = currentWrite.catch(() => {
        });
        await currentWrite;
      }, "write")
    }), "createStream");
    return {
      stdout: createStream(),
      stderr: createStream()
    };
  }
  /**
   * Creates a pair of WritableStreams that both write to the terminal.
   * Used for 2>&1 when stdout goes to terminal.
   */
  createSharedTerminalStreams() {
    const writer = this._terminalWriter;
    const createStream = /* @__PURE__ */ __name(() => new WritableStream({
      write: /* @__PURE__ */ __name(async (chunk) => {
        if (writer) await writer.write(chunk);
      }, "write")
    }), "createStream");
    return {
      stdout: createStream(),
      stderr: createStream()
    };
  }
  async resolveCommand(command) {
    if (command.startsWith("./")) {
      const cwdCommand = path$1.join(this.cwd, command.slice(2));
      if (await this.context.fs.promises.exists(cwdCommand)) {
        return cwdCommand;
      }
      return void 0;
    }
    const paths = this.env.get("PATH")?.split(":") || DefaultShellPath.split(":");
    const resolvedCommand = path$1.resolve(command);
    if (await this.context.fs.promises.exists(resolvedCommand)) {
      return resolvedCommand;
    }
    for (const path2 of paths) {
      const expandedPath = path2.replace(/\$([A-Z_]+)/g, (_, name) => this.env.get(name) || "");
      const fullPath = `${expandedPath}/${command}`;
      if (await this.context.fs.promises.exists(fullPath)) return fullPath;
    }
    return void 0;
  }
  setPositionalParameters(args) {
    this.clearPositionalParameters();
    for (const [index, arg] of args.entries()) this.env.set(`${index}`, arg);
  }
};
__name(_Shell, "Shell");
let Shell = _Shell;
const _Storage = class _Storage {
  constructor(options) {
    __publicField(this, "_db", null);
    __publicField(this, "_kernel");
    __publicField(this, "indexed", globalThis.indexedDB);
    __publicField(this, "local", globalThis.localStorage);
    __publicField(this, "session", globalThis.sessionStorage);
    this._kernel = options.kernel;
    navigator.storage?.persist?.();
    if (this.indexed) {
      const name = options.indexed?.name || "ecmaos:storage";
      const open2 = this.indexed.open(name, options.indexed?.version || 1);
      open2.onsuccess = () => {
        this._db = open2.result;
        this._kernel.log.silly(`IndexedDB connection to ${name} successful`);
      };
      open2.onerror = () => {
        this._kernel.log.error("IndexedDB connection failed");
      };
      open2.onupgradeneeded = (event) => {
        const db = open2.result;
        db.onerror = (event2) => this._kernel.log.error("IndexedDB connection failed", event2);
        const store = db.createObjectStore("ecmaos:storage", { keyPath: "id", autoIncrement: true });
        switch (event.newVersion) {
          case 1:
            store.createIndex("data", "data", { unique: false });
            break;
        }
        this._kernel.log.silly(`IndexedDB schema ${event.newVersion === 1 ? "created" : "updated to version ${event.newVersion}"}`);
      };
    }
  }
  get db() {
    return this._db;
  }
  get kernel() {
    return this._kernel;
  }
  async usage() {
    try {
      const usage = await navigator.storage?.estimate?.();
      if (!usage) throw new Error("Storage usage not available");
      return usage;
    } catch (error) {
      this._kernel.log.error("Storage usage failed", error);
      return null;
    }
  }
};
__name(_Storage, "Storage");
let Storage = _Storage;
const _Users = class _Users {
  constructor(options) {
    __publicField(this, "_options");
    __publicField(this, "_users", /* @__PURE__ */ new Map());
    this._options = options;
  }
  get all() {
    return this._users;
  }
  /**
   * Add a user to the system
   */
  async add(user2, options = {}) {
    if (!user2.uid) user2.uid = this._users.size;
    if (!user2.gid) user2.gid = user2.uid;
    if (!user2.groups) user2.groups = [];
    if (!user2.shell) user2.shell = "ecmaos";
    if (!user2.home) user2.home = `/home/${user2.username}`;
    if (!user2.username || !user2.password) throw new Error("Username and password are required");
    if (this._users.has(user2.uid) || Array.from(this._users.values()).some((u) => u.username === user2.username))
      throw new Error(`User with UID ${user2.uid} or username ${user2.username} already exists`);
    const invalidChars = /[#/\\&=:\t\r\n\f]/;
    if (invalidChars.test(user2.username)) throw new Error("Username contains invalid characters");
    user2.username = user2.username.replace(/[^\x20-\x7E]+/g, "");
    const unhashedPassword = user2.password;
    if (!options.noHash) {
      const hashedPassword = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(unhashedPassword.trim()));
      user2.password = Array.from(new Uint8Array(hashedPassword)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    if (!options.noHome) {
      await this._options.kernel.filesystem.fs.mkdir(user2.home, { recursive: true, mode: 488 });
    }
    if (!user2.keypair) {
      const keyPair = await crypto.subtle.generateKey({ name: "ECDSA", namedCurve: "P-384" }, true, ["sign", "verify"]);
      const privateKey = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
      const publicKey = await crypto.subtle.exportKey("jwk", keyPair.publicKey);
      const paddedPassword = new TextEncoder().encode(unhashedPassword.padEnd(32, "\0")).slice(0, 32);
      let aesKey;
      try {
        aesKey = await crypto.subtle.importKey(
          "raw",
          paddedPassword,
          "AES-GCM",
          false,
          ["encrypt", "decrypt"]
        );
      } catch (err2) {
        console.error(err2);
        throw err2;
      }
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encryptedPrivateKeyBuffer = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        aesKey,
        new TextEncoder().encode(JSON.stringify(privateKey))
      );
      const encryptedData = new Uint8Array(iv.length + encryptedPrivateKeyBuffer.byteLength);
      encryptedData.set(iv);
      encryptedData.set(new Uint8Array(encryptedPrivateKeyBuffer), iv.length);
      const encryptedPrivateKey = btoa(String.fromCharCode(...encryptedData));
      user2.keypair = { publicKey };
      if (!options.noWrite) await this._options.kernel.filesystem.fs.appendFile("/etc/shadow", `${user2.username}:${user2.uid}:${user2.gid}:${user2.password}:${btoa(JSON.stringify(publicKey))}:${encryptedPrivateKey}

`, { encoding: "utf-8", mode: 448 });
    }
    if (!options.noWrite) await this._options.kernel.filesystem.fs.appendFile("/etc/passwd", `${user2.username}:${user2.uid}:${user2.gid}:${user2.groups.join(",")}:${user2.home}:${user2.shell}

`, { encoding: "utf-8", mode: 448 });
    this._users.set(user2.uid, user2);
    try {
      await this._options.kernel.filesystem.fs.chown(user2.home, user2.uid, user2.gid);
    } catch {
    }
  }
  /**
   * Get a user by UID
   */
  get(uid) {
    return this._users.get(uid);
  }
  /**
   * Load users from the filesystem
   */
  async load() {
    const { kernel } = this._options;
    const passwd2 = await kernel.filesystem.fs.readFile("/etc/passwd", "utf-8");
    const shadow = await kernel.filesystem.fs.readFile("/etc/shadow", "utf-8");
    for (const line3 of passwd2.split("\n")) {
      if (line3.trim() === "" || line3.trim() === "\n" || line3.startsWith("#")) continue;
      const [username, uid, gid, groups, home, shell] = line3.split(":");
      if (!username || !uid || !gid || !home || !shell) continue;
      const shadowEntry = shadow.split("\n").find((l) => l.startsWith(username + ":"));
      if (shadowEntry) {
        const [, , , password, publicKey, encryptedPrivateKey] = shadowEntry.split(":");
        if (!publicKey || !encryptedPrivateKey) {
          kernel.log.warn(`User ${username} has no keypair`);
          continue;
        }
        const keypair = { publicKey: JSON.parse(atob(publicKey)), privateKey: encryptedPrivateKey };
        await this.add({
          username,
          password,
          uid: parseInt(uid),
          gid: parseInt(gid),
          groups: groups?.split(",").filter((g) => g !== "").map(Number) ?? [],
          home,
          shell,
          keypair
        }, { noWrite: true, noHome: true, noHash: true });
      } else {
        kernel.log.warn(`User ${username} not found in /etc/shadow`);
      }
    }
  }
  /**
   * Login a user
   */
  async login(username, password) {
    const user2 = Array.from(this._users.values()).find((u) => u.username === username);
    const hashedPassword = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(password.trim()));
    if (!user2 || user2.password !== Array.from(new Uint8Array(hashedPassword)).map((b) => b.toString(16).padStart(2, "0")).join("")) throw new Error("Invalid username or password");
    const cred = createCredentials({
      uid: user2.uid,
      gid: user2.gid,
      groups: user2.groups
    });
    return { user: user2, cred };
  }
  async password(oldPassword, newPassword) {
    const user2 = this._users.get(this._options.kernel.shell.credentials.uid);
    if (!user2) throw new Error(this._options.kernel.i18n.t("User not found"));
    try {
      const hashedOldPassword = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(oldPassword.trim()));
      if (user2.password !== Array.from(new Uint8Array(hashedOldPassword)).map((b) => b.toString(16).padStart(2, "0")).join("")) throw new Error("Invalid password");
      const hashedNewPassword = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(newPassword.trim()));
      user2.password = Array.from(new Uint8Array(hashedNewPassword)).map((b) => b.toString(16).padStart(2, "0")).join("");
      await this.update(user2.uid, user2);
      await this._options.kernel.filesystem.fs.writeFile("/etc/passwd", Array.from(this._users.values()).map((u) => `${u.username}:${u.uid}:${u.gid}:${u.groups.join(",")}:${u.home}:${u.shell}`).join("\n"), { encoding: "utf-8", mode: 488 });
    } catch (err2) {
      console.error(err2);
      throw err2;
    }
  }
  /**
   * Remove a user from the system
  */
  async remove(uid) {
    this._users.delete(uid);
    await this._options.kernel.filesystem.fs.writeFile("/etc/passwd", Array.from(this._users.values()).map((u) => `${u.username}:${u.uid}:${u.gid}:${u.groups.join(",")}:${u.home}:${u.shell}`).join("\n"), { encoding: "utf-8", mode: 488 });
  }
  /**
   * Update a user
   */
  async update(uid, user2) {
    const existingUser = this._users.get(uid);
    if (existingUser) {
      this._users.set(uid, { ...existingUser, ...user2 });
      await this._options.kernel.filesystem.fs.writeFile("/etc/passwd", Array.from(this._users.values()).map((u) => `${u.username}:${u.uid}:${u.gid}:${u.groups.join(",")}:${u.home}:${u.shell}`).join("\n"), { encoding: "utf-8", mode: 488 });
    } else {
      throw new Error(`User with UID ${uid} not found`);
    }
  }
};
__name(_Users, "Users");
let Users = _Users;
const _Wasm = class _Wasm {
  constructor(options) {
    __publicField(this, "_kernel");
    __publicField(this, "_modules", /* @__PURE__ */ new Map());
    this._kernel = options.kernel;
  }
  // private _wabt?: WabtModule
  get modules() {
    return this._modules;
  }
  /**
   * Load an emscripten JS file compiled using -sSINGLE_FILE
   */
  async loadEmscripten(path2) {
    const contents = await this._kernel.filesystem.fs.readFile(path2, "utf-8");
    const script = document.createElement("script");
    script.textContent = contents;
    document.head.appendChild(script);
  }
  /**
   * Load a WebAssembly module
   */
  async loadWasm(path2) {
    const importObject = {
      env: {
        log: console.log
      }
    };
    const wasm = await this._kernel.filesystem.fs.readFile(path2);
    const { module, instance: instance2 } = await WebAssembly.instantiate(wasm, importObject);
    this._modules.set(path2, { module, instance: instance2 });
    return { module, instance: instance2 };
  }
};
__name(_Wasm, "Wasm");
let Wasm = _Wasm;
(function() {
  var e2, aa = document.createElement("style");
  aa.innerHTML = "@keyframes wb-fade-in{0%{opacity:0}to{opacity:.85}}.winbox{position:fixed;left:0;top:0;background:#0050ff;box-shadow:0 14px 28px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.22);transition:width .3s,height .3s,left .3s,top .3s;transition-timing-function:cubic-bezier(.3,1,.3,1);contain:layout size;text-align:left;touch-action:none}.wb-body,.wb-header{position:absolute;left:0}.wb-header{top:0;width:100%;height:35px;line-height:35px;color:#fff;overflow:hidden;z-index:1}.wb-body{top:35px;right:0;bottom:0;overflow:auto;-webkit-overflow-scrolling:touch;overflow-scrolling:touch;will-change:contents;background:#fff;margin-top:0!important;contain:strict;z-index:0}.wb-control *,.wb-icon{background-repeat:no-repeat}.wb-drag{height:100%;padding-left:10px;cursor:move}.wb-title{font-family:Arial,sans-serif;font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.wb-icon{display:none;width:20px;height:100%;margin:-1px 8px 0-3px;float:left;background-size:100%;background-position:center}.wb-e,.wb-w{width:10px;top:0}.wb-n,.wb-s{left:0;height:10px;position:absolute}.wb-n{top:-5px;right:0;cursor:n-resize;z-index:2}.wb-e{position:absolute;right:-5px;bottom:0;cursor:w-resize;z-index:2}.wb-s{bottom:-5px;right:0;cursor:n-resize;z-index:2}.wb-nw,.wb-sw,.wb-w{left:-5px}.wb-w{position:absolute;bottom:0;cursor:w-resize;z-index:2}.wb-ne,.wb-nw,.wb-sw{width:15px;height:15px;z-index:2;position:absolute}.wb-nw{top:-5px;cursor:nw-resize}.wb-ne,.wb-sw{cursor:ne-resize}.wb-ne{top:-5px;right:-5px}.wb-se,.wb-sw{bottom:-5px}.wb-se{position:absolute;right:-5px;width:15px;height:15px;cursor:nw-resize;z-index:2}.wb-control{float:right;height:100%;max-width:100%;text-align:center}.wb-control *{display:inline-block;width:30px;height:100%;max-width:100%;background-position:center;cursor:pointer}.no-close .wb-close,.no-full .wb-full,.no-header .wb-header,.no-max .wb-max,.no-min .wb-min,.no-resize .wb-body~div,.wb-body .wb-hide,.wb-show,.winbox.hide,.winbox.min .wb-body>*,.winbox.min .wb-full,.winbox.min .wb-min,.winbox.modal .wb-full,.winbox.modal .wb-max,.winbox.modal .wb-min{display:none}.winbox.max .wb-drag,.winbox.min .wb-drag{cursor:default}.wb-min{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAyIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNOCAwaDdhMSAxIDAgMCAxIDAgMkgxYTEgMSAwIDAgMSAwLTJoN3oiLz48L3N2Zz4=);background-size:14px auto;background-position:center calc(50% + 6px)}.wb-max{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9IiNmZmYiIHZpZXdCb3g9IjAgMCA5NiA5NiI+PHBhdGggZD0iTTIwIDcxLjMxMUMxNS4zNCA2OS42NyAxMiA2NS4yMyAxMiA2MFYyMGMwLTYuNjMgNS4zNy0xMiAxMi0xMmg0MGM1LjIzIDAgOS42NyAzLjM0IDExLjMxMSA4SDI0Yy0yLjIxIDAtNCAxLjc5LTQgNHY1MS4zMTF6Ii8+PHBhdGggZD0iTTkyIDc2VjM2YzAtNi42My01LjM3LTEyLTEyLTEySDQwYy02LjYzIDAtMTIgNS4zNy0xMiAxMnY0MGMwIDYuNjMgNS4zNyAxMiAxMiAxMmg0MGM2LjYzIDAgMTItNS4zNyAxMi0xMnptLTUyIDRjLTIuMjEgMC00LTEuNzktNC00VjM2YzAtMi4yMSAxLjc5LTQgNC00aDQwYzIuMjEgMCA0IDEuNzkgNCA0djQwYzAgMi4yMS0xLjc5IDQtNCA0SDQweiIvPjwvc3ZnPg==);background-size:17px auto}.wb-close{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9Ii0xIC0xIDE4IDE4Ij48cGF0aCBmaWxsPSIjZmZmIiBkPSJtMS42MTMuMjEuMDk0LjA4M0w4IDYuNTg1IDE0LjI5My4yOTNsLjA5NC0uMDgzYTEgMSAwIDAgMSAxLjQwMyAxLjQwM2wtLjA4My4wOTRMOS40MTUgOGw2LjI5MiA2LjI5M2ExIDEgMCAwIDEtMS4zMiAxLjQ5N2wtLjA5NC0uMDgzTDggOS40MTVsLTYuMjkzIDYuMjkyLS4wOTQuMDgzQTEgMSAwIDAgMSAuMjEgMTQuMzg3bC4wODMtLjA5NEw2LjU4NSA4IC4yOTMgMS43MDdBMSAxIDAgMCAxIDEuNjEzLjIxeiIvPjwvc3ZnPg==);background-size:15px auto;background-position:5px center}.wb-full{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2ZmZiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2Utd2lkdGg9IjIuNSIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNOCAzSDVhMiAyIDAgMCAwLTIgMnYzbTE4IDBWNWEyIDIgMCAwIDAtMi0yaC0zbTAgMThoM2EyIDIgMCAwIDAgMi0ydi0zTTMgMTZ2M2EyIDIgMCAwIDAgMiAyaDMiLz48L3N2Zz4=);background-size:16px auto}.winbox.max .wb-body~div,.winbox.min .wb-body~div,.winbox.modal .wb-body~div,.winbox.modal .wb-drag,body.wb-lock iframe{pointer-events:none}.winbox.max{box-shadow:none}.winbox.max .wb-body{margin:0!important}.winbox iframe{position:absolute;width:100%;height:100%;border:0}body.wb-lock .winbox{will-change:left,top,width,height;transition:none}.winbox.modal:before{content:'';position:absolute;top:0;left:0;right:0;bottom:0;background:inherit;border-radius:inherit}.winbox.modal:after{content:'';position:absolute;top:-50vh;left:-50vw;right:-50vw;bottom:-50vh;background:#0d1117;animation:wb-fade-in .2s ease-out forwards;z-index:-1}.no-animation{transition:none}.no-shadow{box-shadow:none}.no-header .wb-body{top:0}.no-move:not(.min) .wb-title{pointer-events:none}.wb-body .wb-show{display:revert}";
  var h = document.getElementsByTagName("head")[0];
  h.firstChild ? h.insertBefore(aa, h.firstChild) : h.appendChild(aa);
  var ba = document.createElement("div");
  ba.innerHTML = "<div class=wb-header><div class=wb-control><span class=wb-min></span><span class=wb-max></span><span class=wb-full></span><span class=wb-close></span></div><div class=wb-drag><div class=wb-icon></div><div class=wb-title></div></div></div><div class=wb-body></div><div class=wb-n></div><div class=wb-s></div><div class=wb-w></div><div class=wb-e></div><div class=wb-nw></div><div class=wb-ne></div><div class=wb-se></div><div class=wb-sw></div>";
  function k(a, b, c, f) {
    a && a.addEventListener(b, c, f || false);
  }
  __name(k, "k");
  function l(a, b) {
    var c = window, f = m;
    c && c.removeEventListener(a, b, f || false);
  }
  __name(l, "l");
  function t2(a, b) {
    a.stopPropagation();
    b && a.preventDefault();
  }
  __name(t2, "t");
  function u(a, b, c) {
    c = "" + c;
    a["_s_" + b] !== c && (a.style.setProperty(b, c), a["_s_" + b] = c);
  }
  __name(u, "u");
  var x = [], A = [], ca = { capture: true, passive: false }, m = { capture: true, passive: true }, B, da = 0, E = 10, F, J, ha, K, P, ia;
  function U(a, b) {
    if (!(this instanceof U)) return new U(a);
    B || ja();
    if (a) {
      if (b) {
        var c = a;
        a = b;
      }
      if ("string" === typeof a) c = a;
      else {
        var f = a.id;
        var d = a.index;
        var n = a.root;
        var p = a.template;
        c = c || a.title;
        var v = a.icon;
        var L = a.mount;
        var Q = a.html;
        var g = a.url;
        var q = a.width;
        var r = a.height;
        var w = a.minwidth;
        var C = a.minheight;
        var y = a.maxwidth;
        var z = a.maxheight;
        var ea = a.autosize;
        var D = a.overflow;
        var G = a.min;
        var H = a.max;
        var I = a.hidden;
        var fa = a.modal;
        var X = a.x || (fa ? "center" : 0);
        var Y = a.y || (fa ? "center" : 0);
        var M = a.top;
        var N = a.left;
        var R = a.bottom;
        var S = a.right;
        var la = a.background;
        var O = a.border;
        var T = a.header;
        var Z = a["class"];
        var ma = a.oncreate;
        var ra = a.onclose;
        var sa = a.onfocus;
        var ta = a.onblur;
        var ua = a.onmove;
        var va = a.onresize;
        var wa = a.onfullscreen;
        var xa = a.onmaximize;
        var ya = a.onminimize;
        var za = a.onrestore;
        var Aa = a.onhide;
        var Ba = a.onshow;
        var Ca = a.onload;
      }
    }
    this.g = (p || ba).cloneNode(true);
    this.g.id = this.id = f || "winbox-" + ++da;
    this.g.className = "winbox" + (Z ? " " + ("string" === typeof Z ? Z : Z.join(" ")) : "") + (fa ? " modal" : "");
    this.g.winbox = this;
    this.window = this.g;
    this.body = this.g.getElementsByClassName("wb-body")[0];
    this.h = T || 35;
    A.push(this);
    la && this.setBackground(la);
    O ? u(this.body, "margin", O + (isNaN(O) ? "" : "px")) : O = 0;
    T && (b = this.g.getElementsByClassName("wb-header")[0], u(b, "height", T + "px"), u(b, "line-height", T + "px"), u(this.body, "top", T + "px"));
    c && this.setTitle(c);
    v && this.setIcon(v);
    L ? this.mount(L) : Q ? this.body.innerHTML = Q : g && this.setUrl(g, Ca);
    M = M ? V(M, P) : 0;
    R = R ? V(R, P) : 0;
    N = N ? V(N, K) : 0;
    S = S ? V(S, K) : 0;
    c = K - N - S;
    v = P - M - R;
    y = y ? V(y, c) : c;
    z = z ? V(z, v) : v;
    w = w ? V(
      w,
      y
    ) : 150;
    C = C ? V(C, z) : this.h;
    ea ? ((n || B).appendChild(this.body), q = Math.max(Math.min(this.body.clientWidth + 2 * O + 1, y), w), r = Math.max(Math.min(this.body.clientHeight + this.h + O + 1, z), C), this.g.appendChild(this.body)) : (q = q ? V(q, y) : Math.max(y / 2, w) | 0, r = r ? V(r, z) : Math.max(z / 2, C) | 0);
    X = X ? V(X, c, q) : N;
    Y = Y ? V(Y, v, r) : M;
    this.x = X;
    this.y = Y;
    this.width = q;
    this.height = r;
    this.s = w;
    this.o = C;
    this.m = y;
    this.l = z;
    this.top = M;
    this.right = S;
    this.bottom = R;
    this.left = N;
    this.index = d;
    this.j = D;
    this.focused = this.hidden = this.full = this.max = this.min = false;
    this.onclose = ra;
    this.onfocus = sa;
    this.onblur = ta;
    this.onmove = ua;
    this.onresize = va;
    this.onfullscreen = wa;
    this.onmaximize = xa;
    this.onminimize = ya;
    this.onrestore = za;
    this.onhide = Aa;
    this.onshow = Ba;
    I ? this.hide() : this.focus();
    if (d || 0 === d) this.index = d, u(this.g, "z-index", d), d > E && (E = d);
    H ? this.maximize() : G ? this.minimize() : this.resize().move();
    ka(this);
    (n || B).appendChild(this.g);
    ma && ma.call(this, a);
  }
  __name(U, "U");
  U["new"] = function(a) {
    return new U(a);
  };
  U.stack = function() {
    return A;
  };
  function V(a, b, c) {
    "string" === typeof a && ("center" === a ? a = (b - c) / 2 + 0.5 | 0 : "right" === a || "bottom" === a ? a = b - c : (c = parseFloat(a), a = "%" === ("" + c !== a && a.substring(("" + c).length)) ? b / 100 * c + 0.5 | 0 : c));
    return a;
  }
  __name(V, "V");
  function ja() {
    B = document.body;
    B[J = "requestFullscreen"] || B[J = "msRequestFullscreen"] || B[J = "webkitRequestFullscreen"] || B[J = "mozRequestFullscreen"] || (J = "");
    ha = J && J.replace("request", "exit").replace("mozRequest", "mozCancel").replace("Request", "Exit");
    k(window, "resize", function() {
      na();
      oa();
    });
    k(B, "mousedown", function() {
      ia = false;
    }, true);
    k(B, "mousedown", function() {
      if (!ia) {
        var a = A.length;
        if (a) for (--a; 0 <= a; a--) {
          var b = A[a];
          if (b.focused) {
            b.blur();
            break;
          }
        }
      }
    });
    na();
  }
  __name(ja, "ja");
  function ka(a) {
    W(a, "drag");
    W(a, "n");
    W(a, "s");
    W(a, "w");
    W(a, "e");
    W(a, "nw");
    W(a, "ne");
    W(a, "se");
    W(a, "sw");
    k(a.g.getElementsByClassName("wb-min")[0], "click", function(b) {
      t2(b);
      a.min ? a.restore().focus() : a.minimize();
    });
    k(a.g.getElementsByClassName("wb-max")[0], "click", function(b) {
      t2(b);
      a.max ? a.restore().focus() : a.maximize().focus();
    });
    J ? k(a.g.getElementsByClassName("wb-full")[0], "click", function(b) {
      t2(b);
      a.fullscreen().focus();
    }) : a.addClass("no-full");
    k(a.g.getElementsByClassName("wb-close")[0], "click", function(b) {
      t2(b);
      a.close() || (a = null);
    });
    k(a.g, "mousedown", function() {
      ia = true;
    }, true);
    k(a.body, "mousedown", function() {
      a.focus();
    }, true);
  }
  __name(ka, "ka");
  function pa(a) {
    x.splice(x.indexOf(a), 1);
    oa();
    a.removeClass("min");
    a.min = false;
    a.g.title = "";
  }
  __name(pa, "pa");
  function oa() {
    for (var a = x.length, b = {}, c = {}, f = 0, d; f < a; f++) d = x[f], d = d.left + ":" + d.top, c[d] ? c[d]++ : (b[d] = 0, c[d] = 1);
    f = 0;
    for (var n, p; f < a; f++) d = x[f], n = d.left + ":" + d.top, p = Math.min((K - d.left - d.right) / c[n], 250), d.resize(p + 1 | 0, d.h, true).move(d.left + b[n] * p | 0, P - d.bottom - d.h, true), b[n]++;
  }
  __name(oa, "oa");
  function W(a, b) {
    function c(g) {
      t2(g, true);
      a.focus();
      if ("drag" === b) {
        if (a.min) {
          a.restore();
          return;
        }
        if (!a.g.classList.contains("no-max")) {
          var q = Date.now(), r = q - Q;
          Q = q;
          if (300 > r) {
            a.max ? a.restore() : a.maximize();
            return;
          }
        }
      }
      a.min || (B.classList.add("wb-lock"), (p = g.touches) && (p = p[0]) ? (g = p, k(window, "touchmove", f, m), k(window, "touchend", d, m)) : (k(window, "mousemove", f, m), k(window, "mouseup", d, m)), v = g.pageX, L = g.pageY);
    }
    __name(c, "c");
    function f(g) {
      t2(g);
      p && (g = g.touches[0]);
      var q = g.pageX;
      g = g.pageY;
      var r = q - v, w = g - L, C = a.width, y = a.height, z = a.x, ea = a.y, D;
      if ("drag" === b) {
        if (a.g.classList.contains("no-move")) return;
        a.x += r;
        a.y += w;
        var G = D = 1;
      } else {
        if ("e" === b || "se" === b || "ne" === b) {
          a.width += r;
          var H = 1;
        } else if ("w" === b || "sw" === b || "nw" === b) a.x += r, a.width -= r, G = H = 1;
        if ("s" === b || "se" === b || "sw" === b) {
          a.height += w;
          var I = 1;
        } else if ("n" === b || "ne" === b || "nw" === b) a.y += w, a.height -= w, D = I = 1;
      }
      H && (a.width = Math.max(Math.min(a.width, a.m, K - a.x - a.right), a.s), H = a.width !== C);
      I && (a.height = Math.max(Math.min(a.height, a.l, P - a.y - a.bottom), a.o), I = a.height !== y);
      (H || I) && a.resize();
      G && (a.max && (a.x = (q < K / 3 ? a.left : q > K / 3 * 2 ? K - a.width - a.right : K / 2 - a.width / 2) + r), a.x = Math.max(Math.min(a.x, a.j ? K - 30 : K - a.width - a.right), a.j ? 30 - a.width : a.left), G = a.x !== z);
      D && (a.max && (a.y = a.top + w), a.y = Math.max(Math.min(a.y, a.j ? P - a.h : P - a.height - a.bottom), a.top), D = a.y !== ea);
      if (G || D) a.max && a.restore(), a.move();
      if (H || G) v = q;
      if (I || D) L = g;
    }
    __name(f, "f");
    function d(g) {
      t2(g);
      B.classList.remove("wb-lock");
      p ? (l("touchmove", f), l("touchend", d)) : (l("mousemove", f), l("mouseup", d));
    }
    __name(d, "d");
    var n = a.g.getElementsByClassName("wb-" + b)[0];
    if (n) {
      var p, v, L, Q = 0;
      k(n, "mousedown", c, ca);
      k(n, "touchstart", c, ca);
    }
  }
  __name(W, "W");
  function na() {
    var a = document.documentElement;
    K = a.clientWidth;
    P = a.clientHeight;
  }
  __name(na, "na");
  e2 = U.prototype;
  e2.mount = function(a) {
    this.unmount();
    a.i || (a.i = a.parentNode);
    this.body.textContent = "";
    this.body.appendChild(a);
    return this;
  };
  e2.unmount = function(a) {
    var b = this.body.firstChild;
    if (b) {
      var c = a || b.i;
      c && c.appendChild(b);
      b.i = a;
    }
    return this;
  };
  e2.setTitle = function(a) {
    var b = this.g.getElementsByClassName("wb-title")[0];
    a = this.title = a;
    var c = b.firstChild;
    c ? c.nodeValue = a : b.textContent = a;
    return this;
  };
  e2.setIcon = function(a) {
    var b = this.g.getElementsByClassName("wb-icon")[0];
    u(b, "background-image", "url(" + a + ")");
    u(b, "display", "inline-block");
    return this;
  };
  e2.setBackground = function(a) {
    u(this.g, "background", a);
    return this;
  };
  e2.setUrl = function(a, b) {
    var c = this.body.firstChild;
    c && "iframe" === c.tagName.toLowerCase() ? c.src = a : (this.body.innerHTML = '<iframe src="' + a + '"></iframe>', b && (this.body.firstChild.onload = b));
    return this;
  };
  e2.focus = function(a) {
    if (false === a) return this.blur();
    if (!this.focused) {
      a = A.length;
      if (1 < a) for (var b = 1; b <= a; b++) {
        var c = A[a - b];
        if (c.focused) {
          c.blur();
          A.push(A.splice(A.indexOf(this), 1)[0]);
          break;
        }
      }
      u(this.g, "z-index", ++E);
      this.index = E;
      this.addClass("focus");
      this.focused = true;
      this.onfocus && this.onfocus();
    }
    return this;
  };
  e2.blur = function(a) {
    if (false === a) return this.focus();
    this.focused && (this.removeClass("focus"), this.focused = false, this.onblur && this.onblur());
    return this;
  };
  e2.hide = function(a) {
    if (false === a) return this.show();
    if (!this.hidden) return this.onhide && this.onhide(), this.hidden = true, this.addClass("hide");
  };
  e2.show = function(a) {
    if (false === a) return this.hide();
    if (this.hidden) return this.onshow && this.onshow(), this.hidden = false, this.removeClass("hide");
  };
  e2.minimize = function(a) {
    if (false === a) return this.restore();
    F && qa();
    this.max && (this.removeClass("max"), this.max = false);
    this.min || (x.push(this), oa(), this.g.title = this.title, this.addClass("min"), this.min = true, this.focused && (this.blur(), Da()), this.onminimize && this.onminimize());
    return this;
  };
  function Da() {
    var a = A.length;
    if (a) for (--a; 0 <= a; a--) {
      var b = A[a];
      if (!b.min) {
        b.focus();
        break;
      }
    }
  }
  __name(Da, "Da");
  e2.restore = function() {
    F && qa();
    this.min && (pa(this), this.resize().move(), this.onrestore && this.onrestore());
    this.max && (this.max = false, this.removeClass("max").resize().move(), this.onrestore && this.onrestore());
    return this;
  };
  e2.maximize = function(a) {
    if (false === a) return this.restore();
    F && qa();
    this.min && pa(this);
    this.max || (this.addClass("max").resize(K - this.left - this.right, P - this.top - this.bottom, true).move(this.left, this.top, true), this.max = true, this.onmaximize && this.onmaximize());
    return this;
  };
  e2.fullscreen = function(a) {
    this.min && (pa(this), this.resize().move());
    if (!F || !qa()) this.body[J](), F = this, this.full = true, this.onfullscreen && this.onfullscreen();
    else if (false === a) return this.restore();
    return this;
  };
  function qa() {
    F.full = false;
    if (document.fullscreen || document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement) return document[ha](), true;
  }
  __name(qa, "qa");
  e2.close = function(a) {
    if (this.onclose && this.onclose(a)) return true;
    this.min && pa(this);
    A.splice(A.indexOf(this), 1);
    this.unmount();
    this.g.remove();
    this.g.textContent = "";
    this.g = this.body = this.g.winbox = null;
    this.focused && Da();
  };
  e2.move = function(a, b, c) {
    a || 0 === a ? c || (this.x = a ? a = V(a, K - this.left - this.right, this.width) : 0, this.y = b ? b = V(b, P - this.top - this.bottom, this.height) : 0) : (a = this.x, b = this.y);
    u(this.g, "left", a + "px");
    u(this.g, "top", b + "px");
    this.onmove && this.onmove(a, b);
    return this;
  };
  e2.resize = function(a, b, c) {
    a || 0 === a ? c || (this.width = a ? a = V(a, this.m) : 0, this.height = b ? b = V(b, this.l) : 0, a = Math.max(a, this.s), b = Math.max(b, this.o)) : (a = this.width, b = this.height);
    u(this.g, "width", a + "px");
    u(this.g, "height", b + "px");
    this.onresize && this.onresize(a, b);
    return this;
  };
  e2.addControl = function(a) {
    var b = a["class"], c = a.image, f = a.click;
    a = a.index;
    var d = document.createElement("span"), n = this.g.getElementsByClassName("wb-control")[0], p = this;
    b && (d.className = b);
    c && u(d, "background-image", "url(" + c + ")");
    f && (d.onclick = function(v) {
      f.call(this, v, p);
    });
    n.insertBefore(d, n.childNodes[a || 0]);
    return this;
  };
  e2.removeControl = function(a) {
    (a = this.g.getElementsByClassName(a)[0]) && a.remove();
    return this;
  };
  e2.addClass = function(a) {
    this.g.classList.add(a);
    return this;
  };
  e2.removeClass = function(a) {
    this.g.classList.remove(a);
    return this;
  };
  e2.toggleClass = function(a) {
    return this.g.classList.contains(a) ? this.removeClass(a) : this.addClass(a);
  };
  window.WinBox = U;
}).call(void 0);
const template = document.createElement("div");
template.innerHTML = //'<div class=winbox>' +
"<div class=wb-header><div class=wb-control><span class=wb-min></span><span class=wb-max></span><span class=wb-full></span><span class=wb-close></span></div><div class=wb-drag><div class=wb-icon></div><div class=wb-title></div></div></div><div class=wb-body></div><div class=wb-n></div><div class=wb-s></div><div class=wb-w></div><div class=wb-e></div><div class=wb-nw></div><div class=wb-ne></div><div class=wb-se></div><div class=wb-sw></div>";
function template$1(tpl) {
  return (tpl || template).cloneNode(true);
}
__name(template$1, "template$1");
function addListener(node, event, fn, opt) {
  node && node.addEventListener(event, fn, opt || false);
}
__name(addListener, "addListener");
function removeListener(node, event, fn, opt) {
  node && node.removeEventListener(event, fn, opt || false);
}
__name(removeListener, "removeListener");
function preventEvent(event, prevent) {
  event.stopPropagation();
  prevent && /*event.cancelable &&*/
  event.preventDefault();
}
__name(preventEvent, "preventEvent");
function getByClass(root, name) {
  return root.getElementsByClassName(name)[0];
}
__name(getByClass, "getByClass");
function addClass(node, classname) {
  node.classList.add(classname);
}
__name(addClass, "addClass");
function hasClass(node, classname) {
  return node.classList.contains(classname);
}
__name(hasClass, "hasClass");
function removeClass(node, classname) {
  node.classList.remove(classname);
}
__name(removeClass, "removeClass");
function setStyle(node, style, value) {
  value = "" + value;
  if (node["_s_" + style] !== value) {
    node.style.setProperty(style, value);
    node["_s_" + style] = value;
  }
}
__name(setStyle, "setStyle");
function setText(node, value) {
  const textnode = node.firstChild;
  textnode ? textnode.nodeValue = value : node.textContent = value;
}
__name(setText, "setText");
const stack_min = [];
const stack_win = [];
const eventOptions = { "capture": true, "passive": false };
const eventOptionsPassive = { "capture": true, "passive": true };
let body;
let id_counter = 0;
let index_counter = 10;
let is_fullscreen;
let prefix_request;
let prefix_exit;
let root_w, root_h;
let window_clicked;
function WinBox(params, _title) {
  if (!(this instanceof WinBox)) {
    return new WinBox(params);
  }
  body || setup();
  let id, index, root, tpl, title, icon, mount2, html, url, width, height, minwidth, minheight, maxwidth, maxheight, autosize, overflow, x, y, top, left, bottom, right, min, max, hidden, modal, background, border2, header, classname, oncreate, onclose, onfocus, onblur, onmove, onresize, onfullscreen, onmaximize, onminimize, onrestore, onhide, onshow, onload;
  if (params) {
    if (_title) {
      title = params;
      params = _title;
    }
    if (typeof params === "string") {
      title = params;
    } else {
      id = params["id"];
      index = params["index"];
      root = params["root"];
      tpl = params["template"];
      title = title || params["title"];
      icon = params["icon"];
      mount2 = params["mount"];
      html = params["html"];
      url = params["url"];
      width = params["width"];
      height = params["height"];
      minwidth = params["minwidth"];
      minheight = params["minheight"];
      maxwidth = params["maxwidth"];
      maxheight = params["maxheight"];
      autosize = params["autosize"];
      overflow = params["overflow"];
      min = params["min"];
      max = params["max"];
      hidden = params["hidden"];
      modal = params["modal"];
      x = params["x"] || (modal ? "center" : 0);
      y = params["y"] || (modal ? "center" : 0);
      top = params["top"];
      left = params["left"];
      bottom = params["bottom"];
      right = params["right"];
      background = params["background"];
      border2 = params["border"];
      header = params["header"];
      classname = params["class"];
      oncreate = params["oncreate"];
      onclose = params["onclose"];
      onfocus = params["onfocus"];
      onblur = params["onblur"];
      onmove = params["onmove"];
      onresize = params["onresize"];
      onfullscreen = params["onfullscreen"];
      onmaximize = params["onmaximize"];
      onminimize = params["onminimize"];
      onrestore = params["onrestore"];
      onhide = params["onhide"];
      onshow = params["onshow"];
      onload = params["onload"];
    }
  }
  this.dom = template$1(tpl);
  this.dom.id = this.id = id || "winbox-" + ++id_counter;
  this.dom.className = "winbox" + (classname ? " " + (typeof classname === "string" ? classname : classname.join(" ")) : "") + (modal ? " modal" : "");
  this.dom["winbox"] = this;
  this.window = this.dom;
  this.body = getByClass(this.dom, "wb-body");
  this.header = header || 35;
  stack_win.push(this);
  if (background) {
    this.setBackground(background);
  }
  if (border2) {
    setStyle(this.body, "margin", border2 + (isNaN(border2) ? "" : "px"));
  } else {
    border2 = 0;
  }
  if (header) {
    const node = getByClass(this.dom, "wb-header");
    setStyle(node, "height", header + "px");
    setStyle(node, "line-height", header + "px");
    setStyle(this.body, "top", header + "px");
  }
  if (title) {
    this.setTitle(title);
  }
  if (icon) {
    this.setIcon(icon);
  }
  if (mount2) {
    this.mount(mount2);
  } else if (html) {
    this.body.innerHTML = html;
  } else if (url) {
    this.setUrl(url, onload);
  }
  top = top ? parse(top, root_h) : 0;
  bottom = bottom ? parse(bottom, root_h) : 0;
  left = left ? parse(left, root_w) : 0;
  right = right ? parse(right, root_w) : 0;
  const viewport_w = root_w - left - right;
  const viewport_h = root_h - top - bottom;
  maxwidth = maxwidth ? parse(maxwidth, viewport_w) : viewport_w;
  maxheight = maxheight ? parse(maxheight, viewport_h) : viewport_h;
  minwidth = minwidth ? parse(minwidth, maxwidth) : 150;
  minheight = minheight ? parse(minheight, maxheight) : this.header;
  if (autosize) {
    (root || body).appendChild(this.body);
    width = Math.max(Math.min(this.body.clientWidth + border2 * 2 + 1, maxwidth), minwidth);
    height = Math.max(Math.min(this.body.clientHeight + this.header + border2 + 1, maxheight), minheight);
    this.dom.appendChild(this.body);
  } else {
    width = width ? parse(width, maxwidth) : Math.max(maxwidth / 2, minwidth) | 0;
    height = height ? parse(height, maxheight) : Math.max(maxheight / 2, minheight) | 0;
  }
  x = x ? parse(x, viewport_w, width) : left;
  y = y ? parse(y, viewport_h, height) : top;
  this.x = x;
  this.y = y;
  this.width = width;
  this.height = height;
  this.minwidth = minwidth;
  this.minheight = minheight;
  this.maxwidth = maxwidth;
  this.maxheight = maxheight;
  this.top = top;
  this.right = right;
  this.bottom = bottom;
  this.left = left;
  this.index = index;
  this.overflow = overflow;
  this.min = false;
  this.max = false;
  this.full = false;
  this.hidden = false;
  this.focused = false;
  this.onclose = onclose;
  this.onfocus = onfocus;
  this.onblur = onblur;
  this.onmove = onmove;
  this.onresize = onresize;
  this.onfullscreen = onfullscreen;
  this.onmaximize = onmaximize;
  this.onminimize = onminimize;
  this.onrestore = onrestore;
  this.onhide = onhide;
  this.onshow = onshow;
  if (hidden) {
    this.hide();
  } else {
    this.focus();
  }
  if (index || index === 0) {
    this.index = index;
    setStyle(this.dom, "z-index", index);
    if (index > index_counter) index_counter = index;
  }
  if (max) {
    this.maximize();
  } else if (min) {
    this.minimize();
  } else {
    this.resize().move();
  }
  register(this);
  (root || body).appendChild(this.dom);
  oncreate && oncreate.call(this, params);
}
__name(WinBox, "WinBox");
WinBox["new"] = function(params) {
  return new WinBox(params);
};
WinBox["stack"] = function() {
  return stack_win;
};
function parse(num, base, center) {
  if (typeof num === "string") {
    if (num === "center") {
      num = (base - center) / 2 + 0.5 | 0;
    } else if (num === "right" || num === "bottom") {
      num = base - center;
    } else {
      const value = parseFloat(num);
      const unit = "" + value !== num && num.substring(("" + value).length);
      if (unit === "%") {
        num = base / 100 * value + 0.5 | 0;
      } else {
        num = value;
      }
    }
  }
  return num;
}
__name(parse, "parse");
function setup() {
  body = document.body;
  body[prefix_request = "requestFullscreen"] || body[prefix_request = "msRequestFullscreen"] || body[prefix_request = "webkitRequestFullscreen"] || body[prefix_request = "mozRequestFullscreen"] || (prefix_request = "");
  prefix_exit = prefix_request && prefix_request.replace("request", "exit").replace("mozRequest", "mozCancel").replace("Request", "Exit");
  addListener(window, "resize", function() {
    init();
    update_min_stack();
  });
  addListener(body, "mousedown", function(event) {
    window_clicked = false;
  }, true);
  addListener(body, "mousedown", function(event) {
    if (!window_clicked) {
      const stack_length = stack_win.length;
      if (stack_length) {
        for (let i = stack_length - 1; i >= 0; i--) {
          const last_focus = stack_win[i];
          if (last_focus.focused) {
            last_focus.blur();
            break;
          }
        }
      }
    }
  });
  init();
}
__name(setup, "setup");
function register(self2) {
  addWindowListener(self2, "drag");
  addWindowListener(self2, "n");
  addWindowListener(self2, "s");
  addWindowListener(self2, "w");
  addWindowListener(self2, "e");
  addWindowListener(self2, "nw");
  addWindowListener(self2, "ne");
  addWindowListener(self2, "se");
  addWindowListener(self2, "sw");
  addListener(getByClass(self2.dom, "wb-min"), "click", function(event) {
    preventEvent(event);
    self2.min ? self2.restore().focus() : self2.minimize();
  });
  addListener(getByClass(self2.dom, "wb-max"), "click", function(event) {
    preventEvent(event);
    self2.max ? self2.restore().focus() : self2.maximize().focus();
  });
  if (prefix_request) {
    addListener(getByClass(self2.dom, "wb-full"), "click", function(event) {
      preventEvent(event);
      self2.fullscreen().focus();
    });
  } else {
    self2.addClass("no-full");
  }
  addListener(getByClass(self2.dom, "wb-close"), "click", function(event) {
    preventEvent(event);
    self2.close() || (self2 = null);
  });
  addListener(self2.dom, "mousedown", function(event) {
    window_clicked = true;
  }, true);
  addListener(self2.body, "mousedown", function(event) {
    self2.focus();
  }, true);
}
__name(register, "register");
function remove_min_stack(self2) {
  stack_min.splice(stack_min.indexOf(self2), 1);
  update_min_stack();
  self2.removeClass("min");
  self2.min = false;
  self2.dom.title = "";
}
__name(remove_min_stack, "remove_min_stack");
function update_min_stack() {
  const length = stack_min.length;
  const splitscreen_index = {};
  const splitscreen_length = {};
  for (let i = 0, self2, key; i < length; i++) {
    self2 = stack_min[i];
    key = self2.left + ":" + self2.top;
    if (splitscreen_length[key]) {
      splitscreen_length[key]++;
    } else {
      splitscreen_index[key] = 0;
      splitscreen_length[key] = 1;
    }
  }
  for (let i = 0, self2, key, width; i < length; i++) {
    self2 = stack_min[i];
    key = self2.left + ":" + self2.top;
    width = Math.min((root_w - self2.left - self2.right) / splitscreen_length[key], 250);
    self2.resize(width + 1 | 0, self2.header, true).move(self2.left + splitscreen_index[key] * width | 0, root_h - self2.bottom - self2.header, true);
    splitscreen_index[key]++;
  }
}
__name(update_min_stack, "update_min_stack");
function addWindowListener(self2, dir) {
  const node = getByClass(self2.dom, "wb-" + dir);
  if (!node) return;
  let touch2, x, y;
  let dblclick_timer = 0;
  addListener(node, "mousedown", mousedown, eventOptions);
  addListener(node, "touchstart", mousedown, eventOptions);
  function mousedown(event) {
    preventEvent(event, true);
    self2.focus();
    if (dir === "drag") {
      if (self2.min) {
        self2.restore();
        return;
      }
      if (!self2.hasClass("no-max")) {
        const now = Date.now();
        const diff = now - dblclick_timer;
        dblclick_timer = now;
        if (diff < 300) {
          self2.max ? self2.restore() : self2.maximize();
          return;
        }
      }
    }
    if (
      /*!self.max &&*/
      !self2.min
    ) {
      addClass(body, "wb-lock");
      if ((touch2 = event.touches) && (touch2 = touch2[0])) {
        event = touch2;
        addListener(window, "touchmove", handler_mousemove, eventOptionsPassive);
        addListener(window, "touchend", handler_mouseup, eventOptionsPassive);
      } else {
        addListener(window, "mousemove", handler_mousemove, eventOptionsPassive);
        addListener(window, "mouseup", handler_mouseup, eventOptionsPassive);
      }
      x = event.pageX;
      y = event.pageY;
    }
  }
  __name(mousedown, "mousedown");
  function handler_mousemove(event) {
    preventEvent(event);
    if (touch2) {
      event = event.touches[0];
    }
    const pageX = event.pageX;
    const pageY = event.pageY;
    const offsetX = pageX - x;
    const offsetY = pageY - y;
    const old_w = self2.width;
    const old_h = self2.height;
    const old_x = self2.x;
    const old_y = self2.y;
    let resize_w, resize_h, move_x, move_y;
    if (dir === "drag") {
      if (self2.hasClass("no-move")) return;
      self2.x += offsetX;
      self2.y += offsetY;
      move_x = move_y = 1;
    } else {
      if (dir === "e" || dir === "se" || dir === "ne") {
        self2.width += offsetX;
        resize_w = 1;
      } else if (dir === "w" || dir === "sw" || dir === "nw") {
        self2.x += offsetX;
        self2.width -= offsetX;
        resize_w = 1;
        move_x = 1;
      }
      if (dir === "s" || dir === "se" || dir === "sw") {
        self2.height += offsetY;
        resize_h = 1;
      } else if (dir === "n" || dir === "ne" || dir === "nw") {
        self2.y += offsetY;
        self2.height -= offsetY;
        resize_h = 1;
        move_y = 1;
      }
    }
    if (resize_w) {
      self2.width = Math.max(Math.min(self2.width, self2.maxwidth, root_w - self2.x - self2.right), self2.minwidth);
      resize_w = self2.width !== old_w;
    }
    if (resize_h) {
      self2.height = Math.max(Math.min(self2.height, self2.maxheight, root_h - self2.y - self2.bottom), self2.minheight);
      resize_h = self2.height !== old_h;
    }
    if (resize_w || resize_h) {
      self2.resize();
    }
    if (move_x) {
      if (self2.max) {
        self2.x = (pageX < root_w / 3 ? self2.left : pageX > root_w / 3 * 2 ? root_w - self2.width - self2.right : root_w / 2 - self2.width / 2) + offsetX;
      }
      self2.x = Math.max(Math.min(self2.x, self2.overflow ? root_w - 30 : root_w - self2.width - self2.right), self2.overflow ? 30 - self2.width : self2.left);
      move_x = self2.x !== old_x;
    }
    if (move_y) {
      if (self2.max) {
        self2.y = self2.top + offsetY;
      }
      self2.y = Math.max(Math.min(self2.y, self2.overflow ? root_h - self2.header : root_h - self2.height - self2.bottom), self2.top);
      move_y = self2.y !== old_y;
    }
    if (move_x || move_y) {
      if (self2.max) {
        self2.restore();
      }
      self2.move();
    }
    if (resize_w || move_x) {
      x = pageX;
    }
    if (resize_h || move_y) {
      y = pageY;
    }
  }
  __name(handler_mousemove, "handler_mousemove");
  function handler_mouseup(event) {
    preventEvent(event);
    removeClass(body, "wb-lock");
    if (touch2) {
      removeListener(window, "touchmove", handler_mousemove, eventOptionsPassive);
      removeListener(window, "touchend", handler_mouseup, eventOptionsPassive);
    } else {
      removeListener(window, "mousemove", handler_mousemove, eventOptionsPassive);
      removeListener(window, "mouseup", handler_mouseup, eventOptionsPassive);
    }
  }
  __name(handler_mouseup, "handler_mouseup");
}
__name(addWindowListener, "addWindowListener");
function init() {
  const doc = document.documentElement;
  root_w = doc.clientWidth;
  root_h = doc.clientHeight;
}
__name(init, "init");
WinBox.prototype.mount = function(src) {
  this.unmount();
  src._backstore || (src._backstore = src.parentNode);
  this.body.textContent = "";
  this.body.appendChild(src);
  return this;
};
WinBox.prototype.unmount = function(dest) {
  const node = this.body.firstChild;
  if (node) {
    const root = dest || node._backstore;
    root && root.appendChild(node);
    node._backstore = dest;
  }
  return this;
};
WinBox.prototype.setTitle = function(title) {
  const node = getByClass(this.dom, "wb-title");
  setText(node, this.title = title);
  return this;
};
WinBox.prototype.setIcon = function(src) {
  const img = getByClass(this.dom, "wb-icon");
  setStyle(img, "background-image", "url(" + src + ")");
  setStyle(img, "display", "inline-block");
  return this;
};
WinBox.prototype.setBackground = function(background) {
  setStyle(this.dom, "background", background);
  return this;
};
WinBox.prototype.setUrl = function(url, onload) {
  const node = this.body.firstChild;
  if (node && node.tagName.toLowerCase() === "iframe") {
    node.src = url;
  } else {
    this.body.innerHTML = '<iframe src="' + url + '"></iframe>';
    onload && (this.body.firstChild.onload = onload);
  }
  return this;
};
WinBox.prototype.focus = function(state2) {
  if (state2 === false) {
    return this.blur();
  }
  if (!this.focused) {
    const stack_length = stack_win.length;
    if (stack_length > 1) {
      for (let i = 1; i <= stack_length; i++) {
        const last_focus = stack_win[stack_length - i];
        if (last_focus.focused) {
          last_focus.blur();
          stack_win.push(stack_win.splice(stack_win.indexOf(this), 1)[0]);
          break;
        }
      }
    }
    setStyle(this.dom, "z-index", ++index_counter);
    this.index = index_counter;
    this.addClass("focus");
    this.focused = true;
    this.onfocus && this.onfocus();
  }
  return this;
};
WinBox.prototype.blur = function(state2) {
  if (state2 === false) {
    return this.focus();
  }
  if (this.focused) {
    this.removeClass("focus");
    this.focused = false;
    this.onblur && this.onblur();
  }
  return this;
};
WinBox.prototype.hide = function(state2) {
  if (state2 === false) {
    return this.show();
  }
  if (!this.hidden) {
    this.onhide && this.onhide();
    this.hidden = true;
    return this.addClass("hide");
  }
};
WinBox.prototype.show = function(state2) {
  if (state2 === false) {
    return this.hide();
  }
  if (this.hidden) {
    this.onshow && this.onshow();
    this.hidden = false;
    return this.removeClass("hide");
  }
};
WinBox.prototype.minimize = function(state2) {
  if (state2 === false) {
    return this.restore();
  }
  if (is_fullscreen) {
    cancel_fullscreen();
  }
  if (this.max) {
    this.removeClass("max");
    this.max = false;
  }
  if (!this.min) {
    stack_min.push(this);
    update_min_stack();
    this.dom.title = this.title;
    this.addClass("min");
    this.min = true;
    if (this.focused) {
      this.blur();
      focus_next();
    }
    this.onminimize && this.onminimize();
  }
  return this;
};
function focus_next() {
  const stack_length = stack_win.length;
  if (stack_length) {
    for (let i = stack_length - 1; i >= 0; i--) {
      const last_focus = stack_win[i];
      if (!last_focus.min) {
        last_focus.focus();
        break;
      }
    }
  }
}
__name(focus_next, "focus_next");
WinBox.prototype.restore = function() {
  if (is_fullscreen) {
    cancel_fullscreen();
  }
  if (this.min) {
    remove_min_stack(this);
    this.resize().move();
    this.onrestore && this.onrestore();
  }
  if (this.max) {
    this.max = false;
    this.removeClass("max").resize().move();
    this.onrestore && this.onrestore();
  }
  return this;
};
WinBox.prototype.maximize = function(state2) {
  if (state2 === false) {
    return this.restore();
  }
  if (is_fullscreen) {
    cancel_fullscreen();
  }
  if (this.min) {
    remove_min_stack(this);
  }
  if (!this.max) {
    this.addClass("max").resize(
      root_w - this.left - this.right,
      root_h - this.top - this.bottom,
      true
    ).move(
      this.left,
      this.top,
      true
    );
    this.max = true;
    this.onmaximize && this.onmaximize();
  }
  return this;
};
WinBox.prototype.fullscreen = function(state2) {
  if (this.min) {
    remove_min_stack(this);
    this.resize().move();
  }
  if (!is_fullscreen || !cancel_fullscreen()) {
    this.body[prefix_request]();
    is_fullscreen = this;
    this.full = true;
    this.onfullscreen && this.onfullscreen();
  } else if (state2 === false) {
    return this.restore();
  }
  return this;
};
function has_fullscreen() {
  return document["fullscreen"] || document["fullscreenElement"] || document["webkitFullscreenElement"] || document["mozFullScreenElement"];
}
__name(has_fullscreen, "has_fullscreen");
function cancel_fullscreen() {
  is_fullscreen.full = false;
  if (has_fullscreen()) {
    document[prefix_exit]();
    return true;
  }
}
__name(cancel_fullscreen, "cancel_fullscreen");
WinBox.prototype.close = function(force) {
  if (this.onclose && this.onclose(force)) {
    return true;
  }
  if (this.min) {
    remove_min_stack(this);
  }
  stack_win.splice(stack_win.indexOf(this), 1);
  this.unmount();
  this.dom.remove();
  this.dom.textContent = "";
  this.dom["winbox"] = null;
  this.body = null;
  this.dom = null;
  this.focused && focus_next();
};
WinBox.prototype.move = function(x, y, _skip_update) {
  if (!x && x !== 0) {
    x = this.x;
    y = this.y;
  } else if (!_skip_update) {
    this.x = x ? x = parse(x, root_w - this.left - this.right, this.width) : 0;
    this.y = y ? y = parse(y, root_h - this.top - this.bottom, this.height) : 0;
  }
  setStyle(this.dom, "left", x + "px");
  setStyle(this.dom, "top", y + "px");
  this.onmove && this.onmove(x, y);
  return this;
};
WinBox.prototype.resize = function(w, h, _skip_update) {
  if (!w && w !== 0) {
    w = this.width;
    h = this.height;
  } else if (!_skip_update) {
    this.width = w ? w = parse(
      w,
      this.maxwidth
      /*- this.left - this.right*/
    ) : 0;
    this.height = h ? h = parse(
      h,
      this.maxheight
      /*- this.top - this.bottom*/
    ) : 0;
    w = Math.max(w, this.minwidth);
    h = Math.max(h, this.minheight);
  }
  setStyle(this.dom, "width", w + "px");
  setStyle(this.dom, "height", h + "px");
  this.onresize && this.onresize(w, h);
  return this;
};
WinBox.prototype.addControl = function(control) {
  const classname = control["class"];
  const image = control.image;
  const click = control.click;
  const index = control.index;
  const node = document.createElement("span");
  const icons = getByClass(this.dom, "wb-control");
  const self2 = this;
  if (classname) node.className = classname;
  if (image) setStyle(node, "background-image", "url(" + image + ")");
  if (click) node.onclick = function(event) {
    click.call(this, event, self2);
  };
  icons.insertBefore(node, icons.childNodes[index || 0]);
  return this;
};
WinBox.prototype.removeControl = function(control) {
  control = getByClass(this.dom, control);
  control && control.remove();
  return this;
};
WinBox.prototype.addClass = function(classname) {
  addClass(this.dom, classname);
  return this;
};
WinBox.prototype.removeClass = function(classname) {
  removeClass(this.dom, classname);
  return this;
};
WinBox.prototype.hasClass = function(classname) {
  return hasClass(this.dom, classname);
};
WinBox.prototype.toggleClass = function(classname) {
  return this.hasClass(classname) ? this.removeClass(classname) : this.addClass(classname);
};
const DefaultWindowOptions = {
  background: "black",
  border: 1,
  class: "ecmaos-window",
  height: 300,
  title: "Untitled",
  width: 300,
  x: "center",
  y: "center"
};
const DefaultDialogOptions = {
  ...DefaultWindowOptions,
  modal: true,
  width: 320,
  height: 200
};
const _Windows = class _Windows {
  constructor() {
    __publicField(this, "_manager", /* @__PURE__ */ new Map());
  }
  get stack() {
    return WinBox.stack();
  }
  all() {
    return this._manager.entries();
  }
  close(id) {
    this._manager.get(id)?.close();
    this.remove(id);
  }
  create(_options = DefaultWindowOptions) {
    const options = { ...DefaultWindowOptions, ..._options };
    const id = options.id || Math.random().toString(36).substring(2, 8);
    const win = new WinBox(options);
    this._manager.set(id, win);
    return win;
  }
  dialog(options = DefaultDialogOptions) {
    return this.create({ ...DefaultDialogOptions, ...options });
  }
  get(id) {
    return this._manager.get(id);
  }
  remove(id) {
    this._manager.delete(id);
  }
};
__name(_Windows, "Windows");
let Windows = _Windows;
const _Workers = class _Workers {
  constructor() {
    __publicField(this, "_workers");
    this._workers = {
      dedicated: [],
      shared: []
    };
  }
  create(blob) {
    if (!globalThis.Worker) throw new Error("Workers are not supported in this environment");
    const worker = new Worker(URL.createObjectURL(blob));
    this._workers.dedicated.push(worker);
    return worker;
  }
  createShared(blob) {
    if (!globalThis.SharedWorker) throw new Error("SharedWorkers are not supported in this environment");
    const worker = new SharedWorker(URL.createObjectURL(blob));
    this._workers.shared.push(worker);
    return worker;
  }
};
__name(_Workers, "Workers");
let Workers = _Workers;
const __vite_import_meta_env__ = { "AUTHOR": { "name": "Jay Mathis", "email": "code@mathis.network", "url": "https://github.com/mathiscode" }, "BASE_URL": "/", "DESCRIPTION": "ecmaOS: Micro-kernel and framework for web technologies", "DEV": false, "HOMEPAGE": "https://ecmaos.sh", "KNOWN_ISSUES": ["It's best to stick to Chromium-based browsers for the most features", "Keyboard is broken on mobile; ecmaOS is not mobile-friendly at this time", "Don't expect any sort of POSIX compliance at this stage", "Most commands/devices are very basic implementations, not complete reproductions", "stdin/stdout/stderr streams and redirection can be wonky and don't work everywhere, but are coming along", "CTRL-C will return you to a prompt, but doesn't currently interrupt a process", "Lots of unfinished work; watch your step"], "MODE": "production", "NAME": "@ecmaos/kernel", "PROD": true, "REPOSITORY": "https://github.com/ecmaos/ecmaos", "SSR": false, "TIPS": ["If it ever fails to boot, check your logs or try clearing all data", "You can run some devices that offer a CLI - e.g. '/dev/battery --help'", "Use the 'install' command to install packages - e.g. 'install @ecmaos-apps/news'", "You can install any NPM package - e.g. 'install jquery'", "Use the 'news' command to see the latest news about ecmaOS", "Type 'ls /bin' to see all built-in commands", "Type 'ls /usr/bin' to see all installed commands"], "VERSION": "0.5.0", "VITE_APP_SHOW_DEFAULT_LOGIN": "true", "VITE_INITFS": "/initfs.tar.gz", "VITE_RECOMMENDED_APPS": "@ecmaos-apps/news,@ecmaos-apps/code,@ecmaos-apps/webamp", "XTERM_VERSION": "5.5.0", "ZENFS_VERSION": "2.4.2" };
var define_import_meta_env_AUTHOR_default = { name: "Jay Mathis", email: "code@mathis.network", url: "https://github.com/mathiscode" };
var define_import_meta_env_KNOWN_ISSUES_default = ["It's best to stick to Chromium-based browsers for the most features", "Keyboard is broken on mobile; ecmaOS is not mobile-friendly at this time", "Don't expect any sort of POSIX compliance at this stage", "Most commands/devices are very basic implementations, not complete reproductions", "stdin/stdout/stderr streams and redirection can be wonky and don't work everywhere, but are coming along", "CTRL-C will return you to a prompt, but doesn't currently interrupt a process", "Lots of unfinished work; watch your step"];
var define_import_meta_env_TIPS_default = ["If it ever fails to boot, check your logs or try clearing all data", "You can run some devices that offer a CLI - e.g. '/dev/battery --help'", "Use the 'install' command to install packages - e.g. 'install @ecmaos-apps/news'", "You can install any NPM package - e.g. 'install jquery'", "Use the 'news' command to see the latest news about ecmaOS", "Type 'ls /bin' to see all built-in commands", "Type 'ls /usr/bin' to see all installed commands"];
const DefaultKernelOptions = {
  devices: DefaultDevices,
  dom: DefaultDomOptions,
  log: DefaultLogOptions,
  filesystem: DefaultFilesystemOptions,
  service: DefaultServiceOptions
};
const DefaultBootOptions = { silent: false };
const DefaultFigletFonts = [
  "3-D",
  "3x5",
  "3D-ASCII",
  "5 Line Oblique",
  "Acrobatic",
  "Big",
  "Big Money-ne",
  "Broadway",
  "Bubble",
  "Caligraphy",
  "Caligraphy2",
  "Coinstak",
  "Computer",
  "Cosmike",
  "Cyberlarge",
  "Diamond",
  "Doom",
  "Keyboard",
  "Larry 3D",
  "OS2",
  "Poison",
  "Rounded",
  "Runyc",
  "S Blood"
];
const _Kernel = class _Kernel {
  constructor(_options = DefaultKernelOptions) {
    /** Unique identifier for this kernel instance */
    __publicField(this, "id", crypto.randomUUID());
    /** Name of the kernel */
    __publicField(this, "name", "@ecmaos/kernel");
    /** Version string of the kernel */
    __publicField(this, "version", "0.5.0");
    /** Authentication and authorization service */
    __publicField(this, "auth");
    /** BIOS module providing low-level functionality */
    // public bios?: BIOSModule
    /** Broadcast channel for inter-kernel communication */
    __publicField(this, "channel");
    /** Web Components manager */
    __publicField(this, "components");
    /** WebContainer instance */
    __publicField(this, "container");
    /** DOM manipulation service */
    __publicField(this, "dom");
    /** Map of registered devices and their drivers */
    __publicField(this, "devices", /* @__PURE__ */ new Map());
    /** Event management system */
    __publicField(this, "events");
    /** Virtual filesystem */
    __publicField(this, "filesystem");
    /** Internationalization service */
    __publicField(this, "i18n");
    /** Interval management service */
    __publicField(this, "intervals");
    /** Keyboard interface */
    __publicField(this, "keyboard");
    /** Logging system */
    __publicField(this, "log");
    /** Memory management service */
    __publicField(this, "memory");
    /** Map of loaded modules */
    __publicField(this, "modules", /* @__PURE__ */ new Map());
    /** Configuration options passed to the kernel */
    __publicField(this, "options");
    /** Map of loaded packages */
    __publicField(this, "packages", /* @__PURE__ */ new Map());
    /** Process management service */
    __publicField(this, "processes");
    /** Protocol handler service */
    __publicField(this, "protocol");
    /** Map of available screensavers */
    __publicField(this, "screensavers");
    /** Service management system */
    __publicField(this, "service");
    /** Shell for command interpretation and execution */
    __publicField(this, "shell");
    /** Storage provider interface */
    __publicField(this, "storage");
    /** Terminal interface for user interaction */
    __publicField(this, "terminal");
    /** Toast notification service */
    __publicField(this, "toast");
    /** User management service */
    __publicField(this, "users");
    /** WebAssembly service */
    __publicField(this, "wasm");
    /** Window management service */
    __publicField(this, "windows");
    /** Web Worker management service */
    __publicField(this, "workers");
    /** Current state of the kernel */
    __publicField(this, "_state", KernelState.BOOTING);
    this.options = { ...DefaultKernelOptions, ..._options };
    this.auth = new Auth();
    this.channel = new BroadcastChannel("@ecmaos/kernel");
    this.components = new Components();
    this.dom = new Dom(this.options.dom);
    this.devices = /* @__PURE__ */ new Map();
    this.events = new Events();
    this.filesystem = new Filesystem(this);
    this.i18n = new I18n(this.options.i18n);
    this.intervals = new Intervals();
    this.keyboard = navigator.keyboard;
    this.log = this.options.log ? new Log(this.options.log) : new Log();
    this.memory = new Memory();
    this.modules = /* @__PURE__ */ new Map();
    this.processes = new ProcessManager();
    this.protocol = new Protocol({ kernel: this });
    this.screensavers = /* @__PURE__ */ new Map();
    this.service = new Service({ kernel: this, ...this.options.service });
    this.shell = new Shell({ kernel: this, uid: 0, gid: 0 });
    this.storage = new Storage({ kernel: this });
    this.terminal = new Terminal({ kernel: this, socket: this.options.socket });
    this.toast = new Notyf(this.options.toast);
    this.users = new Users({ kernel: this });
    this.windows = new Windows();
    this.wasm = new Wasm({ kernel: this });
    this.workers = new Workers();
    this.shell.attach(this.terminal);
  }
  get state() {
    return this._state;
  }
  /** Add an event listener; alias for `events.on` */
  get addEventListener() {
    return this.events.on;
  }
  /** Remove an event listener; alias for `events.off` */
  get removeEventListener() {
    return this.events.off;
  }
  /**
   * Boots the kernel and initializes all core services.
   * @param options - Boot configuration options
   * @throws {Error} If boot process fails
   */
  async boot(options = DefaultBootOptions) {
    let spinner;
    const t2 = this.i18n.i18next.getFixedT(this.i18n.language, "kernel");
    try {
      this.dom.topbar();
      this.terminal.unlisten();
      this.log.attachTransport((logObj) => {
        if (!logObj?.["_meta"]) return;
        const acceptedLevels = ["WARN", "ERROR"];
        if (!acceptedLevels.includes(logObj["_meta"].logLevelName)) return;
        let color = chalk$1.gray;
        switch (logObj["_meta"].logLevelName) {
          case "DEBUG":
            color = chalk$1.green;
            break;
          case "INFO":
            color = chalk$1.blue;
            break;
          case "WARN":
            color = chalk$1.yellow;
            break;
          case "ERROR":
            color = chalk$1.red;
            break;
        }
        const numericKeys = Object.keys(logObj).filter((key) => !isNaN(Number(key)));
        const logMessage = `${logObj["_meta"].name} ${color(logObj["_meta"].logLevelName)}	${numericKeys.map((key) => logObj[key]).join(" ") || logObj.message}`;
        this.terminal.writeln(logMessage);
      });
      if (!options.silent && this.log) {
        const figletFont = options.figletFontRandom ? DefaultFigletFonts[Math.floor(Math.random() * DefaultFigletFonts.length)] : options.figletFont || getComputedStyle(document.documentElement).getPropertyValue("--figlet-font").trim() || "Poison";
        const figletColor = options.figletColor || getComputedStyle(document.documentElement).getPropertyValue("--figlet-color").trim() || "#00FF00";
        const colorFiglet = /* @__PURE__ */ __name((color, text) => {
          const rgb = color.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
          if (rgb) return chalk$1.rgb(parseInt(rgb[1] ?? "FF"), parseInt(rgb[2] ?? "FF"), parseInt(rgb[3] ?? "FF"))(text);
          if (color.startsWith("#")) return chalk$1.hex(color)(text);
          return chalk$1[color]?.(text) || text;
        }, "colorFiglet");
        let logoFiglet;
        try {
          const loadedFont = await import("./Poison-ChSGZazu.js");
          figlet.parseFont(figletFont || "Poison", loadedFont.default);
          logoFiglet = figlet.textSync(__vite_import_meta_env__["FIGLET_TEXT"] || "ECMAOS", { font: figletFont });
          if (document.body.clientWidth >= 650) this.terminal.writeln(colorFiglet(figletColor, logoFiglet));
        } catch (error) {
          this.log.error(`Failed to load figlet font ${figletFont}: ${error.message}`);
        }
        const dependencyLinks = [
          { name: "@xterm/xterm", link: this.terminal.createSpecialLink("https://github.com/xtermjs/xterm.js", "@xterm/xterm") + `@${"5.5.0"}` },
          { name: "@zen-fs/core", link: this.terminal.createSpecialLink("https://github.com/zen-fs/core", "@zenfs/core") + `@${"2.4.2"}` }
        ];
        this.terminal.writeln(
          `${this.terminal.createSpecialLink("https://ecmaos.sh", "@ecmaos/kernel")}@${"0.5.0"}` + chalk$1.cyan(` [${dependencyLinks.map((link2) => link2.link).join(", ")}]`)
        );
        this.terminal.writeln(`${t2("kernel.madeBy", "Made with ❤️  by Jay Mathis")} ${this.terminal.createSpecialLink(
          define_import_meta_env_AUTHOR_default?.url || "https://github.com/mathiscode",
          `${define_import_meta_env_AUTHOR_default?.name} <${define_import_meta_env_AUTHOR_default?.email}>`
        )}`);
        this.terminal.writeln("https://github.com/ecmaos/ecmaos\n");
        this.terminal.writeln(chalk$1.red.bold(`🐉  ${t2("kernel.experimental", "EXPERIMENTAL")} 🐉`));
        if (define_import_meta_env_KNOWN_ISSUES_default) {
          this.terminal.writeln(chalk$1.yellow.bold(t2("kernel.knownIssues", "Known Issues")));
          this.terminal.writeln(chalk$1.yellow(define_import_meta_env_KNOWN_ISSUES_default.map((issue) => `- ${issue}`).join("\n")) + "\n");
        }
        if (define_import_meta_env_TIPS_default) {
          this.terminal.writeln(chalk$1.green.bold(t2("kernel.tips", "Tips")));
          this.terminal.writeln(chalk$1.green(define_import_meta_env_TIPS_default.map((tip) => `- ${tip}`).join("\n")) + "\n");
        }
        spinner = this.terminal.spinner("arrow3", chalk$1.yellow(this.i18n.t("Booting")));
        spinner.start();
        if (logoFiglet) console.log(`%c${logoFiglet}`, "color: green");
        console.log(`%c${"https://github.com/ecmaos/ecmaos"}`, "color: blue; text-decoration: underline; font-size: 16px");
        this.log.info(`${"@ecmaos/kernel"} v${"0.5.0"}`);
        if (Notification?.permission === "default") Notification.requestPermission();
        if (Notification?.permission === "denied") this.log.warn(t2("kernel.permissionNotificationDenied", "Notification permission denied"));
        this.intervals.set("title-blink", () => {
          globalThis.document.title = globalThis.document.title.includes("_") ? "ecmaos# " : "ecmaos# _";
        }, 600);
        this.toast.success(`${"@ecmaos/kernel"} v${"0.5.0"}`);
      }
      await this.configure({ devices: this.options.devices || DefaultDevices, filesystem: Filesystem.options() });
      const requiredPaths = [
        "/bin",
        "/sbin",
        "/boot",
        "/proc",
        "/tmp",
        "/home",
        "/lib",
        "/run",
        "/root",
        "/opt",
        "/sys",
        "/etc",
        "/etc/opt",
        "/var",
        "/var/cache",
        "/var/lib",
        "/var/log",
        "/var/spool",
        "/var/tmp",
        "/var/lock",
        "/var/opt",
        "/var/games",
        "/usr",
        "/usr/bin",
        "/usr/lib",
        "/usr/sbin",
        "/usr/share",
        "/usr/share/licenses",
        "/usr/include",
        "/usr/local"
      ];
      const specialPermissions = {
        "/root": 448,
        "/proc": 511
      };
      for (const path2 of requiredPaths) {
        let mode2 = 493;
        if (specialPermissions[path2]) mode2 = specialPermissions[path2];
        if (!await this.filesystem.fs.exists(path2)) await this.filesystem.fs.mkdir(path2, { recursive: true, mode: mode2 });
      }
      this.log.attachTransport((logObj) => {
        if (!logObj._meta) return;
        const formattedDate = new Date(logObj._meta.date).toLocaleString(this.memory.config.get("locale") || "en-US", {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          fractionalSecondDigits: 3,
          hour12: false
        }).replace(",", "");
        this.sudo(
          async () => await this.filesystem.fs.appendFile(
            "/var/log/kernel.log",
            `${formattedDate} [${logObj._meta?.logLevelName}] ${logObj[0] || logObj.message}

`
          )
        );
      });
      await this.registerEvents();
      await this.registerDevices();
      await this.registerCommands();
      await this.registerProc();
      await this.registerPackages();
      this.intervals.set("/proc", this.registerProc.bind(this), __vite_import_meta_env__["VITE_KERNEL_INTERVALS_PROC"] ?? 1e3);
      const modules = __vite_import_meta_env__["VITE_KERNEL_MODULES"];
      if (modules) {
        const mods = modules.split(",");
        for (const mod of mods) {
          try {
            const spec = mod.match(/(@[^/]+\/[^@]+|[^@]+)(?:@([^/]+))?/);
            const name = spec?.[1];
            const version2 = spec?.[2];
            if (!name) {
              this.log.error(`Failed to load module ${mod}: Invalid package name format`);
              continue;
            }
            if (!version2) {
              this.log.error(`Failed to load module ${mod}: No version specified`);
              continue;
            }
            this.log.info(`Loading module ${name}@${version2}`);
            const [scope, pkg2] = name.split("/");
            const pkgPath = `/usr/lib/${scope ? `${scope}/` : ""}${pkg2}/${version2}`;
            const exists2 = await this.filesystem.fs.exists(pkgPath);
            let result;
            if (!exists2) {
              result = await this.shell.execute(`/bin/install ${name}@${version2}`);
              if (result !== 0) throw new Error(`Failed to install module ${name}@${version2}: ${result}`);
              if (!await this.filesystem.fs.exists(pkgPath)) throw new Error(`Failed to install module ${name}@${version2}: ${result}`);
            }
            const pkgJson = await this.filesystem.fs.readFile(`${pkgPath}/package.json`, "utf-8");
            const pkgData = JSON.parse(pkgJson);
            const mainFile = this.getPackageMainExport(pkgData);
            if (!mainFile) throw new Error(`Failed to load module ${name}@${version2}: No main export found`);
            const mainPath = path$1.join(pkgPath, mainFile);
            const module = await import(
              /* @vite-ignore */
              `/swapi/fs${mainPath}`
            );
            const modname = module.name?.value || mod;
            module.init?.(this.id);
            this.modules.set(modname, module);
          } catch (error) {
            this.log.error(`Failed to load module ${mod}: ${error.message}`);
          }
        }
      }
      try {
        if (!await this.filesystem.fs.exists("/etc/passwd")) await this.users.add({ username: "root", password: "root", home: "/root" }, { noHome: true });
        else await this.users.load();
      } catch (err2) {
        this.log.error(err2);
        this.terminal.writeln(chalk$1.red(err2.message));
        throw err2;
      }
      spinner?.stop();
      if (this.options.credentials) {
        const { cred } = await this.users.login(this.options.credentials.username, this.options.credentials.password);
        this.shell.credentials = cred;
        this.shell.context = bindContext({ root: "/", pwd: "/", credentials: cred });
        await this.shell.loadEnvFile();
      } else {
        if (true) this.terminal.writeln(chalk$1.yellow.bold("Default Login: root / root\n"));
        this.terminal.writeln(`${Intl.DateTimeFormat(this.memory.config.get("locale") || "en-US", {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        }).format(/* @__PURE__ */ new Date())}`);
        const issue = await this.filesystem.fs.exists("/etc/issue") ? await this.filesystem.fs.readFile("/etc/issue", "utf-8") : null;
        if (issue) this.terminal.writeln(issue);
        while (true) {
          try {
            const username = await this.terminal.readline(`👤  ${this.i18n.t("Username")}: `);
            const password = await this.terminal.readline(`🔒  ${this.i18n.t("Password")}: `, true);
            const { cred } = await this.users.login(username, password);
            this.shell.credentials = cred;
            this.shell.context = bindContext({ root: "/", pwd: "/", credentials: cred });
            await this.shell.loadEnvFile();
            break;
          } catch (err2) {
            console.error(err2);
            this.terminal.writeln(chalk$1.red(err2.message) + "\n");
          }
        }
      }
      const motd = await this.filesystem.fs.exists("/etc/motd") ? await this.filesystem.fs.readFile("/etc/motd", "utf-8") : null;
      if (motd) this.terminal.writeln("\n" + motd);
      const user2 = this.users.get(this.shell.credentials.uid ?? 0);
      if (!user2) throw new Error(t2("kernel.userNotFound", "User not found"));
      this.shell.cwd = localStorage.getItem(`cwd:${this.shell.credentials.uid}`) ?? (user2.uid === 0 ? "/" : user2.home || "/");
      if (user2.uid !== 0) this.terminal.promptTemplate = `{user}:{cwd}$ `;
      const screensavers = /* @__PURE__ */ Object.assign({ "./lib/screensavers/blank.ts": __vite_glob_0_0, "./lib/screensavers/matrix.ts": __vite_glob_0_1 });
      for (const [key, saver] of Object.entries(screensavers)) {
        this.screensavers.set(
          key.replace("./lib/screensavers/", "").replace(".ts", ""),
          saver
        );
      }
      const currentSaver = this.storage.local.getItem("screensaver") || "matrix";
      if (currentSaver && this.screensavers.has(currentSaver)) {
        const saver = this.screensavers.get(currentSaver);
        let idleTimer;
        const resetIdleTime = /* @__PURE__ */ __name(() => {
          clearTimeout(idleTimer);
          idleTimer = setTimeout(() => saver?.default({ terminal: this.terminal }), parseInt(this.storage.local.getItem("screensaver-timeout") ?? "60000"));
        }, "resetIdleTime");
        resetIdleTime();
        const events2 = ["mousemove", "keydown", "keyup", "keypress", "pointerdown"];
        for (const event of events2) globalThis.addEventListener(event, resetIdleTime);
      }
      if (!await this.filesystem.fs.exists("/boot/init")) await this.filesystem.fs.writeFile("/boot/init", "#!ecmaos:bin:script:init\n\n");
      const initProcess = new Process({
        args: [],
        command: "init",
        uid: user2.uid,
        gid: user2.gid,
        kernel: this,
        shell: this.shell,
        terminal: this.terminal,
        entry: /* @__PURE__ */ __name(async () => await this.sudo(async () => await this.execute({ command: "/boot/init", shell: this.shell })), "entry")
      });
      initProcess.keepAlive();
      initProcess.start();
      this._state = KernelState.RUNNING;
      this.setupDebugGlobals();
      if (!this.storage.local.getItem("ecmaos:first-boot")) {
        const recommendedApps = "@ecmaos-apps/news,@ecmaos-apps/code,@ecmaos-apps/webamp";
        if (recommendedApps) {
          const apps = recommendedApps.split(",");
          this.terminal.writeln("\n" + chalk$1.yellow.bold(this.i18n.t("kernel.recommendedApps", "Recommended apps:")));
          this.terminal.writeln(chalk$1.green(apps.map((app) => `- ${app}`).join("\n")));
          this.terminal.write(chalk$1.green.bold(this.i18n.t("kernel.installRecommendedApps", "Do you want to install the recommended apps? (Y/n)")));
          const answer = await this.terminal.readline();
          if (answer.toLowerCase()[0] === "y" || answer === "") {
            for (const app of apps) await this.shell.execute(`/bin/install --reinstall ${app}`);
          }
        }
        this.storage.local.setItem("ecmaos:first-boot", Date.now().toString());
      }
      this.terminal.write(ansi$6.erase.inLine(2) + this.terminal.prompt());
      this.terminal.focus();
      this.terminal.listen();
    } catch (error) {
      this.log.error(error);
      this._state = KernelState.PANIC;
      this.events.dispatch(KernelEvents.PANIC, { error });
      this.toast.error({
        message: t2("kernel.panic", "Uh oh, kernel panic! Check the logs for more details."),
        duration: 0,
        dismissible: false
      });
    } finally {
      this.dom.topbar();
    }
  }
  /**
   * Configures kernel subsystems with the provided options
   * @param options - Configuration options for kernel subsystems
   */
  async configure(options) {
    await this.filesystem.configure(options.filesystem ?? {});
  }
  /**
   * Gets the main entry file path from a package.json
   * @param pkgData - The parsed package.json data
   * @returns The main entry file path or null if not found
   */
  getPackageMainExport(pkgData) {
    let mainFile = null;
    if (pkgData.exports) {
      const exportPaths = [
        "./browser",
        ".",
        "./index",
        "./module",
        "./main"
      ];
      for (const path2 of exportPaths) {
        const entry = pkgData.exports[path2];
        if (typeof entry === "string") {
          mainFile = entry;
          break;
        } else if (typeof entry === "object" && entry !== null) {
          const subPaths = ["browser", "module", "default", "import"];
          for (const subPath of subPaths) {
            if (typeof entry[subPath] === "string") {
              mainFile = entry[subPath];
              break;
            }
          }
          if (mainFile) break;
        }
      }
    }
    if (!mainFile) {
      mainFile = pkgData.browser || pkgData.module || pkgData.main;
      if (typeof mainFile === "object") {
        for (const key of Object.keys(mainFile)) {
          if (typeof mainFile[key] === "string") {
            mainFile = mainFile[key];
            break;
          }
        }
      }
    }
    return mainFile;
  }
  /**
   * Executes a command in the kernel environment
   * @param options - Execution options containing command, args, and shell
   * @returns Exit code of the command
   */
  async execute(options) {
    try {
      if (!await this.filesystem.exists(options.command)) {
        this.log.error(`File not found for execution: ${options.command}`);
        return -1;
      }
      if (options.command.startsWith("/dev/")) {
        const device = Array.from(this.devices.values()).find((d) => d.drivers?.some((driver) => driver.name === options.command.replace(/^\/dev\//, "")));
        if (device) return await this.executeDevice(device.device, options.args);
      }
      const header = await this.readFileHeader(options.command);
      if (!header) return -1;
      let exitCode = -1;
      switch (header.type) {
        case "bin":
          switch (header.namespace) {
            case "terminal":
            // left for backward-compatibility
            case "command":
              if (!header.name) return -1;
              exitCode = await this.executeCommand({ ...options, command: header.name });
              break;
            case "app":
              if (!header.name) return -1;
              exitCode = await this.executeApp({ ...options, command: header.name, file: options.command });
              break;
            case "script":
              exitCode = await this.executeScript(options);
              break;
            case "node":
              exitCode = await this.executeNode(options);
              break;
          }
          ;
          break;
      }
      exitCode = exitCode ?? 0;
      options.shell.env.set("?", exitCode.toString());
      this.events.dispatch(KernelEvents.EXECUTE, { command: options.command, args: options.args, exitCode });
      return exitCode;
    } catch (error) {
      console.error(error);
      this.log.error(error);
      options.shell.env.set("?", "-1");
      return -1;
    }
  }
  /**
   * Executes an app
   * @param options - Execution options containing app path and shell
   * @returns Exit code of the app
   */
  async executeApp(options) {
    try {
      const contents = await this.filesystem.fs.readFile(options.file, "utf-8");
      const binLink = await this.filesystem.fs.readlink(options.file);
      const filePath = path$1.dirname(binLink);
      const blob = new Blob([await this.replaceImports(contents, filePath)], { type: "text/javascript" });
      const url = URL.createObjectURL(blob);
      let exitCode = -1;
      try {
        const module = await import(
          /* @vite-ignore */
          url
        );
        const main = module?.main || module?.default;
        if (typeof main !== "function") throw new Error("No main function found in module");
        const process2 = this.processes.create({
          args: options.args || [],
          command: options.command,
          kernel: this,
          shell: options.shell || this.shell,
          terminal: options.terminal || this.terminal,
          uid: options.shell.credentials.uid,
          gid: options.shell.credentials.gid,
          entry: /* @__PURE__ */ __name(async (params) => await main(params), "entry"),
          stdin: options.stdin,
          stdout: options.stdout,
          stderr: options.stderr
        });
        exitCode = await process2.start();
      } finally {
        URL.revokeObjectURL(url);
      }
      return exitCode;
    } catch (error) {
      this.log.error(`Failed to execute app: ${error}`);
      options.terminal?.writeln(chalk$1.red(error.message));
      return -1;
    }
  }
  /**
   * Executes a terminal command
   * @param options - Execution options containing command name, args, shell, and terminal
   * @returns Exit code of the command
   */
  async executeCommand(options) {
    const command = this.terminal.commands[options.command];
    if (!command) return -1;
    const process2 = new Process({
      uid: options.shell.credentials.uid,
      gid: options.shell.credentials.gid,
      args: options.args,
      command: options.command,
      kernel: options.kernel || this,
      shell: options.shell || this.shell,
      terminal: options.terminal || this.terminal,
      entry: /* @__PURE__ */ __name(async (params) => await command.run.call(params, params.pid, params.args), "entry"),
      stdin: options.stdin,
      stdout: options.stdout,
      stderr: options.stderr
    });
    const exitCode = await process2.start();
    return exitCode;
  }
  /**
   * Executes a device command
   * @param {KernelDevice} device - Device to execute command on
   * @param {string[]} args - Command arguments
   * @param {Shell} shell - Shell instance
   * @returns {Promise<number>} Exit code of the device command
   */
  async executeDevice(device, args = [], shell = this.shell) {
    if (!device || !device.cli) {
      this.log.error(`Device not found or does not have a CLI`);
      return -1;
    }
    let deviceProcess = new Process({
      uid: shell.credentials.uid,
      gid: shell.credentials.gid,
      args,
      command: `/dev/${device.pkg.name}`,
      entry: /* @__PURE__ */ __name(async (params) => await device.cli?.({
        args: params.args,
        kernel: params.kernel,
        pid: params.pid,
        shell: params.shell,
        terminal: params.terminal
      }), "entry"),
      kernel: this,
      shell,
      terminal: this.terminal
    });
    try {
      shell.setPositionalParameters([`/dev/${device.pkg.name}`, ...args]);
      await deviceProcess.start();
    } catch (error) {
      this.log.error(error);
      this.terminal.writeln(chalk$1.red(error.message));
      return -2;
    } finally {
      deviceProcess = null;
    }
    return 0;
  }
  /**
   * Executes a node script (or tries to)
   *
   * @remarks
   * Don't expect it to work; this will help develop further emulation layers
   * We still need to resolve the IndexedDB/sync issues before sync fs calls will work
   *
   * @param options - Execution options containing script path and shell
   * @returns Exit code of the script
   */
  async executeNode(options) {
    if (!options.command) return -1;
    let exitCode = -1;
    let url;
    try {
      const contents = await this.filesystem.fs.readFile(options.command, "utf-8");
      if (!contents) return -1;
      const binLink = await this.filesystem.fs.readlink(options.command);
      const filePath = path$1.dirname(binLink);
      globalThis.process.execPath = "/sbin/ecmanode";
      globalThis.process.execArgv = [];
      globalThis.process.argv = [globalThis.process.execPath, binLink, ...options.args || []];
      globalThis.process.argv0 = options.command;
      const finalContents = contents;
      const code2 = await this.replaceImports(finalContents, filePath);
      const blob = new Blob([code2], { type: "text/javascript" });
      url = URL.createObjectURL(blob);
      if (!url) throw new Error("Failed to create object URL");
      if (!globalThis.requiremap) globalThis.requiremap = /* @__PURE__ */ new Map();
      globalThis.requiremap.set(url, {
        code: code2,
        filePath,
        binLink,
        command: options.command,
        argv: [...globalThis.process.argv],
        argv0: globalThis.process.argv0
      });
      await import(
        /* @vite-ignore */
        url
      );
      exitCode = 0;
    } catch (error) {
      this.log.error(`Failed to execute node script: ${error}`);
      this.terminal.writeln(chalk$1.red(error.message));
      console.error(error);
      exitCode = -1;
      globalThis.requiremap?.delete(url);
    } finally {
      URL.revokeObjectURL(url);
    }
    return exitCode;
  }
  /**
   * Executes a script file
   * @param options - Execution options containing script path and shell
   * @returns Exit code of the script
   */
  async executeScript(options) {
    const header = await this.readFileHeader(options.command);
    if (!header) return -1;
    if (header.type !== "bin" || header.namespace !== "script") {
      this.log.error(`File is not a script: ${options.command}`);
      return -1;
    }
    const script = await this.filesystem.fs.readFile(options.command, "utf-8");
    if (script) {
      for (const line3 of script.split("\n")) {
        if (line3.startsWith("#") || line3.trim() === "") continue;
        await options.shell.execute(line3);
      }
      return 0;
    } else this.log.error(`Script ${options.command} not found`);
    return -1;
  }
  /**
   * Shows a system notification if permissions are granted
   * @param {string} title - Notification title
   * @param {NotificationOptions} options - Notification options
   * @returns {Promise<Notification|void>} The created notification or void if permissions denied
   */
  async notify(title, options = {}) {
    if (Notification?.permission === "granted") return new Notification(title, options);
    await Notification.requestPermission();
  }
  /**
   * Removes an event listener from the kernel.
   * @param {KernelEvents} event - The event to remove the listener from.
   * @param {EventCallback} listener - The listener to remove.
   * @returns {void}
   */
  off(event, listener) {
    this.events.off(event, listener);
  }
  /**
   * Adds an event listener to the kernel.
   * @param {KernelEvents} event - The event to listen for.
   * @param {EventCallback} listener - The listener to add.
   * @returns {void}
   */
  on(event, listener) {
    this.events.on(event, listener);
  }
  /**
   * Reads and parses a file header to determine its type
   * @param {string} filePath - Path to the file
   * @returns {Promise<FileHeader|null>} Parsed header information or null if invalid
   */
  async readFileHeader(filePath) {
    const parseHeader = /* @__PURE__ */ __name((header) => {
      if (!header.startsWith("#!")) return null;
      if (header.startsWith("#!ecmaos:")) {
        const [type, namespace, name] = header.replace("#!ecmaos:", "").split(":");
        if (!type) return null;
        return { type, namespace, name };
      }
      if (header.startsWith("#!/usr/bin/env node")) return { type: "bin", namespace: "node", name: "node" };
      return null;
    }, "parseHeader");
    return new Promise((resolve2, reject) => {
      (async () => {
        try {
          if (!await this.filesystem.fs.exists(filePath)) return resolve2(null);
          const readable2 = this.filesystem.fsSync.createReadStream(filePath);
          readable2.on("data", (chunk) => resolve2(parseHeader(chunk.toString().split("\n")[0] || "")));
          readable2.on("error", (error) => reject(error));
          readable2.on("close", () => resolve2(null));
        } catch (error) {
          this.log.error(error);
          reject(error);
        }
      })();
    });
  }
  /**
   * Reboots the kernel by performing a shutdown and page reload
   */
  async reboot() {
    this.log.warn(this.i18n.t("Rebooting"));
    await this.shutdown();
    globalThis.location.reload();
  }
  /**
   * Registers the terminal commands.
   * @returns {Promise<void>} A promise that resolves when the terminal commands are registered.
   */
  async registerCommands() {
    if (!await this.filesystem.fs.exists("/bin")) await this.filesystem.fs.mkdir("/bin");
    const whitelistedCommands = Object.entries(TerminalCommands(this, this.shell, this.terminal)).filter(([name]) => !this.options.blacklist?.commands?.includes(name));
    for (const [name] of whitelistedCommands) {
      if (await this.filesystem.fs.exists(`/bin/${name}`)) continue;
      await this.filesystem.fs.writeFile(`/bin/${name}`, `#!ecmaos:bin:command:${name}`, { mode: 493 });
    }
  }
  /**
   * Registers the devices.
   * @returns {Promise<void>} A promise that resolves when the devices are registered.
   */
  async registerDevices() {
    for (const device of Object.values(this.options.devices || DefaultDevices)) {
      const drivers = await device.getDrivers(this);
      this.devices.set(device.pkg.name, { device, drivers });
      for (const driver of drivers) {
        driver.singleton = driver.singleton ?? true;
        addDevice(driver);
      }
    }
  }
  /**
   * Registers the kernel events.
   * @returns {Promise<void>} A promise that resolves when the events are registered.
   */
  async registerEvents() {
    for (const event of Object.values(KernelEvents)) {
      this.events.on(event, async (detail) => {
        switch (event) {
          case KernelEvents.PANIC:
            this.log.fatal("KernelPanic:", detail);
            break;
        }
      });
    }
  }
  /**
   * Registers the packages from /etc/packages that should be auto-loaded on boot.
   * @returns {Promise<void>} A promise that resolves when the packages are registered.
   */
  async registerPackages() {
    try {
      const packagesData = await this.filesystem.fs.readFile("/etc/packages", "utf-8");
      const packages = packagesData.split("\n").filter(Boolean).filter((pkg2) => !pkg2.startsWith("#"));
      for (const pkg2 of packages) {
        const spec = pkg2.match(/(@[^/]+\/[^@]+|[^@]+)(?:@([^/]+))?/);
        const name = spec?.[1];
        if (!name || !await this.filesystem.fs.exists(`/usr/lib/${name}`)) continue;
        const versions = await this.filesystem.fs.readdir(`/usr/lib/${name}`);
        const version2 = semver.maxSatisfying(versions, spec?.[2] || "*") || spec?.[2] || "*";
        const pkgData = await this.filesystem.fs.readFile(`/usr/lib/${name}/${version2}/package.json`, "utf-8");
        const pkgJson = JSON.parse(pkgData);
        const mainFile = this.getPackageMainExport(pkgJson);
        if (!mainFile) continue;
        const filePath = `/usr/lib/${name}/${version2}/${mainFile}`;
        const fileContents = await this.filesystem.fs.readFile(filePath, "utf-8");
        const blob = new Blob([fileContents], { type: "text/javascript" });
        const url = URL.createObjectURL(blob);
        try {
          this.log.info(`Loading package ${name} v${version2}`);
          const imports = await import(
            /* @vite-ignore */
            url
          );
          this.packages.set(name, imports);
        } catch (err2) {
          this.log.error(`Failed to load package ${name} v${version2}: ${err2}`);
        } finally {
          URL.revokeObjectURL(url);
        }
      }
    } catch {
    }
  }
  /**
   * Registers the initial /proc entries.
   * @returns {Promise<void>} A promise that resolves when the proc entries are registered.
   */
  async registerProc() {
    if (!await this.filesystem.fs.exists("/proc")) await this.filesystem.fs.mkdir("/proc");
    const contents = {
      memory: "?",
      platform: navigator.userAgentData?.platform || navigator?.platform || navigator.userAgent,
      querystring: location.search,
      version: `${"@ecmaos/kernel"} ${"0.5.0"}`,
      language: navigator.language,
      host: location.host,
      userAgent: navigator.userAgent,
      userAgentData: navigator.userAgentData ? JSON.stringify(navigator.userAgentData, null, 2) : null,
      connection: JSON.stringify({
        downlink: 0,
        effectiveType: "unknown",
        rtt: 0,
        saveData: false
      }, null, 2)
    };
    if ("connection" in navigator) {
      try {
        const { downlink, effectiveType, rtt, saveData } = navigator.connection;
        contents.connection = JSON.stringify({ downlink, effectiveType, rtt, saveData }, null, 2);
      } catch {
        this.log.warn("Failed to get connection data");
      }
    }
    if ("deviceMemory" in navigator) contents.memory = `>= ${navigator.deviceMemory}GB`;
    for (const [key, value] of Object.entries(contents)) {
      try {
        await this.filesystem.fs.writeFile(`/proc/${key}`, value ?? new Uint8Array(), { flag: "w+", mode: 511 });
      } catch (error) {
        this.log.warn(`Failed to write proc data: ${key}`, error);
      }
    }
  }
  /**
   * Replaces imports in a script with SWAPI URLs
   *
   * @remarks
   * I would love to just use import maps, but we need dynamic import maps
   * This is probably not our long-term solution
   *
   * @param {string} contents - The script contents
   * @returns {Promise<string>} The modified script contents
   */
  async replaceImports(contents, packagePath) {
    const replacements = {};
    const importRegex = /from ['"]([^'"]+)['"]/g;
    const imports = contents.match(importRegex) || [];
    for (const match of imports) {
      const importPath = match.replace(/from ['"]|['"]/g, "");
      const exists2 = await this.filesystem.fs.exists(`/usr/lib/${path$1.join(packagePath, importPath)}`);
      if (exists2) replacements[match] = `from "${location.protocol}//${location.host}/swapi/fs${path$1.join(packagePath, importPath)}"`;
    }
    for (const [match, replacement] of Object.entries(replacements)) contents = contents.replace(match, replacement);
    if (!globalThis.requiremap) globalThis.requiremap = /* @__PURE__ */ new Map();
    const requireRegex = /require\(['"]([^'"]+)['"]\)/g;
    const requires = contents.matchAll(requireRegex) || [];
    for (const match of requires) {
      const id = match[1];
      if (!id || !id.startsWith(".")) continue;
      const resolvedPath = path$1.resolve(packagePath, id);
      const resolvedStat = await this.filesystem.fs.stat(resolvedPath);
      const finalPath = resolvedStat.isFile() ? resolvedPath : path$1.resolve(resolvedPath, "index.js");
      const depContents = await this.filesystem.fs.readFile(finalPath, "utf-8");
      const finalContents = await this.replaceImports(depContents, path$1.dirname(finalPath));
      let depUrl = id;
      for (const key of globalThis.requiremap.keys()) {
        depUrl = key;
        break;
      }
      globalThis.requiremap.set(depUrl, {
        command: "ecmaos:require",
        filePath: resolvedPath,
        binLink: "",
        argv: [...globalThis.process.argv],
        argv0: globalThis.process.argv0,
        code: finalContents
      });
      contents = contents.replace(id, depUrl);
    }
    return contents;
  }
  /**
   * Shuts down the kernel.
   * @returns {Promise<void>} A promise that resolves when the kernel is shut down.
   */
  async shutdown() {
    this.terminal.unlisten();
    this._state = KernelState.SHUTDOWN;
    this.events.dispatch(KernelEvents.SHUTDOWN, { data: {} });
  }
  /**
   * Executes an operation with root (or other) privileges
   * @param {() => Promise<T>} operation - Operation to execute
   * @param {Partial<Credentials>} cred - Optional credentials to use
   * @returns {Promise<T>} Result of the operation
   */
  async sudo(operation, cred = { uid: 0, gid: 0, suid: 0, sgid: 0, euid: 0, egid: 0, groups: [] }) {
    const currentCredentials = { ...this.shell.credentials };
    const currentContext = { ...this.shell.context };
    let result;
    try {
      this.shell.credentials = cred;
      this.shell.context = bindContext({ root: "/", pwd: "/", credentials: cred });
      result = await operation();
    } catch (error) {
      this.log.error(error);
    } finally {
      this.shell.credentials = currentCredentials;
      this.shell.context = currentContext;
    }
    return result;
  }
  /**
   * Sets up global debug utilities for browser console access.
   * Access via: ecmaos.kernel, ecmaos.processes(), ecmaos.fd(pid?), etc.
   */
  setupDebugGlobals() {
    const ecmaos = globalThis.ecmaos || {};
    Object.assign(ecmaos, {
      // Core references
      kernel: this,
      // Process utilities
      processes: /* @__PURE__ */ __name(() => {
        const procs = Array.from(this.processes.all.values());
        console.table(procs.map((p) => ({
          pid: p.pid,
          command: p.command,
          status: p.status,
          uid: p.uid,
          gid: p.gid,
          cwd: p.cwd
        })));
        return procs;
      }, "processes"),
      // File descriptor table for a specific process
      fd: /* @__PURE__ */ __name((pid) => {
        if (pid === void 0) {
          const procs = Array.from(this.processes.all.values());
          for (const proc2 of procs) {
            console.group(`PID ${proc2.pid}: ${proc2.command}`);
            console.log("stdin:", proc2.fd.stdin ? "✓" : "✗");
            console.log("stdout:", proc2.fd.stdout ? "✓" : "✗");
            console.log("stderr:", proc2.fd.stderr ? "✓" : "✗");
            console.log("tracked file handles:", proc2.fd.fileHandles.length);
            console.groupEnd();
          }
          return procs.map((p) => ({ pid: p.pid, fd: p.fd }));
        }
        const proc = this.processes.get(pid);
        if (!proc) {
          console.error(`Process ${pid} not found`);
          return null;
        }
        console.group(`FDTable for PID ${pid}: ${proc.command}`);
        console.log("stdin:", proc.fd.stdin);
        console.log("stdout:", proc.fd.stdout);
        console.log("stderr:", proc.fd.stderr);
        console.log("tracked file handles:", proc.fd.fileHandles);
        console.groupEnd();
        return proc.fd;
      }, "fd"),
      // Terminal reference
      terminal: this.terminal,
      // Shell reference
      shell: this.shell,
      // Filesystem reference
      fs: this.filesystem.fs
    });
    globalThis.ecmaos = ecmaos;
    this.log.debug("Debug globals available: ecmaos.kernel, ecmaos.processes(), ecmaos.fd(pid?), ecmaos.terminal, ecmaos.shell, ecmaos.fs");
  }
};
__name(_Kernel, "Kernel");
let Kernel = _Kernel;
export {
  Kernel as K,
  chalk$1 as c,
  getDefaultExportFromCjs$1 as g,
  path$1 as p,
  semver as s
};
//# sourceMappingURL=kernel-CVxDewUD.js.map
